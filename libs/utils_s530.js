/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {};}

// Copy all i18n to ux.i18n
if (!Ext.ux.i18n){
	Ext.ux.i18n = Ext.apply({}, (window.Signavio||{}).I18N || {}, (window.ORYX||{}).I18N || {});
}

new function() {
	
	/**
	 * Define the special I18N strings 
	 * for the ux-package.
	 */
	var strings = {};

	
	
	/**
	 * GERMAN TRANSLATION
	 * First translation into German: -
	 * Translator: -
	 * @translationchecker -
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_de = "Hinzufügen";
	strings.btnopen_de = "Öffnen";
	strings.btnremove_de = "Löschen";
	strings.btnedit_de = "Editieren";
	strings.btnreset_de = "Zurücksetzen";
	strings.btnclose_de = "Schließen";
	strings.btnsave_de = "Speichern";
	strings.btnapply_de = "Übernehmen";
	strings.moveup_de = "Nach oben";
	strings.movedown_de = "Nach unten";
	strings.url_de = "Link";
	strings.label_de = "Beschriftung";
	strings.year_de = "Jahr";
	strings.years_de = "Jahre";
	strings.month_de = "Monat";
	strings.months_de = "Monate";
	strings.month1_de = "Januar";
	strings.month2_de = "Februar";
	strings.month3_de = "März";
	strings.month4_de = "April";
	strings.month5_de = "Mai";
	strings.month6_de = "Juni";
	strings.month7_de = "Juli";
	strings.month8_de = "August";
	strings.month9_de = "September";
	strings.month10_de = "Oktober";
	strings.month11_de = "November";
	strings.month12_de = "Dezember";
	strings.day1_de = "Montag";
	strings.day2_de = "Dienstag";
	strings.day3_de = "Mittwoch";
	strings.day4_de = "Donnerstag";
	strings.day5_de = "Freitag";
	strings.day6_de = "Samstag";
	strings.day7_de = "Sonntag";
	strings.day_de = "Tag";
	strings.days_de = "Tage";
	strings.hour_de = "Stunde";
	strings.hours_de = "Stunden";
	strings.minute_de = "Minute";
	strings.minutes_de = "Minuten";
	strings.second_de = "Sekunde";
	strings.seconds_de = "Sekunden";
	strings.msecond_de = "Millisekunde";
	strings.mseconds_de = "Millisekunden";	
    strings.langdatetime_de = "{weekday}, {day}.{monthname} {year} {hours}:{minutes}:{seconds} Uhr"; 
    strings.langshortdatetime_de = "{day}.{month}.{year}";

	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_de = "'#{0}' erzeugen als #{1}";
	strings.createglossarynew_de = "Neu erzeugen";

	// GLOSSARY CATEGORIES
	strings.document_de = "Dokumente";
	strings.org_unit_de = "Organisation";
	strings.it_system_de = "IT Systeme";
	strings.activity_de = "Aktivitäten";
	strings.state_de = "Ereignisse";

	strings.noglossary_entry_de = "Kein Glossarbegriff";

	// FEEDBACK WINDOW
	strings["views.feedbackpsubject_de"] = "Grund ihrer Anfrage";
	strings["views.feedbackquestion_de"] = "Frage";
	strings["views.feedbackquestiontitle_de"] = "Frage zum Signavio Process Editor";
	strings["views.feedbackquestiondescription_de"] = "Detaillierte Beschreibung der Frage";
	strings["views.feedbackbugreport_de"] = "Bug Report";
	strings["views.feedbackbugreporttitle_de"] = "Problem mit dem Signavio Process Editor";
	strings["views.feedbackfeaturerequest_de"] = "Feature Request";
	strings["views.feedbackideasdescription_de"] = "Für Feature Anfragen bieten wir unseren Kunden ein Ideen-Portal an. Dort können sie Ideen für alle Kunden sichtbar einstellen und auch Ideen anderer Kunden zustimmen. <br/><br/> Die Ideen mit den meisten Wünschen werden durch unser Produktmanagement bevorzugt behandelt. Auch erhalten Sie Feedback sobald wir Ihre Idee evaluieren, eintakten und umgesetzt haben. <br/><br/> Möchten Sie Ihre Feature Anfrage in unserem Idee-Portal veröffentlichen? Dann besuchen Sie einfach <a target='_blank' href='http://ideas.signavio.com'>ideas.signavio.com</a><span style='position: relative; font-size: 10px; top: -3px; left: 2px;'>1</span> .";
	strings["views.feedbackideasdescriptionnote_de"] = "(1) Bitte beachten Sie, dass <a target='_blank' href='http://ideas.signavio.com'>ideas.signavio.com</a> ein Angebot der Signavio Inc. ist. <br/> <span style='margin-left: 17px;'>Es gelten die Geschäftsbedingungen der Signavio Inc. und der IdeaScale LLC.</span>";

	strings["views.feedbacktitleenterprise_de"] = "Supportanfrage senden";
	strings["views.feedbacktitle_de"] = "Supportanfrage an Signavio senden";
	strings["views.feedbacktitleenterprise_de"] = "Supportanfrage senden";
	strings["views.feedbacktitle_de"] = "Supportanfrage an Signavio senden";
	strings["views.feedbackentersubject_de"] = "Bitte geben Sie als Betreff eine kurze Beschreibung Ihres Problems oder Ihrer Frage an.";
	strings["views.feedbackenterdescription_de"] = "Bitte beschreiben Sie Ihr Problem oder Ihre Frage so genau wie möglich, um Ihnen eine schnelle und konkrete Antwort geben zu können.";
	strings["views.feedbackpmsg_de"] = "Detaillierte Beschreibung des Fehlers";
	strings["views.feedbackpempty_de"] = "* Bitte geben Sie uns so genaue Informationen wie möglich. *";
	strings["views.feedbackpbrowser_de"] = "Browser- und Systeminformationen";
	strings["views.feedbackpbrowserdesc_de"] = "Diese Informationen wurde automatisch von Ihrem Browser ermittelt und können uns helfen, den Fehler zu finden.";
	strings["views.feedbackclosetitle_de"] = "Schließen";
	strings["views.feedbackfailure_de"] = "Fehler";
	strings["views.feedbackfailuremsg_de"] = "Beim Senden der Nachricht ist ein Fehler aufgetreten.";
	strings["views.feedbacksuccess_de"] = "Nachricht gesendet";
	strings["views.feedbacksuccessmsg_de"] = "Vielen Dank. Ihre Supportanfrage wurde an uns übermittelt.";
	strings["views.feedbacksending_de"] = "Sende Nachricht...";
	strings["views.sendfeedback_de"] = "Supportanfrage senden";
	strings["views.feedbackcopy_de"] = "Kopie der Supportanfrage an mich senden.";
	strings["views.feedbackcopydesc_de"] = "Sendet eine Kopie Ihrer Supportanfrage an Ihre E-Mail-Adresse.";
	strings["views.feedbackpattach_de"] = "Das Diagramm darf der Supportanfrage angefügt werden.";
	strings["views.feedbackpattachdesc_de"] = "Ihr Diagramm kann uns bei der Fehlersuche helfen. Der Inhalt des Diagramms wird vertraulich behandelt. Wenn Sie nicht möchten, dass das Diagramm an uns geschickt wird, entfernen Sie bitte das Häckchen.";
	strings["views.feedbackreceiver_de"] = "Empfänger";
	strings["views.feedbackreceiversignavio_de"] = " Signavio Support ([mail])";
	strings["views.feedbackreceiverenterprise_de"] = " Ihr Support ([mail])";
	strings["views.feedbackmissingheader_de"] = "Kein Betreff";
	strings["views.feedbackmissingheadermsg_de"] = "Bitte geben Sie einen Betreff an.";
	strings["views.feedbackmissingbody_de"] = "Keine Nachricht";
	strings["views.feedbackmissingbodymsg_de"] = "Bitte geben Sie eine Nachricht ein.";
	strings["views.feedbackerrorlength_de"] = "Die Beschreibung ist zu kurz. Sie muss mindestens 40 Zeichen lang sein.";
	strings["views.feedbackerrorlengthtitle_de"] = "Nachricht is zu kurz";
	strings["views.feedbacksignavio_de"] = "Sie haben ein Problem mit der Bedienung des Signavio Process Editors oder Sie haben einen Fehler festgestellt? Bitte nutzen Sie in diesem "+
		"Falle das Support-Formular um direkten Kontakt mit Signavio aufzunehmen. Bitte beachten Sie, dass eine Bearbeitung Ihrer Anfrage "+
		"ca. 1-2 Werktage in Anspruch nehmen kann. Sie erhalten unsere Antwort anschließend per Email. Sämtliche Informationen werden unverschlüsselt "+
		"übertragen.";
	strings["views.feedbackenterprise_de"] = "Sie haben ein Problem mit der Bedienung des Signavio Process Editors oder Sie haben einen Fehler festgestellt? Bitte nutzen Sie in diesem "+
		"Falle das Support-Formular um direkten Kontakt mit Ihrem Support/Administrator aufzunehmen. Sämtliche Informationen werden unverschlüsselt "+
		"übertragen.";

	// PDF EXPORT WINDOW
	strings["views.offertitle_de"] = "PDF (Einzeldiagramm)";
	strings["views.offertitledesc_de"] = "Um ein einzelnes Diagramm im PDF-Format auszugeben, wählen Sie bitte unten aus wie das Diagramm auf mehrere Seiten verteilt werden soll.";
	strings["views.optionwindowtitle_de"] = "PDF-Export (einzelnes Diagramm)";
	strings["views.buttontitle_de"] = "PDF erzeugen";
	strings["views.closetitle_de"] = "Abbrechen";
	strings["views.fittopage_de"] = "Auf 1 Seite";
	strings["views.clipallsides_de"] = "Endlos-Druck (2-dimensional)";
	strings["views.clipbottom_de"] = "Endlos-Druck (vertikal)";
	strings["views.clipright_de"] = "Endlos-Druck (horizontal)";
	strings["views.landscape_de"] = "Querformat";
	strings["views.portrait_de"] = "Hochformat";
	strings["views.defaultname_de"] = "Export";
	strings["views.branding_de"] = "Signavio-Logos ausblenden";
	strings["views.premiumonly_de"] = "Diese Funktion ist nur in der Professional Edition verfügbar.";
	strings["views.waiting_de"] = "Prozessdokumentation wird erstellt.<br/>Dies kann einen Moment dauern...";
	strings["views.resetview_de"] = "Original";
	strings["views.windowdescription_de"] = "Bitte einen View für den Export auswählen:";


	strings["panel.businessrule_de"] = "Business Regel";
	strings["panel.static_de"] = "Statisch";
	strings["panel.dynamic_de"] = "Dynamisch";
	strings["panel.operation_de"] = "Operation";
	strings["panel.add_de"] = "hinzufügen";
	strings["panel.remove_de"] = "entfernen";
	strings["panel.no_description_de"] = "Keine Beschreibung";
	strings["panel.no_performer_de"] = "Kein Bearbeiter definiert.";
	strings["panel.no_users_de"] = "Keine Nutzer verfügbar.";
	strings["panel.no_free_userselection_de"] = "Freie Benutzerauswahl";
	strings["panel.no_parallel_title_de"] = "Hinzufügen einer Gruppe";
	strings["panel.no_parallel_description_de"] = "Für das aktuelle Element ist der Schleifentyp auf parallel oder sequentiell gestellt, das bedeutet, dass mehrere Nutzer diese Aufgabe durchführen können. Um dies zu vereinfachen, möchten Sie anstelle der Gruppe lieber alle ihre Mitglieder hinzufügen?";
	strings["panel.no_parallel_no_user_de"] = "In der aktuellen Gruppe sind keine Nutzer enthalten.";
	strings["panel.no_defined_role_label_de"] = "Vorselektion";
	strings["panel.no_defined_role_single_user_de"] = "Einzelner Benutzer";
	strings["panel.no_defined_role_role_member_de"] = "Gruppen-/Rollen-Mitglied";
	strings["panel.no_defined_role_group_de"] = "Gruppen-/Rollen";
	strings["panel.label_free_userselection_de"] = "(Freie Benutzerauswahl)";

	strings["wizard.nextbtnlabel_de"] = "Weiter >";
	strings["wizard.previousbtnlabel_de"] = "< Zurück";

	// RICHTEXT
	strings["richtext.title.undo_de"] = "Rückgängig (Strg+Z)";
    strings["richtext.text.undo_de"] = "Die letzte Aktion rückgängig machen.";
    strings["richtext.title.redo_de"] = "Wiederherstellen (Umschalt+Strg+Z)";
    strings["richtext.text.redo_de"] = "Die letzte rückgängig gemachte Aktion wiederherstellen.";
    strings["richtext.title.bold_de"] = "Fett (Strg+B)";
    strings["richtext.text.bold_de"] = "Den markierten Text fett schreiben.";
    strings["richtext.title.italic_de"] = "Kursiv (Strg+I)";
    strings["richtext.text.italic_de"] = "Den markierten Text kursiv schreiben.";
    strings["richtext.title.underline_de"] = "Unterstreichen (Strg+U)";
    strings["richtext.text.underline_de"] = "Den markierten Text unterstreichen.";
    strings["richtext.title.fontselect_de"] = "Schriftart";
    strings["richtext.text.fontselect_de"] = "Die Schriftart des markierten Textes ändern.";
    strings["richtext.title.fontsizeselect_de"] = "Schriftgröße";
    strings["richtext.text.fontsizeselect_de"] = "Die Schriftgröße des markierten Textes ändern.";
    strings["richtext.title.h1_de"] = "Überschrift";
    strings["richtext.text.h1_de"] = "Fügt eine neue Überschrift ein.";
    strings["richtext.title.h2_de"] = "Unterüberschrift";
    strings["richtext.text.h2_de"] = "Fügt eine neue Unterüberschrift ein.";
    strings["richtext.title.h3_de"] = "Abschnittsüberschrift";
    strings["richtext.text.h3_de"] = "Fügt eine neue Abschnittsüberschrift ein.";
    strings["richtext.title.inserthorizontalrule_de"] = "Horizontale Linie";
    strings["richtext.text.inserthorizontalrule_de"] = "Fügt eine horizontale Linie ein.";
    strings["richtext.title.color_de"] = "Schriftfarbe";
    strings["richtext.text.color_de"] = "Ändert die Schriftfarbe des markierten Textes.";
    strings["richtext.title.markupcolor_de"] = "Hintergrundfarbe";
    strings["richtext.text.markupcolor_de"] = "Ändert die Hintergrundfarbe des markierten Textes.";
    strings["richtext.title.justifyleft_de"] = "Linksbündig";
    strings["richtext.text.justifyleft_de"] = "Richtet den Text linksbündig aus.";
    strings["richtext.title.justifycenter_de"] = "Zentriert";
    strings["richtext.text.justifycenter_de"] = "Richtet den Text mittig aus.";
    strings["richtext.title.justifyright_de"] = "Rechtsbündig";
    strings["richtext.text.justifyright_de"] = "Richtet den Text rechtsbündig aus.";
    strings["richtext.title.indent_de"] = "Einrücken (Tab)";
    strings["richtext.text.indent_de"] = "Text einrücken.";
    strings["richtext.title.outdent_de"] = "Ausrücken (Umschalt+Tab)";
    strings["richtext.text.outdent_de"] = "Text ausrücken.";
    strings["richtext.title.createlink_de"] = "Link";
    strings["richtext.text.createlink_de"] = "Den markierten Text in einen Link umwandeln.";
    strings["richtext.title.unlink_de"] = "Link entfernen";
    strings["richtext.text.unlink_de"] = "Entfernt den Link des markierten Textes.";
    strings["richtext.title.insertorderedlist_de"] = "Aufzählung (nummeriert)";
    strings["richtext.text.insertorderedlist_de"] = "Eine nummerierte Liste einfügen.";
    strings["richtext.title.insertunorderedlist_de"] = "Aufzählung";
    strings["richtext.text.insertunorderedlist_de"] = "Eine Liste einfügen.";
    strings["richtext.title.removeformat_de"] = "Formatierung entfernen";
    strings["richtext.text.removeformat_de"] = "Entfernt jegliche Formatierung des markierten Textes.";
    strings["richtext.title.insertimages"] = "Bild einfügen oder bearbeiten";
    strings["richtext.text.insertimages"] = "Erlaubt das editieren eines selektierten Bildes oder fügt ein Bild aus dem Signavio Arbeitsbereich in den Text ein.";
    strings['richtext.colormenu.defaultcolor_de'] = 'Automatisch';
    strings['richtext.stub.more_de'] = 'mehr';
    strings['richtext.stub.less_de'] = 'weniger';
    strings['richtext.stub.openprint_de'] = 'Druckansicht öffnen';

    strings['richtext.simpleeditingmodetitle_de'] = 'Einfacher Editierungsmodus';
    strings['richtext.simpleeditingmodedesc_de'] = 'Zum einfachen Editierungsmodus wechseln';
    strings['richtext.simpleeditingmodewarning_de'] = 'Im einfachen Editierungsmodus stehen keine erweiterten Formatierungsoptionen zur Verfügung. Wenn Sie mit der Textbearbeitung fortfahren, gehen möglicherweise bisherige Formatierungen verloren.';
    strings['richtext.notavailable.title_de'] = "Erweiterte Formatierungsoptionen nicht verfügbar";
    strings['richtext.notavailable.warning_de'] = "Das Editieren von Texten mit erweiterten Formatierungsoptionen wird von ihrem aktuellen Browser nicht unterstützt.<br/>Wenn Sie mit der Textbearbeitung fortfahren, gehen möglicherweise bisherige Formatierungen verloren.";

    strings['richtext.link.address_de'] = 'Bitte geben Sie die Zieladresse ein:';
    strings['richtext.link.tooltip_de']= 'mit Strg+Klick öffnen';

    strings['richtext.img.insertandedit_de'] = 'Einfügen und Bearbeiten';
    strings['richtext.img.insert_de'] = 'Einfügen';
    strings['richtext.img.save_de'] = 'Speichern';
    strings['richtext.img.delete_de'] = 'Bild entfernen';
    strings['richtext.img.edit.title_de'] = 'Bilder bearbeiten';
    strings['richtext.img.edit.imgtitle_de'] = 'Bildinformationen';
    strings['richtext.img.edit.widthtitle_de'] = 'Größe';
    strings['richtext.img.edit.sourcedescription_de'] = 'Hier können Sie die Bildquelle ändern.';
    strings['richtext.img.edit.captiondescription_de'] = 'Hier können Sie eine Bildunterschrift angeben.';
    strings['richtext.img.edit.widthdescription_de'] = 'Hier können Sie die Dimensionen des Bildes bearbeiten. Geben Sie die Breite entweder relativ zur Breite des umfließenden Texts, oder absolut in Pixeln an. Bitte beachten Sie, dass Bilder mit maximal 100% Breite angezeigt werden.';
    strings['richtext.img.edit.relativewidth_de'] = '% (relativ)';
    strings['richtext.img.edit.absolutewidth_de'] = 'px (absolut)';

    strings['attribute.mapper.loading_de'] = "Lade";
    strings['attribute.mapper.stencilsets_de'] = "Diagrammtypen";
    strings['attribute.mapper.attributes_selected_de'] = "#{count} verschiedene Attribut(e) ausgewählt";
    strings['attribute.mapper.attributes_deselected_de'] = "#{count} Attribut(e) ausgeschlossen";
    strings['attribute.mapper.deselected_de'] = "#{count} Element(e) ausgeschlossen";
    strings['attribute.mapper.selected_de'] = "#{count} Element(e) ausgewählt";
    strings['attribute.mapper.no_attributes_de'] = "Für diese Modellierungssprache stehen keine Attribute zur Verfügung.";
    strings['attribute.mapper.no_selection_de'] = "Keines";
    strings['attribute.mapper.exclusion_active_de'] = "Einschränkungen aktiv";
    strings['attribute.mapper.excluion_inactive_de'] = "Keine Einschränkungen";
    strings['attribute.mapper.list_de'] = "Liste";
    strings['attribute.mapper.selected_de'] = "#{count} ausgewählt";
    strings['attribute.mapper.untitled_group_de'] = "Unbenannte Gruppe";
    strings['attribute.mapper.config.all_attributes_de'] = "Alle Attribute";
    strings['attribute.mapper.config.own_attributes_de'] = "Eigene Attribute";
    strings['attribute.mapper.config.select_attributes_de'] = "Attribute selbst wählen";
    strings['attribute.mapper.config.all_elements_de'] = "Alle Elemente";
    strings['attribute.mapper.config.flow_elements_de'] = "Nur Kontrollflusselemente";
    strings['attribute.mapper.config.activities_de'] = "Nur Tätigkeiten";
    strings['attribute.mapper.config.select_elements_de'] = "Elemente selbst wählen";
    strings['attribute.mapper.config.name_de'] = "Name";
    strings['attribute.mapper.config.description_de'] = "Beschreibung";
    
    strings['attribute.mapper.config.hide_attributes_if_de'] = "Attribute verstecken, wenn";
    strings['attribute.mapper.config.hide_attributes_none_de'] = "Nie";
    strings['attribute.mapper.config.hide_attributes_empty_de'] = "Leer";
    strings['attribute.mapper.config.hide_attributes_default_de'] = "Leer oder entspricht dem Standardwert";
    
    strings['attribute.mapper.config.show_attribute_label_de'] = "Name des Attributs anzeigen";
    strings['attribute.mapper.config.separate_labels_de'] = "Attribute trennen durch";
    strings['attribute.mapper.config.separator_comma_de'] = "Komma";
    strings['attribute.mapper.config.separator_space_de'] = "Leerzeichen";
    strings['attribute.mapper.config.separator_linebreak_de'] = "Zeilenumbruch";
    strings['attribute.mapper.config.list_style_de'] = "Listen anzeigen als";
    strings['attribute.mapper.config.list_style_bullet_de'] = "Aufzählung";
    strings['attribute.mapper.config.list_style_numbered_de'] = "Nummerierte Liste";
    strings['attribute.mapper.config.main_properties_de'] = "Hauptattribute";
    strings['attribute.mapper.config.more_properties_de'] = "Weitere Attribute";
    strings['attribute.mapper.config.meta_properties_de'] = "Eigene Attribute";

    strings['glossary.mapper.type.document_de'] = "Dokumente";
    strings['glossary.mapper.type.org_unit_de'] = "Organisation";
    strings['glossary.mapper.type.it_system_de'] = "IT Systeme";
    strings['glossary.mapper.type.activity_de'] = "Aktivitäten";
    strings['glossary.mapper.type.state_de'] = "Ereignisse";
    strings['glossary.mapper.loading_groups_de'] = "Lade Glossarkategorien...";
    strings['glossary.mapper.all_categories_de'] = "Alle ausgewählt";
    strings['glossary.mapper.categories_chosen_de'] = "ausgewählt";
    strings['glossary.mapper.select_all_de'] = "Alle auswählen";
    strings['glossary.mapper.select_none_de'] = "Nichts auswählen";

    strings['glossary.new.languageswitch_de'] = "Sprachauswahl";
    
    strings['glossary.form.description_de'] = "Die folgenden Attribute können Sie mehrsprachig hinterlegen. Wechseln Sie dazu einfach während der Bearbeitung die Sprache, indem Sie über die Dropdown-Liste im oberen Bereich den gewünschten Eintrag auswählen.<br/>Bitte beachten Sie, dass der Titel in mindestens einer Sprache definiert sein muss.";

    strings['glossary.edit.title_de'] = "Glossarbegriff bearbeiten";
    strings['glossary.edit.save_de'] = "Speichern";
    strings['glossary.edit.description_de'] = "Hier können Sie einen vorhandenen Glossareintrag bearbeiten. Dabei aktualisieren sich nach dem Speichern Ihrer Änderungen automatisch alle Verweise auf diesen Glossarbegriff.";

    strings['glossary.new.title_de'] = "Neuer Glossarbegriff";
    strings['glossary.new.save_de'] = "Erzeugen";
    strings['glossary.new.create_de'] = "Erzeugt einen neuen Glossarbegriff.";

    strings['glossary.multilanguage.non_attributes_de'] = "Alle weiteren Attribute können nur in der Standardsprache definiert werden.";
    strings['glossary.multilanguage.copy_link_tt_de'] = "Beachten Sie bitte, dass beim Kopieren der Inhalte alle Inhalte auf der rechten Seiten ersetzt werden.";
    strings['glossary.multilanguage.remove_origin_column_de'] = "Linke Spalte ausblenden";
    strings['glossary.multilanguage.copy_link_title_de'] = "Alle Inhalte kopieren";

    strings['glossary.view.title_de'] = "Titel";
    strings['glossary.view.attachments_de'] = "Mitgeltende Dokumente";
    strings['glossary.view.description_de'] = "Beschreibung";

    strings['propertyeditor.itsm.assignee.company_de'] = "Unternehmen";
    strings['propertyeditor.itsm.assignee.organization_de'] = "Organisation";
    strings['propertyeditor.itsm.assignee.group_de'] = "Gruppe";
    strings['propertyeditor.itsm.location.region_de'] = "Region";
    strings['propertyeditor.itsm.location.sitegroup_de'] = "Standortgruppe";
    strings['propertyeditor.itsm.location.site_de'] = "Standort";
    strings['propertyeditor.itsm.servicecat.tier_de'] = "Schicht {0}";
    strings['propertyeditor.itsm.productcat.name_de'] = "Name";
    strings['propertyeditor.itsm.productcat.model_de'] = "Modell";
    strings['propertyeditor.itsm.variablemapping.header.variable_de'] = "Variable";
    strings['propertyeditor.itsm.variablemapping.header.input_de'] = "Input";
    strings['propertyeditor.itsm.variablemapping.header.output_de'] = "Output";
    strings['propertyeditor.itsm.variablemapping.error.title_de'] = "Zu viele Variablen";
    strings['propertyeditor.itsm.variablemapping.error.message_de'] = "Es werden zu viele Variablen vom Typ '{0}' verwendet.<br/> Das Maximum beträgt: {1}.";

    strings['propertyeditor.itsm.condition.add_de'] = "Hinzufügen der Variable...";

    // PRINT DIALOG
    strings["dialog.print.title_de"] = "PDF Export";
    strings["dialog.print.mask.load.defaults_de"] = "Standardeinstellungen werden geladen...";
    strings["dialog.print.mask.load.preview_de"] = "Erzeuge Vorschau...";
    strings["dialog.print.mask.create.pdf_de"] = "Erzeuge PDF...";
   	strings["dialog.print.button.create_de"] = "PDF erzeugen";
   	strings["dialog.print.button.edit_de"] = "Bearbeiten";
   	strings["dialog.print.button.remove_de"] = "Entfernen";
   	strings["dialog.print.button.upload_de"] = "Logo einfügen";
   	strings["dialog.print.button.configure_de"] = "Konfigurieren";
   	strings["dialog.print.button.remove.picture_de"] = "Logo entfernen";
   	strings["dialog.print.save.defaults.label_de"] = "Als Standard Einstellung übernehmen";
   	strings["dialog.print.orientation.landscape_de"] = "Querformat";
   	strings["dialog.print.orientation.portrait_de"] = "Hochformat";
   	strings["dialog.print.orientation.label_de"] = "Diagrammausrichtung";
   	strings["dialog.print.orientation.policy.label_de"] = "Diagramm ausrichten";
   	strings["dialog.print.orientation.policy.auto_de"] = "Automatisch";
   	strings["dialog.print.orientation.policy.always_de"] = "Immer";
   	strings["dialog.print.orientation.policy.never_de"] = "Niemals";
   	strings["dialog.print.orientation.cw_de"] = "Im Uhrzeigersinn";
   	strings["dialog.print.orientation.ccw_de"] = "Gegen den Uhrzeigersinn";
   	strings["dialog.print.paper.type.label_de"] = "Papiertyp"
   	strings["dialog.print.paper.type.a4_de"] = "DIN A4";
   	strings["dialog.print.paper.type.a3_de"] = "DIN A3";
   	strings["dialog.print.paper.type.us_letter_de"] = "US Letter";
   	strings["dialog.print.distribution.single_de"] = "Eine Seite";
   	strings["dialog.print.distribution.multi_de"] = "Mehrseitig";
   	strings["dialog.print.black.and.white_de"] = "Schwarz-Weiß-Druck";
   	strings["dialog.print.show.headers_de"] = "Zusätzliche Informationen anzeigen";
   	strings["dialog.print.label_de"] = "Exportieren Sie ein oder mehrere Diagramme als PDF. Sie können generelle Exportoptionen festlegen, sowie spezielle Attribute zu dem exportierten Diagramm anzeigen lassen.";
   	strings["dialog.print.label.managed_de"] = "Exportieren Sie dieses Diagramm als PDF. Sie können hier noch generelle Exportoptionen, wie zum Beispiel die Ausrichtung festlegen.";
   	strings["dialog.print.label.download_de"] = "Ihr PDF wird nun erstellt. Der Download startet in wenigen Momenten automatisch.";
   	strings["dialog.print.label.more.models_de"] = "(und #{count} weitere(s))";
   	strings["dialog.print.label.selected.models_de"] = "Ausgewählte Diagramme";
   	strings["dialog.print.label.select.view_de"] = "Sicht auswählen...";
   	strings["dialog.print.label.view.selected_de"] = "(Aktuelle Sicht: #{view})";
   	strings["dialog.print.label.no.logo_de"] = "Kein Logo";
   	strings["dialog.print.label.logo.size_de"] = "Originalgröße verwenden";
   	strings["dialog.print.label.logo.description_de"] = "Wenn Sie das Logo in seiner Originalgröße verwenden, stellen Sie bitte sicher, dass es eine Auflösung von 150 DPI hat.";
   	strings["dialog.print.label.preview.unavailable_de"] = "Es ist keine Vorschau verfügbar.";
   	strings["dialog.print.header.general_de"] = "Allgemein";
   	strings["dialog.print.header.orientation_de"] = "Ausrichtung";
   	strings["dialog.print.header.distribution_de"] = "Verteilung";
   	strings["dialog.print.header.logo_de"] = "Logo";
   	strings["dialog.print.logo.label_de"] = "Originalgröße verwenden";
   	strings["dialog.print.attribute.hint_de"] = "Fügen Sie hier bis zu 3 Attribute hinzu.";
   	strings["dialog.print.attribute.ownattribute_de"] = "Eigenes Attribut";
   	strings["dialog.print.attribute.lastauthor_de"] = "Letzer Autor";
   	strings["dialog.print.attribute.publishingdate_de"] = "Veröffentlicht am";
   	strings["dialog.print.attribute.publishingstatus_de"] = "Veröffentlicht";
   	strings["dialog.print.attribute.authors_de"] = "Autoren";
   	strings["dialog.print.attribute.updatedate_de"] = "Zuletzt geändert";
   	strings["dialog.print.attribute.modelpath_de"] = "Pfad";
   	strings["dialog.print.attribute.pagenumber_de"] = "Seitennummer";
   	strings["dialog.print.attribute.printdate_de"] = "Druckdatum";
   	strings["dialog.print.attribute.printedby_de"] = "Gedruckt von";
   	strings["dialog.print.diagram.name_de"] = "Diagrammname";
   	strings["dialog.print.error.no.models_de"] = "Bitte selektieren Sie mindestens ein Diagram oder einen Ordner.";
   	strings["dialog.print.error.creating.pdf_de"] = "Beim Erzeugen des PDF ist ein Fehler aufgetreten. Versuchen Sie es bitte erneut. Sollte der Fehler weiterhin bestehen, kontaktieren Sie bitte den Support.";

	strings['dialog.print.layersselection.title_de'] = "Attributvisualisierung";
	strings['dialog.print.layersselection.label_de'] = "Regeln";
	strings['layersselectiongrid.emptytext_de'] = "Es sind keine Regeln definiert worden";

   	// UPLOAD DIALOG
   	strings["dialog.upload.title_de"] = "Datei auswählen oder hochladen";
   	strings["dialog.upload.label.new.file_de"] = "Neue Datei hochladen";
   	strings["dialog.upload.label.existing.file_de"] = "Datei/Bild aus Dateiablage auswählen";
   	strings["dialog.upload.label.external.file_de"] = "Datei/Bild auf Netzlaufwerk oder Webressource verlinken";
   	strings["dialog.upload.label.external.empty_de"] = "Es sind keine Einträge vorhanden.";
   	strings["dialog.upload.label.choose.spacer_de"] = "Datei auswählen";
   	strings["dialog.upload.label.spacer.or_de"] = "Oder";
   	strings["dialog.upload.label.description_de"] = "Bitte wählen Sie eine Datei oder ein Bild aus Ihrer Signavio Dateiablage aus. Alternativ können Sie eine Datei auch als Webresource über eine URL verlinken oder einen Pfad zu einer Datei oder einem Bild auf einem Netzlaufwerk angeben.";
   	strings["dialog.upload.label.disabled_de"] = "Die Signavio Dateiablage ist für Ihren Arbeitsbereich deaktiviert.";
   	strings["dialog.upload.label.upload.disabled_de"] = "Das Hochladen neuer Dateien ist für Ihren Arbeitsbereich deaktiviert.";
   	strings["dialog.upload.label.max.size_de"] = "Die maximale Dateigröße beträgt "
   	strings["dialog.upload.label.quota.info_de"] = "Sie benutzen zur Zeit #{used} von #{available} zur Verfügung stehendem Speicher.";
   	strings["dialog.upload.label.file_de"] = "Datei";
   	strings["dialog.upload.label.file.destination_de"] = "Ablegen unter";
   	strings["dialog.upload.error.file.too.big.title_de"] = "Datei zu groß";
   	strings["dialog.upload.error.file.too.big.description_de"] = "Das Dokument/Bild ist zu groß oder würde das maximal zulässige Datenkontingent überschreiten. Bitte löschen Sie nicht mehr benötigte Dateien oder wenden Sie sich an den Signavio Support, um das Datenkontingent zu erweitern.";
   	strings["dialog.upload.error.file.too.big.single_de"] = "Die Datei ist größer als die maximal erlaubte Dateigröße";
   	strings["dialog.upload.error.file.too.big.all_de"] = "Die Datei würde das maximal zulässige Speicherkontingent überschreiten.";
   	strings["dialog.upload.error.no.folder.selected_de"] = "Bitte wählen Sie einen Ordner aus Ihrer Signavio Dateiablage, in welchem das neue Dokument/Bild gespeichert werden soll.";
   	strings["dialog.upload.error.no.file.selected_de"] = "Bitte wählen Sie eine Datei aus, die Sie hochladen möchten.";
   	strings["dialog.upload.error.no.image.selected_de"] = "Bitte wählen Sie ein Bild aus Ihrer Signavio Dateiablage aus.";
   	strings["dialog.upload.error.no.url_de"] = "Bitte tragen sie eine URL ein, auf die verlinkt werden soll.";
   	strings["dialog.upload.action.upload_de"] = "Daten werden hochgeladen...";
   	// changes for richtext images
   	strings["dialog.upload.richtext.title_de"] = "Bild auswählen oder hochladen";
   	strings["dialog.upload.richtext.label.new.file_de"] = "Neues Bild hochladen";
   	strings["dialog.upload.richtext.label.existing.file_de"] = "Bild aus Dateiablage auswählen";
   	strings["dialog.upload.richtext.label.choose.spacer_de"] = "Bild auswählen";
   	strings["dialog.upload.richtext.label.description_de"] = "Bitte wählen Sie ein Bild aus Ihrer Signavio Dateiablage aus.";
   	strings["dialog.upload.richtext.error.file.too.big.description_de"] = "Die Datei ist zu groß oder würde das maximal zulässige Datenkontingent überschreiten. Bitte löschen Sie nicht mehr benötigte Dateien oder wenden Sie sich an den Signavio Support, um das Datenkontingent zu erweitern.";
   	strings["dialog.upload.richtext.error.no.folder.selected_de"] = "Bitte wählen Sie einen Ordner aus Ihrer Signavio Dateiablage, in welchem das neue Bild gespeichert werden soll.";
   	strings["dialog.upload.richtext.error.no.image.selected_de"] = "Bitte wählen Sie ein Bild aus Ihrer Signavio Dateiablage aus.";
   	

   	strings["dialog.view.selection.label.settings_de"] = "Einstellungen";
   	strings["dialog.view.selection.label.original_de"] = "Original";
   	strings["dialog.view.selection.label.multiple.views_de"] = "Für dieses Diagramm sind mehrere stakeholder-spezifische Sichten vorhanden. Die Original-Sicht wurde für Sie vorselektiert. Wenn Sie eine andere Sicht exportieren möchten, können Sie diese unten auswählen.";

   	strings["component.folder.picker.empty_de"] = "Bitte wählen Sie einen Ordner aus.";
   	strings["component.folder.picker.custom_de"] = "Anderen Ordner wählen...";
   	strings["component.folder.picker.description_de"] = strings["component.folder.picker.empty_de"];
   	strings["component.folder.picker.head_de"] = "Ordnerauswahl";

   	strings["component.types.folder_de"] = "&raquo; Ordner";
   	strings["component.types.favorits_de"] = "&raquo; Favoriten";
   	strings["component.types.savedSearch_de"] = "&raquo; Gespeicherte Suche";
   	strings["component.types.public_de"] = "Gemeinsame Dokumente";
   	strings["component.types.private_de"] = "Meine Dokumente";
   	strings["component.types.published_de"] = "Öffentliche Dokumente";
   	strings["component.types.trash_de"] = "Papierkorb";
   	strings["component.types.internal_de"] = "Templates";


    strings['language_bg_de'] =  "Bulgarisch";
    strings['language_cz_de'] =  "Tschechisch";
    strings['language_da_de'] =  "Dänisch";
    strings['language_nl_de'] =  "Niederländisch";
    strings['language_ee_de'] =  "Estnisch";
    strings['language_fi_de'] =  "Finnisch";
    strings['language_fr_de'] =  "Französisch";
    strings['language_de_de'] =  "Deutsch";
    strings['language_gr_de'] =  "Griechisch";
    strings['language_hu_de'] =  "Ungarisch";
    strings['language_ie_de'] =  "Irisch";
    strings['language_it_de'] =  "Italienisch";
    strings['language_lv_de'] =  "Lettisch";
    strings['language_lt_de'] =  "Litauisch";
    strings['language_mt_de'] =  "Maltesisch";
    strings['language_pl_de'] =  "Polnisch";
    strings['language_pt_de'] =  "Portugiesisch";
    strings['language_ro_de'] =  "Rumänisch";
    strings['language_sk_de'] =  "Slowakisch";
    strings['language_si_de'] =  "Slowenisch";
    strings['language_es_de'] =  "Spanisch";
    strings['language_se_de'] =  "Schwedisch";
    strings['language_en_de'] =  "Englisch";
    strings['language_lu_de'] =  "Luxemburgisch";
    strings['language_za_de'] = "Afrikaans";
    strings['language_ru_de'] = "Russisch";
    strings['language_ja_de'] = "Japanisch";
    strings['language_zh_de'] = "Chinesisch";
    strings['language_ko_de'] = "Koreanisch";
    strings['language_tr_de'] = "Türkisch";


    strings['country_at_de'] = "Österreich";
    strings['country_be_de'] = "Belgien";
    strings['country_bg_de'] = "Bulgarien";
    strings['country_ch_de'] = "Schweiz";
    strings['country_cz_de'] = "Tschechisch";
    strings['country_dk_de'] = "Dänemark";
    strings['country_gb_de'] = "Großbritannien";
    strings['country_nl_de'] = "Niederlande";
    strings['country_ee_de'] = "Estland";
    strings['country_fi_de'] = "Finnland";
    strings['country_fr_de'] = "Frankreich";
    strings['country_de_de'] = "Deutschland";
    strings['country_gr_de'] = "Griechenland";
    strings['country_hu_de'] = "Ungarn";
    strings['country_ie_de'] = "Irland";
    strings['country_it_de'] = "Italien";
    strings['country_lv_de'] = "Lettland";
    strings['country_lt_de'] = "Litauen";
    strings['country_mt_de'] = "Malta";
    strings['country_pl_de'] = "Polen";
    strings['country_pt_de'] = "Portugal";
    strings['country_ro_de'] = "Rumänien";
    strings['country_sk_de'] = "Slowakei";
    strings['country_si_de'] = "Slowenien";
    strings['country_es_de'] = "Spanien";
    strings['country_se_de'] = "Schweden";
    strings['country_en_de'] = "England";
    strings['country_mx_de'] = "Mexiko";
    strings['country_us_de'] = "USA";
    strings['country_lu_de'] = "Luxemburg";
    strings['country_za_de'] = "Südafrika";
    strings['country_br_de'] = "Brasilien";
    strings['country_ca_de'] = "Kanada";
    strings['country_cl_de'] = "Chile";
    strings['country_li_de'] = "Liechtenstein";
    strings['country_nz_de'] = "Neuseeland";
    strings['country_au_de'] = "Australien";
    strings['country_ru_de'] = "Russland";
    strings['country_jp_de'] = "Japan";
    strings['country_cn_de'] = "China";
    strings['country_kr_de'] = "Südkorea";
    strings['country_tr_de'] = "Türkei";

    //TODO
    strings['multilanguage.label_de'] = "Sprache";

    strings['multilanguage.language.bg_de'] = "Bulgarisch";
	strings['multilanguage.language.cs_de'] = "Tschechisch";
	strings['multilanguage.language.dk_de'] = "Dänisch";
	strings['multilanguage.language.nl_de'] = "Niederländisch";
	strings['multilanguage.language.et_de'] = "Estnisch";
	strings['multilanguage.language.fi_de'] = "Finnisch";
	strings['multilanguage.language.fr_de'] = "Französisch";
	strings['multilanguage.language.de_de'] = "Deutsch";
	strings['multilanguage.language.el_de'] = "Griechisch";
	strings['multilanguage.language.hu_de'] = "Ungarisch";
	strings['multilanguage.language.ie_de'] = "Irisch";
	strings['multilanguage.language.it_de'] = "Italienisch";
	strings['multilanguage.language.lv_de'] = "Lettisch";
	strings['multilanguage.language.lt_de'] = "Litauisch";
	strings['multilanguage.language.mt_de'] = "Maltesisch";
	strings['multilanguage.language.pl_de'] = "Polnisch";
	strings['multilanguage.language.pt_de'] = "Portugiesisch";
	strings['multilanguage.language.ro_de'] = "Romänisch";
	strings['multilanguage.language.sk_de'] = "Slowakisch";
	strings['multilanguage.language.sl_de'] = "Slowenisch";
	strings['multilanguage.language.es_de'] = "Spanisch";
	strings['multilanguage.language.sv_de'] = "Schwedisch";
	strings['multilanguage.language.en_de'] = "Englisch";
	strings['multilanguage.language.lb_de'] = "Luxemburgisch";
	strings['multilanguage.language.af_de'] = "Afrikaans";
    strings['multilanguage.language.ru_de'] = "Russisch";
    strings['multilanguage.language.ja_de'] = "Japanisch";
    strings['multilanguage.language.zh_de'] = "Chinesisch";
    strings['multilanguage.language.ko_de'] = "Koreanisch";
    strings['multilanguage.language.tr_de'] = "Türkisch";

	strings['multilanguage.country.at_de'] = "Österreich";
	strings['multilanguage.country.be_de'] = "Belgien";
	strings['multilanguage.country.bg_de'] = "Bulgarien";
	strings['multilanguage.country.ch_de'] = "Schweiz";
	strings['multilanguage.country.cz_de'] = "Tschechisch";
	strings['multilanguage.country.dk_de'] = "Dänemark";
	strings['multilanguage.country.gb_de'] = "Großbritannien";
	strings['multilanguage.country.nl_de'] = "Niederlande";
	strings['multilanguage.country.ee_de'] = "Estland";
	strings['multilanguage.country.fi_de'] = "Finnland";
	strings['multilanguage.country.fr_de'] = "Frankreich";
	strings['multilanguage.country.de_de'] = "Deutschland";
	strings['multilanguage.country.gr_de'] = "Griechenland";
	strings['multilanguage.country.hu_de'] = "Ungarn";
	strings['multilanguage.country.ie_de'] = "Irland";
	strings['multilanguage.country.it_de'] = "Italien";
	strings['multilanguage.country.lv_de'] = "Lettland";
	strings['multilanguage.country.lt_de'] = "Litauen";
	strings['multilanguage.country.mt_de'] = "Malta";
	strings['multilanguage.country.pl_de'] = "Polen";
	strings['multilanguage.country.pt_de'] = "Portugal";
	strings['multilanguage.country.ro_de'] = "Rumänien";
	strings['multilanguage.country.sk_de'] = "Slowakei";
	strings['multilanguage.country.si_de'] = "Slowenien";
	strings['multilanguage.country.es_de'] = "Spanien";
	strings['multilanguage.country.se_de'] = "Schweden";
	strings['multilanguage.country.en_de'] = "England";
	strings['multilanguage.country.mx_de'] = "Mexiko";
	strings['multilanguage.country.us_de'] = "USA";
	strings['multilanguage.country.lu_de'] = "Luxemburg";
	strings['multilanguage.country.za_de'] = "Südafrika";
	strings['multilanguage.country.br_de'] = "Brasilien";
	strings['multilanguage.country.ca_de'] = "Kanada";
	strings['multilanguage.country.cl_de'] = "Chile";
	strings['multilanguage.country.li_de'] = "Liechtenstein";
	strings['multilanguage.country.nz_de'] = "Neuseeland";
	strings['multilanguage.country.au_de'] = "Australien";
    strings['multilanguage.country.ru_de'] = "Russland";
    strings['multilanguage.country.jp_de'] = "Japan";
    strings['multilanguage.country.cn_de'] = "China";
    strings['multilanguage.country.kr_de'] = "Südkorea";
    strings['multilanguage.country.tr_de'] = "Türkei";

	// IKS
	strings['iks.title_de'] = "Risiken und Kontrollen";
	strings['iks.desc_de'] = "Definieren Sie mögliche Risiken und deren Kontrollen.";
	strings['iks.windowapply_de'] = "Übernehmen";
	strings['iks.overlayhint_de'] = "Klicken Sie hier um Risiken und Kontrollen dieses Elements zu bearbeiten";
	strings['iks.toolbarname_de'] = "Risiken und Kontrollen anzeigen";
	strings['iks.toolbardesc_de'] = "Risiken und Kontrollen am Prozesselement anzeigen";
	strings['iks.risk_de'] = "Risiko";
	strings['iks.risks_de'] = "Risiken";
	strings['iks.control_de'] = "Kontrolle";
	strings['iks.controls_de'] = "Kontrollen";
	strings['iks.newentry_de'] = "Klicken Sie hier, um ein{0}hinzuzufügen...";
	strings['iks.newentryrisk_de'] = " neues Risiko ";
	strings['iks.newentrycontrol_de'] = "e neue Kontrolle ";
	strings['iks.addcontrols_de'] = "Kontrollen hinzufügen";
	strings['iks.removerisk_de'] = "Dieses Risiko löschen";
	strings['iks.removecontrol_de'] = "Diese Kontrolle löschen";
	strings['iks.deletethistpl_de'] = "Diese";
	strings['iks.deletethisrisk_de'] = "s Risiko und alle zugehörigen Kontrollen löschen?";
	strings['iks.deletethiscontrol_de'] = " Kontrolle löschen?";
	strings['iks.yes_de'] = "Ja";
	strings['iks.no_de'] = "Nein";
	strings['iks.globalrisks_de'] = "Risiken auf Diagrammebene";
	
	// NestableEditorGridPanel
	strings['negp.nestedfield.emptytext_de'] = "Inhalt hinzufügen";
	strings['negp.delete_de'] = "Löschen?";
	strings['negp.yes_de'] = "Ja";
	strings['negp.no_de'] = "Nein";

	strings['propertyeditor.npb.title_de'] = "Prozessattribute für die Nationale Prozessbibliothek";
	strings['propertyeditor.npb.topics.title_de'] = "Themenbereiche festlegen";
	strings['propertyeditor.npb.topics.desc_de'] = "Wählen Sie einen oder mehrere vordefinierte Themenbereiche aus oder geben Sie einen neuen Themenbereich an.";
	strings['propertyeditor.npb.topics.predefined_de'] = "vordefinierte Themenbereiche";
	strings['propertyeditor.npb.topics.other_de'] = "Sonstiges";
	strings['propertyeditor.npb.render_msg_de'] = " von 9 Pflichtattributen gesetzt";
    strings['propertyeditor.npb.invalid_leika_de'] = "Der eingebene Wert ist kein gültiger LeiKa-Schlüssel.";
    strings['propertyeditor.npb.no_leika_de'] = "Kein LeiKa-Eintrag.";
    strings['propertyeditor.npb.searching_de'] = "Suche...";
    strings['propertyeditor.npb.tab_mandatory_de'] = "Pflichtattribute";
    strings['propertyeditor.npb.tab_optional_de'] = "optionale Attribute";
    strings['propertyeditor.npb.tags.title_de'] = "Schlagworte";
    strings['propertyeditor.npb.tags.desc_de'] = "Geben Sie ein oder mehrere Schlagworte ein:";

	// Glossary Controls
	strings['glossary.category.label_de'] = "Kategorie";
﻿
	/**
	 * ENGLISH TRANSLATION
	 * First translation into English: -
	 * Translator: -
	 * @translationchecker -
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd = "Add";
	strings.btnopen = "Open";
	strings.btnremove = "Remove";
	strings.btnedit = "Edit";
	strings.btnreset = "Reset";
	strings.btnclose = "Close";
	strings.btnsave = "Save";
	strings.btnapply = "Apply";
	strings.moveup = "Move up";
	strings.movedown = "Move down";
	strings.url = "URL";
	strings.label = "Label";
	strings.year = "Jahr";
	strings.years = "Jahre";
	strings.month = "Monat";
	strings.months = "Monate";
	strings.month1 = "January";
	strings.month2 = "February";
	strings.month3 = "March";
	strings.month4 = "April";
	strings.month5 = "May";
	strings.month6 = "June";
	strings.month7 = "July";
	strings.month8 = "August";
	strings.month9 = "September";
	strings.month10 = "October";
	strings.month11 = "November";
	strings.month12 = "December";
	strings.day1 = "Monday";
	strings.day2 = "Tuesday";
	strings.day3 = "Wednesday";
	strings.day4 = "Thursday";
	strings.day5 = "Friday";
	strings.day6 = "Saturday";
	strings.day7 = "Sunday";
	strings.year = "Year";
	strings.years = "Years";
	strings.month = "Month";
	strings.months = "Months";
	strings.day = "Day";
	strings.days = "Days";
	strings.hour = "Hour";
	strings.hours = "Hours";
	strings.minute = "Minute";
	strings.minutes = "Minutes";
	strings.second = "Second";
	strings.seconds = "Seconds";
	strings.msecond = "Millisecond";
	strings.mseconds = "Milliseconds";	
	strings.langdatetime = '{day}<tpl if="day == 1">st</tpl><tpl if="day == 2">nd</tpl><tpl if="day&gt;2">th</tpl> of {monthname}, {year} <tpl if="hours&gt;11">{hours - 12}</tpl><tpl if="hours&lt;12">{hours}</tpl>:{minutes}:{seconds} <tpl if="hours&gt;11">PM</tpl><tpl if="hours&lt;12">AM</tpl>'; 
    strings.langshortdatetime = "{month}/{day}/{year}";
	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly = "'#{0}' create as #{1}";
	strings.createglossarynew = "Create new";

	// GLOSSARY CATEGORIES
	strings.document = "Documents";
	strings.org_unit = "Organizational Units";
	strings.it_system = "IT Systems";
	strings.activity = "Activities";
	strings.state = "Events";

	strings.noglossary_entry = "No dictionary entry.";

	//Feedback Window
	
	strings["views.feedbackpsubject"] = "Cause of your request";
	strings["views.feedbackquestion"] = "Question";
	strings["views.feedbackquestiontitle"] = "Your Question concerning the Signavio Process Editor";
	strings["views.feedbackquestiondescription"] = "Detailed description of your question";
	strings["views.feedbackbugreport"] = "Bug report";
	strings["views.feedbackbugreporttitle"] = "Problem with the Signavio Process Editor";

	strings["views.feedbacktitleenterprise"] = "Signavio Support";
	strings["views.feedbacktitle"] = "Support";
	strings["views.feedbacktitleenterprise"] = "Support";
	strings["views.feedbacktitle"] = "Signavio Support";
	strings["views.feedbackentersubject"] = "Please enter a subject that briefly describes the problem or question.";
	strings["views.feedbackenterdescription"] = "Please describe your problem or question as detailed as possible.";
	strings["views.feedbackpmsg"] = "Detailed description of the error";
	strings["views.feedbackpempty"] = "* Please describe your request. Please provide as detailed information as possible.";
	strings["views.feedbackpsubject"] = "Problem with the Signavio Process Editor";
	strings["views.feedbackpbrowser"] = "Information about your browser and environment";
	strings["views.feedbackpbrowserdesc"] = "This information has been auto-detected from your browser. It can be helpful if you 	encountered a bug associated with browser-specific behavior.";
	strings["views.feedbackclosetitle"] = "Close";
	strings["views.feedbackfailure"] = "Failure";
	strings["views.feedbackfailuremsg"] = "The message could not be sent!";
	strings["views.feedbacksuccess"] = "Success";
	strings["views.feedbacksuccessmsg"] = "Thank you for your feedback!";
	strings["views.feedbacksending"] = "Sending message ...";
	strings["views.sendfeedback"] = "Send support request";
	strings["views.feedbackcopy"] = "Send a copy to e-mail.";
	strings["views.feedbackcopydesc"] = "Sends a copy of your support request to your e-mail.";
	strings["views.feedbackpattach"] = "Attach Current Diagram";
	strings["views.feedbackpattachdesc"] = "This information can be helpful for debugging purposes. If your diagram contains any sensitive data, remove it before sending or uncheck this behavior.";
	strings["views.feedbackreceiver"] = "Recipient";
	strings["views.feedbackreceiversignavio"] = " Signavio support ([mail])";
	strings["views.feedbackreceiverenterprise"] = " Your support ([mail])";
	strings["views.feedbackmissingheader"] = "No problem statement";
	strings["views.feedbackmissingheadermsg"] = "Please enter a short problem statement.";
	strings["views.feedbackmissingbody"] = "No detailed description";
	strings["views.feedbackmissingbodymsg"] = "Please describe in a detailed message: What kind of problems do you have? What is the expected behaviour?";
	strings["views.feedbackerrorlength"] = "The description is too short. Please type at least 40 letters.";
	strings["views.feedbackerrorlengthtitle"] = "Message is too short";
	strings["views.feedbacksignavio"] = "You have a problem with using the Signavio Process Editor or you have found an error? In this case please use the support form to contact the Signavio " +
										"support directly. Please notice, that the handling of your request can take about 1-2 business days. " +
										"We will respond by email. All information is transferred unencrypted.";
										   "Falle das Support-Formular um direkten Kontakt mit Signavio aufzunehmen. Bitte beachten Sie, dass eine Bearbeitung Ihrer Anfrage "+
										   "ca. 1-2 Werktage in Anspruch nehmen kann. Sie erhalten unsere Antwort anschließend per Email. Sämtliche Informationen werden unverschlüsselt "+
										   "übertragen.";
										  "Por favor tome en cuenta que el manejo de su solicitud puede tardar de 1-2 días hábiles." + "Le responderemos por correo electrónico. Toda la información se transmite cifrada";
	strings["views.feedbackenterprise"] = "You have a problem with using the Signavio Process Editor or you have found an error? In this case please use the support form to directly contact your " +
										  "support or administrator. All information is transferred unencrypted.";
											 "Falle das Support-Formular um direkten Kontakt mit Ihrem Support/Administrator aufzunehmen. Sämtliche Informationen werden unverschlüsselt "+
											 "übertragen.";
										  "Por favor tome en cuenta que el manejo de su solicitud puede tardar de 1-2 días hábiles." + "Le responderemos por correo electrónico. Toda la información se transmite cifrada";
	//PDF Export Window
	strings["views.offertitle"] = "PDF (single diagram)";
	strings["views.offertitledesc"] = "You can print your diagram across multiple pages. Please select the layout you would like to have your PDF export.";
	strings["views.optionwindowtitle"] = "PDF Export (single diagram)";
	strings["views.buttontitle"] = "Generate PDF";
	strings["views.closetitle"] = "Cancel";
	strings["views.fittopage"] = "Fit to one page";
	strings["views.clipallsides"] = "Continuous print (2-dimensional)";
	strings["views.clipbottom"] = "Continuous print (vertical)";
	strings["views.clipright"] = "Continuous print (horizontal)";
	strings["views.landscape"] = "Landscape";
	strings["views.portrait"] = "Portrait";
	strings["views.defaultname"] = "Export";
	strings["views.branding"] = "Remove Signavio logos";
	strings["views.premiumonly"] = "This feature is only available in the Professional edition.";
	strings["views.waiting"] = "Process documentation will be created.<br/>This might take some time...";
	strings["views.resetview"] = "Original";
	strings["views.windowdescription"] = "Please select a View for the Export:";


	strings["panel.businessrule"] = "Business Rule";
	strings["panel.static"] = "Static";
	strings["panel.dynamic"] = "Dynamic";
	strings["panel.operation"] = "Operation";
	strings["panel.add"] = "add";
	strings["panel.remove"] = "remove";

	strings["panel.no_description"] = "No description";
	strings["panel.no_performer"] = "No Performer defined.";
	strings["panel.no_users"] = "No Users available.";
	strings["panel.no_free_userselection"] = "Unrestricted user selection";
	strings["panel.no_parallel_title"] = "Add a group";
	strings["panel.no_parallel_description"] = "For the current element the loop type is set either to parallel or sequential, it means that several users might perform the task. To simplify this, do you want to use all members of the selected group instead of the group themselve?";
	strings["panel.no_parallel_no_user"] = "The current group has no members contained.";
	strings["panel.no_defined_role_label"] = "Pre-selection";
	strings["panel.no_defined_role_single_user"] = "Single user";
	strings["panel.no_defined_role_role_member"] = "Group/role members";
	strings["panel.no_defined_role_group"] = "Groups/roles";
	strings["panel.label_free_userselection"] = "(Unrestricted user selection)";

	strings["wizard.nextbtnlabel"] = "Next >";
	strings["wizard.previousbtnlabel"] = "< Previous";

	/** New Language Properties 27.07.2010 */
    strings["richtext.title.undo"] = "Undo (Ctrl+Z)";
    strings["richtext.text.undo"] = "Undoes the last changes.";

    strings["richtext.title.redo"] = "Redo (Shift+Ctrl+Z)";
    strings["richtext.text.redo"] = "Redoes the last changes.";
    strings["richtext.title.bold"] = "Bold (Ctrl+B)";
    strings["richtext.text.bold"] = "Make the selected text bold.";

    strings["richtext.title.italic"] = "Italic (Ctrl+I)";
    strings["richtext.text.italic"] = "Make the selected text italic.";

    strings["richtext.title.underline"] = "Underline (Ctrl+U)";
    strings["richtext.text.underline"] = "Underline the selected text.";

    strings["richtext.title.fontselect"] = "Font";
    strings["richtext.text.fontselect"] = "Change the font of the selected text.";

    strings["richtext.title.fontsizeselect"] = "Fontsize";
    strings["richtext.text.fontsizeselect"] = "Change the fontsize of the selected text.";

    strings["richtext.title.h1"] = "Headline";
    strings["richtext.text.h1"] = "Insert a headline.";

    strings["richtext.title.h2"] = "Subheadline";
    strings["richtext.text.h2"] = "Insert a subheadline.";

    strings["richtext.title.h3"] = "Section Headline";
    strings["richtext.text.h3"] = "Insert a new section headline.";

    strings["richtext.title.inserthorizontalrule"] = "Horizontal Rule";
    strings["richtext.text.inserthorizontalrule"] = "Inserts a horizontal rule.";

    strings["richtext.title.color"] = "Font Color";
    strings["richtext.text.color"] = "Change the color of the selected text.";

    strings["richtext.title.markupcolor"] = "Text Highlight Color";
    strings["richtext.text.markupcolor"] = "Change the background color of the selected text.";

    strings["richtext.title.justifyleft"] = "Align Text Left";
    strings["richtext.text.justifyleft"] = "Align text to the left.";

    strings["richtext.title.justifycenter"] = "Center Text";
    strings["richtext.text.justifycenter"] = "Center text in the editor.";

    strings["richtext.title.justifyright"] = "Align Text Right";
    strings["richtext.text.justifyright"] = "Align text to the right.";

    strings["richtext.title.indent"] = "Indent (Tab)";
    strings["richtext.text.indent"] = "Indent Text.";

    strings["richtext.title.outdent"] = "Outdent (Shift+Tab)";
    strings["richtext.text.outdent"] = "Outdent Text.";

    strings["richtext.title.createlink"] = "Hyperlink";
    strings["richtext.text.createlink"] = "Make the selected text a hyperlink.";

    strings["richtext.title.unlink"] = "Remove Hyperlink";
    strings["richtext.text.unlink"] = "Removes the Hyperlink of the selection.";

    strings["richtext.title.insertorderedlist"] = "List (numbered)";
    strings["richtext.text.insertorderedlist"] = "Start a numbered list.";

    strings["richtext.title.insertunorderedlist"] = "Bullet List";
    strings["richtext.text.insertunorderedlist"] = "Start a bulleted list.";

    strings["richtext.title.removeformat"] = "Remove Format";
    strings["richtext.text.removeformat"] = "Removes all formatting applied to the selection.";

    strings["richtext.title.insertimages"] = "Insert/edit image";
    strings["richtext.text.insertimages"] = "Edit a selected image or insert an image from your Signavio workspace";

    strings['richtext.colormenu.defaultcolor'] = 'Automatic';

    strings['richtext.stub.more'] = 'more';
    strings['richtext.stub.less'] = 'less';
    strings['richtext.stub.openprint'] = 'Open print view';

    strings['richtext.simpleeditingmodetitle'] = 'Simple Editing Mode';
    strings['richtext.simpleeditingmodedesc'] = 'Switch to simple Editing mode';
    strings['richtext.simpleeditingmodewarning'] = 'Advanced formating options are not available in the simple Editing mode. If you continue, all existing formating options can be lost.';
    strings['richtext.notavailable.title'] = "Advanced formating not available";
    strings['richtext.notavailable.warning'] = "The advanced Editing mode is not supported by your browser.<br/>If you continue, all existing formating options can be lost.";


    strings['richtext.link.address'] = 'Please enter the target address:';
    strings['richtext.link.tooltip'] = 'open with Ctrl+Click';

    strings['richtext.img.insertandedit'] = 'Insert and edit';
    strings['richtext.img.insert'] = 'Insert';
    strings['richtext.img.save'] = 'Save';
    strings['richtext.img.delete'] = 'Delete image';
    strings['richtext.img.edit.title'] = 'Edit Image';
    strings['richtext.img.edit.imgtitle'] = 'Image';
    strings['richtext.img.edit.widthtitle'] = 'Size';
    strings['richtext.img.edit.sourcedescription'] = 'Here you can configure the source of the image.';
    strings['richtext.img.edit.captiondescription'] = 'Here you can enter the image caption.';
    strings['richtext.img.edit.widthdescription'] = 'Configure the image width, either relative to the width of the surrounding text or absolute in pixels. However, the displayed image size will not exceed a width of 100%';
    strings['richtext.img.edit.relativewidth'] = '% (relative)';
    strings['richtext.img.edit.absolutewidth'] = 'px (absolute)';




    strings['attribute.mapper.loading'] = "Loading";
    strings['attribute.mapper.stencilsets'] = "diagram types";
    strings['attribute.mapper.deselected'] = "#{count} element(s) excluded";
    strings['attribute.mapper.attributes_selected'] = "#{count} different attribute(s) selected";
    strings['attribute.mapper.attributes_deselected'] = "#{count} attribute(s) excluded";
    strings['attribute.mapper.selected'] = "#{count} element(s) selected";
    strings['attribute.mapper.no_attributes'] = "There are no attributes available for this modeling language.";
    strings['attribute.mapper.no_selection'] = "None";
    strings['attribute.mapper.exclusion_active'] = "Restrictions set";
    strings['attribute.mapper.excluion_inactive'] = "No restrictions set";
    strings['attribute.mapper.list'] = "List";

    strings['attribute.mapper.selected'] = "#{count} selected";

    strings['attribute.mapper.untitled_group'] = "Untitled group";

    strings['attribute.mapper.config.all_attributes'] = "All attributes";
    strings['attribute.mapper.config.own_attributes'] = "Custom attributes";
    strings['attribute.mapper.config.select_attributes'] = "Select attributes";
    strings['attribute.mapper.config.all_elements'] = "All elements";
    strings['attribute.mapper.config.flow_elements'] = "Only flow elements";
    strings['attribute.mapper.config.activities'] = "Only activities";
    strings['attribute.mapper.config.select_elements'] = "Select elements";

    strings['attribute.mapper.config.name'] = "Name";
    strings['attribute.mapper.config.description'] = "Description";

    strings['attribute.mapper.config.hide_attributes_if'] = "Hide attributes if";
    strings['attribute.mapper.config.hide_attributes_none'] = "Never";
    strings['attribute.mapper.config.hide_attributes_empty'] = "Empty";
    strings['attribute.mapper.config.hide_attributes_default'] = "Empty or corresponds to default value";
            
    strings['attribute.mapper.config.show_attribute_label'] = "Display attribute labels";
    strings['attribute.mapper.config.separate_labels'] = "Separate attributes by";
    strings['attribute.mapper.config.separator_comma'] = "Comma";
    strings['attribute.mapper.config.separator_space'] = "Space";
    strings['attribute.mapper.config.separator_linebreak'] = "Linebreak";
    strings['attribute.mapper.config.list_style'] = "Lists are shown as";
    strings['attribute.mapper.config.list_style_bullet'] = "Bullet list";
    strings['attribute.mapper.config.list_style_numbered'] = "Ordered list";

    strings['attribute.mapper.config.main_properties'] = "Main properties";
    strings['attribute.mapper.config.more_properties'] = "More properties";
    strings['attribute.mapper.config.meta_properties'] = "Custom attributes";

    // Glossary Controls
	strings['glossary.category.label'] = "Category";

	strings['glossary.form.description'] = "The following attributes can be defined in different languages. Please use the drop-down field in the top to change the language.<br/>Consider that the title must be defined in at least one language.";

	strings['glossary.edit.title'] = "Edit entry";
    strings['glossary.edit.save'] = "Save";
    strings['glossary.edit.description'] = "Edit the current dictionary entry.";

    strings['glossary.new.title'] = "New entry";
    strings['glossary.new.save'] = "Create";
    strings['glossary.new.create'] = "Create a new dictionary entry.";

    strings['glossary.multilanguage.non_attributes'] = "The following attributes can only be defined in the default language.";
    strings['glossary.multilanguage.copy_link_tt'] = "Please notice that all contents will be replace by the new contents.";
    strings['glossary.multilanguage.remove_origin_column'] = "Hide left column";
    strings['glossary.multilanguage.copy_link_title'] = "Copy all contents";

    strings['glossary.view.title'] = "Title";
    strings['glossary.view.attachments'] = "Relevant documents";
    strings['glossary.view.description'] = "Description";

    strings['glossary.mapper.type.document'] = "Documents";
    strings['glossary.mapper.type.org_unit'] = "Organizational Units";
    strings['glossary.mapper.type.it_system'] = "IT Systems";
    strings['glossary.mapper.type.activity'] = "Activities";
    strings['glossary.mapper.type.state'] = "Events";

    strings['glossary.mapper.loading_groups'] = "Loading dictionary groups...";
    strings['glossary.mapper.all_categories'] = "All chosen";
    strings['glossary.mapper.categories_chosen'] = "chosen";
    strings['glossary.mapper.select_all'] = "Select all";
    strings['glossary.mapper.select_none'] = "Select nothing";

    strings['propertyeditor.itsm.assignee.company'] = "Enterprise";
    strings['propertyeditor.itsm.assignee.organization'] = "Organization";
    strings['propertyeditor.itsm.assignee.group'] = "Group";

    strings['propertyeditor.itsm.location.region'] = "Region";
    strings['propertyeditor.itsm.location.sitegroup'] = "Site Group";
    strings['propertyeditor.itsm.location.site'] = "Site";

    strings['propertyeditor.itsm.servicecat.tier'] = "Tier {0}";

    strings['propertyeditor.itsm.productcat.name'] = "Name";
    strings['propertyeditor.itsm.productcat.model'] = "Model";

    strings['propertyeditor.itsm.variablemapping.header.variable'] = "Variable";
    strings['propertyeditor.itsm.variablemapping.header.input'] = "Input";
    strings['propertyeditor.itsm.variablemapping.header.output'] = "Output";

    strings['propertyeditor.itsm.variablemapping.error.title'] = "Too many variables";
    strings['propertyeditor.itsm.variablemapping.error.message'] = "Too many variables of type '{0}' are being used.<br/> The maximum is: {1}.";

    strings['propertyeditor.itsm.condition.add'] = "Add variable...";

    strings['glossary.new.languageswitch'] = "Language";

    strings["dialog.print.titlte"] = "PDF Export";
    strings["dialog.print.mask.load.defaults"] = "Loading default settings...";
    strings["dialog.print.mask.load.preview"] = "Creating preview...";
    strings["dialog.print.mask.create.pdf"] = "Creating PDF...";
   	strings["dialog.print.button.create"] = "Create PDF";
   	strings["dialog.print.button.edit"] = "Edit";
   	strings["dialog.print.button.remove"] = "Remove";
   	strings["dialog.print.button.upload"] = "Add custom logo";
   	strings["dialog.print.button.configure"] = "Configure";
   	strings["dialog.print.button.remove.picture"] = "Remove logo";
   	strings["dialog.print.save.defaults.label"] = "Save as defaults";
   	strings["dialog.print.orientation.landscape"] = "Landscape";
   	strings["dialog.print.orientation.portrait"] = "Portrait";
   	strings["dialog.print.orientation.label"] = "Diagram orientation";
   	strings["dialog.print.orientation.policy.label"] = "Diagram orientation";
   	strings["dialog.print.orientation.policy.auto"] = "Automatic";
   	strings["dialog.print.orientation.policy.always"] = "Always";
   	strings["dialog.print.orientation.policy.never"] = "Never";
   	strings["dialog.print.orientation.cw"] = "Clockwise";
   	strings["dialog.print.orientation.ccw"] = "Counterclockwise";
   	strings["dialog.print.paper.type.label"] = "Paper size"
   	strings["dialog.print.paper.type.a4"] = "A4";
   	strings["dialog.print.paper.type.a3"] = "A3";
   	strings["dialog.print.paper.type.us_letter"] = "US Letter";
   	strings["dialog.print.distribution.single"] = "Single page";
   	strings["dialog.print.distribution.multi"] = "Multiple pages";
   	strings["dialog.print.black.and.white"] = "Print in black and white";
   	strings["dialog.print.show.headers"] = "Show additional information";
   	strings["dialog.print.label"] = "Export one or more diagrams to PDF. You can change the general export settings as well as add additional attributes which are printed along with the diagram.";
   	strings["dialog.print.label.managed"] = "Export this diagram to PDF. You can change the general export settings such as orientation before you print the diagram.";
   	strings["dialog.print.label.download"] = "Your PDF is being created. The download will start automatically in a few moments.";
   	strings["dialog.print.label.more.models"] = "(and #{count} more)";
   	strings["dialog.print.label.selected.models"] = "Selected diagrams";
   	strings["dialog.print.label.select.view"] = "Select a view...";
   	strings["dialog.print.label.view.selected"] = "(Current view: #{view})";
   	strings["dialog.print.label.preview.unavailable"] = "The preview is not available.";
   	strings["dialog.print.label.no.logo"] = "No logo";
   	strings["dialog.print.header.logo.description"] = "If you want to use the logo in its original size, please make that it has a resolution of 150 DPI.";
   	strings["dialog.print.label.logo.size"] = "Use the original size";
   	strings["dialog.print.header.general"] = "General";
   	strings["dialog.print.header.orientation"] = "Orientation";
   	strings["dialog.print.header.distribution"] = "Distribution";
   	strings["dialog.print.header.logo"] = "Logo";
   	strings["dialog.print.logo.label"] = "Use original size";
   	strings["dialog.print.attribute.hint"] = "Add up to 3 attributes.";
   	strings["dialog.print.attribute.ownattribute"] = "Own attribute";
   	strings["dialog.print.attribute.lastauthor"] = "Last author";
   	strings["dialog.print.attribute.publishingdate"] = "Publishing date";
   	strings["dialog.print.attribute.publishingstatus"] = "Published";
   	strings["dialog.print.attribute.authors"] = "Authors";
   	strings["dialog.print.attribute.updatedate"] = "Last modified";
   	strings["dialog.print.attribute.modelpath"] = "Path";
   	strings["dialog.print.attribute.pagenumber"] = "Page number";
   	strings["dialog.print.attribute.printdate"] = "Print date";
   	strings["dialog.print.attribute.printedby"] = "Printed by";
   	strings["dialog.print.diagram.name"] = "Diagram name";
   	strings["dialog.print.error.no.models"] = "Please select at least one diagram or one folder.";
   	strings["dialog.print.error.creating.pdf"] = "An error occurred while your PDF was being created. Please try again. If the problem persists, please contact the support.";

	strings['dialog.print.layersselection.title'] = "Attribute visualization";
	strings['dialog.print.layersselection.label'] = "Rule sets";
	strings['layersselectiongrid.emptytext'] = "No attribute visualization is defined";

   	// UPLOAD DIALOG
   	strings["dialog.upload.title"] = "Choose or upload a file/picture";
   	strings["dialog.upload.label.new.file"] = "Upload a new file/picture";
   	strings["dialog.upload.label.existing.file"] = "Choose a file/picture from your file storage";
   	strings["dialog.upload.label.external.file"] = "Link a file/picture on a web resource or network storage";
   	strings["dialog.upload.label.external.empty"] = "No list entries.";
   	strings["dialog.upload.label.choose.spacer"] = "Choose file/picture";
   	strings["dialog.upload.label.spacer.or"] = "Or";
   	strings["dialog.upload.label.description"] = "Please choose a file from your Siganvio file storage. As an alternative, you can define a URL that points to a web resource or a link to a file on a network storage.";
   	strings["dialog.upload.label.disabled"] = "The Signavio file storage is not available in your workspace.";
   	strings["dialog.upload.label.upload.disabled"] = "The upload of new files has been disabled for your workspace.";
   	strings["dialog.upload.label.max.size"] = "The maximum file size is "
   	strings["dialog.upload.label.quota.info"] = "You are currently using #{used} of #{available} of available storage.";
   	strings["dialog.upload.label.file"] = "File";
   	strings["dialog.upload.label.file.destination"] = "Save to";
   	strings["dialog.upload.error.file.too.big.title"] = "File too large";
   	strings["dialog.upload.error.file.too.big.description"] = "The Document/Picture is too big or would exceed the size of your Signavio file storage. Please delete unused files or contact the Signavio Support to order additional storage.";
   	strings["dialog.upload.error.file.too.big.single"] = "The file exceeds the maximum file size.";
   	strings["dialog.upload.error.file.too.big.all"] = "The file would exceed the storage capacity.";
   	strings["dialog.upload.error.no.folder.selected"] = "Please select a folder from your Signavio file storage where the document/picture will be stored.";
   	strings["dialog.upload.error.no.file.selected"] = "Please choose a file/picture you want to upload.";
   	strings["dialog.upload.error.no.image.selected"] = "Please chosse a file/picture form your Signavio file storage.";
   	strings["dialog.upload.error.no.url"] = "Please enter a URL to which this link should point to.";
   	strings["dialog.upload.action.upload"] = "Upload in progress...";
   	// changes for richtext images
   	strings["dialog.upload.richtext.title"] = "Choose or upload a picture";
   	strings["dialog.upload.richtext.label.new.file"] = "Upload a new picture";
   	strings["dialog.upload.richtext.label.existing.file"] = "Choose a picture from your file storage";
   	strings["dialog.upload.richtext.label.choose.spacer"] = "Choose picture";
	strings["dialog.upload.richtext.label.description"] = "Please choose a picture from your Siganvio file storage.";
   	strings["dialog.upload.richtext.label.upload.disabled"] = "The upload of new pictures has been disabled for your workspace.";
   	strings["dialog.upload.richtext.error.file.too.big.description"] = "The file is too big or would exceed the size of your Signavio file storage. Please delete unused files or contact the Signavio Support to order additional storage.";
   	strings["dialog.upload.richtext.error.file.too.big.single"] = "The file exceeds the maximum file size.";
   	strings["dialog.upload.richtext.error.no.folder.selected"] = "Please select a folder from your Signavio file storage where the picture will be stored.";
   	strings["dialog.upload.richtext.error.no.file.selected"] = "Please choose a picture you want to upload.";
   	strings["dialog.upload.richtext.error.no.image.selected"] = "Please chosse a picture form your Signavio file storage.";

   	strings["dialog.view.selection.label.settings"] = "Settings";
   	strings["dialog.view.selection.label.original"] = "Original";
   	strings["dialog.view.selection.label.multiple.views"] = "There are several stakeholder specific views available for this diagram. The original view has been pre selected for you. If you like to export another one, please select it at the bottom.";

   	strings["component.folder.picker.empty"] = "Please choose a folder.";
   	strings["component.folder.picker.custom"] = "Choose another folder...";
   	strings["component.folder.picker.description"] = strings["component.folder.picker.empty"];
   	strings["component.folder.picker.head"] = "Folder selection";

   	strings["component.types.folder"] = "&raquo; Folder";
   	strings["component.types.favorits"] = "&raquo; Favorites";
   	strings["component.types.savedSearch"] = "&raquo; Saved Search";
   	strings["component.types.public"] = "Shared documents";
   	strings["component.types.private"] = "My documents";
   	strings["component.types.published"] = "Public documents";
   	strings["component.types.trash"] = "Trash";
   	strings["component.types.internal"] = "Templates";

    strings['language_bg'] = "Bulgarian";
    strings['language_cz'] = "Czech";
    strings['language_da'] = "Danish";
    strings['language_nl'] = "Dutch";
    strings['language_et'] = "Estonian";
    strings['language_fi'] = "Finnish";
    strings['language_fr'] = "French";
    strings['language_de'] = "German";
    strings['language_el'] = "Greek";
    strings['language_hu'] = "Hungarian";
    strings['language_ie'] = "Irish";
    strings['language_it'] = "Italian";
    strings['language_lv'] = "Latvian";
    strings['language_lt'] = "Lithunian";
    strings['language_mt'] = "Maltese";
    strings['language_pl'] = "Polish";
    strings['language_pt'] = "Portuguese";
    strings['language_ro'] = "Romanian";
    strings['language_sk'] = "Slovak";
    strings['language_sl'] = "Slovene";
    strings['language_es'] = "Spanish";
    strings['language_sv'] = "Swedish";
    strings['language_mx'] = "Spanish";
    strings['language_en'] = "English";
    strings['language_lb'] = "Luxembourgish";
    strings['language_af'] = "Afrikaans";
    strings['language_ru'] = "Russian";
    strings['language_ja'] = "Japanese";
    strings['language_zh'] = "Chinese";
    strings['language_ko'] = "Korean";
    strings['language_tr'] = "Turkish";

    strings['country_at'] = "Austria";
    strings['country_be'] = "Belgium";
    strings['country_bg'] = "Bulgaria";
    strings['country_ch'] = "Switzerland";
    strings['country_cz'] = "Czech";
    strings['country_dk'] = "Denmark";
    strings['country_gb'] = "Great Britain";
    strings['country_nl'] = "Netherlands";
    strings['country_ee'] = "Estonia";
    strings['country_fi'] = "Finland";
    strings['country_fr'] = "France";
    strings['country_de'] = "Germany";
    strings['country_gr'] = "Greece";
    strings['country_hu'] = "Hungary";
    strings['country_ie'] = "Ireland";
    strings['country_it'] = "Italy";
    strings['country_lv'] = "Latvia";
    strings['country_lt'] = "Lithuania";
    strings['country_mt'] = "Malta";
    strings['country_pl'] = "Poland";
    strings['country_pt'] = "Portugal";
    strings['country_ro'] = "Romania";
    strings['country_sk'] = "Slovakia";
    strings['country_si'] = "Slovenia";
    strings['country_es'] = "Spain";
    strings['country_se'] = "Sweden";
    strings['country_en'] = "England";
    strings['country_mx'] = "Mexico";
    strings['country_us'] = "USA";
    strings['country_lu'] = "Luxembourg";
    strings['country_za'] = "South Africa";
    strings['country_br'] = "Brazil";
    strings['country_ca'] = "Canada";
    strings['country_cl'] = "Chile";
    strings['country_li'] = "Liechtenstein";
    strings['country_nz'] = "New Zealand";
    strings['country_au'] = "Australia";
    strings['country_ru'] = "Russia";
    strings['country_jp'] = "Japan";
    strings['country_cn'] = "China";
    strings['country_kr'] = "Republic of Korea";
    strings['country_tr'] = "Turkey";


    //TODO
    strings['multilanguage.label'] = "Language";

	strings['multilanguage.language.bg'] = "Bulgarian";
	strings['multilanguage.language.cz'] = "Czech";
	strings['multilanguage.language.dk'] = "Danish";
	strings['multilanguage.language.nl'] = "Dutch";
	strings['multilanguage.language.ee'] = "Estonian";
	strings['multilanguage.language.fi'] = "Finnish";
	strings['multilanguage.language.fr'] = "French";
	strings['multilanguage.language.de'] = "German";
	strings['multilanguage.language.gr'] = "Greek";
	strings['multilanguage.language.hu'] = "Hungarian";
	strings['multilanguage.language.ie'] = "Irish";
	strings['multilanguage.language.it'] = "Italian";
	strings['multilanguage.language.lv'] = "Latvian";
	strings['multilanguage.language.lt'] = "Lithunian";
	strings['multilanguage.language.mt'] = "Maltese";
	strings['multilanguage.language.pl'] = "Polish";
	strings['multilanguage.language.pt'] = "Portuguese";
	strings['multilanguage.language.ro'] = "Romanian";
	strings['multilanguage.language.sk'] = "Slovak";
	strings['multilanguage.language.si'] = "Slovene";
	strings['multilanguage.language.es'] = "Spanish";
	strings['multilanguage.language.se'] = "Swedish";
	strings['multilanguage.language.mx'] = "Spanish";
	strings['multilanguage.language.en'] = "English";
	strings['multilanguage.language.lu'] = "Luxembourgish";
	strings['multilanguage.language.za'] = "Afrikaans";
    strings['multilanguage.language.ru'] = "Russian";
    strings['multilanguage.language.ja'] = "Japanese";
    strings['multilanguage.language.zh'] = "Chinese";
    strings['multilanguage.language.ko'] = "Korean";
    strings['multilanguage.language.tr'] = "Turkish";

	strings['multilanguage.country.at'] = "Austria";
	strings['multilanguage.country.be'] = "Belgium";
	strings['multilanguage.country.bg'] = "Bulgaria";
	strings['multilanguage.country.ch'] = "Switzerland";
	strings['multilanguage.country.cz'] = "Czech";
	strings['multilanguage.country.dk'] = "Denmark";
	strings['multilanguage.country.gb'] = "Great Britain";
	strings['multilanguage.country.nl'] = "Netherlands";
	strings['multilanguage.country.ee'] = "Estonia";
	strings['multilanguage.country.fi'] = "Finland";
	strings['multilanguage.country.fr'] = "France";
	strings['multilanguage.country.de'] = "Germany";
	strings['multilanguage.country.gr'] = "Greece";
	strings['multilanguage.country.hu'] = "Hungary";
	strings['multilanguage.country.ie'] = "Ireland";
	strings['multilanguage.country.it'] = "Italy";
	strings['multilanguage.country.lv'] = "Latvia";
	strings['multilanguage.country.lt'] = "Lithuania";
	strings['multilanguage.country.mt'] = "Malta";
	strings['multilanguage.country.pl'] = "Poland";
	strings['multilanguage.country.pt'] = "Portugal";
	strings['multilanguage.country.ro'] = "Romania";
	strings['multilanguage.country.sk'] = "Slovakia";
	strings['multilanguage.country.si'] = "Slovenia";
	strings['multilanguage.country.es'] = "Spain";
	strings['multilanguage.country.se'] = "Sweden";
	strings['multilanguage.country.en'] = "England";
	strings['multilanguage.country.mx'] = "Mexico";
	strings['multilanguage.country.us'] = "USA";
	strings['multilanguage.country.lu'] = "Luxembourg";
	strings['multilanguage.country.za'] = "South Africa";
	strings['multilanguage.country.br'] = "Brazil";
	strings['multilanguage.country.ca'] = "Canada";
	strings['multilanguage.country.cl'] = "Chile";
	strings['multilanguage.country.li'] = "Liechtenstein";
	strings['multilanguage.country.nz'] = "New Zealand";
	strings['multilanguage.country.au'] = "Australia";
    strings['multilanguage.country.ru'] = "Russia";
    strings['multilanguage.country.jp'] = "Japan";
    strings['multilanguage.country.cn'] = "China";
    strings['multilanguage.country.kr'] = "Republic of Korea";
    strings['multilanguage.country.tr'] = "Turkey";

	// IKS
	strings['iks.title'] = "Risks and Controls";
	strings['iks.desc'] = "Define possible risks and the associated controls for the process element.";
	strings['iks.windowapply'] = "Apply";
	strings['iks.overlayhint'] = "Please click the item to edit risk and controls for that particular process element.";
	strings['iks.toolbarname'] = "Show risks and controls";
	strings['iks.toolbardesc'] = "Show risks and controls on process elements";
	strings['iks.risk'] = "Risk";
	strings['iks.risks'] = "Risks";
	strings['iks.control'] = "Control";
	strings['iks.controls'] = "Controls";
	strings['iks.newentry'] = "Please click here to create a{0}...";
	strings['iks.newentryrisk'] = " new risk entry ";
	strings['iks.newentrycontrol'] = " a new control entry ";
	strings['iks.addcontrols'] = "Add Controls";
	strings['iks.removerisk'] = "Remove this risk";
	strings['iks.removecontrol'] = "Remove this control";
	strings['iks.deletethistpl'] = "Delete this ";
	strings['iks.deletethisrisk'] = "risk and all associated controls?";
	strings['iks.deletethiscontrol'] = "control?";
	strings['iks.yes'] = "Yes";
	strings['iks.no'] = "No";
	strings['iks.globalrisks'] = "Global risks";
	
	// NestableEditorGridPanel
	strings['negp.nestedfield.emptytext'] = "Add content";
	strings['negp.delete'] = "Delete?";
	strings['negp.yes'] = "yes";
	strings['negp.no'] = "no";

	strings['propertyeditor.npb.title'] = "Process attributes for the National Process Library";
	strings['propertyeditor.npb.topics.title'] = "Choose topics";
	strings['propertyeditor.npb.topics.desc'] = "Choose one or more predefined topics or enter a completely new topic.";
	strings['propertyeditor.npb.topics.predefined'] = "predefined Topics";
	strings['propertyeditor.npb.topics.other'] = "other";
	strings['propertyeditor.npb.render_msg'] = " of 9 mandatory attributes set";
    strings['propertyeditor.npb.invalid_leika'] = "The entered value is no valid LeiKa key.";
    strings['propertyeditor.npb.no_leika'] = "No LeiKa entry.";
    strings['propertyeditor.npb.searching'] = "Searching...";
    strings['propertyeditor.npb.tab_mandatory'] = "Mandatory attributes";
    strings['propertyeditor.npb.tab_optional'] = "Optional attributes";
    strings['propertyeditor.npb.tags.title'] = "Tags";
    strings['propertyeditor.npb.tags.desc'] = "Enter one or more tags:";

	/**
	 * SPANISH TRANSLATION
	 * First translation into Spanish: 2010.05.31
	 * Translator: idroAVILA
	 * @translationchecker fernando.candia 18/08/2010
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_es = "Agregar";
	strings.btnopen_es = "Abrir";
	strings.btnremove_es = "Quitar";
	strings.btnedit_es = "Editar";
	strings.btnreset_es = "Reinicializar";
	strings.moveup_es = "Mover arriba";
	strings.movedown_es = "Mover abajo";
	strings.url_es = "URL";
	strings.label_es = "Etiqueta";
	
	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_es = "'#{0}' crear como #{1}";
	strings.createglossarynew_es = "Crear nuevo";
	
	// GLOSSARY CATEGORIES
	strings.document_es = "Documentos";
	strings.org_unit_es = "Unidades Organizacionales";
	strings.it_system_es = "Sistemas de TI";
	strings.activity_es = "Actividades";
	strings.state_es = "Eventos";
	
	// TIME AND DATE
	strings.year_es = "Año";
	strings.years_es = "Años";
	strings.month_es = "Mes";
	strings.months_es = "Meses";
	strings.day_es = "Día";
	strings.days_es = "Días";
	strings.hour_es = "Hora";
	strings.hours_es = "Horas";
	strings.minute_es = "Minuto";
	strings.minutes_es = "Minutos";
	strings.second_es = "Segundo";
	strings.seconds_es = "Segundos";
	strings.msecond_es = "Milisegundo";
	strings.mseconds_es = "Milisegundos";
	
	// FEEDBACK WINDOW
	strings["views.feedbacktitleenterprise_es"] = "Soporte Signavio";
	strings["views.feedbacktitle_es"] = "Soporte";
	strings["views.feedbackentersubject_es"] = "Por favor ingrese un tema que describa brevemente el problema o la pregunta.";
	strings["views.feedbackenterdescription_es"] = "Por favor describa su problema o pregunta tan detalladamente como sea posible.";
	strings["views.feedbackpmsg_es"] = "Descripción/Mensaje";
	strings["views.feedbackpempty_es"] = "* Por favor describa su petición. Por favor proporcione información tan detallada como sea posible.\n* Para reporte de errores, por favor enliste los pasos de cómo se produjo el error y el mensaje que esperaba.";
	strings["views.feedbackpsubject_es"] = "Tema";
	strings["views.feedbackpbrowser_es"] = "Información acerca de su navegador y ambiente";
	strings["views.feedbackpbrowserdesc_es"] = "Esta información ha sido auto-detectada de su navegador. Puede ser útil en caso de que encuentre un error asociado con el comportamiento del navegador (específicamente).";
	strings["views.feedbackclosetitle_es"] = "Cerrar";
	strings["views.feedbackfailure_es"] = "Falla";
	strings["views.feedbackfailuremsg_es"] = "El mensaje no pudo ser enviado";
	strings["views.feedbacksuccess_es"] = "Éxito";
	strings["views.feedbacksuccessmsg_es"] = "¡Gracias por su retroalimentación!";
	strings["views.feedbacksending_es"] = "Enviando mensaje...";
	strings["views.sendfeedback_es"] = "Enviar Mensaje";
	strings["views.feedbackpattach_es"] = "Adjuntar diagrama actual";
	strings["views.feedbackpattachdesc_es"] = "Esta información puede ser útil para propósitos de depuración. Si su diagrama contiene algunos datos delicados, elimínelos antes de enviar o desmarque su comportamiento.";
	strings["views.feedbackmissingheader_es"] = "Sin Asunto";
	strings["views.feedbackmissingheadermsg_es"] = "Por favor defina un Asunto.";
	strings["views.feedbackmissingbody_es"] = "No hay mensaje";
	strings["views.feedbackmissingbodymsg_es"] = "Por favor escriba un mensaje.";
	strings["views.feedbackerrorlength_es"] = "La descripción es demasiado corta. Por favor teclee al menos 40 letras.";
	strings["views.feedbackerrorlengthtitle_es"] = "El mensaje es demasiado corto";
	strings["views.feedbacksignavio_es"] = "¿Ha tenido algún problema o encontrado algún error al usar Signavio Process Editor? Si es así, por favor utilice el formulario de servicio al cliente para ponerse en contacto con Servicio" +
										"al Cliente de Signavio directamente. Por favor, note que su petición será atendida en un plazo de 1-2 días hábiles." +
										"Responderemos por correo. Toda la información se transfiere sin encriptación.";
	strings["views.feedbackenterprise_es"] = "¿Ha tenido algún problema o encontrado algún error al usar Signavio Process Editor? Si es así, por favor utilice el formulario de servicio al cliente para ponerse en contacto con su departamento de Servicio" +
										  "al cliente o con su administrador. Toda la información será transmitida sin encriptación.";
	
	// PDF EXPORT WINDOW
	strings["views.offertitle_es"] = "PDF (sólo diagrama)";
	strings["views.offertitledesc_es"] = "Usted puede imprimir su diagrama en varias páginas. Por favor seleccione el diseño que desee para su PDF.";
	strings["views.optionwindowtitle_es"] = "Exportar PDF (sólo diagrama)";
	strings["views.buttontitle_es"] = "Generar PDF";
	strings["views.closetitle_es"] = "Cancelar";
	strings["views.fittopage_es"] = "Ajustar a una página";
	strings["views.clipallsides_es"] = "Impresión Continua (2 dimensiones)";
	strings["views.clipbottom_es"] = "Impresión Continua (vertical)";
	strings["views.clipright_es"] = "Impresión Continua(horizontal)";
	strings["views.landscape_es"] = "Paisaje";
	strings["views.portrait_es"] = "Retrato";
	strings["views.defaultname_es"] = "Exportar";
	strings["views.branding_es"] = "Quitar logos de Signavio";
	strings["views.premiumonly_es"] = "Esta función sólo está disponible en la Edición Profesional.";
	strings["views.waiting_es"] = "Se generará la Documentación del Proceso.<br/>Esto puede tomar algún tiempo...";
	strings["views.resetview_es"] = "Original";
	strings["views.windowdescription_es"] = "Por favor seleccione una Vista para la Exportación";	

	strings["panel.businessrule_es"] = "Regla de Negocio";
	strings["panel.static_es"] = "Estático";
	strings["panel.dynamic_es"] = "Dinámico";
	strings["panel.operation_es"] = "Operación";
	strings["panel.add_es"] = "añadir";
	strings["panel.remove_es"] = "eliminar";
	
	strings["panel.no_description_es"] = "Sin descripción";
	strings["panel.no_performer_es"] = "No hay Ejecutante definido.";
	strings["panel.no_users_es"] = "No hay Usuarios disponibles.";
	strings["panel.no_free_userselection_es"] = "Selección de usuarios sin restricción";
	strings["panel.label_free_userselection_es"] = "(Selección de usuarios sin restricción)";
	strings["panel.no_parallel_title_es"] = "Añadir a un grupo";
	strings["panel.no_parallel_description_es"] = "Para el elemento actual el tipo de repetición está fijado como paralelo o secuencial, esto significa que varios usuarios pueden realizar la tarea. Para simplificar esto, ¿desea utilizar todos los miembros del grupo seleccionado en vez del grupo en sí mismo?";
	strings["panel.no_parallel_no_user_es"] = "El grupo actual no contiene miembros.";
	strings["panel.no_defined_role_label_es"] = "Pre-selección";
	strings["panel.no_defined_role_single_user_es"] = "Un solo usuario";
	strings["panel.no_defined_role_role_member_es"] = "Miembros de grupo/rol";
	strings["panel.no_defined_role_group_es"] = "Grupos/Roles";
	strings["panel.label_free_userselection_es"] = "(Selección de usuario libre)";	
	
	strings["wizard.nextbtnlabel_es"] = "Siguiente >";
	strings["wizard.previousbtnlabel_es"] = "< Anterior";

	strings["richtext.title.undo_es"] = "Deshacer (Ctrl+Z)";
    strings["richtext.text.undo_es"] = "Deshace los últimos cambios.";
    strings["richtext.title.redo_es"] = "Rehacer (Shift+Ctrl+Z)";
    strings["richtext.text.redo_es"] = "Rehace los últimos cambios.";   
    strings["richtext.title.bold_es"] = "Negrita (Ctrl+B)";
    strings["richtext.text.bold_es"] = "Poner texto en negrita.";
    strings["richtext.title.italic_es"] = "Itálica (Ctrl+I)";
    strings["richtext.text.italic_es"] = "Poner texto en itálica.";
    strings["richtext.title.underline_es"] = "Subrayar (Ctrl+U)";
    strings["richtext.text.underline_es"] = "Subraya el texto seleccionado.";
    strings["richtext.title.fontselect_es"] = "Fuente";
    strings["richtext.text.fontselect_es"] = "Cambia la fuente del texto seleccionado.";
    strings["richtext.title.fontsizeselect_es"] = "Tamaño de Fuente";
    strings["richtext.text.fontsizeselect_es"] = "Cambia el tamaño de fuente del texto seleccionado.";   
    strings["richtext.title.h1_es"] = "Título";
    strings["richtext.text.h1_es"] = "Insertar un título.";	
    strings["richtext.title.h2_es"] = "Subtítulo";
    strings["richtext.text.h2_es"] = "Inserta un subtítulo.";	
    strings["richtext.title.h3_es"] = "Sección de Título";
    strings["richtext.text.h3_es"] = "Inserta una nueva sección de título.";
    strings["richtext.title.inserthorizontalrule_es"] = "Regla Horizontal";
    strings["richtext.text.inserthorizontalrule_es"] = "Inserta una regla horizontal.";  
    strings["richtext.title.color_es"] = "Color de Fuente";
    strings["richtext.text.color_es"] = "Cambia el color del texto seleccionado.";  
    strings["richtext.title.markupcolor_es"] = "Color del Texto Subrayado";
    strings["richtext.text.markupcolor_es"] = "Cambia el color de fondo del texto seleccionado";   
    strings["richtext.title.justifyleft_es"] = "Alinear Texto a la Izquierda";
    strings["richtext.text.justifyleft_es"] = "Alinea el Texto a la Izquierda.";    
    strings["richtext.title.justifycenter_es"] = "Centrar Texto";
    strings["richtext.text.justifycenter_es"] = "Centrar texto en el editor.";	
    strings["richtext.title.justifyright_es"] = "Alinear texto a la Derecha";
    strings["richtext.text.justifyright_es"] = "Alinea el texto a la derecha.";
    strings["richtext.title.indent_es"] = "Sangría (Tab)";
    strings["richtext.text.indent_es"] = "Indentar Texto.";	
    strings["richtext.title.outdent_es"] = "Anular Sangría (Shift+Tab)";
    strings["richtext.text.outdent_es"] = "Anular la Sangría del Texto.";
    strings["richtext.title.createlink_es"] = "Hipervínculo";
    strings["richtext.text.createlink_es"] = "Convierte el texto seleccionado en un hipervínculo.";   
    strings["richtext.title.unlink_es"] = "Quitar Hipervínculo";
    strings["richtext.text.unlink_es"] = "Remueve el Hipervínculo de la selección.";	
    strings["richtext.title.insertorderedlist_es"] = "Lista Numerada";
    strings["richtext.text.insertorderedlist_es"] = "Comienza una lista numerada.";	
    strings["richtext.title.insertunorderedlist_es"] = "Lista de Viñetas";
    strings["richtext.text.insertunorderedlist_es"] = "Comienza una lista de viñetas.";	
    strings["richtext.title.removeformat_es"] = "Quitar Formato";
    strings["richtext.text.removeformat_es"] = "Quita todo el formato aplicado a la selección.";    
    strings['richtext.colormenu.defaultcolor_es'] = 'Automático';
    strings['richtext.stub.more_es'] = 'más';
    strings['richtext.stub.less_es'] = 'menos';
    strings['richtext.stub.openprint_es'] = 'Abrir vista de impresión';
    
	strings['glossary.mapper.type.document_es'] = "Documentos";
    strings['glossary.mapper.type.org_unit_es'] = "Unidades Organizacionales";
    strings['glossary.mapper.type.it_system_es'] = "Sistemas de TI";
    strings['glossary.mapper.type.activity_es'] = "Actividades";
    strings['glossary.mapper.type.state_es'] = "Eventos";

    strings['glossary.form.description_es'] = "The following attributes can be defined in different languages. Please use the drop-down field in the top to change the language.<br/>Consider that the title must be defined in at least one language.";

    strings['glossary.edit.title_es'] = "Editar entrada";
    strings['glossary.edit.save_es'] = "Guardar";
    strings['glossary.edit.description_es'] = "Editar la entrada de diccionario actual.";

    strings['glossary.new.title_es'] = "Nueva entrada";
    strings['glossary.new.save_es'] = "Crear";
    strings['glossary.new.create_es'] = "Crear una nueva entrada de diccionario.";

	strings['glossary.multilanguage.non_attributes_es'] = "The following attributes can only be defined in the default language.";
    strings['glossary.multilanguage.copy_link_tt_es'] = "Please notice that all contents will be replace by the new contents.";
    strings['glossary.multilanguage.remove_origin_column_es'] = "Hide left column";
    strings['glossary.multilanguage.copy_link_title_es'] = "Copy all contents";

    strings['glossary.view.title_es'] = "Título";
    strings['glossary.view.attachments_es'] = "Documentos Anexados";
    strings['glossary.view.description_es'] = "Descripción";
	
	/**
	 * FRENCH TRANSLATION
	 * First translation into French: -
	 * Translator: Gerjan Grootenboer / Steve Biapan
	 * @translationchecker - Steve Biapan
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_fr = "Ajouter";
	strings.btnopen_fr = "Ouvrir";
	strings.btnremove_fr = "Supprimer";
	strings.btnedit_fr = "Éditer";
	strings.btnreset_fr = "Réinitialiser";
	strings.btnclose_fr = "Fermer";
	strings.btnsave_fr = "Enregistrer";
	strings.moveup_fr = "Vers le haut";
	strings.movedown_fr = "Vers le bas";
	strings.url_fr = "URL";
	strings.label_fr = "Label";
	strings.year_fr = "Année";
	strings.years_fr = "Années";
	strings.month_fr = "Mois";
	strings.months_fr = "Mois";
	strings.month1_fr = "Janvier";
	strings.month2_fr = "Février";
	strings.month3_fr = "Mars";
	strings.month4_fr = "Avril";
	strings.month5_fr = "Mai";
	strings.month6_fr = "Juin";
	strings.month7_fr = "Juillet";
	strings.month8_fr = "Août";
	strings.month9_fr = "Septembre";
	strings.month10_fr = "Octobre";
	strings.month11_fr = "Novembre";
	strings.month12_fr = "Décembre";
	strings.day1_fr = "Lundi";
	strings.day2_fr = "Mardi";
	strings.day3_fr = "Mercredi";
	strings.day4_fr = "Jeudi";
	strings.day5_fr = "Vendredi";
	strings.day6_fr = "Samedi";
	strings.day7_fr = "Dimanche";
	strings.day_fr = "Jour";
	strings.days_fr = "Jours";
	strings.hour_fr = "Heure";
	strings.hours_fr = "Heures";
	strings.minute_fr = "Minute";
	strings.minutes_fr = "Minutes";
	strings.second_fr = "Seconde";
	strings.seconds_fr = "Secondes";
	strings.msecond_fr = "Milliseconde";
	strings.mseconds_fr = "Millisecondes";
	strings.langdatetime_fr = "{weekday}, {day}.{monthname} {year} {hours}:{minutes}:{seconds} h"; 
	
	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_fr = "'#{0}' créer en tant que #{1}";
	strings.createglossarynew_fr = "Créer un nouveau";
	
	// GLOSSARY CATEGORIES
	strings.documen_fr = "Documents";
	strings.org_unit_fr = "Unités d'organisation";
	strings.it_system_fr = "Systèmes IT";
	strings.activity_fr = "Activités";
	strings.state_fr = "Événements";
	
	strings.noglossary_entry_fr = "Aucun terme du glossaire";

	
	// FEEDBACK WINDOW
	strings["views.feedbackpsubject_fr"] = "Objet de la demande";
	strings["views.feedbackquestion_fr"] = "Question";
	strings["views.feedbackquestiontitle_fr"] = "Question sur Signavio Process Editor";
	strings["views.feedbackquestiondescription_fr"] = "Description détaillée de la question";
	strings["views.feedbackbugreport_fr"] = "Bug Report";
	strings["views.feedbackbugreporttitle_fr"] = "Problème avec le Signavio Process Editor";
	strings["views.feedbackfeaturerequest_fr"] = "Demande de fonctionnalité";
	strings["views.feedbackideasdescription_fr"] = "Pour les demandes de fonctionnalités, nous offrons à nos clients un portail idées. Là, ils peuvent mettre des idées visibles pour tous les clients  et aussi approuver les idées des autres clients. <br/><br/> Les idées qui ont le plus de sollicitations seront traités en priorité par notre service de Management des produits. En outre, vous recevrez de nous un retour dès que nous auront évalué et implémenté votre idée.<br/><br/> Voulez-vous publier votre demande de fonctionnalité sur notre portail d'idée? Alors consultez simplement <a href='http://ideas.signavio.com'>ideas.signavio.com</a><span style='position: relative; font-size: 10px; top: -3px; left: 2px;'>1</span> .";
	strings["views.feedbackideasdescriptionnote_fr"] = "(1) Veuillez noter que <a href='http://ideas.signavio.com'>ideas.signavio.com</a> est une offre de Signavio Inc. <br/> <span style='margin-left: 17px;'>Les termes et conditions générales sont celle de Signavio Inc. et de IdeaScale LLC.</span>";
	
	strings["views.feedbacktitleenterprise_fr"] = "Support";
	strings["views.feedbacktitle_fr"] = "Support de Signavio";
	strings["views.feedbacktitleenterprise_fr"] = "Envoyer une demande de support";
	strings["views.feedbacktitle_fr"] = "Envoyer une demande de support à Signavio";
	strings["views.feedbackentersubject_fr"] = "Veuillez entrer un sujet qui décrit brièvement le problème ou la question.";
	strings["views.feedbackenterdescription_fr"] = "Veuillez décrire votre problème ou votre question en détail";
	strings["views.feedbackpmsg_fr"] = "Description détaillée de l'erreur";
	strings["views.feedbackpempty_fr"] = "* Veuillez décrire votre demande et fournir des informations aussi détaillées que possible.\n* Pour les rapports de bugs, veuillez lister les étapes effectuées pour que nous puissions reproduire le problème et précisez également le résultat escompté.";
	//strings["views.feedbackpsubject_fr"] = "Problème avec le Signavio Process Editor";
	strings["views.feedbackpbrowser_fr"] = "Informations sur votre navigateur et sur l'environnement";
	strings["views.feedbackpbrowserdesc_fr"] = "Cette information a été détectée automatiquement par votre navigateur. Elle peut être utile si vous avez rencontré un bug associé au comportement spécifique du navigateur.";
	strings["views.feedbackclosetitle_fr"] = "Fermer";
	strings["views.feedbackfailure_fr"] = "Échec";
	strings["views.feedbackfailuremsg_fr"] = "Le message n'a pas pu être envoyé!";
	strings["views.feedbacksuccess_fr"] = "Réussite";
	strings["views.feedbacksuccessmsg_fr"] = "Merci pour votre feedback!";
	strings["views.feedbacksending_fr"] = "Envoi du message en cours...";
	strings["views.sendfeedback_fr"] = "Envoyer une demande de soutien";
	strings["views.feedbackpattach_fr"] = "Attacher le diagramme actuel";
	strings["views.feedbackpattachdesc_fr"] = "Cette information peut être utile pour le réparer le bug. Si votre diagramme contient des données sensibles, retirerez-les avant d'envoyer votre demande ou décochez cette option.";
	strings["views.feedbackreceiver_fr"] = "Destinataire";
	strings["views.feedbackreceiversignavio_fr"] = "Support de Signavio ([mail])";
	strings["views.feedbackreceiverenterprise_fr"] = "Votre support ([mail])";
	strings["views.feedbackmissingheader_fr"] = "Pas de sujet";
	strings["views.feedbackmissingheadermsg_fr"] = "Veuillez définir un sujet.";
	strings["views.feedbackmissingbody_fr"] = "Pas de message";
	strings["views.feedbackmissingbodymsg_fr"] = "Veuillez écrire un message.";
	strings["views.feedbackerrorlength_fr"] = "La description est trop courte. Veuillez entrer au moins 40 caractères.";
	strings["views.feedbackerrorlengthtitle_fr"] = "Le message est trop court";
	strings["views.feedbacksignavio_fr"] = "Vous avez un problème avec l'utilisation du Signavio Process Editor ou vous avez trouvé une erreur? Dans ce cas, veuillez utiliser le formulaire de support pour contacter directement le support de Signavio. Le traitement de votre demande peut prendre environ 1-2 jours ouvrables. Nous vous répondrons par e-mail. Toutes les informations transférées sont non-cryptées.";
	strings["views.feedbackenterprise_fr"] = "Vous avez un problème avec l'utilisation du Signavio Process Editor ou vous avez trouvé une erreur? Dans ce cas, veuillez utiliser le formulaire d'aide pour contacter directement le support ou l'administrateur. Toutes les informations transférées ne sont pas cryptées.";	
	
	// PDF EXPORT WINDOW
	strings["views.offertitle_fr"] = "PDF (diagramme simple)";
	strings["views.offertitledesc_fr"] = "Vous pouvez imprimer votre diagramme sur plusieurs pages. Veuillez sélectionner la mise en page souhaitée lors de l'exportation en PDF.";
	strings["views.optionwindowtitle_fr"] = "Exportation en PDF (Diagramme simple)";
	strings["views.buttontitle_fr"] = "Générer le PDF";
	strings["views.closetitle_fr"] = "Annuler";
	strings["views.fittopage_fr"] = "Ajuster à une seule page";
	strings["views.clipallsides_fr"] = "Impression en continu (2 dimensions)";
	strings["views.clipbottom_fr"] = "Impression en continu (vertical)";
	strings["views.clipright_fr"] = "Impression en continu (horizontal)";
	strings["views.landscape_fr"] = "Paysage";
	strings["views.portrait_fr"] = "Portrait";
	strings["views.defaultname_fr"] = "Exporter";
	strings["views.branding_fr"] = "Supprimer les logos de Signavio";
	strings["views.premiumonly_fr"] = "Cette fonctionnalité est uniquement disponible dans la version Professionnel Edition.";
	strings["views.waiting_fr"] = "Le processus de documentation sera créée.<br/>Cela pourrait prendre un peu de temps...";
	strings["views.resetview_fr"] = "Original";
	strings["views.windowdescription_fr"] = "Veuillez sélectionner une vue pour l'exportation:";
	strings["panel.businessrule_fr"] = "Règle d'affaire";
	strings["panel.static_fr"] = "Statique";
	strings["panel.dynamic_fr"] = "Dynamique";
	strings["panel.operation_fr"] = "Opération";
	strings["panel.add_fr"] = "Ajouter";
	strings["panel.remove_fr"] = "Supprimer";
	strings["panel.no_description_fr"] = "Pas de description";
	strings["panel.no_performer_fr"] = "Aucun exécuteur défini.";
	strings["panel.no_users_fr"] = "Aucun utilisateur disponible.";
	strings["panel.no_free_userselection_fr"] = "Sélection de l'utilisateur sans restriction";
	strings["panel.no_parallel_title_fr"] = "Ajouter un groupe";
	strings["panel.no_parallel_description_fr"] = "Pour l'élément courant, le type de boucle est fixé soit en parallèle ou en série, cela signifie que plusieurs utilisateurs peuvent effectuer la tâche. Pour simplifier ceci, voulez-vous utiliser directement tous les membres du groupe sélectionné au lieu du groupe lui-même?";
	strings["panel.no_parallel_no_user_fr"] = "Le groupe actuel n'a pas de membres.";
	strings["panel.no_defined_role_label_fr"] = "Pré-sélection";
	strings["panel.no_defined_role_single_user_fr"] = "Utilisateur unique";
	strings["panel.no_defined_role_role_member_fr"] = "Groupe/rôle des membres";
	strings["panel.no_defined_role_group_fr"] = "Groupes/rôles";
	strings["panel.label_free_userselection_fr"] = "(Sélection par l'utilisateur sans restriction)";
	
	strings["wizard.nextbtnlabel_fr"] = "Suivant >";
	strings["wizard.previousbtnlabel_fr"] = "< Précédant";
    
	strings["richtext.title.undo_fr"] = "Annuler (Ctrl+Z)";
    strings["richtext.text.undo_fr"] = "Annule les dernières modifications.";
    strings["richtext.title.redo_fr"] = "Restaurer (Maj+Ctrl+Z)";
    strings["richtext.text.redo_fr"] = "Restaurer les dernières modifications.";
    strings["richtext.title.bold_fr"] = "Gras (Ctrl+B)";
    strings["richtext.text.bold_fr"] = "Mettre le texte sélectionné en gras.";
    strings["richtext.title.italic_fr"] = "Italique (Ctrl+I)";
    strings["richtext.text.italic_fr"] = "Mettre le texte sélectionné en italique.";
    strings["richtext.title.underline_fr"] = "Souligné (Ctrl+U)";
    strings["richtext.text.underline_fr"] = "Souligner le texte sélectionné.";
    strings["richtext.title.fontselect_fr"] = "Police";
    strings["richtext.text.fontselect_fr"] = "Modifier la police du texte sélectionné.";
    strings["richtext.title.fontsizeselect_fr"] = "Taille de la police";
    strings["richtext.text.fontsizeselect_fr"] = "Changer la police du texte sélectionné.";
    strings["richtext.title.h1_fr"] = "Titre";
    strings["richtext.text.h1_fr"] = "Insérer un titre.";
    strings["richtext.title.h2_fr"] = "Sous titre";
    strings["richtext.text.h2_fr"] = "Insérer un sous-titre.";
    strings["richtext.title.h3_fr"] = "Titre de la section";
    strings["richtext.text.h3_fr"] = "Insérer un titre pour une nouvelle section.";   
    strings["richtext.title.inserthorizontalrule_fr"] = "Règle horizontale";
    strings["richtext.text.inserthorizontalrule_fr"] = "Insérer une règle horizontale.";
    strings["richtext.title.color_fr"] = "Couleur de la police";
    strings["richtext.text.color_fr"] = "Changer la couleur du texte sélectionné.";
    strings["richtext.title.markupcolor_fr"] = "Couleur de surbrillance du texte";
    strings["richtext.text.markupcolor_fr"] = "Changer la couleur de fond du texte sélectionné.";
    strings["richtext.title.justifyleft_fr"] = "Aligner le texte sur la gauche";
    strings["richtext.text.justifyleft_fr"] = "Aligner le texte à gauche.";
    strings["richtext.title.justifycenter_fr"] = "Texte centré";
    strings["richtext.text.justifycenter_fr"] = "Centrer le texte dans l'éditeur";
    strings["richtext.title.justifyright_fr"] = "Aligner le titre à droite";
    strings["richtext.text.justifyright_fr"] = "Aligner le texte à droite.";
    strings["richtext.title.indent_fr"] = "Retrait (Tab)";
    strings["richtext.text.indent_fr"] = "Retrait du texte.";
    strings["richtext.title.outdent_fr"] = "Diminuer le retrait (Shift+Tab)";
    strings["richtext.text.outdent_fr"] = "Diminuer le retrait du texte.";
    strings["richtext.title.createlink_fr"] = "Lien hypertexte";
    strings["richtext.text.createlink_fr"] = "Mettre le texte sélectionné en lien hypertexte.";
    strings["richtext.title.unlink_fr"] = "Supprimer le lien hypertexte";
    strings["richtext.text.unlink_fr"] = "Supprimer le lien hypertexte de la sélection.";
    strings["richtext.title.insertorderedlist_fr"] = "Liste (numérotée)";
    strings["richtext.text.insertorderedlist_fr"] = "Démarrer une liste numérotée.";
    strings["richtext.title.insertunorderedlist_fr"] = "Liste à puces";
    strings["richtext.text.insertunorderedlist_fr"] = "Démarrer une liste à puces.";
    strings["richtext.title.removeformat_fr"] = "Retirer le format";
    strings["richtext.text.removeformat_fr"] = "Supprimer le formatage appliqué à la sélection.";  
    strings['richtext.colormenu.defaultcolor_fr'] = 'Automatique';
    strings['richtext.stub.more_fr'] = 'Plus';
    strings['richtext.stub.less_fr'] = 'Moins';
    strings['richtext.stub.openprint_fr'] = 'Aperçu avant impression';
    
    // COMMED TRANSLATIONS
    strings['commed.expression.otherwise_fr'] = 'Défaut';
    strings['commed.expression.manual_fr'] = 'Action manuelle de l\'utilisateur';
    strings['commed.expression.automaticrule_fr'] = 'Règle automatique pour JavaScript'; 
    strings['commed.expression.jsrule_fr'] = 'Règle JavaScript';
    strings['commed.expression.standarderror_fr'] = 'Erreur standard';
    strings['commed.expression.exception_fr'] = 'Exception';
    strings['commed.expression.exceptions_fr'] = 'Exceptions';
    strings['commed.rolemapping.loadingroles_fr'] = 'Chargement des rôles';
    strings['commed.servicecall.and_fr'] = 'et';
    strings['commed.servicecall.aredefined_fr'] = 'sont définis.';
    strings['commed.servicecall.loadingformulars_fr'] = 'Chargement du formulaire.';
    strings['commed.servicecall.loadingmeasures_fr'] = 'Mesures en cours...';
    strings['commed.servicecall.formulars_fr'] = 'Formulaires';
    strings['commed.servicecall.performingsearch_fr'] = 'Recherche en cours...';
    strings['commed.servicecall.nofound_fr'] = 'Aucune mesure trouvée.';
    strings['commed.servicecall.nomeasuresselected_fr'] = 'Aucune mesure sélectionnée jusqu\'ici.';
    strings['commed.servicecall.pleaseselect_fr'] = 'S\'il vous plaît choisir une mesure sur le côté droit pour l\'ajouter à votre sélection.';
    strings['commed.servicecall.measure_fr'] = 'Mesure';
    strings['commed.servicecall.nowfv_fr'] = 'Pas de WFV défini.';
    strings['commed.servicecall.loadinginputs_fr'] = 'Chargement des entrées.';
    strings['commed.servicecall.noinputs_fr'] = 'Pas d\'entrées.';
    strings['commed.servicecall.loadingoutputs_fr'] = 'Chargement des sorties.';
    strings['commed.servicecall.nooutputs_fr'] = 'Pas de sorties.';
    strings['commed.servicecall.loadingservice_fr'] = 'Chargement du service';
    strings['commed.servicecall.selectservice_fr'] = 'Sélectionnez s\'il vous plait un service.';
    strings['commed.servicecall.remove_fr'] = 'Supprimer';
    strings['commed.servicecall.parameteralert_fr'] = "Pour cette attribut, vous devez définir un «Sous-processus de référence». Veuillez appuyer sur le bouton plus pour lier un sous-processus";
    strings['commed.servicecall.selectboandservice_fr'] = 'Veuillez sélectionner un service et un BO.';
    strings['commed.servicecall.noinputsinsub_fr'] = 'Aucune entrée définie dans le sous-processus';
    strings['commed.servicecall.nooutputsinsub_fr'] = 'Pas de sorties définies dans le sous-processus';
    strings['commed.servicecall.noserviceinsub_fr'] = 'Le sous-processus référencé n\'a pas de services définis';

	
    
    strings['attribute.mapper.loading_fr'] = "Chargement en cours";
    strings['attribute.mapper.stencilsets_fr'] = "types de diagrammes";
    strings['attribute.mapper.deselected_fr'] = "#{count} éléments(s) exclus";
    strings['attribute.mapper.attributes_selected_fr'] = "#{count} différent(s) attribut(s) sélectionné(s)";
    strings['attribute.mapper.attributes_deselected_fr'] = "#{count} attribut(s) exclus";
    strings['attribute.mapper.selected_fr'] = "#{count} élément(s) sélectionné(s)";
    strings['attribute.mapper.no_attributes_fr'] = "Il n'y a pas d'attributs disponibles pour cette langage de modélisation.";
    strings['attribute.mapper.no_selection_fr'] = "Aucun";
    strings['attribute.mapper.exclusion_active_fr'] = "Ensemble de restrictions";
    strings['attribute.mapper.excluion_inactive_fr'] = "Pas d'ensemble de restrictions";
    strings['attribute.mapper.list_fr'] = "Liste";
    
    strings['attribute.mapper.selected_fr'] = "#{count} sélectionné";
    
    strings['attribute.mapper.untitled_group_fr'] = "Goupe sans titre";
    
    strings['attribute.mapper.config.all_attributes_fr'] = "Tous les attributs";
    strings['attribute.mapper.config.own_attributes_fr'] = "Attributs personnalisés";
    strings['attribute.mapper.config.select_attributes_fr'] = "Sélectionner des attributs";
    strings['attribute.mapper.config.all_elements_fr'] = "Tous les éléments";
    strings['attribute.mapper.config.flow_elements_fr'] = "Seulement les éléments du flux";
    strings['attribute.mapper.config.activities_fr'] = "Seulement les activités";
    strings['attribute.mapper.config.select_elements_fr'] = "Sélectionner des éléments";
    
    strings['attribute.mapper.config.name_fr'] = "Nom";
    strings['attribute.mapper.config.description_fr'] = "Description";
    
    strings['attribute.mapper.config.hide_empty_attributes_fr'] = "Cacher les attributs sans valeur";
    strings['attribute.mapper.config.show_attribute_label_fr'] = "Faire apparaître les labels";
    strings['attribute.mapper.config.separate_labels_fr'] = "Séparer les attributs par";
    strings['attribute.mapper.config.separator_comma_fr'] = "Virgule";
    strings['attribute.mapper.config.separator_space_fr'] = "Espace";
    strings['attribute.mapper.config.separator_linebreak_fr'] = "Saut de ligne";
    strings['attribute.mapper.config.list_style_fr'] = "Les listes sont affichées comme";
    strings['attribute.mapper.config.list_style_bullet_fr'] = "Liste avec des puces";
    strings['attribute.mapper.config.list_style_numbered_fr'] = "Liste ordonnée";
    
    strings['attribute.mapper.config.main_properties_fr'] = "Propriétés principales";
    strings['attribute.mapper.config.more_properties_fr'] = "Plus de propriétés";
    strings['attribute.mapper.config.meta_properties_fr'] = "Attributs personnalisés";
    
    strings['glossary.mapper.type.document_fr'] = "Documents";
    strings['glossary.mapper.type.org_unit_fr'] = "Unitées d'organisation";
    strings['glossary.mapper.type.it_system_fr'] = "Systèmes IT";
    strings['glossary.mapper.type.activity_fr'] = "Activités";
    strings['glossary.mapper.type.state_fr'] = "Événements";
    
    strings['glossary.mapper.loading_groups_fr'] = "Chargement des groupes du dictionnaire en cours...";
    strings['glossary.mapper.all_categories_fr'] = "Tout choisir";
    strings['glossary.mapper.categories_chosen_fr'] = "choisis";
    strings['glossary.mapper.select_all_fr'] = "Sélectionner tout";
    strings['glossary.mapper.select_none_fr'] = "Ne rien sélectionner";
    
    strings['glossary.form.description_fr'] = "Les attributs suivants peuvent être définis dans d'autres langues. Veuillez utiliser le menu avec le champs déroulant en haut de la page pour changer la langue.<br/>Veuillez prendre note que le titre doit être défini dans une langue au moins.";

    strings['glossary.edit.title_fr'] = "Éditer l'entrée";
    strings['glossary.edit.save_fr'] = "Sauvegarder";
    strings['glossary.edit.description_fr'] = "Éditer l'entrée actuelle du dictionnaire.";

    strings['glossary.new.title_fr'] = "Nouvelle entrée";
    strings['glossary.new.save_fr'] = "Créer";
    strings['glossary.new.create_fr'] = "Création d'une nouvelle entrée dans le dictionnaire.";

	strings['glossary.multilanguage.non_attributes_fr'] = "Les attributs suivants ne peuvent être défini que dans la langue par défaut.";
    strings['glossary.multilanguage.copy_link_tt_fr'] = "Veuillez prendre note que tout le contenu sera remplacé par le nouveau.";
    strings['glossary.multilanguage.remove_origin_column_fr'] = "Cacher la colonne de gauche";
    strings['glossary.multilanguage.copy_link_title_fr'] = "Copier tout le contenu";

    strings['glossary.view.title_fr'] = "Titre";
    strings['glossary.view.attachments_fr'] = "Liens vers des documents externes";
    strings['glossary.view.description_fr'] = "Description";

    strings['propertyeditor.itsm.assignee.company_fr'] = "Société";
    strings['propertyeditor.itsm.assignee.organization_fr'] = "Organisation";
    strings['propertyeditor.itsm.assignee.group_fr'] = "Groupe";
    
    strings['propertyeditor.itsm.location.region_fr'] = "Région";
    strings['propertyeditor.itsm.location.sitegroup_fr'] = "Groupe du site";
    strings['propertyeditor.itsm.location.site_fr'] = "Site";
    
    strings['propertyeditor.itsm.servicecat.tier_fr'] = "Rang {0}";
    
    strings['propertyeditor.itsm.productcat.name_fr'] = "Nom";
    strings['propertyeditor.itsm.productcat.model_fr'] = "Diagramme";
    
    strings['propertyeditor.itsm.variablemapping.header.variable_fr'] = "Variable";
    strings['propertyeditor.itsm.variablemapping.header.input_fr'] = "Entrant";
    strings['propertyeditor.itsm.variablemapping.header.output_fr'] = "Sortant";
    
    strings['propertyeditor.itsm.variablemapping.error.title_fr'] = "Trop de variables";
    strings['propertyeditor.itsm.variablemapping.error.message_fr'] = "Trop de variables de type '{0}' sont utilisées.<br/> Le maximum est de: {1}.";
    
    strings['propertyeditor.itsm.condition.add_fr'] = "Ajouter une variable...";

    strings['glossary.new.languageswitch_fr'] = "Langue";
    
    strings['language_bg_fr'] = "Bulgare";
    strings['language_cz_fr'] = "Tchèque";
    strings['language_dk_fr'] = "Danois";
    strings['language_nl_fr'] = "Néerlandais";
    strings['language_ee_fr'] = "Estonien";
    strings['language_fi_fr'] = "Finnois";
    strings['language_fr_fr'] = "Français";
    strings['language_de_fr'] = "Allemand";
    strings['language_gr_fr'] = "Grec";
    strings['language_hu_fr'] = "Hongrois";
    strings['language_ie_fr'] = "Irlandais";
    strings['language_it_fr'] = "Italien";
    strings['language_lv_fr'] = "Letton";
    strings['language_lt_fr'] = "Lituanien";
    strings['language_mt_fr'] = "Maltais";
    strings['language_pl_fr'] = "Polonais";
    strings['language_pt_fr'] = "Portugais";
    strings['language_ro_fr'] = "Roumain";
    strings['language_sk_fr'] = "Slovaque";
    strings['language_si_fr'] = "Slovène";
    strings['language_es_fr'] = "Espagnol";
    strings['language_se_fr'] = "Suédois";
    strings['language_mx_fr'] = "Spanish";
    strings['language_en_fr'] = "Anglais";
    strings['language_lu_fr'] = "Luxembourgeois";
    strings['language_za_fr'] = "Afrikaans";
    
    strings['country_at_fr'] = "Autriche";
    strings['country_be_fr'] = "Belgique";
    strings['country_bg_fr'] = "Bulgarie";
    strings['country_ch_fr'] = "Suisse";
    strings['country_cz_fr'] = "République tchèque";
    strings['country_dk_fr'] = "Danemark";
    strings['country_gb_fr'] = "Grande-Bretagne";
    strings['country_nl_fr'] = "Pays-Bas";
    strings['country_ee_fr'] = "Estonie";
    strings['country_fi_fr'] = "Finlande";
    strings['country_fr_fr'] = "France";
    strings['country_de_fr'] = "Allemagne";
    strings['country_gr_fr'] = "Grèce";
    strings['country_hu_fr'] = "Hongrie";
    strings['country_ie_fr'] = "Irlande";
    strings['country_it_fr'] = "Italie";
    strings['country_lv_fr'] = "Lettonie";
    strings['country_lt_fr'] = "Lituanie";
    strings['country_mt_fr'] = "Malte";
    strings['country_pl_fr'] = "Pologne";
    strings['country_pt_fr'] = "Portugal";
    strings['country_ro_fr'] = "Roumanie";
    strings['country_sk_fr'] = "Slovaquie";
    strings['country_si_fr'] = "Slovénie";
    strings['country_es_fr'] = "Espagne";
    strings['country_se_fr'] = "Suède";
    strings['country_en_fr'] = "Angleterre";
    strings['country_mx_fr'] = "Mexique";
    strings['country_us_fr'] = "Etats-Unis";
    strings['country_lu_fr'] = "Luxembourg";
    strings['country_za_fr'] = "Afrique du Sud";
    strings['country_br_fr'] = "Brésil";
    strings['country_ca_fr'] = "Canada";
    strings['country_cl_fr'] = "Chili";
    strings['country_li_fr'] = "Liechtenstein";
    strings['country_nz_fr'] = "Nouvelle Zélande";
    strings['coutnry_au_fr'] = "Australie";

    //TODO
	strings['multilanguage.language.bg_fr'] = "Bulgare";
	strings['multilanguage.language.cz_fr'] = "Tchèque";
	strings['multilanguage.language.dk_fr'] = "Danois";
	strings['multilanguage.language.nl_fr'] = "Néerlandais";
	strings['multilanguage.language.ee_fr'] = "Estonien";
	strings['multilanguage.language.fi_fr'] = "Finnois";
	strings['multilanguage.language.fr_fr'] = "Français";
	strings['multilanguage.language.de_fr'] = "Allemand";
	strings['multilanguage.language.gr_fr'] = "Grec";
	strings['multilanguage.language.hu_fr'] = "Hongrois";
	strings['multilanguage.language.ie_fr'] = "Irlandais";
	strings['multilanguage.language.it_fr'] = "Italien";
	strings['multilanguage.language.lv_fr'] = "Letton";
	strings['multilanguage.language.lt_fr'] = "Lituanien";
	strings['multilanguage.language.mt_fr'] = "Maltais";
	strings['multilanguage.language.pl_fr'] = "Polonais";
	strings['multilanguage.language.pt_fr'] = "Portugais";
	strings['multilanguage.language.ro_fr'] = "Roumain";
	strings['multilanguage.language.sk_fr'] = "Slovaque";
	strings['multilanguage.language.si_fr'] = "Slovène";
	strings['multilanguage.language.es_fr'] = "Espagnol";
	strings['multilanguage.language.se_fr'] = "Suédois";
	strings['multilanguage.language.mx_fr'] = "Espagnol";
	strings['multilanguage.language.en_fr'] = "Anglais";
	strings['multilanguage.language.lu_fr'] = "Luxembourgeois";
	strings['multilanguage.language.za_fr'] = "Afrikaans";

	strings['multilanguage.country.at_fr'] = "Austria";
	strings['multilanguage.country.be_fr'] = "Belgique";
	strings['multilanguage.country.bg_fr'] = "Bulgarie";
	strings['multilanguage.country.ch_fr'] = "Suisse";
	strings['multilanguage.country.cz_fr'] = "République tchèque";
	strings['multilanguage.country.dk_fr'] = "Danemark";
	strings['multilanguage.country.gb_fr'] = "Grande-Bretagne";
	strings['multilanguage.country.nl_fr'] = "Pays-Bas";
	strings['multilanguage.country.ee_fr'] = "Estonie";
	strings['multilanguage.country.fi_fr'] = "Finlande";
	strings['multilanguage.country.fr_fr'] = "France";
	strings['multilanguage.country.de_fr'] = "Allemagne";
	strings['multilanguage.country.gr_fr'] = "Grèce";
	strings['multilanguage.country.hu_fr'] = "Hongrie";
	strings['multilanguage.country.ie_fr'] = "Irlande";
	strings['multilanguage.country.it_fr'] = "Italie";
	strings['multilanguage.country.lv_fr'] = "Lettonie";
	strings['multilanguage.country.lt_fr'] = "Lituanie";
	strings['multilanguage.country.mt_fr'] = "Malte";
	strings['multilanguage.country.pl_fr'] = "Pologne";
	strings['multilanguage.country.pt_fr'] = "Portugal";
	strings['multilanguage.country.ro_fr'] = "Roumanie";
	strings['multilanguage.country.sk_fr'] = "Slovaquie";
	strings['multilanguage.country.si_fr'] = "Slovénie";
	strings['multilanguage.country.es_fr'] = "Espagne";
	strings['multilanguage.country.se_fr'] = "Suède";
	strings['multilanguage.country.en_fr'] = "Angleterre";
	strings['multilanguage.country.mx_fr'] = "Mexique";
	strings['multilanguage.country.us_fr'] = "Etats-Unis";
	strings['multilanguage.country.lu_fr'] = "Luxembourg";
	strings['multilanguage.country.za_fr'] = "Afrique du Sud";
	strings['multilanguage.country.br_fr'] = "Brésil";
	strings['multilanguage.country.ca_fr'] = "Canada";
	strings['multilanguage.country.cl_fr'] = "Chili";
	strings['multilanguage.country.li_fr'] = "Liechtenstein";
	strings['multilanguage.country.nz_fr'] = "Nouvelle Zélande";
	strings['multilanguage.country.au_fr'] = "Australie";

	/**
	 * DUTCH TRANSLATION
	 * First translation into Dutch: -
	 * Translator: Gerjan Grootenboer
	 * @translationchecker - 
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_nl = "Toevoegen";
	strings.btnopen_nl = "Openen";
	strings.btnremove_nl = "Verwijderen";
	strings.btnedit_nl = "Wijzigen";
	strings.btnreset_nl = "Resetten";
	strings.btnclose_nl = "Sluiten";
	strings.btnsave_nl = "Opslaan";
	strings.moveup_nl = "Verplaats omhoog";
	strings.movedown_nl = "Verplaats omlaag";
	strings.url_nl = "URL";
	strings.label_nl = "Label";
	strings.year_nl = "Jaar";
	strings.years_nl = "Jaren";
	strings.month_nl = "Maand";
	strings.months_nl = "Maanden";
	strings.day_nl = "Dag";
	strings.days_nl = "Dagen";
	strings.hour_nl = "Uur";
	strings.hours_nl = "Uren";
	strings.minute_nl = "Minuut";
	strings.minutes_nl = "Minuten";
	strings.second_nl = "Seconde";
	strings.seconds_nl = "Seconden";
	strings.msecond_nl = "Milliseconden";
	strings.mseconds_nl = "Milliseconden";
	
	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_nl = "'#{0}' aanmaken als #{1}";
	strings.createglossarynew_nl = "Nieuwe aanmaken";
	
	// GLOSSARY CATEGORIES
	strings.documen_nl = "Dokumente";
	strings.org_unit_nl = "Organisatie-eenheden";
	strings.it_system_nl = "IT-systemen";
	strings.activity_nl= "Activiteiten";
	strings.state_nl = "Events";
	
	// FEEDBACK WINDOW
	strings["views.feedbacktitleenterprise_nl"] = "Support";
	strings["views.feedbacktitle_nl"] = "Signavio Support";
	strings["views.feedbacktitleenterprise_nl"] = "Supportanfrage senden";
	strings["views.feedbacktitle_nl"] = "Supportanfrage an Signavio senden";
	strings["views.feedbackentersubject_nl"] = "Geef een onderwerp dat het probleem of vraag kort beschrijft.";
	strings["views.feedbackenterdescription_nl"] = "Beschrijf uw probleem of vraag zo gedetailleerd mogelijk.";
	strings["views.feedbackpmsg_nl"] = "Gedetailleerde beschrijving van de fout";
	strings["views.feedbackpempty_nl"] = "* Beschrijf uw vraag en verstrek zoveel mogelijk details.\n* Ingeval van foutmeldingen ook de stappen aangeven hoe het probleem kan worden gereproduceerd en beschrijf de output die u verwacht.";
	strings["views.feedbackpsubject_nl"] = "Probleem met de Signavio Process Editor";
	strings["views.feedbackpbrowser_nl"] = "Informatie over uw browser en omgeving";
	strings["views.feedbackpbrowserdesc_nl"] = "Deze informatie is automatisch gedetecteerd via uw browser. Dit kan nuttig zijn als u een bug heeft gevonden welke verband houdt met browserspecifiek gedrag.";
	strings["views.feedbackclosetitle_nl"] = "Sluiten";
	strings["views.feedbackfailure_nl"] = "Mislukt";
	strings["views.feedbackfailuremsg_nl"] = "Het bericht kon niet worden verzonden!";
	strings["views.feedbacksuccess_nl"] = "Gelukt";
	strings["views.feedbacksuccessmsg_nl"] = "Bedankt voor uw feedback!";
	strings["views.feedbacksending_nl"] = "Bericht versturen...";
	strings["views.sendfeedback_nl"] = "Verstuur supportverzoek";
	strings["views.feedbackpattach_nl"] = "Koppel het huidige diagram";
	strings["views.feedbackpattachdesc_nl"] = "Deze informatie kan nuttig zijn voor debugging doeleinden. Als het diagram vertrouwelijke gegevens bevat, verwijder die dan voorafgaand aan het verzenden of vink dit af.";
	strings["views.feedbackreceiver_nl"] = "Ontvanger";
	strings["views.feedbackreceiversignavio_nl"] = "Signavio support ([mail])";
	strings["views.feedbackreceiverenterprise_nl"] = "Uw support ([mail])";
	strings["views.feedbackmissingheader_nl"] = "Geen onderwerp";
	strings["views.feedbackmissingheadermsg_nl"] = "Geef een onderwerp.";
	strings["views.feedbackmissingbody_nl"] = "Geen bericht";
	strings["views.feedbackmissingbodymsg_nl"] = "Schrijf een bericht.";
	strings["views.feedbackerrorlength_nl"] = "De beschrijving is te kort, type tenminste 40 tekens.";
	strings["views.feedbackerrorlengthtitle_nl"] = "Bericht is te kort";
	strings["views.feedbacksignavio_nl"] = "Hebt u een probleem met het gebruik van de Signavio Process Editor of hebt u een fout gevonden? Gebruik dan het supportformulier om direct contact op te nemen met Signavio Support. Het behandelen van uw aanvraag kan 1-2 werkdagen duren. We zullen reageren per e-mail. Alle informatie wordt ongecodeerd verzonden.";
	strings["views.feedbackenterprise_nl"] = "Hebt u een probleem met het gebruik van de Signavio Process Editor of hebt u een fout gevonden? Gebruik dan het supportformulier om rechtstreeks contact op te nemen met Support of de administrator. Alle informatie wordt ongecodeerd verzonden.";	
	
	// PDF EXPORT WINDOW
	strings["views.offertitle_nl"] = "PDF (enkel diagram)";
	strings["views.offertitledesc_nl"] = "U kunt het diagram afdrukken op meerdere pagina's. Selecteer de layout voor uw PDF-export.";
	strings["views.optionwindowtitle_nl"] = "PDF-Export (enkel diagram)";
	strings["views.buttontitle_nl"] = "Genereer PDF";
	strings["views.closetitle_nl"] = "Annuleren";
	strings["views.fittopage_nl"] = "Alles op één pagina plaatsen";
	strings["views.clipallsides_nl"] = "Doorlopende afdruk (2-dimensionaal)";
	strings["views.clipbottom_nl"] = "Doorlopende afdruk (verticaal)";
	strings["views.clipright_nl"] = "Doorlopende afdruk (horizontaal)";
	strings["views.landscape_nl"] = "Liggend";
	strings["views.portrait_nl"] = "Staand";
	strings["views.defaultname_nl"] = "Exporteren";
	strings["views.branding_nl"] = "Verwijder Signavio logo's";
	strings["views.premiumonly_nl"] = "Deze functie is alleen beschikbaar in de Professional Editie.";
	strings["views.waiting_nl"] = "Procesdocumentatie wordt aangemaakt.<br/>Dit kan enige tijd duren...";
	strings["views.resetview_nl"] = "Origineel";
	strings["views.windowdescription_nl"] = "Selecteer een weergave voor de export:";
	strings["panel.businessrule_nl"] = "Business Rule";
	strings["panel.static_nl"] = "Statisch";
	strings["panel.dynamic_nl"] = "Dynamisch";
	strings["panel.operation_nl"] = "Operatie";
	strings["panel.add_nl"] = "toevoegen";
	strings["panel.remove_nl"] = "Verwijderen";
	strings["panel.no_description_nl"] = "Geen beschrijving";
	strings["panel.no_performer_nl"] = "Geen uitvoerder gedefinieerd.";
	strings["panel.no_users_nl"] = "Geen gebruikers beschikbaar.";
	strings["panel.no_free_userselection_nl"] = "Onbeperkte gebruikersselectie";
	strings["panel.no_parallel_title_nl"] = "Groep toevoegen";
	strings["panel.no_parallel_description_nl"] = "Voor het huidige element is het lustype ingesteld op parallel of sequentieel, het betekent dat verschillende gebruikers de taak kunnen uitvoeren. Om dit te vereenvoudigen: wilt u alle leden van de geselecteerde groep gebruiken in plaats van de groep zelf?";
	strings["panel.no_parallel_no_user_nl"] = "De huidige groep bevat geen leden.";
	strings["panel.no_defined_role_label_nl"] = "Voorselectie";
	strings["panel.no_defined_role_single_user_nl"] = "Single-user";
	strings["panel.no_defined_role_role_member_nl"] = "Leden van de groep/rol";
	strings["panel.no_defined_role_group_nl"] = "Groepen/rollen";
	strings["panel.label_free_userselection_nl"] = "(Onbeperkte gebruikersselectie)";
	
	strings["wizard.nextbtnlabel_nl"] = "Volgende >";
	strings["wizard.previousbtnlabel_nl"] = "< Vorige";
    
	// RICHTEXT
	strings["richtext.title.undo_nl"] = "Ongedaan maken (Ctrl+Z)";
    strings["richtext.text.undo_nl"] = "De laatste veranderingen ongedaan maken.";
    strings["richtext.title.redo_nl"] = "Opnieuw uitvoeren (Shift+Ctrl+Z)";
    strings["richtext.text.redo_nl"] = "De laatste wijzigingen opnieuw uitvoeren.";
    strings["richtext.title.bold_nl"] = "Vet (Ctrl+B)";
    strings["richtext.text.bold_nl"] = "De geselecteerde tekst in vet zetten.";
    strings["richtext.title.italic_nl"] = "Cursief (Ctrl+I)";
    strings["richtext.text.italic_nl"] = "De geselecteerde tekst cursief zetten.";
    strings["richtext.title.underline_nl"] = "Onderstrepen (Ctrl+U)";
    strings["richtext.text.underline_nl"] = "De geselecteerde tekst onderstrepen.";
    strings["richtext.title.fontselect_nl"] = "Lettertype";
    strings["richtext.text.fontselect_nl"] = "Het lettertype van de geselecteerde tekst wijzigen.";
    strings["richtext.title.fontsizeselect_nl"] = "Lettergrootte:";
    strings["richtext.text.fontsizeselect_nl"] = "De tekengrootte van de geselecteerde tekst wijzigen.";
    strings["richtext.title.h1_nl"] = "Koptekst";
    strings["richtext.text.h1_nl"] = "Koptekst invoegen.";
    strings["richtext.title.h2_nl"] = "Subkoptekst";
    strings["richtext.text.h2_nl"] = "Een subkop invoegen.";
    strings["richtext.title.h3_nl"] = "Sectie koptekst";
    strings["richtext.text.h3_nl"] = "Voeg een nieuwe sectie koptekst in.";   
    strings["richtext.title.inserthorizontalrule_nl"] = "Horizontale Rule";
    strings["richtext.text.inserthorizontalrule_nl"] = "Invoegen van een horizontale lijn.";
    strings["richtext.title.color_nl"] = "Letterkleur";
    strings["richtext.text.color_nl"] = "De kleur van de geselecteerde tekst wijzigen.";
    strings["richtext.title.markupcolor_nl"] = "Tekst markeerkleur";
    strings["richtext.text.markupcolor_nl"] = "De achtergrondkleur van de geselecteerde tekst wijzigen.";
    strings["richtext.title.justifyleft_nl"] = "Tekst links uitlijnen";
    strings["richtext.text.justifyleft_nl"] = "Tekst links uitlijnen.";
    strings["richtext.title.justifycenter_nl"] = "Tekst centreren";
    strings["richtext.text.justifycenter_nl"] = "Tekst centreren in de editor.";
    strings["richtext.title.justifyright_nl"] = "Tekst rechts uitlijnen";
    strings["richtext.text.justifyright_nl"] = "Tekst rechts uitlijnen.";
    strings["richtext.title.indent_nl"] = "Inspringen (Tab)";
    strings["richtext.text.indent_nl"] = "Tekst laten inspringen.";
    strings["richtext.title.outdent_nl"] = "Inspringing verkleinen (Shift+Tab)";
    strings["richtext.text.outdent_nl"] = "Uitspringen van tekst.";
    strings["richtext.title.createlink_nl"] = "Hyperlink";
    strings["richtext.text.createlink_nl"] = "Van de geselecteerde tekst een hyperlink maken.";
    strings["richtext.title.unlink_nl"] = "Hyperlink verwijderen";
    strings["richtext.text.unlink_nl"] = "Hiermee verwijdert u de hyperlink van de selectie.";
    strings["richtext.title.insertorderedlist_nl"] = "Lijst (genummerd)";
    strings["richtext.text.insertorderedlist_nl"] = "Begin een genummerde lijst.";
    strings["richtext.title.insertunorderedlist_nl"] = "Lijst met opsommingstekens";
    strings["richtext.text.insertunorderedlist_nl"] = "Start een lijst met opsommingstekens.";
    strings["richtext.title.removeformat_nl"] = "Opmaak verwijderen";
    strings["richtext.text.removeformat_nl"] = "Verwijdert alle toegepaste opmaak in de selectie.";  
    strings['richtext.colormenu.defaultcolor_nl'] = 'Automatisch';
    strings['richtext.stub.more_nl'] = 'meer';
    strings['richtext.stub.less_nl'] = 'minder';
    strings['richtext.stub.openprint_nl'] = 'Open afdrukweergave';
    
    strings['glossary.form.description_nl'] = "The following attributes can be defined in different languages. Please use the drop-down field in the top to change the language.<br/>Consider that the title must be defined in at least one language.";

    strings['glossary.edit.title_nl'] = "Item bewerken";
    strings['glossary.edit.save_nl'] = "Opslaan";
    strings['glossary.edit.description_nl'] = "Huidige dictionary vermelding bewerken.";

    strings['glossary.new.title_nl'] = "Nieuw item";
    strings['glossary.new.save_nl'] = "Aanmaken";
    strings['glossary.new.create_nl'] = "Creëer een nieuw dictionary item.";

    strings['glossary.multilanguage.non_attributes_nl'] = "The following attributes can only be defined in the default language.";
    strings['glossary.multilanguage.copy_link_tt_nl'] = "Please notice that all contents will be replace by the new contents.";
    strings['glossary.multilanguage.remove_origin_column_nl'] = "Hide left column";
    strings['glossary.multilanguage.copy_link_title_nl'] = "Copy all contents";

    strings['glossary.view.title_nl'] = "Titel";
    strings['glossary.view.attachments_nl'] = "Relevant documents";
    strings['glossary.view.description_nl'] = "Beschrijving";
﻿
	/**
	 * ENGLISH TRANSLATION
	 * First translation into English: -
	 * Translator: -
	 * @translationchecker -
	*/

	// PACKAGE - FORM - BUTTON LABELS
	strings.btnadd_ru = "Добавить";
	strings.btnopen_ru = "Открыть";
	strings.btnremove_ru = "Удалить";
	strings.btnedit_ru = "Редактировать";
	strings.btnreset_ru = "Сбросить";
	strings.btnclose_ru = "Закрыть";
	strings.btnsave_ru = "Сохранить";
	strings.btnapply_ru = "Применить";
	strings.moveup_ru = "Вверх";
	strings.movedown_ru = "Вниз";
	strings.url_ru = "URL";
	strings.label_ru = "Метка";
	strings.year_ru = "Год";
	strings.years_ru = "Года";
	strings.month_ru = "Месяц";
	strings.months_ru = "Месяца";
	strings.day_ru = "День";
	strings.days_ru = "Дни";
	strings.hour_ru = "Час";
	strings.hours_ru = "Часы";
	strings.minute_ru = "Минута";
	strings.minutes_ru = "Минуты";
	strings.second_ru = "Секунда";
	strings.seconds_ru = "Секунды";
	strings.msecond_ru = "Милисекунда";
	strings.mseconds_ru = "Милисекунды";

	// GLOSSARY SPECIFIC VARS
	strings.createglossaryonthefly_ru = "'#{0}' создано как #{1}";
	strings.createglossarynew_ru = "Создать новый";

	// GLOSSARY CATEGORIES
	strings.document_ru = "Документы";
	strings.org_unit_ru = "Организационные части";
	strings.it_system_ru = "IT системы";
	strings.activity_ru = "Действия";
	strings.state_ru = "События";

	strings.noglossary_entry_ru = "Нет полей словаря.";

	//Feedback Window
	strings["views.feedbacktitleenterprise_ru"] = "Служба поддержки Signavio";
	strings["views.feedbacktitle_ru"] = "Служба поддержки";
	strings["views.feedbacktitleenterprise_ru"] = "Служба поддержки";
	strings["views.feedbacktitle_ru"] = "Служба поддержки Signavio";
	strings["views.feedbackentersubject_ru"] = "Пожалуйста, введите тему, которая кратко определяет проблему или вопрос.";
	strings["views.feedbackenterdescription_ru"] = "Пожалуйста, опишите проблему или вопрос, как можно детальнее.";
	strings["views.feedbackpmsg_ru"] = "Детальное описание ошибки";
	strings["views.feedbackpempty_ru"] = "* Пожалуйста, опишите Ваш запрос. Пожалуйста, дайте как можно более детальную информацию.\n* Для отчета об ошибках, пожалуйста, приведите список шагов, которые помогут воспроизвести проблему и опишите результат, который Вы ожидаете.";
	strings["views.feedbackpsubject_ru"] = "Проблема с Signavio Process Editor";
	strings["views.feedbackpbrowser_ru"] = "Информация про Ваш браузер и систему";
	strings["views.feedbackpbrowserdesc_ru"] = "Эта информация была получена автоматически с Вашего браузера. Это может быть полезно, если у Вас была ошибка связанная с поведением браузера.";
	strings["views.feedbackclosetitle_ru"] = "Закрыть";
	strings["views.feedbackfailure_ru"] = "Неудачно";
	strings["views.feedbackfailuremsg_ru"] = "Сообщение не могло быть отправлено!";
	strings["views.feedbacksuccess_ru"] = "Удачно";
	strings["views.feedbacksuccessmsg_ru"] = "Спасибо за Ваш отзыв!";
	strings["views.feedbacksending_ru"] = "Отправка сообщения ...";
	strings["views.sendfeedback_ru"] = "Отправить запрос службе поддержки";
	strings["views.feedbackpattach_ru"] = "Прикрепить текущую диаграмму";
	strings["views.feedbackpattachdesc_ru"] = "Эта информация может быть полезна в целях отладки. Если Ваша диаграмма содержит какую-либо важную информацию, удалите ее перед отправкой, либо отмените запрос.";
	strings["views.feedbackreceiver_ru"] = "Получатель";
	strings["views.feedbackreceiversignavio_ru"] = " служба поддержки Signavio ([mail])";
	strings["views.feedbackreceiverenterprise_ru"] = " Ваша поддержка ([mail])";
	strings["views.feedbackmissingheader_ru"] = "Нет описания проблемы";
	strings["views.feedbackmissingheadermsg_ru"] = "Пожалуйста, введите короткое описание проблемы.";
	strings["views.feedbackmissingbody_ru"] = "Нет детального описания";
	strings["views.feedbackmissingbodymsg_ru"] = "Пожалуйста, опишите в детальном сообщении: Какие у Вас проблемы? Какое ожидаемое поведение?";
	strings["views.feedbackerrorlength_ru"] = "Описание слишком короткое. Пожалуйста, введите как минимум 40 букв.";
	strings["views.feedbackerrorlengthtitle_ru"] = "Сообщение слишком короткое";
	strings["views.feedbacksignavio_ru"] = "You have a problem with using the Signavio Process Editor or you have found an error? In this case please use the support form to contact the Signavio " +
										"support directly. Please notice, that the handling of your request can take about 1-2 business days. " +
										"We will respond by email. All information is transferred unencrypted.";
										   "Falle das Support-Formular um direkten Kontakt mit Signavio aufzunehmen. Bitte beachten Sie, dass eine Bearbeitung Ihrer Anfrage "+
										   "ca. 1-2 Werktage in Anspruch nehmen kann. Sie erhalten unsere Antwort anschließend per Email. Sämtliche Informationen werden unverschlüsselt "+
										   "übertragen.";
										  "Por favor tome en cuenta que el manejo de su solicitud puede tardar de 1-2 días hábiles." + "Le responderemos por correo electrónico. Toda la información se transmite cifrada";
										  "У Вас есть проблемы и использованием Signavio Process Editor или Вы нашли ошибку? В этом случае используйте, пожалуйста, форму поддержки чтобы напрямую связаться с службой поддержки " +
											"Signavio. Пожалуйста, обратите внимание, что обработка Вашего запроса может занять 1-2 рабочих дня. " + "Мы ответим по email. Вся передаваемая информация незашифрована.";
	strings["views.feedbackenterprise_ru"] = "You have a problem with using the Signavio Process Editor or you have found an error? In this case please use the support form to directly contact your " +
										  "support or administrator. All information is transferred unencrypted.";
											 "Falle das Support-Formular um direkten Kontakt mit Ihrem Support/Administrator aufzunehmen. Sämtliche Informationen werden unverschlüsselt "+
											 "übertragen.";
										  "Por favor tome en cuenta que el manejo de su solicitud puede tardar de 1-2 días hábiles." + "Le responderemos por correo electrónico. Toda la información se transmite cifrada";
										  "У Вас есть проблемы с использованием Signavio Process Editor или Вы нашли ошибку? В этом случае, пожалуйста, используйте форму поддержки чтобы напрямую связаться с службой поддержки " +
										  "или администратором. Вся передаваемая информация незашифрована.";
	//PDF Export Window
	strings["views.offertitle_ru"] = "PDF (одна диаграмма)";
	strings["views.offertitledesc_ru"] = "Вы можете напечатать диаграмму на нескольких страницах. Пожалуйста, выберите  расположение, которое Вы хотите для Вашего PDF экспорта.";
	strings["views.optionwindowtitle_ru"] = "PDF Экспорт (одна диаграмма)";
	strings["views.buttontitle_ru"] = "Сгенерировать PDF";
	strings["views.closetitle_ru"] = "Отмена";
	strings["views.fittopage_ru"] = "Подогнать под одну страницу";
	strings["views.clipallsides_ru"] = "Непрерывная печать (2-мерная)";
	strings["views.clipbottom_ru"] = "Непрерывная печать (вертикальная)";
	strings["views.clipright_ru"] = "Непрерывная печать (горизонтальная)";
	strings["views.landscape_ru"] = "Горизотальная";
	strings["views.portrait_ru"] = "Вертикальная";
	strings["views.defaultname_ru"] = "Экспорт";
	strings["views.branding_ru"] = "Убрать значки Signavio";
	strings["views.premiumonly_ru"] = "Эта функция доступна только для Professional edition.";
	strings["views.waiting_ru"] = "Будет создана документация процесса.<br/>Это может занять некоторое время...";
	strings["views.resetview_ru"] = "Оригинал";
	strings["views.windowdescription_ru"] = "Пожалуйста, выберите представление для экспорта:";


	strings["panel.businessrule_ru"] = "Бизнесс правило";
	strings["panel.static_ru"] = "Статическое";
	strings["panel.dynamic_ru"] = "Динамическое";
	strings["panel.operation_ru"] = "Операция";
	strings["panel.add_ru"] = "добавить";
	strings["panel.remove_ru"] = "удалить";

	strings["panel.no_description_ru"] = "Нет описания";
	strings["panel.no_performer_ru"] = "Выполнитель не определен.";
	strings["panel.no_users_ru"] = "Нет доступных пользователей.";
	strings["panel.no_free_userselection_ru"] = "Неограниченный выбор";
	strings["panel.no_parallel_title_ru"] = "Добавить группу";
	strings["panel.no_parallel_description_ru"] = "Для текущего элемента, тип цикла установлен как паралельный или последовательный, это значит что несколько пользователей  могут выполнять это задание. Чтобы упростить это, Вы хотие использовать всех пользователей выбранной группы вместо группы?";
	strings["panel.no_parallel_no_user_ru"] = "Текущая группа не содержит пользователей.";
	strings["panel.no_defined_role_label_ru"] = "Предварительный выбор";
	strings["panel.no_defined_role_single_user_ru"] = "Один пользователь";
	strings["panel.no_defined_role_role_member_ru"] = "Члены группы/роли";
	strings["panel.no_defined_role_group_ru"] = "Группы/поли";
	strings["panel.label_free_userselection_ru"] = "(Неограниченный выбор)";

	strings["wizard.nextbtnlabel_ru"] = "Дальше >";
	strings["wizard.previousbtnlabel_ru"] = "< Назад";

	/** New Language Properties 27.07.2010 */
    strings["richtext.title.undo_ru"] = "Отменить (Ctrl+Z)";
    strings["richtext.text.undo_ru"] = "Отменяет последние изменения.";

    strings["richtext.title.redo_ru"] = "Вернуть (Shift+Ctrl+Z)";
    strings["richtext.text.redo_ru"] = "Возвращает последние изменения.";
    strings["richtext.title.bold_ru"] = "Жирный (Ctrl+B)";
    strings["richtext.text.bold_ru"] = "Сделать выбранный текст жирным.";

    strings["richtext.title.italic_ru"] = "Курсив (Ctrl+I)";
    strings["richtext.text.italic_ru"] = "Сделать выбранный текст курсивом.";

    strings["richtext.title.underline_ru"] = "Подчеркнутый (Ctrl+U)";
    strings["richtext.text.underline_ru"] = "Подчеркнуть выбранный текст.";

    strings["richtext.title.fontselect_ru"] = "Шрифт";
    strings["richtext.text.fontselect_ru"] = "Изменить шрифт выбранного текста.";

    strings["richtext.title.fontsizeselect_ru"] = "Размер шрифта";
    strings["richtext.text.fontsizeselect_ru"] = "Изменить размер выбранного шрифта.";

    strings["richtext.title.h1_ru"] = "Заголовок";
    strings["richtext.text.h1_ru"] = "Вставить заголовок.";

    strings["richtext.title.h2_ru"] = "Подзаголовок";
    strings["richtext.text.h2_ru"] = "Вставить подзаголовок.";

    strings["richtext.title.h3_ru"] = "Заголовок раздела";
    strings["richtext.text.h3_ru"] = "Вставить новый заголовок раздела.";

    strings["richtext.title.inserthorizontalrule_ru"] = "Горизонтальное правило";
    strings["richtext.text.inserthorizontalrule_ru"] = "Вставляет горизонтальное правило.";

    strings["richtext.title.color_ru"] = "Цвет шрифта";
    strings["richtext.text.color_ru"] = "Меняет цвет шрифта для выбранного текста.";

    strings["richtext.title.markupcolor_ru"] = "Цвет выделения текста";
    strings["richtext.text.markupcolor_ru"] = "Изменить цвет фона для выбранного текста.";

    strings["richtext.title.justifyleft_ru"] = "Выровнять текст по левому краю";
    strings["richtext.text.justifyleft_ru"] = "Выровнять текст по левому краю.";

    strings["richtext.title.justifycenter_ru"] = "Выровнять текст по центру";
    strings["richtext.text.justifycenter_ru"] = "Выровнять текст по центру.";

    strings["richtext.title.justifyright_ru"] = "Выровнять текст по правому краю";
    strings["richtext.text.justifyright_ru"] = "Выровнять текст по правому краю.";

    strings["richtext.title.indent_ru"] = "Отступ (Tab)";
    strings["richtext.text.indent_ru"] = "Отступ текста.";

    strings["richtext.title.outdent_ru"] = "Выступ (Shift+Tab)";
    strings["richtext.text.outdent_ru"] = "Выступ текста.";

    strings["richtext.title.createlink_ru"] = "Гиперссылка";
    strings["richtext.text.createlink_ru"] = "Сделать выделенный текст гиперссылкой.";

    strings["richtext.title.unlink_ru"] = "Удалить гиперссылку";
    strings["richtext.text.unlink_ru"] = "Убрать гиперсылку для выбранного текста.";

    strings["richtext.title.insertorderedlist_ru"] = "Список (нумерованный)";
    strings["richtext.text.insertorderedlist_ru"] = "Начать нумерованный список.";

    strings["richtext.title.insertunorderedlist_ru"] = "Маркированный список";
    strings["richtext.text.insertunorderedlist_ru"] = "Начать маркированный список.";

    strings["richtext.title.removeformat_ru"] = "Отменить форматирование";
    strings["richtext.text.removeformat_ru"] = "Отменяет все форматирование для выбранного текста.";

    strings['richtext.colormenu.defaultcolor_ru'] = 'Автоматический';

    strings['richtext.stub.more_ru'] = 'больше';
    strings['richtext.stub.less_ru'] = 'меньше';
    strings['richtext.stub.openprint_ru'] = 'Открыть вид для печати';

    strings['richtext.simpleeditingmodetitle_ru'] = 'Простой режим редактирования';
    strings['richtext.simpleeditingmodedesc_ru'] = 'Переключить к простому режиму редактирования';
    strings['richtext.simpleeditingmodewarning_ru'] = 'Усовершенствованные опции форматирования не доступны в простом режиме редактирования.Если Вы продолжите все существующие опции форматирования могут быть утеряны.';
    strings['richtext.notavailable.title_ru'] = "Усовершенствованные опции форматирования не доступны";
    strings['richtext.notavailable.warning_ru'] = "Усовершенствованный режим редактирования не поддерживается Вашим браузером.<br/>Если Вы продолжите, все существующие опции форматирования могут быть утеряны.";


    strings['richtext.link.address_ru'] = 'Пожалуйста, введите адрес:';
    strings['richtext.link.tooltip_ru'] = 'oткрыть с Ctrl+Click';




    strings['attribute.mapper.loading_ru'] = "Загрузка";
    strings['attribute.mapper.stencilsets_ru'] = "типы диаграмм";
    strings['attribute.mapper.deselected_ru'] = "#{count} исключено элемента(-ов)";
    strings['attribute.mapper.attributes_selected_ru'] = "#{count} разных аттрибутов выбрано";
    strings['attribute.mapper.attributes_deselected_ru'] = "#{count} аттрибутов исключено";
    strings['attribute.mapper.selected_ru'] = "#{count} аттрибутов выбрано";
    strings['attribute.mapper.no_attributes_ru'] = "Нет доступных аттрибутов для этого языка моделирования.";
    strings['attribute.mapper.no_selection_ru'] = "Нет";
    strings['attribute.mapper.exclusion_active_ru'] = "Набор ограничений";
    strings['attribute.mapper.excluion_inactive_ru'] = "Нет набора ограничений";
    strings['attribute.mapper.list_ru'] = "List";

    strings['attribute.mapper.selected_ru'] = "#{count} выбрано";

    strings['attribute.mapper.untitled_group_ru'] = "Группа без заголовка";

    strings['attribute.mapper.config.all_attributes_ru'] = "Все аттрибуты";
    strings['attribute.mapper.config.own_attributes_ru'] = "Выбранные аттрибуты";
    strings['attribute.mapper.config.select_attributes_ru'] = "Выбрать аттрибуты";
    strings['attribute.mapper.config.all_elements_ru'] = "Все элементы";
    strings['attribute.mapper.config.flow_elements_ru'] = "Только элементы потока";
    strings['attribute.mapper.config.activities_ru'] = "Только действия";
    strings['attribute.mapper.config.select_elements_ru'] = "Выбрать элементы";

    strings['attribute.mapper.config.name_ru'] = "Название";
    strings['attribute.mapper.config.description_ru'] = "Пожалуйста, определите название и набор аттрибутов, которые должны учитываться в конвенциях.";

    strings['attribute.mapper.config.hide_empty_attributes_ru'] = "Спрятать аттрибуты без значения";
    strings['attribute.mapper.config.show_attribute_label_ru'] = "Показать аттрибуты без значения";
    strings['attribute.mapper.config.separate_labels_ru'] = "Разделить аттрибуты по";
    strings['attribute.mapper.config.separator_comma_ru'] = "Запятая";
    strings['attribute.mapper.config.separator_space_ru'] = "Пробел";
    strings['attribute.mapper.config.separator_linebreak_ru'] = "Разрыв строки";
    strings['attribute.mapper.config.list_style_ru'] = "Списки показаны как";
    strings['attribute.mapper.config.list_style_bullet_ru'] = "Маркированный список";
    strings['attribute.mapper.config.list_style_numbered_ru'] = "Нумерованный список";

    strings['attribute.mapper.config.main_properties_ru'] = "Основные свойства";
    strings['attribute.mapper.config.more_properties_ru'] = "Больше свойств";
    strings['attribute.mapper.config.meta_properties_ru'] = "Определенные свойства";

    strings['glossary.mapper.type.document_ru'] = "Документы";
    strings['glossary.mapper.type.org_unit_ru'] = "Организационные части";
    strings['glossary.mapper.type.it_system_ru'] = "IT системы";
    strings['glossary.mapper.type.activity_ru'] = "Дейтсвия";
    strings['glossary.mapper.type.state_ru'] = "События";

    strings['glossary.mapper.loading_groups_ru'] = "Загрузка групп словаря...";
    strings['glossary.mapper.all_categories_ru'] = "Все выбраны";
    strings['glossary.mapper.categories_chosen_ru'] = "выбрано";
    strings['glossary.mapper.select_all_ru'] = "Выбрать все";
    strings['glossary.mapper.select_none_ru'] = "Ничего не выбирать";

    strings['glossary.form.description_ru'] = "Следующие аттрибуты могут быть определены на разных языках. Пожалуйста, используйте выпадающий список сверху чтобы изменить язык.<br/>Учтите что заголовок должен быть определен хотя бы на одном языке.";

    strings['glossary.edit.title_ru'] = "Редактировать поле";
    strings['glossary.edit.save_ru'] = "Сохранить";
    strings['glossary.edit.description_ru'] = "Редактировать текущее поле словаря.";

    strings['glossary.new.title_ru'] = "Новое поле";
    strings['glossary.new.save_ru'] = "Создать";
    strings['glossary.new.create_ru'] = "Создать новое поле словаря.";

    strings['glossary.multilanguage.non_attributes_ru'] = "Следующие аттрибуты могут быть определены только на языке по умолчанию.";
    strings['glossary.multilanguage.copy_link_tt_ru'] = "Пожалуйста, обратите внимание, что все содержимое будет заменено новым содержимым.";
    strings['glossary.multilanguage.remove_origin_column_ru'] = "Спрятать левый столбец";
    strings['glossary.multilanguage.copy_link_title_ru'] = "Скопировать все содержимое";

    strings['glossary.view.title_ru'] = "Заголовок";
    strings['glossary.view.attachments_ru'] = "Соответствующие документы";
    strings['glossary.view.description_ru'] = "Описание";

    strings['propertyeditor.itsm.assignee.company_ru'] = "Компания";
    strings['propertyeditor.itsm.assignee.organization_ru'] = "Организация";
    strings['propertyeditor.itsm.assignee.group_ru'] = "Группа";

    strings['propertyeditor.itsm.location.region_ru'] = "Регион";
    strings['propertyeditor.itsm.location.sitegroup_ru'] = "Группа сайтов";
    strings['propertyeditor.itsm.location.site_ru'] = "сайт";

    strings['propertyeditor.itsm.servicecat.tier_ru'] = "Ярус {0}";

    strings['propertyeditor.itsm.productcat.name_ru'] = "Название";
    strings['propertyeditor.itsm.productcat.model_ru'] = "Модель";

    strings['propertyeditor.itsm.variablemapping.header.variable_ru'] = "Переменная";
    strings['propertyeditor.itsm.variablemapping.header.input_ru'] = "Ввод";
    strings['propertyeditor.itsm.variablemapping.header.output_ru'] = "Вывод";

    strings['propertyeditor.itsm.variablemapping.error.title_ru'] = "Слишком много переменных";
    strings['propertyeditor.itsm.variablemapping.error.message_ru'] = "Использовано слишком много переменных типа '{0}'.<br/>  Максимум: {1}.";

    strings['propertyeditor.itsm.condition.add_ru'] = "Добавить переменную...";

    strings['glossary.new.languageswitch_ru'] = "Язык";

    strings['language_bg_ru'] = "Болгарский";
    strings['language_cz_ru'] = "Чешский";
    strings['language_da_ru'] = "Датский";
    strings['language_nl_ru'] = "Голландский";
    strings['language_et_ru'] = "Эстонский";
    strings['language_fi_ru'] = "Финский";
    strings['language_fr_ru'] = "Французкий";
    strings['language_de_ru'] = "Немецкий";
    strings['language_el_ru'] = "Греческий";
    strings['language_hu_ru'] = "Венгерский";
    strings['language_ie_ru'] = "Ирландский";
    strings['language_it_ru'] = "Итальянский";
    strings['language_lv_ru'] = "Латышский";
    strings['language_lt_ru'] = "Литовский";
    strings['language_mt_ru'] = "Мальтийский";
    strings['language_pl_ru'] = "Польский";
    strings['language_pt_ru'] = "Португальский";
    strings['language_ro_ru'] = "Румынский";
    strings['language_sk_ru'] = "Словацкий";
    strings['language_sl_ru'] = "Словенский";
    strings['language_es_ru'] = "Испанский";
    strings['language_sv_ru'] = "Шведский";
    strings['language_mx_ru'] = "Испанский";
    strings['language_en_ru'] = "Английский";
    strings['language_lb_ru'] = "Люксембургский";
    strings['language_af_ru'] = "Африканский";

    strings['country_at_ru'] = "Австрия";
    strings['country_be_ru'] = "Бельгия";
    strings['country_bg_ru'] = "Болгария";
    strings['country_ch_ru'] = "Швейцария";
    strings['country_cz_ru'] = "Чехия";
    strings['country_dk_ru'] = "Дания";
    strings['country_gb_ru'] = "Великобритания";
    strings['country_nl_ru'] = "Нидерланды";
    strings['country_ee_ru'] = "Эстония";
    strings['country_fi_ru'] = "Финляндия";
    strings['country_fr_ru'] = "Франция";
    strings['country_de_ru'] = "Германия";
    strings['country_gr_ru'] = "Греция";
    strings['country_hu_ru'] = "Венгрия";
    strings['country_ie_ru'] = "Ирландия";
    strings['country_it_ru'] = "Италия";
    strings['country_lv_ru'] = "Латвия";
    strings['country_lt_ru'] = "Литва";
    strings['country_mt_ru'] = "Мальта";
    strings['country_pl_ru'] = "Польша";
    strings['country_pt_ru'] = "Португалия";
    strings['country_ro_ru'] = "Румыния";
    strings['country_sk_ru'] = "Словакия";
    strings['country_si_ru'] = "Словения";
    strings['country_es_ru'] = "Испания";
    strings['country_se_ru'] = "Швеция";
    strings['country_en_ru'] = "Англия";
    strings['country_mx_ru'] = "Мексика";
    strings['country_us_ru'] = "США";
    strings['country_lu_ru'] = "Люксембург";
    strings['country_za_ru'] = "Южная Африка";
    strings['country_br_ru'] = "Бразилия";
    strings['country_ca_ru'] = "Канада";
    strings['country_cl_ru'] = "Чили";
    strings['country_li_ru'] = "Лихтнштейн";
    strings['country_nz_ru'] = "Новая Зеландия";
    strings['coutnry_au_ru'] = "Австралия";

    //TODO
	strings['multilanguage.language.bg_ru'] = "Болгарский";
	strings['multilanguage.language.cz_ru'] = "Чешский";
	strings['multilanguage.language.dk_ru'] = "Датский";
	strings['multilanguage.language.nl_ru'] = "Голландский";
	strings['multilanguage.language.ee_ru'] = "Эстонский";
	strings['multilanguage.language.fi_ru'] = "Финский";
	strings['multilanguage.language.fr_ru'] = "Французкий";
	strings['multilanguage.language.de_ru'] = "Немецкий";
	strings['multilanguage.language.gr_ru'] = "Греческий";
	strings['multilanguage.language.hu_ru'] = "Венгерский";
	strings['multilanguage.language.ie_ru'] = "Ирландский";
	strings['multilanguage.language.it_ru'] = "Итальянский";
	strings['multilanguage.language.lv_ru'] = "Латышский";
	strings['multilanguage.language.lt_ru'] = "Литовский";
	strings['multilanguage.language.mt_ru'] = "Мальтийский";
	strings['multilanguage.language.pl_ru'] = "Польский";
	strings['multilanguage.language.pt_ru'] = "Португальский";
	strings['multilanguage.language.ro_ru'] = "Румынский";
	strings['multilanguage.language.sk_ru'] = "Словацкий";
	strings['multilanguage.language.si_ru'] = "Словенский";
	strings['multilanguage.language.es_ru'] = "Испанский";
	strings['multilanguage.language.se_ru'] = "Шведский";
	strings['multilanguage.language.mx_ru'] = "Испанский";
	strings['multilanguage.language.en_ru'] = "Английский";
	strings['multilanguage.language.lu_ru'] = "Люксембургский";
	strings['multilanguage.language.za_ru'] = "Африканский";

	strings['multilanguage.country.at_ru'] = "Австрия";
	strings['multilanguage.country.be_ru'] = "Бельгия";
	strings['multilanguage.country.bg_ru'] = "Болгария";
	strings['multilanguage.country.ch_ru'] = "Швейцария";
	strings['multilanguage.country.cz_ru'] = "Чехия";
	strings['multilanguage.country.dk_ru'] = "Дания";
	strings['multilanguage.country.gb_ru'] = "Великобритания";
	strings['multilanguage.country.nl_ru'] = "Нидерланды";
	strings['multilanguage.country.ee_ru'] = "Эстония";
	strings['multilanguage.country.fi_ru'] = "Финляндия";
	strings['multilanguage.country.fr_ru'] = "Франция";
	strings['multilanguage.country.de_ru'] = "Германия";
	strings['multilanguage.country.gr_ru'] = "Греция";
	strings['multilanguage.country.hu_ru'] = "Венгрия";
	strings['multilanguage.country.ie_ru'] = "Ирландия";
	strings['multilanguage.country.it_ru'] = "Италия";
	strings['multilanguage.country.lv_ru'] = "Латвия";
	strings['multilanguage.country.lt_ru'] = "Литва";
	strings['multilanguage.country.mt_ru'] = "Мальта";
	strings['multilanguage.country.pl_ru'] = "Польша";
	strings['multilanguage.country.pt_ru'] = "Португалия";
	strings['multilanguage.country.ro_ru'] = "Румыния";
	strings['multilanguage.country.sk_ru'] = "Словакия";
	strings['multilanguage.country.si_ru'] = "Словения";
	strings['multilanguage.country.es_ru'] = "Испания";
	strings['multilanguage.country.se_ru'] = "Швеция";
	strings['multilanguage.country.en_ru'] = "Англия";
	strings['multilanguage.country.mx_ru'] = "Мексика";
	strings['multilanguage.country.us_ru'] = "США";
	strings['multilanguage.country.lu_ru'] = "Люксембург";
	strings['multilanguage.country.za_ru'] = "Южная Африка";
	strings['multilanguage.country.br_ru'] = "Бразилия";
	strings['multilanguage.country.ca_ru'] = "Канада";
	strings['multilanguage.country.cl_ru'] = "Чили";
	strings['multilanguage.country.li_ru'] = "Лихтенштейн";
	strings['multilanguage.country.nz_ru'] = "Новая Зеландия";
	strings['multilanguage.country.au_ru'] = "Австралия";

	// IKS
	strings['iks.title_ru'] = "Риски и контроль";
	strings['iks.desc_ru'] = "Определите возможные риски и связанный контроль для элементов процесса.";
	strings['iks.windowapply_ru'] = "Применить";
	strings['iks.overlayhint_ru'] = "Пожалуйста, нажмите чтобы редактировать риск и контроли для этого элемента процесса.";
	strings['iks.toolbarname_ru'] = "Показать риски и контроль";
	strings['iks.toolbardesc_ru'] = "Показать риски и контроль для элементов процесса";
	strings['iks.risk_ru'] = "Риск";
	strings['iks.risks_ru'] = "Риски";
	strings['iks.control_ru'] = "Контроль";
	strings['iks.controls_ru'] = "Контроль";
	strings['iks.newentry_ru'] = "Пожалуйста, нажмите здесь чтобы создать {0}...";
	strings['iks.newentryrisk_ru'] = " новый риск ";
	strings['iks.newentrycontrol_ru'] = " новый контроль ";
	strings['iks.addcontrols_ru'] = "Добавить контроль";
	strings['iks.removerisk_ru'] = "Удалить этот риск";
	strings['iks.removecontrol_ru'] = "Удалить этот контроль";
	strings['iks.deletethistpl_ru'] = "Удалить этот ";
	strings['iks.deletethisrisk_ru'] = "риск и все связанные контроли?";
	strings['iks.deletethiscontrol_ru'] = "контроль?";
	strings['iks.yes_ru'] = "Да";
	strings['iks.no_ru'] = "Нет";
	strings['iks.globalrisks_ru'] = "Глобальные риски";

	
	
	Ext.ux.getLang = function(){
		return Ext.ux && Ext.ux.i18n && Ext.ux.i18n.Language ? Ext.ux.i18n.Language.split("_").first().toLowerCase() : "en";
	};
	
	/**
	 * Returns the internationalized string of
	 * its property.
	 * 
	 * @param {String} prop
	 * @return {String}
	 * 
	 */
	Ext.ux.getI18N = function(prop) {
		prop = (prop || "").toLowerCase();
		var lang = Ext.ux.getLang();
		return Ext.ux.i18n[prop + "_" + lang] || Ext.ux.i18n[prop] ||  strings[prop+"_"+lang] || strings[prop] || "";
	};
}();
/**
 *  utils.js
 *  (c) 2009 Signavio GmbH
 *
 *  @author Willi Tscheschner
 *
 *  Utils is a shared javascript file which provides common
 *  functionalities for all applications in the Signavio Process Editor
 *
 */

if(!window.Signavio){ window.Signavio = {}; }

(function(window, Signavio, Ext) {

	var ns = window.ns = function(ns, base) {
		base = base || "Signavio";

		var root = window[base] || Signavio;
		var packages = (ns || "").split(".");

		var createNS = function(current, packages) {
			var pack = packages.shift();

			if(!pack) {
				return;
			}

			if(pack === base) {
				return createNS(root, packages);
			}

			if(!current[pack]) {
				current[pack] = {};
			}

			return createNS(current[pack], packages);
		};

		createNS(root, packages);
	};

	ns("Utils");

	var _round = Math.round;

	Math.round = function(number, precision) {
		precision = Math.abs(parseInt(precision, 10)) || 0;
		var coefficient = Math.pow(10, precision);

		return _round(number * coefficient) / coefficient;
	};

	if ('undefined' !== typeof Element) {
		Element.addMethods({
			setWidth: function(element, width) {
				return Element.setStyle(element, {
					width: Ext.isNumber(width) ? width + "px" : width
				});
			},
			setHeight: function(element, height) {
				return Element.setStyle(element, {
					height: Ext.isNumber(height) ? height + "px" : height
				});
			}
		});
	}

	if(!Array.prototype.randomElement) {
		Array.prototype.randomElement = function() {
			return this[Math.floor(Math.random() * this.length)];
		};
	}

	if(!Object.toQueryString) {
		Object.toQueryString = function(object) {
			return $H(object).toQueryString();
		};
	}

	if(!document.viewport && 'undefined' !== typeof Prototype) {
		(function() {
			var IS_OLD_OPERA = Prototype.Browser.Opera &&
				(window.parseFloat(window.opera.version()) < 9.5);
			var ROOT = null;

			function getRootElement() {
				if (ROOT) {
					return ROOT;
				}

				ROOT = IS_OLD_OPERA ? document.body : document.documentElement;

				return ROOT;
			}

			document.viewport = {
				getWidth: function() {
					return getRootElement().clientWidth;
				},
				getHeight: function() {
					return getRootElement().clientHeight;
				}
			};
		}());
	}

	var getH = function(r, g, b) {
		var max = Math.max(r, g, b);
		var min = Math.min(r, g, b);

		if(r === max) {
			return (g - b) / (max -min);
		}

		if(g === max) {
			return 2 + (b - r) / (max - min);
		}

		return 4 + (r - g) / (max - min);
	};

	var getS = function(l, min, max) {
		if(l < 0.5) {
			return (max - min) / (max + min);
		}

		return (max -min) / (2 - max - min);
	};

	Signavio.Utils.rgb2hsl = function(value) {
		value = value.replace("#", "");

		var r = parseInt(value.slice(0, 2), 16) / 255;
		var g = parseInt(value.slice(2, 4), 16) / 255;
		var b = parseInt(value.slice(4, 6), 16) / 255;

		var max = Math.max(r, g, b);
		var min = Math.min(r, g, b);

		var h = 0;
		var s = 0;
		var l = (max + min) / 2;

		if(max !== min) {
			s = getS(l, min, max);
			h = getH(r, g, b);
		}

		h = h * 60;
		s = s * 100;
		l = l * 100;

		if(h < 0) {
			h = h + 360;
		}

		return {
			h: h,
			s: s,
			l: l
		};
	};

	var hue2rgb = function(p, q, t){
        if(t < 0) {
			t += 1;
        }

        if(t > 1) {
			t -= 1;
        }

        if(t < 1/6) {
			return p + (q - p) * 6 * t;
        }

        if(t < 1/2)  {
			return q;
        }

        if(t < 2/3) {
			return p + (q - p) * (2/3 - t) * 6;
        }

        return p;
    };

    var getQ = function(l, s) {
		if(l < 0.5) {
			return l * (1 + s);
        }

        return (l + s) - (l * s);
    };

	Signavio.Utils.hsl2rgb = function(h, s ,l) {
		h = h / 360;
		s = s / 100;
		l = l / 100;

		var r, g, b;

		if(s === 0){
			return {
				r: (l * 255).toString(16),
				g: (l * 255).toString(16),
				b: (l * 255).toString(16)
			};
		}

        var q = getQ(l, s);
        var p = 2 * l - q;

        var getHex = function(number) {
			var value = Math.round(number * 255).toString(16);

			if(value.length === 1) {
				return "0" + value;
			}

			return value;
        };

        r = getHex(hue2rgb(p, q, h + 1/3));
        g = getHex(hue2rgb(p, q, h));
        b = getHex(hue2rgb(p, q, h - 1/3));

        return {
			r: r,
			g: g,
			b: b
        };
	};

	Signavio.Utils.darken = function(color, amount) {
		var hsl = Signavio.Utils.rgb2hsl(color);

		// +100 because modulo in chrome could yield negative values.
		hsl.l = ((hsl.l - amount) + 100) % 100;

		var rgb = Signavio.Utils.hsl2rgb(hsl.h, hsl.s, hsl.l);

		return "#" + rgb.r + rgb.g + rgb.b;
	};

	if(!Ext.isDefined) {
		Ext.isDefined = function(value) {
			return typeof value !== "undefined";
		};
	}

	if(!Ext.isNumber) {
		Ext.isNumber = function(value) {
			return typeof value === "number" && isFinite(value);
		};
	}

	var checkType = function(record, type) {
		if(!record) {
			return false;
		}

		return record.get("rel") === type;
	};

	Signavio.Utils.isModel = function(record) {
		return checkType(record, Signavio.Const.REL.MODEL);
	};

	Signavio.Utils.isDirectory = function(record) {
		return checkType(record, Signavio.Const.REL.DIRECTORY);
	};

	Signavio.Utils.isPublic = function(record) {
		return !record.get("rep").type || record.get("rep").type === "public";
	};

	Signavio.Utils.isFile = function(record) {
		return checkType(record, Signavio.Const.REL.FILE);
	};

	Signavio.Utils.isGlossary = function(record) {
		return checkType(record, Signavio.Const.REL.GLOSSARY);
	};
	
	Signavio.Utils.isGlossaryCategory = function(record) {
		return checkType(record, Signavio.Const.REL.CATEGORY);
	};

	Signavio.Utils.isTrashFolder = function(record, facade) {
		var trash = facade.getTrashRecord();

		if(!trash) {
			return false;
		}

		// Removing the possible directoryall handler
		var href = record.get("href").replace("directoryall", "directory");

		return href === trash.get("href");
	};

	Signavio.Utils.isInternalFolder = function(record) {
		return record.get("rep").type === "internal";
	};

	if (Ext.data) {
		Signavio.Utils.DummyRecord = Ext.data.Record.create([
			{ name: "href", mapping: "href" },
			{ name: "rel", mapping: "rel" },
			{ name: "rep", mapping: "rep" }
		]);		
	}

	var bound = function(ctxs, method) {
		var ctx = ctxForMethod(ctxs, method);

		if(!ctx || !ctx[method]) {
			return;
		}

		return function() {
			return ctx[method].apply(ctx, arguments);
		};
	};

	var ctxForMethod = function(ctxs, method) {
		return ctxs.compact().find(function(ctx) {
			return ctx[method];
		});
	};

	Signavio.Utils.createForm = function(win, action, inputs) {
		var parent;

		if(win.contentDocument) {
			parent = win.contentDocument.body;
		} else {
			parent = win.document.body;
		}

		var securityParameter = $H(Ext.Ajax.getSecurityParameter()).map(function(hash){
			return ["input", {
				type: "hidden",
				value: hash.value,
				name: hash.key
			}];
		});

		var contexts = [Signavio.Core, Ext.isDefined(window.ORYX) ? ORYX.Editor : null];

		return bound(contexts, "graft")(null, Ext.isIE ? document.body : parent,
			["form", { action: action, method: "POST" }].concat(securityParameter, inputs)
		);
	};

	Signavio.Utils.getSecurityParameterField = function() {
		return $H(Ext.Ajax.getSecurityParameter()).map(function(entry) {
			return new Ext.form.TextField({
				name: entry.key,
				value: entry.value,
				inputType: "hidden"
			});
		})[0];
	};

	Signavio.Utils.getImagePath = function() {
		if(window.Signavio && Signavio.Config) {
			return Signavio.Config.IMAGE_PATH;
		}

		if(window.ORYX && ORYX.CONFIG) {
			return ORYX.CONFIG.IMAGE_PATH;
		}

		return "";
	};

	/**
	 * Function to request the parents of a single node(model/directory) ordered bottom top.
	 * @param {String} nodeName : resource to be requested, in the form "/directory/[ID]" or "/model/[ID]"
	 * @param {boolean} async
	 * @return {array} parents : bottom to top, the last element is the requested resource itself
	 */
	Signavio.Utils.getResourcePath = function(nodeName, async) {
		var parents = [];
		var that = this;

		var resourceRequest = {
			success: function(response) {
				parents = [{
					href: nodeName,
					rel: 'info',
					rep: response
				}].concat(parents);
			},
			asynchronous: false
		};

		this.Request.execute(ORYX.CONFIG.SERVER_HANDLER_ROOT + nodeName + "/parents", {
			success: function(response) {
				parents = response;
				that.Request.execute(ORYX.CONFIG.SERVER_HANDLER_ROOT + nodeName + "/info", resourceRequest);
			},
			asynchronous: async === true
		});

		return parents;
	};

	Signavio.Utils.SplitIntoTwoLines = function(text, width){
		
		if (!text) {
			return "";
		}

		// first unescape the text, so you know how long it will really be
		var uText = text.unescapeHTML();
		
		// Get the first line
		var first = Signavio.Utils.TruncateByWidth(uText, (width / 2) + 16, "");
		
		// Text is short enough for one line
		if (first === uText) {
			// return original text
			return text;
		}
		
		var second = uText.slice(first.length);
		second = Signavio.Utils.TruncateByWidthAndEscape(second, width / 2, "<small>&#8230;</small>");
		
		// escape the first part again, the second part is already escaped by truncating function
		return first.escapeHTML() + "<br />" + second;
	};

	Signavio.Utils.TruncateByWidth = function(text, width, suffix) {
		text = text || "";
		
		if (typeof width !== "number"){
			return text;
		}
	
		var truncateWidth = 0;
		var index = 0;
		
		// Stop when have more width than given
		while (truncateWidth < width && index < text.length) {
			truncateWidth += Signavio.Utils.approximateWidth(text.charAt(index));
			index = index + 1;
		}
		
		// If there is a truncate, leav space for the suffix	
		while((truncateWidth + 14) > width && index > 0){
			truncateWidth -= Signavio.Utils.approximateWidth(text.charAt(index));
			index = index - 1;
		}

		if(index === text.length) {
			return text;
		}

		text = text.slice(0, index-1);

		if(Ext.isDefined(suffix)) {
			return text + suffix;
		}

		return text + "&#8230;";
	};

	Signavio.Utils.TruncateByWidthAndEscape = function(text, width, suffix){
		text = text || "";
		
		if (typeof width !== "number"){
			return text;
		}
	
		var truncateWidth = 0;
		var index = 0;
		
		// Stop when have more width than given
		while (truncateWidth < width && index < text.length) {
			truncateWidth += Signavio.Utils.approximateWidth(text.charAt(index));
			index = index + 1;
		}
		
		// If there is a truncate, leav space for the suffix
		while((truncateWidth + 14) > width && index > 0){
			truncateWidth -= Signavio.Utils.approximateWidth(text.charAt(index));
			index = index - 1;
		}
		
		if(index == text.length) {
			return text.escapeHTML();
		}

		// escape the text but not the suffix
		text = text.slice(0, index-1).escapeHTML();

		if(!Ext.isDefined(suffix)) {
			return text + suffix;
		}

		return text + "&#8230;";
	};

	Signavio.Utils.CHARACTER_SETS = [
		"%",
		"W@",
		"mwMOQÖ#+=<>~^",
		"DGCHNRUÜ&AÄ",
		"BKSVXZbdghnopquxöüETY1234567890ß_§$*´`µ€vyPaeäF",
		"{}kL?°²³cszJ",
		"\"-rt/()[]:;|\\!fI.,",
		"j ",
		"'il"
	];
	Signavio.Utils.CHARACTER_SET_VALUES = [11, 10, 8, 7, 6, 5, 4, 3, 2];
	Signavio.Utils.FONT_SIZE = 11.0;

	Signavio.Utils.approximateWidth = function(letter){
		var cs = Signavio.Utils.CHARACTER_SETS.find(function(c) {
			return c.include(letter);
		});

		var width = 9;

		if(cs) {
			width = Signavio.Utils.CHARACTER_SET_VALUES[Signavio.Utils.CHARACTER_SETS.indexOf(cs)];
		}

		return Math.ceil(width * (Signavio.Utils.FONT_SIZE/11.0));
	};

	/**
	 * Creates and returns custom check functions for stencils.
	 * Through closures, arrays do not have to be created every
	 * time the function is called, but only once.
	 */
	Signavio.Utils.getIdentityCheckFunction = function(ns) {
		return function(elements) {
			if(!(elements instanceof Array)) {
				elements = [elements];
			}

			elements = elements.map(function(element) {
				if(!element.startsWith(ns)) {
					return ns + element;
				}

				return element;
			});

			return function(element) {
				return element && elements.include(element.getStencil().id());
			};
		};
	};

	var SEPARATOR = {
		DECIMAL: {
			en: ".",
			de: ","
		},
		GROUP: {
			en: ",",
			de: "."
		}
	};

	Signavio.Utils.getDecimalSeparator = function(locale, fallback) {
		locale = (locale || "").split("_").first();

		return SEPARATOR.DECIMAL[locale] || fallback || ".";
	};

	var toGroups = function(number, size) {
		if(!number) {
			return [];
		}

		var groupSize = number.length % size || size;
		var group = number.slice(0, groupSize);

		return [group].concat(toGroups(number.slice(groupSize), size));
	};

	if(!Number.prototype.toLocaleGroup) {
		Number.prototype.toLocaleGroup = function(locale) {
			var negative = "";

			if(this < 0) {
				negative = "-";
			}

			if(this < 1 && this > -1) {
				return negative + "0";
			}

			var string = this.toFixed(0).toString();

			if(this <= -1) {
				// remove the dash
				string = string.slice(1);
			}

			var separator = SEPARATOR.GROUP[locale] || " ";
			var groupSize = 3;

			var result = toGroups(string, groupSize);

			return negative + result.join(separator);
		};
	}

	if(!Number.prototype.toLocale) {
		Number.prototype.toLocale = function(locale) {
			locale = (locale || "").split("_").first();

			var string = this.toString();
			var characteristic = this.toLocaleGroup(locale);
			var mantissa = string.split(".")[1] || "";

			var decimal = SEPARATOR.DECIMAL[locale] || ".";

			if(mantissa) {
				return characteristic + decimal + mantissa;
			}

			return characteristic;
		};
	}

	Signavio.Utils.Request = {
		execute: function(url, options) {
			options = options || {};

			options.method = options.method || "get";

			var successcallback = options.success || Ext.emptyFn;
			var failedcallback = options.error || Ext.emptyFn;

			options.params = options.params || {};
			options.params._dc = new Date().getTime();

			if(options.method.toLowerCase() === "post") {
				Ext.apply(options.params, Ext.Ajax.getSecurityParameter());
			}

			new Ajax.Request(url, {
				method      : options.method,
				parameters  : options.params,
				requestHeaders : {
					'Accept': "application/json"
				},
				asynchronous: options.async === true,
				onSuccess: function(transport){
					var json;
					try {
						json = transport.responseText.evalJSON();
					} catch(e){
						json = transport.responseText;
					}

					successcallback(json, transport);
				},
				onFailure: failedcallback,
				on409: options.on409,
				on403: options.on403
			});
		}
	};

	var MS_TO_SECOND = function(value) {
		return value / 1000;
	};

	var SECOND_TO_MS = function(value) {
		return value * 1000;
	};

	var MS_TO_MINUTE = function(value) {
		return MS_TO_SECOND(value) / 60;
	};

	var MINUTE_TO_MS = function(value) {
		return SECOND_TO_MS(value) * 60;
	};

	var MS_TO_HOUR = function(value) {
		return MS_TO_MINUTE(value) / 60;
	};

	var HOUR_TO_MS = function(value) {
		return MINUTE_TO_MS(value) * 60;
	};

	var MS_TO_DAY = function(value) {
		return MS_TO_HOUR(value) / 24;
	};

	var DAY_TO_MS = function(value) {
		return HOUR_TO_MS(value) * 24;
	};

	Signavio.Utils.MillisecondsToDays = function(ms) {
		var days = Math.floor(MS_TO_DAY(ms));

		var overflowDays = ms % DAY_TO_MS(1);

		var time = Signavio.Utils.MillisecondsToTime(overflowDays);

		return {
			days: days,
			hours: time.hours,
			minutes: time.minutes,
			seconds: time.seconds
		};
	};

	Signavio.Utils.DaysToMilliseconds = function(time) {
		if(time.split) {
			time = time.split(":");
		} else {
			time = time ? [time] : [];
		}

		var days = time[0] ? parseInt(time[0], 10) : 0;

		return DAY_TO_MS(days) + Signavio.Utils.TimeToMilliseconds(time.slice(1).join(":"));
	};

	Signavio.Utils.MillisecondsToTime = function(ms) {
		var hours = Math.floor(MS_TO_HOUR(ms));

		var overflowHours = ms % HOUR_TO_MS(1);
		var minutes = Math.floor(MS_TO_MINUTE(overflowHours));

		var overflowMinutes = ms % MINUTE_TO_MS(1);
		var seconds = Math.floor(MS_TO_SECOND(overflowMinutes));

		return {
			hours: hours < 10 ? "0" + hours : hours,
			minutes: minutes < 10 ? "0" + minutes : minutes,
			seconds: seconds < 10 ? "0" + seconds : seconds
		};
	};

	/**
	 * Converts a time string to ms.
	 * @param {String} time
	 * @param {Boolean} notNegative if true the returned value cannot be smaller than 0
	 */
	Signavio.Utils.TimeToMilliseconds = function(time, notNegative) {
		time = time ? time.split(":") : [];

		var hours = time[0] ? parseInt(time[0], 10) : 0;
		var minutes = time[1] ? parseInt(time[1], 10) : 0;
		var seconds = time[2] ? parseInt(time[2], 10): 0;
		
		if (notNegative) {
			return Math.max(HOUR_TO_MS(hours) + MINUTE_TO_MS(minutes) + SECOND_TO_MS(seconds), 0);
		}
		
		return HOUR_TO_MS(hours) + MINUTE_TO_MS(minutes) + SECOND_TO_MS(seconds);
	};

	Signavio.Utils.getLanguageDescriptor = function(rel) {
		var language = rel.split("_").first();
		var country = rel.split("_").last();

		var imageSource = Signavio.Utils.getImagePath() + "/flags/" + country + ".png";

		return "<img src='" + imageSource + "' /> "
				+ Ext.ux.getI18N('language_' + language)
				+ " (" + Ext.ux.getI18N('country_' + country) + ")";
	};

	Signavio.Utils.getApplicationLanguage = function() {
		if(window.ORYX && ORYX.I18N.Language) {
			return ORYX.I18N.Language;
		}

		if(window.Signavio && Signavio.I18N.Language) {
			return Signavio.I18N.Language;
		}

		return "";
	};

	/**
	 * Splits the text by " " and \n and adds those
	 * strings to the resulting set of the tokenization
	 * @param {String} text The text which should be tokenized
	 */
	Signavio.Utils.tokenize = function(text) {
		var token = text.split(" ");

		token = token.map(function(t, i){
			return i === 0 ? t : [" ", t];
		}).flatten();

		token = token.map(function(t){
			var tn= t.split("\n");
			return tn.map(function(tt, i){
				return i === 0 ? tt : ["\n", tt];
			}).flatten();
		}).flatten();

		return token.findAll(function(t){
			return t;
		});
	};

	Signavio.Utils.defer = function(fn, scope, timeout) {
		return window.setTimeout(function() {
			fn.apply(scope || this);
		}, timeout || 1);
	};

	Signavio.Utils.debounce = function(fn, scope, timeout) {
		var timer;

		return function() {
			if(timer) {
				window.clearTimeout(timer);
			}

			var args = arguments;

			timer = Signavio.Utils.defer(function() {
				fn.apply(scope || this, args);
			}, scope, timeout);
		};
	};

	Signavio.Utils.block = function(fn, scope) {
		var blocked = false;

		var release = function() {
			blocked = false;
		};

		return function() {
			if(blocked) {
				return;
			}

			blocked = true;

			var args = $A(arguments);

			fn.apply(scope || this, [release].concat(args));
		};
	};


	/**
	 * Returns a callback that if called runs the given defaultFn as long 
	 * as the timeout didn't happen. If a timeoutFn is given it will be
	 * called in case the timeout happens and the defaultFn wasn't already executed.
	 * Instead of a single function, defaultFn can contain an array of functions. Either
	 * one of the given functions is executed before the timeout occurs or the timeout
	 * function is executed. Be aware, that only one of the functions can be executed.
	 *
	 * @param {Function | Array} defaultFn - the function (array of functions) that shall be callable as long as the timeout didn't happen
	 * @param {Function} timeoutFn - (optional) the function that will be called when the timeout happens
	 * @param {Integer} timeout
	 * @param {Object} scope
	 */
	Signavio.Utils.timeOut = function(defaultFn, timeoutFn, timeout, scope) {
		var executed = false;
		var timer = Signavio.Utils.defer(function() {
			if (!executed) {
				executed = true;
				if (typeof timeoutFn === 'function') {
					timeoutFn.apply(scope || this);
				}
			}
		}, scope, timeout);
		if (defaultFn instanceof Array) {
			return defaultFn.map(function(fn) {
				return function() {
					if (!executed) {
						executed = true;
						window.clearTimeout(timer);
						fn.apply(scope || this, arguments);
					}
				};
			});
		} else {
			return function() {
				if (!executed) {
					executed = true;
					window.clearTimeout(timer);
					defaultFn.apply(scope || this, arguments);
				}
			};
		}
	};

	/**
	 * Strips all none letter and digits
	 * out of the string
	 *
	 * @param {String} phrase
	 * @return {String}
	 */
	Signavio.Utils.strip = function(phrase){
		return phrase.toLowerCase()
					.replace(/[^a-zäöüß0-9]/g, '')
					.replace(/ü/g, 'u')
					.replace(/ä/g, 'a')
					.replace(/ö/g, 'o');
	};

	/**
	 * Returns true if a is in b included or other way around.
	 *
	 * @param {String} a
	 * @param {String} b
	 * @return {boolean}
	 */
	Signavio.Utils.isEqualTerms = function(a, b){

		// Check if initial values are equal
		if (a && b && (a.include(b) || b.include(a))){
			return true;
		}

		// Strip
		a = this.strip(a);
		b = this.strip(b);

		// Check if included
		return a && b && (a.include(b) || b.include(a));
	};

	/**
	 * Replace all common stings from string1 with those
	 * which are in the string2
	 *
	 * @param {String} string1
	 * @param {String} string2
	 * @param {int} cursor (Optional)
	 */
	Signavio.Utils.replaceCommonSubString = function(string1, string2, cursor) {

		// If string1 and string2 includes each other after stripingv
		var s1 = this.strip(string1);
		var s2 = this.strip(string2);
		if(s1 === s2 || s2.include(s1)){
			return string2;
		}

		// Get cursor pos
		var pos = cursor === undefined ? string1.length : cursor;
		// Tokenize
		var textT = this.tokenize(string1);
		var token = string2.split(/\s+/g); // Replace all special chars and split by " "

		// Get index of the token where the cursor is
		var selectedIndex = textT.indexOf(textT.find(function(t){
			pos -= t === "\n" ? 0 : (t === " " ? 1 : t.length+1);
			return pos <= 0;
		}));

		selectedIndex = Math.max(selectedIndex , 0);
		var rounds = textT.length;
		var found = false;

		// Go from the selected index to 0 and then up from the length of the textT to the selected index, but only one round
		for (var i=selectedIndex; i != selectedIndex+1 && rounds >= 0;  i == 0 ? i = textT.length -1 : --i, --rounds ){


			// If current text phrase is empty, go furhter
			if (textT[i] == " " || textT[i] == "\n") {
				continue;
			}

			// Find the token from the suggestion
			var tok = token.find(function(t){
				return this.isEqualTerms(t, textT[i]);
			}.bind(this));

			// If there is a suggested phrases
			if (tok) {
				found = true;
				// Partition all words to word which occur before and after this word
				var front = token.slice(0, token.indexOf(tok)).reverse();
				var back = token.slice(token.indexOf(tok)+1);
				// Replace current phrase with the word
				textT[i] = tok;

				var lastKnownIndex = i;

				// Go through every word which occurs before
				for (var j=i; j>=0; --j){
					if (textT[j] == " " || textT[j] == "\n") {
						continue;
					}

					tok = front.find(function(t){
						return this.isEqualTerms(t, textT[j]);
					}.bind(this));

					if (tok) {
						var index = front.indexOf(tok);
						textT[lastKnownIndex] = front.slice(0,index).reverse().join(" ") +(index >0?" ":"")+ textT[lastKnownIndex];

						lastKnownIndex = j;
						textT[j] = tok;
						front= front.slice(index+1);
					}
				}

				if (front.length >0){
					textT[lastKnownIndex] = front.reverse().join(" ") + " " + textT[lastKnownIndex];
				}

				var lastKnownIndex = i;

				// Go through every word which occurs after
				for (var j=i; j<textT.length; j++){
					if (textT[j] == " " || textT[j] == "\n") {
						continue;
					}

					tok = back.find(function(t){
						return this.isEqualTerms(t, textT[j]);
					}.bind(this));

					if (tok) {
						var index = back.indexOf(tok);
						textT[lastKnownIndex] += (index>0?" ":"")+back.slice(0, index).join(" ");

						lastKnownIndex = j;
						textT[j] = tok;
						back = back.slice(index+1);
					}
				}

				if (back.length >0){
					textT[lastKnownIndex] += " "+back.join(" ");
				}
				break;
			}

			if (selectedIndex === 0 && textT.length === 1){
				break;
			}
		}

		var nString1 = textT.join("");

		if (nString1 == string1 && !found) {
			nString1 += (nString1.endsWith(" ") ? "" : " ") + string2;
		}
		return nString1;
	};


	/**
	 * Returns a string which is
	 * HTML unescaped.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	Signavio.Utils.unescapeHTML = function(str){

		str = str || "";

		var d = document.createElement("div");

		// IE8 does collapse all sequences of whitespaces into one single whitespace.
		// This changes the number of chars in the string, which messes up indices,
		// for instance in richtextHelper.js decode(). This workaround is from the comments in:
		// http://www.quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
		
		if (Ext.isIE8 || Ext.isIE7 || Ext.isIE6) {
			var whitespacePreservingElement = document.createElement("pre");
			d.appendChild(whitespacePreservingElement);
			whitespacePreservingElement.outerHTML = "<pre>" + str + "</pre>";
		} else {
			try {
				d.innerHTML = str;
			} catch (e){
				d.textContent = str;
			}
		}

		var nstr =  d.textContent || d.innerText || "";

		// Unescape the unecaped string till no changes are there
		return nstr && str && nstr !== str ? Signavio.Utils.unescapeHTML(nstr) : nstr;
	};

	/**
	 * Returns a string which is
	 * HTML escaped.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	Signavio.Utils.escapeHTML = function(str){

		str = String(str || "").replace(/</g, '&lt;');

		var d = document.createElement("div");
		try {
			d.innerHTML = str;
		} catch (e){
			if (!!str.match(/&[aAoOuU]uml;/g)||!!str.match(/&szlig;/g)){
				$H({
					"ä" : "&auml;",
					"Ä" : "&Auml;",
					"ö" : "&ouml;",
					"Ö" : "&Ouml;",
					"ü" : "&uuml;",
					"Ü" : "&Uuml;",
					"ß" : "&szlig;"
				}).each(function(map){
					str = str.gsub(map.value, map.key);
				});
			}
			try {
				d.innerHTML = str;
			} catch (ee) {
			   d.textContent = str;
			}
		}
		return d.innerHTML;
	};

	/**
	 * Evaluates a given string if it matches a local url (e.g. C:/... or //...)
	 * @returns with file prefix
	 */
	Signavio.Utils.evaluateLocalURL = function(value) {
		// Replace '/' to '\'
		value = (value||"").replace(/\\/g, "/");

		// FIND: C:...
		if (value.match(/^[A-Z]:[\/\\]/i)){
			value = "file:///" + value.replace(/^[A-Z]:/i, function(r){ return r.toUpperCase(); });

		// FIND: //...
		} else if (value.match(/^\/\/[^\/]/)){
			value = "file://///" + value.slice(2);
		}
		return value;
	};

	/**
	 * Return the value in the record
	 * for a given query.
	 * @param {Object} record Record
	 * @param {Object} query Query to extract the value (e.g. "rep.title")
	 */
	if (Ext.data) {
		Signavio.Utils.extractValue = function(record, query){
			if( !record || !query ){
				return null;
			}

			// Split data field
			var o = query.split(".");

			// Get value
			var val = record instanceof Ext.data.Record ? record.get(o[0]) : record[o[0]];
			var i	= 0;

			// Iterate over value since there is no
			// value of the end is reached
			while( val && ++i < o.length ){
				val = val[o[i]];
			}

			return typeof val == "string" ? val.unescapeHTML() : val;
		};
	}


	/**
	 * Beautifies the given file size to Byte/KB/MB
	 * @params {Integer} size The size of the file in Bytes
	 * @returns {String}
	 */
	Signavio.Utils.BeautifySize = function(size) {
		if (size === undefined) return "";

		if ("number" !== typeof size) {
			size = Number(size);
			// If 0 or NaN
			if (!size) return "0 KB";
		}
		if (size < 1024) {
			return size + " Byte";
		} else if (size < Math.pow(1024,2)) {
			return Math.round(size * 10 / 1024) / 10 + " KB";
		} else {
			return Math.round(size * 10 / Math.pow(1024,2)) / 10 + " MB";
		}
	};

	/**
	 * Parses a Date from the date parameter and returns a pretty printable String.
	 *
	 * @param  {Date|String} dateMillis The date to pring
	 * @return {String}      Pretty printable date string
	 */
	Signavio.Utils.printDate = function(dateMillis) {
		var printDate = '', millis = dateMillis, date;

		if(typeof dateMillis === 'string') {
			dateMillis = parseInt(dateMillis, 10);
		}

		if(!isNaN(dateMillis)) {
			date = new Date(dateMillis);
			printDate = date.format(Signavio.Const.DATE_FORMAT);
		}

		return printDate;
	};

	/**
	 * Checks whether the given date is today.
	 *
	 * @param {Date} the date object to check
	 * @return {Boolean} true if the date is todat
	 */
	Signavio.Utils.isToday = function(date) {
		if (date && date instanceof Date) {
			var today = new Date();
			return date.getYear() === today.getYear() &&
				date.getMonth() === today.getMonth() &&
				date.getDate() === today.getDate();
		}
		return false;
	};

	/**
	 * Parse a date form date parameter and return a date string depends on current language
	 * @param  {[type]} date [description]
	 * @return {[type]}      [description]
	 */
	Signavio.Utils.formatDateByCurrentLanguage = function(date) {
		
		var datetime = (date && new Date(date)) || new Date(); 

		// get language depended template
		var dateTemplate = new Ext.XTemplate(Ext.ux.getI18N("langDatetime"));

		var year = datetime.getFullYear();
		var month = datetime.getMonth();
		var dayWeek = datetime.getDay();
		var dayMonth = datetime.getDate();
		var month = datetime.getMonth();
		var hours   = datetime.getHours();
		var minutes = datetime.getMinutes();
		var seconds = datetime.getSeconds();

		if (minutes <= 9) { minutes = "0" + minutes; }
		if (seconds <= 9) { seconds = "0" + seconds; }

		var tempObject = {
			hours: hours,
			minutes : minutes,
			seconds: seconds,
			weekday: Ext.ux.getI18N("day" + dayWeek),
			day: dayMonth,
			monthname: Ext.ux.getI18N("month" + (month + 1)),
			year: year		
		};

		var templateValue = dateTemplate.apply(tempObject);

		return templateValue;
	};

	Signavio.Utils.formatShortDateByCurrentLanguage = function(date) {


		var datetime = (date && new Date(date)) || new Date(); 

		// get language depended template
		var dateTemplate = new Ext.XTemplate(Ext.ux.getI18N("langshortdatetime"));

		var year = datetime.getFullYear();
		var month = datetime.getMonth() + 1;
		var dayMonth = datetime.getDate();

		if (month <= 9) { month = "0" + month; }
		if (dayMonth <= 9) { dayMonth = "0" + dayMonth; }

		var tempObject = {
			day: dayMonth,
			month: month,
			year: year
		};

		return dateTemplate.apply(tempObject);
	};

	/**
	 * Closure for business object sorting functions
	 */
	(function() {

		var sort = function(a, b, bottomUp) {
			if (!a || !b){
				return 0;
			}

			/**
			 * Fix for using the sorting function with things
			 */
			var get = function(x) {
				return this[x];
			};

			a.get = a.get || get;
			b.get = b.get || get;

			try {
				// Get the type
				var relA = a.get("rel").toLowerCase();
				var relB = b.get("rel").toLowerCase();

				// Mapping
				relA = ["ext", "att"].include(relA) ? "file" : relA;
				relB = ["ext", "att"].include(relB) ? "file" : relB;

				// If there are the same type
				if (relA == relB) {

					if (relA == "dir" && a.get("rep").type == "public"){ return -1; }
					if (relB == "dir" && b.get("rep").type == "public"){ return 1;  }

					var tA = (a.get("rep").name||a.get("rep").title||a.get("rep").username||-a.get("rep").rev||a.get("rep").label||a.get("rep").url||"");
					var tB = (b.get("rep").name||b.get("rep").title||b.get("rep").username||-b.get("rep").rev||b.get("rep").label||b.get("rep").url||"");

					// Return the sorting of the name values
					if ("string" == typeof tA && "string" == typeof tB){
						return Signavio.Utils.AlphaNumericComparator(tA, tB);
					}

					return (tA < tB ? -1 : (tA > tB ? 1 : 0));

				// Otherwise return the sorting of the type
				}

				// if bottomUp: mod > file > dir
				if (!!bottomUp){
					relA = relA == "mod" ? "a" : relA == "file" ? "b" : "c"+relA;
					relB = relB == "mod" ? "a" : relB == "file" ? "b" : "c"+relB;
				}
				// If not bottomUp: dir > mod > file
				else {
					relA = relA == "dir" ? "a" : relA == "mod" ? "b" : "c"+relA;
					relB = relB == "dir" ? "a" : relB == "mod" ? "b" : "c"+relB;
				}

				return (relA < relB ? -1 : (relA > relB ? 1 : 0));

			// ON Exception, do nothing
			} catch(e){
				return 0;
			}
		};

		/**
		 * Comparator between two strings
		 * It goes throught the string and creates groups of digits and groups of other strings.
		 * It than goes to this groups and compares the first discrepancy. For groups of digits
		 * a parseInt function get called previously.
		 * @param {string} a
		 * @param {string} b
		 * @return {number} -1,0,1
		 */
		Signavio.Utils.AlphaNumericComparator = function(a, b){

			a = String(a).toLowerCase().gsub("ä", "ae").gsub("ö", "oe").gsub("ü", "ue").replace(/([ ][ ]*)/g, " ").trim();
			b = String(b).toLowerCase().gsub("ä", "ae").gsub("ö", "oe").gsub("ü", "ue").replace(/([ ][ ]*)/g, " ").trim();

			// Get groups of digits and none digits
			var as = a.match(/([0-9]+|[^0-9]+)/g),
				bs = b.match(/([0-9]+|[^0-9]+)/g), ca, cb;

			// Compare each group with each other
			while((ca = as.shift()) && (cb = bs.shift())){
				// Parse int if the group only contains digits
				if (ca.match(/^([0-9]+)$/)) ca = Number(ca);
				if (cb.match(/^([0-9]+)$/)) cb = Number(cb);

				// If the values are diffent
				if (ca !== cb){

					// If the type of the values are different...
					if (typeof ca !== typeof cb){
						// ...sort numbers higher than strings
						return "number" == typeof ca ? -1 : 1;
					}

					// ...otherway, compare each values with each other
					return (ca < cb ? -1 : (ca > cb ? 1 : 0));
				}
			}

			// If one group has less different values than the other, sort them higher.
			return "undefined" == typeof ca && "undefined" == typeof cb ?
						  0
						:("undefined" == typeof ca ?
							  -1
							:("undefined" == typeof cb ?
									  1
									: 0));
		};


		/**
		 * Sorting function to sort folders, models and files in the correct way
		 * @param {Object} a
		 * @param {Object} b
		 * @return {int} Returns
		 */
		Signavio.Utils.BusinessObjectSortingFunction = function(a, b) {

			return sort(a,b, false);

		};

		/**
		 * Sorting function to sort folders, models and files bottom up
		 * @param {Object} a
		 * @param {Object} b
		 * @return {int} Returns
		 */
		Signavio.Utils.BottomUpBusinessObjectSortingFunction = function(a, b) {

			return sort(a,b, true);
		};
	}());

	(function() {
		/**
		 * Sets of characters with common width
		 */
		var _characterSets=[
			"%W",
			"@",
			"m",
			"wDGMOQÖ#+=<>~^",
			"ABCHKNRSUVXZÜÄ&",
			"bdghnopquxöüETY1234567890ß_§${}*´`µ€",
			"aeksvyzäFLP?°²³",
			"c-",
			"rtJ\"/()[]:;!|\\",
			"fjI., ",
			"'",
			"il"
			];
		/**
		 * The width of the characters in the _characterSets
		 */
		var _characterSetValues=[15,14,13,11,10,9,8,7,6,5,4,3];

		/**
		 * Calculates the width of a given character in font size 14
		 * @param character
		 * @returns
		 */
		var _estimateCharacterWidth = function(character) {

			for(var i = 0; i < _characterSets.length; i++) {
				if(_characterSets[i].indexOf(character) >= 0) {
					return _characterSetValues[i];
				}
			}
			return 9;
		};

		/**
		 * Returns the estimated text width of the given string for the given font size (default to size 14).
		 * @param {String} text
		 * @param {Number} fontSize
		 * @param {Boolean} round True to return an integer
		 */
		Signavio.Utils.estimateTextWidth = function(text, fontSize, round) {
			if (!text) { return 0; }

			var sum = 0.0;
			for(var i = 0; i < text.length; ++i) {
				sum += _estimateCharacterWidth(text.charAt(i));
			}

			sum = sum*((fontSize || 14) / 14.0);
			return round ? Math.round(sum) : sum;
		};

		/**
		 * Truncates the given text to the desired width and appends '...'.
		 * @param {String} text
		 * @param {Number} width
		 * @param {Number} fontSize The font size of the given next, default is 14.
		 */
		Signavio.Utils.truncateTextToWidth = function(text, width, fontSize) {
			if (!text || "string" !== typeof text) { return ""; }

			var sum = 0.0;
			var result = "";
			var wasTruncated = $A(text).any(function(char, i) {
				if (sum > width) { 
					return true; 
				}

				// sum up the character widths
				sum += _estimateCharacterWidth(text[i]) * ((fontSize || 14) / 14.0);
				result += char;
			});

			return (wasTruncated ? result + "..." : result);
		};

	}());


	/**
	 * Returns the width of HTML Element specified via selector
	 * @param {String} selector The HTML selector string (#string for id, .string for class, etc)
	 * @param {margins} Set true to include the margins
	 * @returns {Number}
	 */
	Signavio.Utils.getElementWidth = function(selector, margins) {
		var $el = Ext.DomQuery.select(selector||"")[0];
		if (!$el) { return 0; }
		// Use the sum function to prevent NaN
		return [$el.width||$el.clientWidth].concat(margins ? [$el.offsetLeft, $el.offsetRight] : []).sum();
	},


	/**
	 * Returns an icon for a given record or extension/file type name/namespace.
	 * @param {Object|String} arg Either an Object with rel, href, rep; a String or a record
	 * @param {Boolean} onlyIconName If true, only the name of the icon is returned, e.g. for use of css classes
	 * @param {String} format can be 12x12, 16x16 or 52x62
	 * @param {Boolean} sw Set true to get black/white images if available
	 */
	Signavio.Utils.getIcon = function(arg, onlyIconName, format, sw) {
		// If nothing is provided, link the s.gif
		if (!arg) {
			return onlyIconName && "undefined" || "/libs/ext-2.0.2/resources/images/default/s.gif";
		}

		// If the given argument is a data store record, parse the data
		if (arg.data && arg.data.rep) {
			arg = arg.data;
		}

		// Check if the given argument represents a record of a file or if it's a string
		if (["file", "mod"].include(arg.rel) || "string" == typeof (arg.extension || arg.namespace) || "string" == typeof arg) {

			// Get the extension name
			var extension = arg.rep && (arg.rep.extension || arg.rep.namespace) ||
							(arg.extension || arg.namespace) ||
							arg;

			var prefix	= "",
				suffix	= "",
				ending	= ".png",
				icon	= "";


			// The output format
			format = format || "16x16";

			// Get the path to the parent directory
			var image_path = Signavio && Signavio.Config && Signavio.Config.IMAGE_PATH || ORYX && ORYX.CONFIG && ORYX.CONFIG.IMAGE_PATH;
			if (!image_path) { return; }

			var imgBasePath = image_path;

			/** Format **/
			switch (format) {
			case "12x12":
				imgBasePath += "/signavio/12x12/";
				break;
			case "52x62":
				imgBasePath += "/signavio/52x62/";
				break;
			default:
				imgBasePath += "/famfamfam/page_white_";
			}

			// The path to the diagram icon directory
			var diagramImgBasePath = "/images/diagrams/";

			/** Files **/
			switch (extension) {
			// Pictures
			case "jpg":
			case "png":
			case "bmp":
			case "gif":
				icon = "picture";
				if (sw) icon += "_sw";
				break;
			// PDFs
			case "pdf":
				icon = "pdf";
				if (sw) icon += "_sw";
				break;
			// Archives
			case "zip":
			case "rar":
			case "war":
			case "sgx":
				icon = "zip";
				if (sw) icon += "_sw";
				break;
			// Word
			case "doc":
			case "docx":
				icon = "word";
				if (sw) icon += "_sw";
				break;
			// Excel
			case "xls":
			case "xlsx":
				icon = "excel";
				if (sw) icon += "_sw";
				break;
			// Powerpoint
			case "ppt":
			case "pptx":
				icon = "powerpoint";
				if (sw) icon += "_sw";
				break;

								/** Diagrams **/
			case "http://www.signavio.com/stencilsets/processmap#":
			case "processmap":
				imgBasePath = diagramImgBasePath;
				icon = "processmap";
				suffix = "-16x16-2";
				break;
			case "bpmn":
			case "http://b3mn.org/stencilset/bpmn2.0#":
			case "http://b3mn.org/stencilset/bpmn1.1#":
			case "http://b3mn.org/stencilset/bpmn2.0conversation#":
			case "http://b3mn.org/stencilset/bpmn2.0choreography#":
			case "http://b3mn.org/stencilset/jbpm4#":
				imgBasePath = diagramImgBasePath;
				icon = "bpmn";
				suffix = "-16x16-2";
				break;
			case "http://b3mn.org/stencilset/epc#":
			case "epc":
				imgBasePath = diagramImgBasePath;
				icon = "epc";
				suffix = "-16x16-2";
				break;
			case "http://www.signavio.com/stencilsets/organigram#":
//			case "http://b3mn.org/stencilset/UML2.2Class#":
				imgBasePath = diagramImgBasePath;
				icon = "organigram";
				suffix = "-16x16-2";
				break;

			case "dir":
				if (format == "16x16") {
					imgBasePath = image_path + "/nuvola/16x16/filesystems/";
					icon = "folder_grey";
					break;
				}
			default:
				if (extension.startsWith("http://")){ // <-- Stencilset
					imgBasePath = imgBasePath.slice(0, imgBasePath.length-1);

					if (onlyIconName) {
						icon = "empty";
					}

				} else {
					icon = "file";
					if (sw) icon += "_sw";
				}
			};

			return onlyIconName && icon || (imgBasePath + icon + suffix + ending);
		}

		/* Check if it's a model */
		/* Check if it's a directory */
		/* ... */
	};

	Signavio.Utils.urlParser = function(type, text) {

		var rules = {
			email : {
				// mail regex	  optional pre  name			  @	domain			  optional post
				// 				   |---------| |-----------------|||----------------------||--|
				regex			: /(.*[\s\n]+)?([a-z0-9\.\+\-\_]+\@[a-z0-9\-]+\.[a-z]{2,3})(.*)/i,

				// the matching function translates the url to a mailto: link
				fn				: function(full, pre, mail, post) {
					return (pre||'').escapeHTML().replace(/\"/i, '&quot;') + '<a href="mailto:' + mail + '" rel="external" target="_blank">' + mail + '</a>' + (post||'').escapeHTML().replace(/\"/i, '&quot;');
				}
			},
			localFile : {
				// matches C:\...
				regex			: /([a-z]:[\/\\][^\/\\][^\s\n<"]+)/ig,
				// the matching function translates the url to a file:/// link
				fn				: function(match){
					var url = match.replace(/\\/g, "/");
					return '<a href="file:///'+url.escapeHTML()+'" rel="external" target="_blank">'+match.escapeHTML()+'</a>';
				}
			},
			// Matches //.. but not ...://...
			networkFile	: {
				regex			: /([^\/\:])(\/\/[^\/][^\s\n<"]+)/ig,
				// the matching function translates the link to a file:/// link
				fn				: function(foo, $1, $2) {
					return $1.escapeHTML()+'<a href="file:///'+encodeURI($2.escapeHTML())+'" rel="external" target="_blank">'+$2.escapeHTML()+'</a>';
				}
			},
			// Matches enclosing text, an url with optional prefix without javascript:
			url	: {
				// url regex	  		optional pre  	optional protocol	  	base url		allowed url chars $#%+/;:=?@_-.,&	 optional post
				// 				   |----------------| |--------------------| |-------------||---------------------------------------||--|
				regex			: /([\"\']>|.*[\"\'])?([a-z0-9]+\:[\/]{0,5})?([a-z0-9\.\-]+)([a-z0-9\$\#\%\+\/\;\:\=\?\@\_\-\.\,\&]*)(.*)?/i,
				// the matching function translates the link to a real link if a protocol was found and it's not a javscript function
				fn				: function(full, pre, protocol, url, hash, post) {
					// if no protocol is set AND the url doesn't have a TLD, this might just be a normal word instead of a link
					if (!protocol && !url.match(/^[a-z0-9\-\.]+\.[a-z]{2,4}$/i)) {
						return full;
					}
					// filter out javascript:, allow the rest
					protocol = ((protocol||'').toLowerCase() !== 'javascript:' && protocol || 'http://');
					//		escape preceding text	build link	 include protocol + url																						 name w/o protocol	escape trailing text
					return (pre||'').escapeHTML().replace(/\"/i, '&quot;') + '<a href="' + protocol + url.escapeHTML() + (hash||'').escapeHTML() + '" rel="external" target="_blank">' + url.escapeHTML() + (hash||'').escapeHTML() + '</a>' + (post||'').escapeHTML().replace(/\"/i, '&quot;');
				}
			} 
		};

		// find the matching rule for the given type of link
		var rule = rules[type];
		// if a matching rule was found
		if (rule) {
			// parse the text
			return text.replace(rule.regex, rule.fn);
		}
		// return the original text if no matching rule was found
		return text;
	},

	/**
	 * Converts all links from the text into HTML links.
	 * Link patterns are: http://www.google.de or www.google.de or //internal
	 * @param {String} text
	 * @return {String}
	 */
	Signavio.Utils.convertLinks = function(text){

		// Create a node out of the text
		var create = function(text){
			var node = document.createElement("body");
			node.innerHTML = text;
			return node;
		};

		// Iterate over all child nodes and
		// call the fn for each text node
		var forEach = function(fn, node){
			if (node && node.nodeType == 1){
				$A(node.childNodes).each(forEach.bind(this, fn));
			} else if (node && node.nodeType == 3){
				fn(node);
			}
		}

		// Replace the text content with the given reg exp
		var replace = function(text){
			var content = text.nodeValue, replaced = content;

			// Matches www.google.de/something?more#does or google.de/something?more#does
			// 
			// test for <a href="google.com"> fails
			// 
			// '$1<a href="http://$2" rel="external" target="_blank">$2</a>$4'
			// 
			
			// matches mail
			if (content == replaced) {
				replaced = Signavio.Utils.urlParser('email', content);
			}

			// Matches C:\...
			if (content == replaced){
				replaced = Signavio.Utils.urlParser('localFile', content);
			}

			// Matches //.. but not ...://...
			if (content == replaced){
				replaced = Signavio.Utils.urlParser('networkFile', content);
			}

			// Matches enclosing text, an url with optional prefix without javascript:
			if (content == replaced) {
				replaced = Signavio.Utils.urlParser('url', content);
			}

			// Matches http://www.google.de/something?more#does
			// if (content == replaced){
			// 	replaced = content.replace(/([a-z]+:\/{2,5}([^\s\n<"]+))/ig, function(foo, $1, $2) {
			// 		return '<a href="'+$1.escapeHTML()+'" rel="external" target="_blank">'+$2.escapeHTML()+'</a>';
			// 	});
			// }

			// if (content == replaced){
			// 	replaced = content.replace(/(^|[\s\n<"])([a-z0-9\.]+\.[a-z]{2,3}(\/[^\s\n<"]+|))([\s\n<"]|$)/ig, function(foo, $1, $2, $3, $4){
			// 		return $1+'<a href="http://' + $2.escapeHTML() + '" rel="external" target="_blank">' + $2.escapeHTML() + '</a>';
			// 	});
			// }

			// Replace (if changed)
			if (content !== replaced){
				var node = create(replaced),
					parent = text.parentNode,
					children = $A(node.childNodes);
				children.each(function(child){
					parent.insertBefore(child, text);
				});
				parent.removeChild(text);
				children.each(function(child){
					if (child.nodeType == 3){
						replace(child);
					}
				});
			}
		}.bind(this);


		var root = create(text);
		forEach(function(node){ replace(node); }, root);
		return root.innerHTML;
	};
	
	Signavio.Utils.registerNumberFormatterFunctions = function(formatter) {
		Number.prototype.toCurrency = function() {
			return formatter.formatCurrency(this);
		};

		Number.prototype.toFormatted = function() {
			return formatter.format(this);
		};

		var decimalFn = Signavio.Utils.getDecimalSeparator;
		Signavio.Utils.getDecimalSeparator = function() {
			if (arguments.length === 0) {
				return formatter.getDecimalSeparator();
			}
			
			return decimalFn.apply(Signavio.Utils, arguments);
	};

		Signavio.Utils.getGroupSeparator = function() {
			return formatter.getGroupSeparator();
		};
	};
	
	Signavio.Utils.NumberFormatter = function(config, currency) {
		var conf = (config && typeof config === "object") ? config : {};
		this._numberFormat = conf.numberFormat || "#,##0.###";
		this._currencyFormat = conf.currencyFormat || "#,##0.00 %C";
		this._decimalSeparator = conf.decimal || ",";
		this._groupSeparator = conf.group || ".";
		
		var cur = (currency && typeof currency === "object") ? currency : {};
		this._currencyCode = cur.id || "EUR";
		this._currencySign = cur.sign || "&euro;";
	};
	
	Signavio.Utils.NumberFormatter = Ext.extend(Signavio.Utils.NumberFormatter, {
		
		getDecimalSeparator : function() {
			return this._decimalSeparator;
		},
		
		getGroupSeparator : function() {
			return this._groupSeparator;
		},
		
		formatCurrency : function(number) {
			var formatted = this._formatFn(this._currencyFormat, number, this._decimalSeparator, this._groupSeparator);
			return formatted.gsub("%C", this._currencySign);
		}, 
		
		format : function(number) {
			return this._formatFn(this._numberFormat, number, this._decimalSeparator, this._groupSeparator);
		},
		
		/**
		 * This is the internal formatting function. It uses a format string, which defines, how 
		 * the number will be formatted. The format string can contain the following symbols:
		 * . - decimal separator
		 * , - group separator
		 * # - digit
		 * 0 - digit that will be filled with a zero if not existing
		 * ; - pattern separator to divide the positive and the negative pattern
		 * Moreover, the pattern can contain any other string content. 
		 * The definition of a negative pattern is optional. If no negative pattern is defined,
		 * a leading '-' will be used to indicate negative values. Both patterns are defined in one 
		 * string, first the positive pattern and afterwards the negative one, separated by a ';'.
		 * Example: "#,##0.###;-#,##0.###"
		 * 
		 * @param {String} mask - the format string
		 * @param {Number} value - the value to be formatted
		 * @param {String} decimal - the decimal separator
		 * @param {String} group - the group separator
		 */
		_formatFn : function(mask, value, decimal, group) {
			if (!mask || isNaN(+value)) {
				return value; //return as it is.
			}
			// process only abs(), and turn on flag.
			var isNegative = value < 0 ? value = -value : 0; 
			var hasNegativeMask = false;
			// check if there is a special mask for negative values
			mask = mask.split(';');
			if (mask.length > 1 && isNegative) {
				mask = mask[1];
				hasNegativeMask = true;
			} else {
				mask = mask[0];
			}
			// remember what is wrapped around the number
			var completeMask = mask.replace(/[#,.0]+/g, '%N');
			// and remove it
			mask = mask.replace(/[^#,.0]+/g, '');
			
			// split the decimal for the format string if any.
			var mask = mask.split('.')
			// Fix the decimal first, toFixed will auto fill trailing zero.
			// toFixed(null) will create integer
			value = value.toFixed( mask[1] && mask[1].length);
			// convert number to string to trim off *all* trailing decimal zero(es)
			value = +(value) + ''; 

			// fill back any trailing zero according to format
			var iTailZero = mask[1] && mask[1].lastIndexOf('0'); //look for last zero in format
			var part = value.split('.');
			// integer will get !part[1]
			if (!part[1] || part[1] && part[1].length <= iTailZero) {
				// convert to number and then fix size of tail again
				value = (+value).toFixed( iTailZero + 1);
			}
			// look for group separator
			var groups = mask[0].split(',');
			// join back without separator for counting the pos of any leading 0.
			mask[0] = groups.join(''); 

			// check how many leading zeroes there shall be
			var iFrontZero = mask[0] && mask[0].indexOf('0');
			if (iFrontZero > -1 ) {
				while (part[0].length < (mask[0].length - iFrontZero)) {
					// add missing zero to the front
					part[0] = '0' + part[0];
				}
			} else if (+part[0] == 0) {
				part[0] = '';
			}
			
			value = value.split('.');
			value[0] = part[0];
			
			// process the first group separator from decimal (.) only, the rest ignore.
			// get the length of the last slice of split result.
			var iSep = ( groups[1] && groups[groups.length - 1].length);
			if (iSep) {
				// found a group separator
				var integer = value[0];
				var str = '';
				var offset = integer.length % iSep;
				for (var i = 0, l = integer.length; i < l; i++) { 
					// ie6 only support charAt for sz.
					str += integer.charAt(i); 
					// check if a group separator needs to be added
					// calculate -iSep so that the separator isn't added to the end
					if (!((i - offset + 1) % iSep) && i < l - iSep) {
						str += group;
					}
				}
				value[0] = str;
			}
			// just add the fraction if it is demanded
			value[1] = (mask[1] && value[1]) ? decimal + value[1] : "";
			// check negation
			if (isNegative && !hasNegativeMask) {
				// a normal negative value, just add the leading '-'
				value = '-' + value[0] + value[1];
			} else {
				// the value is positive or has a special mask for negative values
				value = value[0] + value[1]; 
			}
			// fill the formatted value back in the complete mask
			return completeMask.gsub('%N', value);
		}
	});
	
	/**
	 * Generates a UUID based on (pseudo) random numbers as defined in RFC 4122.
	 * 
	 * @param {Boolean} useHyphens - indicates whether the generated UUID should contain hyphens
	 * @param {Boolean} omitPrefix - indicates whether the generated UUID should omit the pref "sid-"
	 */
	Signavio.Utils.generateUUID = function(useHyphens, omitPrefix) {
		// http://www.ietf.org/rfc/rfc4122.txt
		var s = [];
		var hexDigits = "0123456789abcdef";
		for (var i = 0; i < 36; i++) {
			s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
		}
		s[14] = "4";  // bits 12-15 of the time_hi_and_version field to 0010
		s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01
		s[8] = s[13] = s[18] = s[23] = !!useHyphens ? "-" : "";
		var uuid = s.join("");
			
		return !!omitPrefix ? uuid : "sid-" + uuid;
	};
	
	/**
	 * Calculates the perceived brightness of a color.
	 * 
	 * @param color
	 * @returns a value between 0 (black) and 255 (white) indicating the brightness
	 */
	Signavio.Utils.getPerceivedBrightness = function(color) {
		var hexColor = color.gsub("#", "");
		var r, g, b;
		if (hexColor.length === 3) {
			r = parseInt(hexColor[0].concat(hexColor[0]), 16);
			g = parseInt(hexColor[1].concat(hexColor[1]), 16);
			b = parseInt(hexColor[2].concat(hexColor[2]), 16);
		} else if (hexColor.length === 6) {
			r = parseInt(hexColor.substring(0, 2), 16);
			g = parseInt(hexColor.substring(2, 4), 16);
			b = parseInt(hexColor.substring(4, 6), 16);
		} else {
			// default value, just assume it's black
			return 0;
		}
		// this is a weighted formula following the example here:
		// http://www.nbdtech.com/Blog/archive/2008/04/27/Calculating-the-Perceived-Brightness-of-a-Color.aspx			
		return Math.round(Math.sqrt((r * r * 0.241) + (g * g * 0.691) + (b * b * 0.068)));
	};
	
	/**
	 * Splits a String into several parts
	 * Returns an object with "context", "identifier", "extension", and "param" as attributes 
	 * @param {String} url String
	 * @return Returns an object
	 */
	Signavio.Utils.splitURL = function(url) {
		var PATTERN = new RegExp("(" + Signavio.Config.BACKEND_PATH + "/p/)?([^/]+)(/([^/]+))?(/([^/]+))?(/+(.*))?$");

		if( !url || !(url.startsWith("/")) ){
			throw "Signavio.Utils.splitURL needs a relative url starting with a /."
		}
		
		var match = url.match(PATTERN);
		o = {};

		o.context = match[2];
		o.identifier = match[4];
		o.extension = match[6];
		o.param = match[8];
		
		return o;
	};
	
	/**
	 * Gives the "rel"-string of the "interesting" items in a given store,
	 * found out by looking at the store's URL
	 */
	Signavio.Utils.getRelForStore = function(store) {
		/*
		 *  The part of a store-URL specifiying
		 * 	the context. Usually, the part between the first two slashes
		 *  in a URL like "/model/2fe45c29762f4a9b89bcfc120935e8b8"
		 */
		var storeContext = Signavio.Utils.splitURL(store.getIdentifier()).context;

		switch(storeContext) {
			case "model":
				return Signavio.Const.REL.MODEL;
			case "directory":
			case "directoryall":
				return Signavio.Const.REL.DIRECTORY;
			case "glossary":
			case "glossarymanager":
				return Signavio.Const.REL.GLOSSARY;
			case "file":
				return Signavio.Const.REL.FILE;
			case "glossarycategory":
				return Signavio.Const.REL.CATEGORY;
		}
	};

	/**
	 * Opens a new window and adds a form with the given configuration.
	 * Possible configuration parameters are:
	 * 		action : the form action
	 *		method : the form method (default: POST)
	 * 		authenticated : a hidden field with the signavio-id will be added
	 * 		values : an object with key value pairs which will be added as hidden fields
	 * @param {Object} config the form configuration
	 */
	Signavio.Utils.submitFormInNewWindow = function(config) {
		config = Ext.apply({
			method 			: 'POST',
			values 			: {},
			action 			: '',
			authenticated 	: false
		}, config);
		var fields = '';
		Object.keys(config.values).each(function(key) {
			fields = fields.concat('<input type="hidden" name="' + key + '" value="' + config.values[key] + '"/>');
		});
		if (config.authenticated) {
			fields = fields.concat('<input type="hidden" name="signavio-id", value="' + Ext.Ajax.getSecurityToken() + '"/>');
		}
		var win = window.open('');
        win.document.write([
            '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ',
            '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
            '<html xmlns="http://www.w3.org/1999/xhtml">',
                '<head></head>',
                '<body>',
                    '<form id="form" method="',
                    config.method,
                    '" action="',
                    config.action,
                    '">',
                        fields,
                    '</form>',
                '</body>',
            '</html>'
        ].join(''));
        win.document.close();
        win.document.getElementById('form').submit();
	};

	if ('undefined' !== typeof module) {
		module.exports = Signavio.Utils;
	}
}(window, window.Signavio, Ext || {}));
/**
 * Copyright (c) 2012
 * Lukas Brand
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

/**
 * Define namespaces
 */
if (!window.Ext) { window.Ext = {}; }
if (!Ext.ux) { Ext.ux = {}; }

(function() {
	Ext.ux.Window = function(options) {
		
		options = options||{};
		
		var title = options.frameTitle;
		
		/************ OPTIONS FOR THE WINDOW *****************/
		options.height		= options.height 		|| "auto";
		options.width		= options.width 		|| "auto";
		options.title		= options.title			|| "";
		options.description	= options.description	|| "";
		options.bodyStyle	= options.bodyStyle		|| "padding:10px;background:white;";
		options.layout		= options.layout		|| "anchor";
		options.cls			= "x-ux-window " + ("string" === typeof options.cls ? options.cls : "");

		if(options.useFrame) {
			options.cls += " y-wizard";
		}

		options.minButtonWidth = options.minButtonWidth || 75;
		
		options.cancelButton= options.cancelButton	|| {}; 
		options.noLinkButton= options.noLinkButton	|| false;
		options.hideCancelButton = options.hideCancelButton || false;
		options.cancelText = options.cancelText  || Ext.MessageBox.buttonText.cancel;
		
		var cancelButtonCfg = {
			text 	: options.cancelText,
			cls 	: "x-button-plain",
			handler : function(){								
				// Close the Window
				if (options.closeAction === "hide") {
					this.hide();
				} else {	
					this.close();
				}
			}.bind(this)
		};
		
		var cancelButton;
		// If the noLinkButton flag is not set, display the cancel button as a link
		if (!options.noLinkButton) {
			cancelButton = new Signavio.ux.dialog.Link(cancelButtonCfg);
		} else {
			cancelButton = new Ext.Button(cancelButtonCfg);
		}

		// If a cancel button is provided, it gets enhanced to be a link button
		if (options.cancelButton) {
			cancelButtonCfg = Ext.apply(cancelButtonCfg, options.cancelButton);
		}
		
		// Prepend the cancel button
		if (!options.hideCancelButton) {
			options.buttons = [].concat(cancelButton).concat(options.buttons||[]);
		}

		//	THE ITEMS FOR THE WINDOW ITSELF
		options.items 		= [].concat(
		//	ADD THE WINDOW DESCRIPTION
			(options.description ?
					new Ext.form.Label({
						style	: "background:white;display:block;" + options.useFrame ? "margin-top:0;" : "",
						html	: options.description
					}) : [])
		)
		// ADD THE CONTENT FRAME
		.concat(
			(!options.useFrame ? (options.items||[new Ext.form.Label()]) :
				new Ext.ux.view.OptionsContainer({
					title		: title,
					autoHeight	: true,
					desc		: options.frameDescription,
					style		: "margin: 10px 0 0 0",
					bodyStyle	: "padding: 0",
					items		: options.items
				}))
		);
		
		var listeners = Object.clone(options.listeners);
		
		options.listeners = Ext.apply({}, {
			show	: function() {
				this.syncSize();
				if (listeners && "function" == typeof listeners.show){
					listeners.show.apply(this, arguments);
				}
			},
			specialkey : function(e) {
				if (e.getKey() === e.ESC) {
					if (options.onEsc instanceof Function) {
						options.onEsc();
					} else {
						this.handler.apply(this, arguments);
						e.stopEvent();	
					}
				}
			}
		}, listeners);
		
		Ext.ux.Window.superclass.constructor.call(this, options);
	};
	
	Ext.extend(Ext.ux.Window, Ext.Window, {
		
	});
}());
if(!window.Signavio) { var Signavio = {}; }
if(!Signavio.Config) { Signavio.Config = {}; }

(function() {

    Signavio.Config.BACKEND_PATH = '../p';
    Signavio.Config.STENCILSET_URI = Signavio.Config.BACKEND_PATH + "/editor_stencilset";
    Signavio.Config.IMAGE_PATH = '/images';

    Signavio.Config.KEY_CODE_X = 88;
    Signavio.Config.KEY_CODE_C = 67;
    Signavio.Config.KEY_CODE_V = 86;
    Signavio.Config.KEY_CODE_DELETE = 46;
    Signavio.Config.KEY_CODE_META = 224;
    Signavio.Config.KEY_CODE_BACKSPACE = 8;
    Signavio.Config.KEY_CODE_LEFT = 37;
    Signavio.Config.KEY_CODE_RIGHT = 39;
    Signavio.Config.KEY_CODE_UP = 38;
    Signavio.Config.KEY_CODE_DOWN = 40;

    Signavio.Config.META_KEY_META_CTRL = "metactrl";
    Signavio.Config.META_KEY_ALT = "alt";
    Signavio.Config.META_KEY_SHIFT = "shift";

    Signavio.Config.KEY_ACTION_DOWN = "down";
    Signavio.Config.KEY_ACTION_UP = "up";

    Signavio.Config.EVENT_MOUSEDOWN = "mousedown";
    Signavio.Config.EVENT_MOUSEUP = "mouseup";
    Signavio.Config.EVENT_MOUSEOVER = "mouseover";
    Signavio.Config.EVENT_MOUSEOUT = "mouseout";
    Signavio.Config.EVENT_MOUSEMOVE = "mousemove";
    Signavio.Config.EVENT_DBLCLICK = "dblclick";
    Signavio.Config.EVENT_KEYDOWN = "keydown";
    Signavio.Config.EVENT_KEYUP = "keyup";

    Signavio.Config.TYPE_STRING = "string";
    Signavio.Config.TYPE_BOOLEAN = "boolean";
    Signavio.Config.TYPE_INTEGER = "integer";
    Signavio.Config.TYPE_FLOAT = "float";
    Signavio.Config.TYPE_COLOR = "color";
    Signavio.Config.TYPE_DATE = "date";
    Signavio.Config.TYPE_CHOICE = "choice";
    Signavio.Config.TYPE_URL = "url";
    Signavio.Config.TYPE_DIAGRAM_LINK = "diagramlink";
    Signavio.Config.TYPE_COMPLEX = "complex";
    Signavio.Config.TYPE_TEXT = "text";
    Signavio.Config.TYPE_EPC_FREQ = "epcfrequency";
    Signavio.Config.TYPE_GLOSSARY_LINK = "glossarylink";
    Signavio.Config.TYPE_RADIOBUTTON = "radiobutton";
    Signavio.Config.TYPE_IKS = "metadataiks";

    Signavio.Config.COMPONENT_SPACING = 10;

    // Deprecated
    Signavio.Config.SPREADSHEET_LICENSE = "quickmodel";

    // Active licenses
    Signavio.Config.TRIAL_LICENSE   = "trial";
    Signavio.Config.QUICKMODEL_LICENSE = Signavio.Config.SPREADSHEET_LICENSE;
    Signavio.Config.TEAM_LICENSE    = "team";
    Signavio.Config.PREMIUM_LICENSE = "premium";
    Signavio.Config.GUEST_LICENSE = "guest";

    Signavio.Config.PROFESSIONAL_LICENSE = "professional";
    Signavio.Config.CORPORATE_LICENSE = "corporate";
    Signavio.Config.ULTIMATE_LICENSE = "ultimate";
    Signavio.Config.API_ACCESS_LICENSE = "apiaccess";
    Signavio.Config.ARCHIMATE = "archimate";

    Signavio.Config.MAIN_LICENSES = [
        Signavio.Config.ULTIMATE_LICENSE,
        Signavio.Config.CORPORATE_LICENSE,
        Signavio.Config.PROFESSIONAL_LICENSE,
        Signavio.Config.QUICKMODEL_LICENSE,
        Signavio.Config.PREMIUM_LICENSE,
        Signavio.Config.GUEST_LICENSE,
        Signavio.Config.TEAM_LICENSE,
        Signavio.Config.API_ACCESS_LICENSE,
        Signavio.Config.ARCHIMATE
    ];

    // List of licenses which are the main ones. The sorting of the array will also be used for prioritizing.
    Signavio.Config.ALL_LICENSES = [Signavio.Config.TRIAL_LICENSE].concat(Signavio.Config.MAIN_LICENSES);

    //List of licenses to be ignored in purchase and in invitation dialog by default
    Signavio.Config.DEPRECATED_LICENSES = [
        Signavio.Config.PREMIUM_LICENSE,
        Signavio.Config.TEAM_LICENSE,
        Signavio.Config.ARCHIMATE
    ];

    // Define propety ids and types in lower case
    Signavio.Config.HIDDEN_PROPERTIES = [];
    Signavio.Config.HIDDEN_PROPERTY_TYPES = [Signavio.Config.TYPE_IKS];

    Signavio.Const = Signavio.Const || {};
    Signavio.Const.EVENT = Signavio.Const.EVENT || {};

    Signavio.Const.REL = Signavio.Const.REL || {};
    /**
     * Define the rel tag posible values
     * @final
     */
    Signavio.Const.REL.DIRECTORY    = 'dir';
    Signavio.Const.REL.MODEL        = 'mod';
    Signavio.Const.REL.INFO         = 'info';
    Signavio.Const.REL.USER         = 'user';
    Signavio.Const.REL.ORDER        = 'order';
    Signavio.Const.REL.PURL         = 'purl';
    Signavio.Const.REL.NOTIFY       = 'notify';
    Signavio.Const.REL.SUBSCRIPTION = 'subscription';
    Signavio.Const.REL.PRIVILEGE    = 'priv';
    Signavio.Const.REL.GROUP        = 'group';
    Signavio.Const.REL.CHILD_GROUP  = 'cgroup';
    Signavio.Const.REL.GLOSSARY     = 'glos';
    Signavio.Const.REL.INVITATION   = 'invitation';
    Signavio.Const.REL.VIEWS        = 'views';
    Signavio.Const.REL.FILE         = 'file';
    Signavio.Const.REL.REVISION     = 'revision';
    Signavio.Const.REL.CATEGORY		= 'cat';

    Signavio.Const.EVENT.OPEN_FILE_UPLOAD = "open.file.upload";
    Signavio.Const.EVENT.NEW_FILE_UPLOAD = "new.file.upload";
    Signavio.Const.EVENT.CANCEL_FILE_UPLOAD = "cancel.file.upload";

    Signavio.Const.THUMBNAIL        = '/thumbnail';

    Signavio.Config.Events = Signavio.Config.Events || {};

    Signavio.Config.registerEvents = function(key, events) {
        if(!key) {
            return;
        }

        events = events || {};

        if(!Signavio.Config.Events[key]) {
            Signavio.Config.Events[key] = {};
        }
        
        if(Hash.prototype.toObject) {
            Signavio.Config.Events[key] = $H(Signavio.Config.Events[key]).merge(events).toObject();
        } else {
            Signavio.Config.Events[key] = $H(Signavio.Config.Events[key]).merge(events);
        }
    };
    
    Signavio.Config.GROWING_TEXT_AREA = {
    		HORIZONTAL_PADDING 	: 15,
    		VERTICAL_PADDING	: 10,
    		GROW_APPEND 		: '&#160;',
    		GROW_MAX 			: 1000,
    		DEFAULT_TEXTAREA_WIDTH : 90,
    		GROW_MIN			: 10,
    		GROW_MIN_HORIZONTAL	: 90
    };
    
    Signavio.Const.Template = Signavio.Const.Template || {};
    Signavio.Const.Template.HIDE_ATTR_NONE = "HideNone";
    Signavio.Const.Template.HIDE_ATTR_EMPTY = "HideEmpty";
    Signavio.Const.Template.HIDE_ATTR_DEFAULT = "HideDefault";

}());
/**
* Copyright by Fabian Dill, 2010
* Licensed under the MIT License (http://www.opensource.org/licenses/mit-license.php).
* 
* This script was written by Fabian Dill and published
* at http://informationandvisualization.de
* 
* If you use it, it would be nice if you link to our page
* and/or drop us a line where you use it (for our interest only).
* to fabian.dill(at)googlemail.com
*/
var lowerWhisker;
var q1;
var median;
var q3;
var upperWhisker;
var mildOutliers;
var extremeOutliers;
var min;
var max;

function sortNumber(a, b) {
	return a - b;
}

// map the values onto a scale of fixed height
function mapValue(v, height) {
	return Math.round(height - (((v - min) / (max - min)) * height));
}

function calculateValues(data) {
	data.sort(sortNumber);
	var n = data.length;
	// lower quartile
	var q1Pos = (n * 0.25);
	if (q1Pos % 1 != 0) {
	    q1Pos = Math.floor(q1Pos);
	    q1 = data[q1Pos];
	} else {
	    q1Pos = Math.floor(q1Pos);
	    q1 = (data[q1Pos] + data[q1Pos-1]) / 2;
	}
	// median
	var medianPos = (n * 0.5);
	if (medianPos % 1 != 0) {
	    medianPos = Math.floor(medianPos);
	    median = data[medianPos];
	} else {
	    medianPos = Math.floor(medianPos);
	    median = (data[medianPos] + data[medianPos-1]) / 2;
	}
	// upper quartile
	var q3Pos = (n * 0.75);
	if (q3Pos % 1 != 0) {
	    q3Pos = Math.floor(q3Pos);
	    q3 = data[q3Pos];
	} else {
	    q3Pos = Math.floor(q3Pos);
	    q3 = (data[q3Pos] + data[q3Pos-1]) / 2;
	}	
	min = data[0];
	max = data[n - 1];
	
	var iqr = q3 - q1;
	mildOutliers = new Array();
	extremeOutliers = new Array();
	lowerWhisker = min;
	upperWhisker = max;
	if (min < (q1 - 1.5 * iqr)) {
		for (var i = 0; i < q1Pos; i++) {
			// we have to detect outliers
			if (data[i] < (q1 - 3 * iqr)) {
				extremeOutliers.push(data[i]);
			} else if (data[i] < (q1 - 1.5 * iqr)) {
				mildOutliers.push(data[i]);
			} else if (data[i] >= (q1 - 1.5 * iqr)) {
				lowerWhisker = data [i];
				break;
			}
		}
	}
	if (max > (q3 + (1.5 * iqr))) {
		for (i = q3Pos; i < data.length; i++) {
			// we have to detect outliers
			if (data[i] > (q3 + 3 * iqr)) {
				extremeOutliers.push(data[i]);
			} else if (data[i] > (q3 + 1.5 * iqr)) {
				mildOutliers.push(data[i]);
			} else if (data[i] <= (q3 + 1.5 * iqr)) {
				upperWhisker = data[i];
			}
		}
	}
}

function roundVal(val){
	var dec = 2;
	var result = Math.round(val*Math.pow(10,dec))/Math.pow(10,dec);
	return result;
}

function createBoxPlot(dataArray, height, divID) {
	calculateValues(dataArray);
	var overallID = divID + "overall";

	var mlowerWhisker = mapValue(lowerWhisker, height);
	var mq1 = mapValue(q1, height);
	var mmedian = mapValue(median, height);
	var mq3 = mapValue(q3, height);
	var mupperWhisker = mapValue(upperWhisker, height);
	var mmildOutliers = new Array(mildOutliers.length);
	for (i = 0; i < mildOutliers.length; i++) {
		mmildOutliers[i] = mapValue(mildOutliers[i], height);
	}
	var mextremeOutliers = extremeOutliers;
	for (i = 0; i < extremeOutliers.length; i++) {
		mextremeOutliers[i] = mapValue(extremeOutliers[i], height);
	}
  
  var overallDiv = document.createElement("div");
	overallDiv.style.height = height + "px";
	overallDiv.style.width = "56px";
	overallDiv.style.border = "none";
	overallDiv.style.borderRight = "1px dotted";
	overallDiv.id = overallID;
	document.getElementById(divID).appendChild(overallDiv);

	var upperDiv = document.createElement("div");
	upperDiv.id = "upperBox" + divID;
	upperDiv.className = "boxplot-element";
	upperDiv.style.top = mq3 + "px";
	upperDiv.style.height = (mmedian - mq3) + "px";
	document.getElementById(overallID).appendChild(upperDiv);

	var lowerDiv = document.createElement("div");
	lowerDiv.id = "lowerBox" + divID;
	lowerDiv.className = "boxplot-element";
	lowerDiv.style.top = mmedian + "px";
	lowerDiv.style.height = mq1 - mmedian + "px";
	document.getElementById(overallID).appendChild(lowerDiv);

	var lowerWhiskerDiv = document.createElement("div");
	lowerWhiskerDiv.id = "lowerWhisker" + divID;
	lowerWhiskerDiv.className = "boxplot-element";
	lowerWhiskerDiv.style.top = mlowerWhisker + "px";
	document.getElementById(overallID).appendChild(lowerWhiskerDiv);
	
	var upperWhiskerDiv = document.createElement("div");
	upperWhiskerDiv.id = "upperWhisker" + divID;
	upperWhiskerDiv.className = "boxplot-element";
	upperWhiskerDiv.style.top = mupperWhisker + "px";
	document.getElementById(overallID).appendChild(upperWhiskerDiv);

	for(i = 0; i < mildOutliers.length; i++) {
		var newDiv = document.createElement("div");
		newDiv.className = "boxplot-element";
		newDiv.style.width="4px";
		newDiv.style.height="4px";
		newDiv.style.top = mmildOutliers[i] + "px";
		newDiv.style.left= "50px";
		document.getElementById(overallID).appendChild(newDiv);
	}
	for(i = 0; i < extremeOutliers.length; i++) {
		var newDiv = document.createElement("div");
		newDiv.className = "boxplot-element";
		newDiv.style.background = "#666";
		newDiv.style.width="4px";
		newDiv.style.height="4px";
		newDiv.style.top = mextremeOutliers[i] + "px";
		newDiv.style.left= "50px";
		document.getElementById(overallID).appendChild(newDiv);
	}
	// labels
	var lowerLabel = document.createElement("div");
	lowerLabel.className = "boxplot-label";
	lowerLabel.innerHTML = "" + roundVal(lowerWhisker);
	lowerLabel.style.top = mlowerWhisker + "px";
	lowerLabel.style.left = "0px";
	document.getElementById(overallID).appendChild(lowerLabel);
	
	var q1Label = document.createElement("div");
	q1Label.className = "boxplot-label";
	q1Label.innerHTML = "" + roundVal(q1);
	q1Label.style.top = (mq1 - 9) + "px";
	q1Label.style.left = "80px";
	document.getElementById(overallID).appendChild(q1Label);
	
	var medianLabel = document.createElement("div");
	medianLabel.className = "boxplot-label";
	medianLabel.innerHTML = "" + roundVal(median);
	medianLabel.style.top = (mmedian - 9) + "px";
	medianLabel.style.left = "0px";
	document.getElementById(overallID).appendChild(medianLabel);
	
	var q3Label = document.createElement("div");
	q3Label.className = "boxplot-label";
	q3Label.innerHTML = "" + roundVal(q3);
	q3Label.style.top = (mq3 - 9) + "px";
	q3Label.style.left = "80px";
	document.getElementById(overallID).appendChild(q3Label);
	
	var upperLabel = document.createElement("div");
	upperLabel.className = "boxplot-label";
	upperLabel.innerHTML = "" + roundVal(upperWhisker);
	upperLabel.style.top = (mupperWhisker - 9) + "px";
	upperLabel.style.left = "0px";
	document.getElementById(overallID).appendChild(upperLabel);
	
	for (i = 0; i < mmildOutliers.length; i++) {
		var label = document.createElement("div");
		label.className = "boxplot-label";
		label.innerHTML = "" + roundVal(mildOutliers[i]);
		label.style.top = (mmildOutliers[i] - 9) + "px";
		if (i%2 == 0) {
			label.style.left = "10px";
		} else {
			label.style.left = "70px";
		}
		document.getElementById(overallID).appendChild(label);
	}	
}

/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.kpi){ Ext.ux.kpi = {}; }

new function() {
	
	Ext.ux.kpi.KpiPanel = Ext.extend(Ext.Panel,  {
		
		constructor: function(config, facade, panelConfig){
			this.facade = facade;
			
			//KPI configuration
			this.init();
			
			
			Ext.apply(this.conf, config, {});
			
			Ext.ux.kpi.KpiPanel.superclass.constructor.apply(this, [panelConfig||{}]);
		},
		
		/**
		 * Initial KPI configuration
		 */
		init: function() {
			this.conf = {
				name: "KPI-Name",
				unit: "",
				minVal: 0,
				maxVal: 0,
				range: 0,
				value: 0,
				badStart: 0,
				badWidth: 30,
				thresStart: 30,
				thresWidth: 30,
				goodStart: 60,
				goodWidth: 40,
				kpiMinVal: 30,
				kpiGoodVal: 50,
				kpiTargetVal: 70,
				kpiMinValPos: undefined,
				kpiGoodValPos: undefined
			};
			
			/*
			 * Forcing recreation of Element on refresh
			 */
			this.forceRecreation = false;
			
			//Container
			this.kpiTextCt = undefined;
			this.kpiCt = undefined;
			
			//Div-Boxes
			this.kpiComp = undefined; //Top-Parent container
			this.kpiBadBox = undefined;
			this.kpiThresBox = undefined;
			this.kpiGoodBox = undefined;
			this.kpiMiddleLane = undefined;
			this.kpiValueLane = undefined;
			this.kpiTargetMarker = undefined;
			this.kpiBorder = undefined;
			
			//Caption Boxes
			this.kpiName = undefined;
			this.kpiTargetValue = undefined;
			this.kpiGoodValue = undefined;
			this.kpiMinValue = undefined;
			this.kpiValue = undefined;
			
			//Values
			//Caption
			this.kpiNameText = "iniKpiName";
			this.kpiValueText = "iniKpiValue";
			this.kpiMinValueText = "iniMinValue";
			this.kpiGoodValueText = "iniGoodValue";
			this.kpiTargetValueText = "iniTargetValueText";
			
			//Box params
			this.kpiBadBoxStart = 0;
			this.kpiBadBoxWidth = 30;
			this.kpiThresBoxStart = 30;
			this.kpiThresBoxWidth = 30;
			this.kpiGoodBoxStart = 60;
			this.kpiGoodBoxWidth = 40;
			this.kpiTargetMarkerPos = 80;
			this.kpiValueLaneWidth = 50;
			
			this.kpiGoodValPos = undefined;
			this.kpiMinValPos = undefined;
			
		},
		
		_initializeElements: function()	{
			if(this.forceRecreation || !this.kpiCt) {
				this.kpiCt = new Ext.Element(document.createElement('div'));
				this.kpiCt.addClass('x-analytics-kpi-ct');
			}
			
			if(this.forceRecreation || !this.kpiTextCt) {
				this.kpiTextCt = new Ext.Element(document.createElement('div'));
				this.kpiTextCt.addClass('x-analytics-kpi-textct');
			}
			
			if(this.forceRecreation || !this.kpiComp) {
				this.kpiComp = new Ext.Element(document.createElement('div'));
				this.kpiComp.addClass('x-analytics-kpi-comp');
			}
			
			if(this.forceRecreation || !this.kpiBadBox) {
				this.kpiBadBox = new Ext.Element(document.createElement('div'));
				this.kpiBadBox.addClass('x-analytics-kpi-badbox');
			}
			
			if(this.forceRecreation || !this.kpiThresBox) {
				this.kpiThresBox = new Ext.Element(document.createElement('div'));
				this.kpiThresBox.addClass('x-analytics-kpi-thresbox');
			}
			
			if(this.forceRecreation || !this.kpiGoodBox) {
				this.kpiGoodBox = new Ext.Element(document.createElement('div'));
				this.kpiGoodBox.addClass('x-analytics-kpi-goodbox');
			}
			
			if(this.forceRecreation || !this.kpiMiddleLane) {
				this.kpiMiddleLane = new Ext.Element(document.createElement('div'));
				this.kpiMiddleLane.addClass('x-analytics-kpi-middlelane');
			}
			
			if(this.forceRecreation || !this.kpiValueLane) {
				this.kpiValueLane = new Ext.Element(document.createElement('div'));
				this.kpiValueLane.addClass('x-analytics-kpi-valuelane');
			}
			
			if(this.forceRecreation || !this.kpiTargetMarker) {
				this.kpiTargetMarker = new Ext.Element(document.createElement('div'));
				this.kpiTargetMarker.addClass('x-analytics-kpi-targetmarker');
			}
			
//			if(this.forceRecreation || !this.kpiBorder) {
//				this.kpiBorder = new Ext.Element(document.createElement('div'));
//				this.kpiBorder.addClass('x-analytics-kpi-border');
//			}
			
			
			//Caption-Fields
			if(this.forceRecreation || !this.kpiName) {
				this.kpiName = new Ext.Element(document.createElement('span'));
				this.kpiName.addClass('x-analytics-kpi-name');
			}
			
			if(this.forceRecreation || !this.kpiTargetValue) {
				this.kpiTargetValue = new Ext.Element(document.createElement('span'));
				this.kpiTargetValue.addClass('x-analytics-kpi-targetvalue');
			}
			
			if(this.forceRecreation || !this.kpiGoodValue) {
				this.kpiGoodValue = new Ext.Element(document.createElement('span'));
				this.kpiGoodValue.addClass('x-analytics-kpi-goodvalue');
			}
			
			if(this.forceRecreation || !this.kpiMinValue) {
				this.kpiMinValue = new Ext.Element(document.createElement('span'));
				this.kpiMinValue.addClass('x-analytics-kpi-minvalue');
			}
			
			if(this.forceRecreation || !this.kpiValue) {
				this.kpiValue = new Ext.Element(document.createElement('span'));
				this.kpiValue.addClass('x-analytics-kpi-value');
			}
		},	
		
		_setupHierarchy: function() {
			if(this.kpiComp.parent()) {
				return;
			}
			
			//Value progress bar
			this.kpiMiddleLane.appendChild(this.kpiValueLane);
			
			// Top parent childs
			this.kpiComp.appendChild(this.kpiBadBox);
			this.kpiComp.appendChild(this.kpiThresBox);
			this.kpiComp.appendChild(this.kpiGoodBox);
			this.kpiComp.appendChild(this.kpiMiddleLane);
//			this.kpiComp.appendChild(this.kpiBorder);
			this.kpiComp.appendChild(this.kpiTargetMarker);
			
			// Text elements
			this.kpiTextCt.appendChild(this.kpiName);
			this.kpiTextCt.appendChild(this.kpiMinValue);
			this.kpiTextCt.appendChild(this.kpiGoodValue);
			this.kpiTextCt.appendChild(this.kpiTargetValue);
			this.kpiTextCt.appendChild(this.kpiValue);
			
			this.kpiCt.appendChild(this.kpiTextCt);
			this.kpiCt.appendChild(this.kpiComp);
			
			this.body.appendChild(this.kpiCt);
		},
		
		_setText: function(el, text) {
			el.dom.innerText = text;
			el.dom.textContent = text;
		},
		
		/**
		 * Updates the KPI visualisation
		 */
		updateVis: function() {
			//VARs
			var textRelOffset = 65 / 20; // width text box and kpi box
			
			// Update Captions
			this._setText(this.kpiName, this.kpiNameText);
			this._setText(this.kpiTargetValue, this.kpiTargetValueText);
			this._setText(this.kpiGoodValue, this.kpiGoodValueText);
			this._setText(this.kpiMinValue, this.kpiMinValueText);
			this._setText(this.kpiValue, this.kpiValueText);
			
			//Adjust Element positions
			this.kpiBadBox.applyStyles({left:this.kpiBadBoxStart + "%", width:this.kpiBadBoxWidth + "%"});
			this.kpiThresBox.applyStyles({left:this.kpiThresBoxStart + "%", width:this.kpiThresBoxWidth + "%"});
			this.kpiGoodBox.applyStyles({left:this.kpiGoodBoxStart + "%", width:this.kpiGoodBoxWidth + "%"});
			
			this.kpiTargetMarker.applyStyles({left: this.kpiTargetMarkerPos + "%"});
			this.kpiValueLane.applyStyles({width: this.kpiValueLaneWidth + "%"});
			
			// Text Element Positions
			this.kpiMinValue.applyStyles({left: this.kpiMinValPos * textRelOffset + "%"});
			this.kpiGoodValue.applyStyles({left: this.kpiGoodValPos * textRelOffset + "%"});
			this.kpiTargetValue.applyStyles({left: (this.kpiTargetMarkerPos - 2) * textRelOffset + "%"});
		},
		
		updateKpiValue: function(value) {
			
			if( typeof value !== "undefined" ) {
				this.conf.value = value;
			}
			
			this.conf.range = this.conf.maxVal - this.conf.minVal;
			
			//Set Boxes
			//TODO: Calculation of box configuration
			this.kpiBadBoxStart = this.conf.badStart;
			this.kpiBadBoxWidth = this.conf.badWidth;
			this.kpiThresBoxStart = this.conf.thresStart;
			this.kpiThresBoxWidth = this.conf.thresWidth;
			this.kpiGoodBoxStart = this.conf.goodStart;
			this.kpiGoodBoxWidth = this.conf.goodWidth;
			
			this.kpiTargetMarkerPos = (this.conf.kpiTargetVal - this.conf.minVal) / this.conf.range * 100;
			this.kpiValueLaneWidth = (this.conf.value - this.conf.minVal) / this.conf.range * 100;
			
			this.kpiMinValPos = (this.conf.kpiMinValPos||this.kpiThresBoxStart||0) - 5;
			this.kpiGoodValPos = (this.conf.kpiGoodValPos||this.kpiGoodBoxStart||0) - 5; 
			
			this.kpiNameText = "" + this.conf.name;
			this.kpiValueText = "" + this.conf.value + " " + this.conf.unit;
			this.kpiMinValueText = "" + this.conf.kpiMinVal + " " + this.conf.unit;
			this.kpiGoodValueText = "" + this.conf.kpiGoodVal + " " + this.conf.unit;
			this.kpiTargetValueText = "" + this.conf.kpiTargetVal + " " + this.conf.unit;
			
			this.updateVis();
		},
		
		render: function(ct, pos) {
			Ext.ux.kpi.KpiPanel.superclass.render.apply(this, arguments);
			
			this.updateKpiValue();
		},
		
		/**
		 * Rendering the KPI elements.
		 * 
		 * @param container
		 * @param pos
		 */
		onRender: function(container, pos) {
			Ext.ux.kpi.KpiPanel.superclass.onRender.apply(this, arguments);
			
			this._initializeElements();
			this._setupHierarchy();
			
			this.updateKpiValue();
		}
	});
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


new function(){
	
	/**
	 * Truncate the size of an Array and 
	 * add a truncate object to it 
	 * @class Array
	 * @method truncate
	 * @param {int} size The result size of the array (+ the truncate object)
	 * @param {Object} trunc The last element which will be added (defaults to "...")
	 * @return {Array}
	 */
	if (!Array.prototype.truncate) {
		Array.prototype.truncate = function(size, trunc){
		    if (this.length > size){
		       return [].concat(this.findAll(function(foo, i){ return i < size; }), (trunc || "..."));
		    }
		    return this;
		};	
	}
	
	/**
	 * Sums up all array elements of type 'number' and returns the sum as Integer.
	 * Uses iterative implementation due to a memory issue caused by an overload stack when summing up
	 * more than 1000 array elements using recursion.
	 * @class Array
	 * @method sum
	 * @returns {Integer} The sum 
	 */
	if (!Array.prototype.sum) {
		Array.prototype.sum = function(){
		    var sum = 0;
		    for(var i=0; i < this.length; ++i) {
		        if (typeof this[i] === 'number' && (!!this[i] || this[i] == 0)) {
		            sum += this[i];
		        }
		    };
		    return parseInt(sum);
		};
	}

	/**
	 * Multiplies all array elements of type 'number' and returns the Array.
	 * @class Array
	 * @method multiply
	 * @param {Number} factor The factor by which should be multiplied
	 */
	if (!Array.prototype.multiply) {
		Array.prototype.multiply = function(factor) {
			if (typeof factor === "number" && (!!factor || factor == 0)) {
				for (var i = 0; i < this.length; ++i) {
					if (typeof this[i] === "number" && (!!this[i] || this[i] == 0)) {
						this[i] *= factor;
					}
				}
			}
			return this;
		};
	}
	
}();
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

ns("ux.dialog");

(function() {

	Signavio.ux.dialog.Link = function(attrs) {
		attrs = attrs || {};

		attrs.text = attrs.text || "";

		var cls = ["x-signavio-link"].concat(attrs.cls).compact().join(" ");

		attrs.template = attrs.template || new Ext.Template(
			"<a href='#' class='" + cls + "'>{0}</a>"
		);

		delete attrs.cls;

		Signavio.ux.dialog.Link.superclass.constructor.apply(this, arguments);
	};

	Ext.extend(Signavio.ux.dialog.Link, Ext.Button, {

		onRender: function() {
			var that = this;

			this.el = Ext.get(this.template.append(this.container.dom, [this.text]));
			this.el.on("click", function(event) {
				if(that.disabled) {
					event.preventDefault();

					return false;
				}

				that.handler.apply(that, arguments);

				event.stopEvent();

				return false;
			});
		}
	});

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
 
ns("ux.dialog");

(function() {

	var ENTRY_CLS = "x-entry";
	var ENTRY_SELECTOR = "." + ENTRY_CLS;

	Signavio.ux.dialog.List = function(attrs) {
		this.entries = attrs.entries || [];
		this.size = attrs.size;

		this.setup(attrs);
		
		if(attrs.emptyText) {
			this.emptyText = new Ext.form.Label({
				text: attrs.emptyText,
				cls: "x-empty-text " + (attrs.labelCls ? attrs.labelCls : "")
			});

			delete attrs.emptyText;
		}

		Signavio.ux.dialog.List.superclass.constructor.apply(this, arguments);

		var that = this;

		this._add = function() {
			Ext.Panel.prototype.add.apply(that, arguments);
		};

		this._remove = function() {
			Ext.Panel.prototype.remove.apply(that, arguments);
		};

		this.addEvents({
			"rerender": true
		});
	};

	Ext.extend(Signavio.ux.dialog.List, Ext.Panel, {

		setup: function(attrs) {
			attrs.equals = attrs.equals || function() {
				return false;
			};
			attrs.border = attrs.border || false;
			attrs.collapsible = attrs.collapsible || false;
			attrs.cls = attrs.cls || "x-list";
		},

		clear: function() {
			if(!this.items) {
				return;
			}

			var list = this;

			this.items.each(function(item) {
				list._remove(item);
			});
		},

		count: function() {
			return this.entries.length;
		},

		getValues: function() {
			return this.entries.map(function(entry) {
				entry.value.title = entry.text;

				return entry.value;
			});
		},

		find: function(clb) {
			return this.entries.find(clb);
		},

		update: function(current, updated, clb) {
			if(!current) {
				return;
			}

			clb = clb || Ext.emptyFn;

			var index = this.entries.indexOf(current);

			var before = this.entries.slice(0, index);
			var after = this.entries.slice(index + 1);

			updated.actions = current.actions;

			this.entries = before.concat([updated]).concat(after);
			this.rerender();

			clb(this, updated, current);
		},

		getElement: function(entry) {
			var index = this.entries.indexOf(entry);

			if(index === -1 || !this.rendered) {
				return;
			}

			return this.el.select(ENTRY_SELECTOR).item(index);
		},

		rerender: function() {
			this.clear();

			var list = this;

			this.entries.each(function(entry) {
				list._add(new Ext.form.Label({
					cls: ENTRY_CLS + " " + (entry.cls || ""),
					text: entry.text
				}));

				if(!entry.actions) {
					return;
				}

				entry.actions.each(function(action) {
					list._add(new Signavio.ux.dialog.Link({
						text: action.text,
						cls: action.cls,
						handler: function() {
							action.handler(list, entry);
						}
					}));
				});

				list._add(new Signavio.ux.dialog.ListSeparator());
			});

			if(this.entries.length === 0 && this.emptyText) {
				this._add(this.emptyText);
			}

			this.doLayout();

			this.fireEvent("rerender", this);
		},

		full: function() {
			if(!Ext.isDefined(this.size)) {
				return false;
			}

			return this.count() === this.size;
		},

		allowed: function(entry) {
			var that = this;

			return !this.entries.find(function(sample) {
				return that.equals(sample, entry);
			});
		},

		add: function(entry, clb) {
			if(Ext.isDefined(this.size) && this.entries.length >= this.size) {
				return;
			}

			if(!this.allowed(entry)) {
				return;
			}

			clb = clb || Ext.emptyFn;

			this.entries.push(entry);

			this.rerender();

			clb(this, entry);
		},

		remove: function(entry) {
			this.entries = this.entries.without(entry);

			this.rerender();
		},

		render: function() {
			Signavio.ux.dialog.List.superclass.render.apply(this, arguments);

			Signavio.Utils.defer(function() {
				this.rerender();
			}, this);
		}

	});

	Signavio.ux.dialog.ListSeparator = function(attrs) {
		attrs = attrs || {};

		attrs.cls = attrs.cls || "x-list-separator";

		Signavio.ux.dialog.ListSeparator.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.dialog.ListSeparator, Ext.form.Label);

}());
/**
 * Copyright (c) 2013
 * Willi Tscheschner, Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

ns("ux.dialog.tree");

(function() {

	Signavio.ux.dialog.tree.DefaultRoot = function(facade, attrs) {
		this.facade = facade;

		attrs = this.setup(attrs);

		var that = this;

		attrs.filterFn = attrs.filterFn || function() {
			return that.filterFn.apply(that, arguments);
		};

		attrs.isChildLeaf = attrs.isChildLeaf || Signavio.Utils.isModel;

		Signavio.ux.dialog.tree.DefaultRoot.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.dialog.tree.DefaultRoot, Ext.tree.TreeNode, {

		setup: function(attrs) {
			attrs = attrs || {};

			return Ext.apply({}, attrs, {
				text: "",
				draggable: false,
				leaf: false,
				expanded: true,
				cls: "folder",
				dataField: "rep.name",
				// expanded: Ext.isDefined(attrs.expanded) ? attrs.expanded : true,
				recordRel: [
					Signavio.Const.REL.DIRECTORY,
					Signavio.Const.REL.MODEL
				],
				identifier: Signavio.Config.DIRECTORY_PATH ?
					Signavio.Config.DIRECTORY_PATH :
					((typeof ORYX !== "undefined") && ORYX.CONFIG.DIRECTORY_PATH)

			});
		},

		getRootFolder: function() {
			Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + this.facade.getModelMetaData().parent, {
				success: function(response) {
					if(!response || response.length === 0) {
						return;
					}
				}
			});
		},

		selectionInInternal: function() {
			var root;

			if(!this.facade.getCurrentRootFolder) {
				root = this.getRootFolder();
			} else {
				root = this.facade.getCurrentRootFolder();
			}

			return  Ext.isDefined(root) && Signavio.Utils.isInternalFolder(root);
		},

		filterFn: function(record) {
			if (Signavio.Utils.isModel(record) || Signavio.Utils.isFile(record)) {
				return true;
			}

			if (Signavio.Utils.isDirectory(record)) {
				return !Signavio.Utils.isTrashFolder(record, this.facade) &&
					((this.selectionInInternal() && Signavio.Utils.isInternalFolder(record)) ||
						(!this.selectionInInternal() && !Signavio.Utils.isInternalFolder(record)));
			}

			return false;
		}
	});

	/**
	 * Treeloader implements the specific behavior of loading data via an Ext.data.Store
	 * An Node within the Tree Panel needs to have following attributes 
	 * {dataField:String, recordRel:String, identifier:String}
	 * @class
	 */
	Signavio.ux.dialog.tree.Loader = function(){
		this.cachedStores = [];
		this.cachedCallbacks = {};
		
		Signavio.ux.dialog.tree.Loader.superclass.constructor.apply(this, arguments);

		this.addEvents({
			"node.checkchange": true
		});
	};

	Ext.extend(Signavio.ux.dialog.tree.Loader, Ext.tree.TreeLoader, {
		
		findRecord: function(identifier) {
			
			var record;
			
			(this.cachedStores || []).any(function(store){
				record = store.data.items.find(function(r){
					return r.get("href") === identifier;
				});

				return !!record;
			});

			return record;
		},
		
		/**
		 * Enable requesting
		 */
		dataUrl: true,

		/**
		 * Overrides the request handler for the treepanel
		 * @param {Object} node
		 * @param {Object} callback
		 */
		requestData: function(node, callback){
			callback = callback || Ext.emptyFn;
			var that = this;

			var clb = function(tree, node) {
				that.fireEvent("update", tree, node);

				callback(tree, node);
			};

			if(!node.ownerTree) {
				node.ownerTree = this.panel;
			}

			if(node.attributes.identifier && this.fireEvent("beforeload", this, node, callback)){
				node.collapse();
				
				var requestUrl = this.getRequestUrl(node.attributes.identifier);
				// Make suitable for editor
				// load store via request
				var store = Signavio.Core.StoreManager.getRelatedStore(requestUrl, this.storekey, [], {
					params: this.baseParams || {}
				});
				
				this.initStoreEvents( store, node, clb);
			} else {
				clb(this, node);
			}
		},
		
		getRequestUrl: function(identifier) {
			return identifier;
		},

		setGetRequestUrlCallback: function(f) {
			this.getRequestUrl = f;
		},
		
		releaseEvent: function(key, store) {
			if(!this.cachedCallbacks || !this.cachedCallbacks[key]) {
				return;
			}

			store.un("load", this.cachedCallbacks[key].update);
			store.un("update", this.cachedCallbacks[key].update);
			store.un("add", this.cachedCallbacks[key].add);
			store.un("remove", this.cachedCallbacks[key].remove);
		},

		addEvent: function(key, store) {
			if(!this.cachedCallbacks || !this.cachedCallbacks[key]) {
				return;
			}

			store.on("load", this.cachedCallbacks[key].update);
			store.on("update", this.cachedCallbacks[key].update);
			store.on("add", this.cachedCallbacks[key].add);
			store.on("remove", this.cachedCallbacks[key].remove);
		},

		initStoreEvents: function(store, node, callback){
			var hashkey = node.id + (node.attributes.identifier || store.getIdentifier());
			
			this.releaseEvent(hashkey, store);
			
			var that = this;

			this.cachedCallbacks[hashkey] = {
				update: function() {
					that.doResponse(store, node, callback);
				},
				add: function(store, records) {
					if(!node.ownerTree) {
						node.ownerTree = that.panel;
					}

					that.onAdd(node, store, records);
				},
				remove: function(store, record) {
					that.onRemove(node, store, record);
				}
			};

			this.addEvent(hashkey, store);

			if( !this.cachedStores.include(store) ){
				this.cachedStores.push(store);
			}
			
			// If already loaded
			if (store.lastOptions && !store.isLoading && node.rendered){
				this.cachedCallbacks[hashkey].update();
			}
		},
		
		releaseAllEvents: function(){
			var that = this;

			(this.cachedStores||[]).each(function(store){
				var id = store.lastOptions.id;
				var key	= $H(that.cachedCallbacks).keys().find(function(key) {
					return key.endsWith(id);
				});

				that.releaseEvent(key, store);
			});
		},
		
		onAdd: function(node, store, records){
			var rel = [node.attributes.recordRel].flatten();
			
			if(records.any(function(r) {
				return !rel.include(r.get("rel"));
			})){
				return;
			}

			node.attributes.leaf = false;
			node.expand(false, true);
			
			var generateNodes = [];
			
			// For every record in the store, append a new child
			this.generateNodeData(store, records, node).each(function(data){
				var r = records.find(function(re){
					return re.get("href") === data.identifier;
				});
				
				var sortedRecords = ([]).concat(store.data.items);

				if(r && !store.data.contains(r)) {
					sortedRecords = sortedRecords.concat([r]);
				}

				sortedRecords = sortedRecords.findAll(function(t) {
					return t.get("rel") === "dir";
				}).sort(store.lastOptions.sort || Signavio.Utils.BottomUpBusinessObjectSortingFunction);
			
				var cn = this.createNode(data);
				generateNodes.push(cn);
				
				if (r && sortedRecords.indexOf(r)+1 < sortedRecords.length){
					node.insertBefore(cn, node.item(sortedRecords.indexOf(r)));
				} else {
					node.appendChild(cn);
				}
				
			}.bind(this));
			//node.endUpdate();
			
			// Anim the adding
			generateNodes.each(function(node){
				if (node.ui.elNode) {
					Ext.get(node.ui.elNode).slideIn("t", {
						duration:0.2
					});
				}
			});
			
			if (this.showTooltip) {
				generateNodes.each(function(cn){
					(cn.getUI().wrap.dom||cn.getUI().wrap).setAttribute("title", cn.text);
				});
			}
		},
		
		onRemove: function(node, store, record){
			var rel = [node.attributes.recordRel].flatten();
			
			if( !rel.include(record.get("rel")) ){
				return;
			}
			
			// Remove the node which is linked with the record
			var deleteNode = node.findChild("identifier", record.get("href"));
			if (deleteNode && deleteNode.getOwnerTree()) {
				deleteNode.remove();
			}
		},
		
		/**
		 * Generate the data for the nodes depending on the records
		 * @param {Object} records
		 */
		generateNodeData: function(store, records, node){
			if (this.sortingFn) {
				records = records.sort(this.panel.sortingFn || this.sortingFn);
			} else if ( !(store.lastOptions.sort)  ){
				records = records.sort(Signavio.Utils.BottomUpBusinessObjectSortingFunction);
			}

			if(this.filterFn) {
				var that = this;
				
				records = records.select(function(record) {
					return that.filterFn(record, node);
				});
			}
				
			return this.processNode(store, records, node);
		},

		processNode: function(store, records, node) {
			// Set loaded store to the node
			node.attributes.store = store;

			var that = this;

			// For every record in the store, append a new child
			return records.map(function(record){
				return that.processItem(store, record, node);
			}).compact();
		},

		processItem: function(store, record, node) {
			var attr = node.attributes;
			var fn = node.attributes.filterFn;
				
			if( fn instanceof Function && !fn(record) ){
				return;
			}
			
			var data = this.createData(store, record, node);
			
			if (this.showTooltip || attr.getToolTip) {
				data.qtip = (attr.getToolTip ? attr.getToolTip(record) : "") || (this.showTooltip && data.text) || "";
			}
			
			if(this.panel && this.panel.disabledIds && this.panel.disabledIds.include(data.identifier) ){
				return null;
			}
			
			return data;
		},

		hasChange: function(node, items) {
			var children = node.childNodes;

			return children.length > 0 &&
				children.length === items.length &&
				children.all(function(n) {
					var attrs = n.attributes;

					return items.any(function(i) {
						return attrs.identifier === i.identifier &&
							attrs.text === i.text &&
							attrs.color === i.color &&
							attrs.order === i.order;
					});
				});
		},

		getChildClass: function(attrs, record) {
			if(attrs.childCls) {
				return attrs.childCls;
			}

			if(attrs.hasChildCls) {
				return attrs.hasChildCls(record);
			}

			if(Signavio.Utils.isModel(record)) {
				return "model model-" + Signavio.Utils.getIcon(record, true);
			}

			if(Signavio.Utils.isFile(record)) {
				return "file file-" + Signavio.Utils.getIcon(record, true);
			}

			if(Signavio.Utils.isDirectory(record)) {
				return "folder";
			}

			if(Signavio.Utils.isGlossary(record)) {
				return "x-glossary";
			}

			return "";
		},

		createData: function(store, record, node) {
			var attr = node.attributes;
			var text = store.parseValue(record, node.attributes.dataField) || "";

			if(text.include("&amp;") || text.include("&lt;")) {
				text = Signavio.Utils.escapeHTML(text);
			}

			text = text.escapeHTML();

			return {
				text: Signavio.I18N.Repository.Folder[record.get("rep").type] || (attr.parseText ? attr.parseText(text, record) : false) || text || attr.value,
				// cls			: attr.childCls || (attr.hasChildCls ? attr.hasChildCls(record) : ""),
				cls: this.getChildClass(attr, record),
				leaf: attr.childLeaf || (attr.isChildLeaf ? attr.isChildLeaf(record) : false),
				rel: record.get("rel"),
				childLeaf: attr.childLeaf,
				isChildLeaf: attr.isChildLeaf,
				filterFn: attr.filterFn,
				checked: Ext.isDefined(attr.checked) ? node.ui.isChecked() : undefined,
				hasChildCls: attr.hasChildCls,
				parseText: attr.parseText,
				childCls: attr.childCls,
				dataField: attr.dataField,
				recordRel: attr.recordRel,
				singleClickExpand: attr.singleClickExpand || false,
				getIdentifier: attr.getIdentifier,
				getToolTip: attr.getToolTip,
				identifier: attr.getIdentifier instanceof Function ? attr.getIdentifier(record) : record.get("href")
			};
		},

		/**
		 * Callback when loading the new data from the store
		 * @param {Object} store Store where the new data comes from
		 * @param {Object} node Node where the data should append
		 * @param {Object} callback Callback when ready loading
		 * @param {Object} records New records of the store
		 */
		doResponse: function(store, node, callback){

			// if( (typeof c === "string" && c !== Ext.data.Record.COMMIT) || !node.getOwnerTree() ){
			if(!node.getOwnerTree()){
				return;
			}

			// Get the new items
			var items = this.generateNodeData( store, store.getRecords(node.attributes.recordRel), node );
			// Check if there are changes
			if(this.hasChange(node, items)) {
				return;
			}
			
			// Hide all childs
			node.collapse();
			
			// Remove all children
			var index = node.childNodes.length-1;
			for(; index>=0; index = index - 1){
				node.childNodes[index].remove();
			}
			
			var that = this;

			node.beginUpdate();
			// For every record in the store, append a new child
			items.each(function(data){
				var cn = that.createNode(data);

				cn.on("checkchange", function(node, value) {
					that.fireEvent("node.checkchange", node, value);
				});
				
				node.appendChild(cn);
			});

			node.endUpdate();

			Signavio.Utils.defer(function() {
				if(!node.ownerTree) {
					node.ownerTree = that.panel;
				}

				node.expand();
			}, this, 100);
			
			this.fireEvent("update", this, items);
			this.fireEvent("load", this, node);
				
			if(callback){
				callback(this, node);
			}
		}
	});

	/**
	 * TreePanel implements a specific Tree Panel.
	 * @class
	 * @param {Object} attributes
	 */
	Signavio.ux.dialog.tree.Panel = function(attrs){
		attrs = attrs || {};
		
		if (!attrs.loader) {
			// Create a new loader instance if none was specified.
			// Todo: remove switch when editor and explorer use the same code base
			// Currently, the stores accesses are not available in editor
			// and are being simulated by a different treeloader
			if (Signavio.Core.StoreManager) {
				attrs.loader = new Signavio.ux.dialog.tree.Loader({
					panel: this,
					sortingFn: attrs.sortingFn
				});
			} else if (Signavio.Extensions.TreeLoader) {
				var filter = attrs.filter || (attrs.root.attributes ? attrs.root.attributes.recordRel : undefined);

				attrs.loader = new Signavio.Extensions.TreeLoader({
					acceptTypes: filter,
					filterFn: attrs.filterFn
				});
			}
		} else {
			attrs.loader.panel = this;
		}

		var that = this;

		this.addEvents({
			"tree.loaded": true
		});

		attrs.cls = ["tree-panel", attrs.cls].compact().join(" ");

		// Call super class
		Signavio.ux.dialog.tree.Panel.superclass.constructor.call(this, attrs);
		
		this.loader.on("node.checkchange", function(node, value) {
			that.onNodeCheckChange(node, value);
		});
		this.loader.on("update", this.onUpdate.bind(this));
		this.loader.on('beforeload', function() {
			that.el.mask();
		});
		this.loader.on('load', function() {
			that.el.unmask();

			that.fireEvent("tree.loaded", that.root);
		});
		
		if( attrs.root instanceof Ext.tree.TreeNode ){
		
			this.on("render", function(){
				this.getLoader().requestData(this.root, this.onRootLoaded.bind(this));
			}.bind(this));
		
		} else if( attrs.data ){
			
			// Create root node
			var root = new Ext.tree.TreeNode({
				text: '',
				draggable: false,
				expanded: true
			});
			
			this.setRootNode( root );
			
			// Append data to the root node
			this.appendChildNodes(root, attrs.data);
		}
	};

	Ext.extend(Signavio.ux.dialog.tree.Panel, Ext.tree.TreePanel, {
		
		/**
		 * Initial default values
		 */
		animate		: true,
		enableDD	: false,
		rootVisible : false,
		useArrows	: true,
		autoScroll	: true,
		//maskDisabled: false,
				
		onRootLoaded: Ext.emptyFn,
		onUpdate	: Ext.emptyFn,

		onNodeCheckChange: Ext.emptyFn,
				
		appendChildNodes: function( node, data ){
			return data.map(function(d) {
				if (d.useTreeNode) {
					return node.appendChild( new Ext.tree.TreeNode(d) );
				}

				return node.appendChild(this.getLoader().createNode(d));
			}.bind(this));
		},

		expandTo: function(id) {
			if(!id) {
				return;
			}

			var that = this;

			Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + id, {
				success: function(response) {
					var record = response.find(function(record) {
						return record.rel === "parents";
					});

					if(!record) {
						return;
					}

					var parents = record.rep.reverse().map(function(parent) {
						return parent.href;
					});
					// add self to this list in order to be selected
					parents = parents.concat(id);

					that.expandRecursively(parents, that.root);
				}
			});
		},

		expandRecursively: function(parents, parent, index) {
			index = index || 0;
			var that = this;

			parent.childNodes.each(function(node) {
				if(!parents.include(node.attributes.identifier)) {
					return;
				}

				if(index === parents.length - 1) {
					if(node.expand) {
						node.expand(false, true);
					}

					node.select();
				} else {
					node.expand(false, true, function() {
						that.expandRecursively(parents, node, index + 1);
					});
				}
			});
		},
		
		removeChildNodes: function( node ){
			var index = node.childNodes.length-1;
			for(; index>=0; index = index - 1){
				node.childNodes[index].remove();
			}
		},
		
		/**
		 * Return the selected record
		 * @return {Record} Return the selected record or undefined if no element is selected
		 */
		getSelectedRecord:function(){
			var selNode = this.getSelectionModel().getSelectedNode();
			
			if(!selNode){
				return;
			}
			// TODO: Switch for editor usagé, since loader ist not linked to a store (since we havent gote stores there, yet)
			if (this.loader instanceof Signavio.ux.dialog.tree.Loader) {
				return this.loader.findRecord( selNode.attributes.identifier );
			} else {
				return selNode.attributes.data;
			}
		},
		
		onRender: function(){
			Signavio.ux.dialog.tree.Panel.superclass.onRender.apply(this, arguments);
			
			if(!this.unselectable){
				return;
			}

			var that = this;

			this.el.on("click", function(b,e){
				if (e !== that.body.dom){
					return;
				}
				
				that.selectPath("");
			});
		},

		onDestroy: function(){
			if(!this.rendered){
				return;
			}
			
			// TODO: remove switch when editor and explorer have same code base.
			// in editor, another loader is used (Signavio.Extensions.TreeLoader)
			// that one has other event handling
			var loader = this.getLoader();
			if (loader.releaseAllEvents) {
				loader.releaseAllEvents();
			}
		}
	});

	/**
	 * TreePanel implements a specific Tree Panel which has a setValue method which uses to generate new children.
	 * @class
	 * @param {Object} attributes
	 */
	Signavio.ux.dialog.tree.CheckPanel = function(attrs){
		attrs = attrs || {};
		
		this.data = attrs.data;
		delete attrs.data;

		this.dataLabel = attrs.dataLabel;
		
		Signavio.ux.dialog.tree.CheckPanel.superclass.constructor.call(this, attrs);

		if (attrs.dataStore instanceof Ext.data.Store) {
			this.data = [];
			attrs.dataStore.on("load", function(store){
				this.data = store.data.items.map(function(r){return r.data;});
				this.loadData();
			}.bind(this));
		}
		
		if (this.data instanceof Array) {
			// Create root node
			var root = new Ext.tree.TreeNode({
				text: '',
				draggable: false,
				expanded: true
			});
			
			this.setRootNode(root);
		}
	};

	Ext.extend(Signavio.ux.dialog.tree.CheckPanel, Signavio.ux.dialog.tree.Panel, {
		
		/**
		 * Initial default values
		 */
		animate		: true,
		autoScroll	: true,
		enableDD	: false,
		rootVisible : false,
		useArrows	: true,
		cls			: "x-tree-check-panel",
		loader		: new Ext.tree.TreeLoader(),
		value		: null,
		height		: 100,
		width		: 129,
		isFormField : true,
		checkRecursive : false,
		originalValue : null,
		
		defaultItem : {
			leaf: true,
			checked: false,
			useTreeNode: true,
			iconCls: "x-hidden"
		},
		
		afterRender : function(){
			Signavio.ux.dialog.tree.CheckPanel.superclass.afterRender.call(this);
			
			this.loadData();
		},
		
		loadData: function(){
			var that = this;

			// Render/add recursive new childs
			var fn = function(children, parent) {

				// Define child nodes.
				children = children.map(function(child){
					var attrs = {};
					 
					if(typeof child === "string") {
						attrs.text = child;
						attrs.identifier = child;
					} else if(that.dataLabel) {
						attrs.text = child[that.dataLabel];
						attrs.identifier = child[that.dataLabel];
					} else {
						attrs = child;
					}
				
					return Ext.apply(Object.clone(that.defaultItem), attrs, {
						value: child
					});
					
				});
				// Append data to the root node
				var nodes = that.appendChildNodes(parent, children);
				
				// Create recursive all children
				nodes.each(function(node){
					if(node.attributes.children){
						fn(node.attributes.children, node);
					}

					node.render();
				});
			};
			
			if(this.data && this.root){
				fn(this.data, this.root);
			}
		},
		
		/**
		 * @member Signavio.Extensions.TreeDataPanel
		 * @param {Object} val
		 */
		setValue: function(values){
			this.value = values;

			if(!(values instanceof Array)) {
				return;
			}

			var that = this;

			this.root.cascade(function(node){
				that.toggleCheck(node, false);
				node.enable();
			});
			
			values.each(function(value) {
				var identifier = that.dataLabel ? value[that.dataLabel] : value;
				var node = that.findChildNode(that.root, "identifier", identifier, that.checkRecursive, value);

				that.toggleCheck(node, true);
			});
		},
		
		/**
		 * Returns a child node from the given node with the given attribtue
		 * @param {Ext.tree.Node} node
		 * @param {Object} attr
		 * @param {Object} val
		 * @param {Boolean} recusive
		 */
		findChildNode: function(node, attr, val, recursive){
			var found = node.findChild(attr, val),
				that = this;
			
			if (!found && recursive) {
				node.childNodes.any(function(child){
					found = that.findChildNode(child, attr, val, recursive);
					return !!found;
				});
			}

			return found;
		},
		
		/**
		 * Returns the data for a given node
		 * @param {Ext.tree.Node} node
		 * @returns {Object}
		 */
		getData: function(node){
			return this.data.find(function(n){
				return n[this.dataLabel] === (node.attributes.identifier || node.attributes.text);
			}.bind(this));
		},
		
		/**
		 * Return all identifiers/text from all selected nodes 
		 */
		getValue: function(){
			var value = [];
			var that = this;

			this.root.cascade(function(node){
				if (!node.ui.isChecked()) {
					return;
				}

				if (that.dataLabel){
					var data = that.getData(node);
					
					if (data) {
						value.push(data);
					}
				} else {
					value.push(node.identifier || node.text);
				}
			});

			return value;
		},
		
		/**
		 * Toggle the checkbox of the node
		 * @param {Object} node Node with the cb
		 * @param {Object} value 
		 */
		toggleCheck: function(node, value){
			if(!node) {
				return;
			}

			node.beginUpdate();
			node.ui.toggleCheck(value);
			node.endUpdate();
		}
	});

	/**
	 * ModelDirectoryCheckTreePanel implements a specific Tree Panel.
	 * 
	 */
	Signavio.ux.dialog.tree.ModelCheckPanel = function(attrs, elements){
		
		this.initialSelection = elements;
		
		attrs = attrs || {};
		
		if (!attrs.sortingFn) {
			attrs.sortingFn = Signavio.Utils.BottomUpBusinessObjectSortingFunction;
		}
		
		attrs.anchor = Ext.isDefined(attrs.anchor) ? attrs.anchor : '100% -15';
		attrs.style= attrs.style || "padding:0px;padding-top:10px;";
		
		Signavio.ux.dialog.tree.ModelCheckPanel.superclass.constructor.call(this, attrs);

		var that = this;

		var handleClick = function(node) {
			if (!Ext.isDefined(node.attributes.checked)) {
				return true;
			}
			
			that.handleCheckChange(node, !node.attributes.checked);
				
			return false;
		};

		this.on("dblclick", handleClick);
		this.on("click", handleClick);

		this.addListener('checkchange', function(node, checked) {
			if(that.firing) {
				return;
			}

			that.firing = true;
			that.handleCheckChange(node, checked);
			delete that.firing;
		});
	};

	Ext.extend(Signavio.ux.dialog.tree.ModelCheckPanel, Signavio.ux.dialog.tree.Panel, {
		
		bodyStyle	: "padding:2px 0px !important;",
		cls			: "x-tableview-plugin x-div-textbackground",
		forceUpdate : true, // Force immediate update
		recordRel	: [ Signavio.Const.REL.DIRECTORY, Signavio.Const.REL.MODEL ],
		
		toggleAllChildren: function(parent, value) {
			var that = this;

			parent.childNodes.each(function(child) {
				child.ui.toggleCheck(value);
				child.attributes.checked = value;

				that.fireEvent("node.checkchange", child, value);
				
				that.toggleAllChildren(child, value);
			});
		},

		updateParentSelection: function(parent, value){
			if (!parent){
				return;
			}
			
			if (!value) {
				parent.ui.toggleCheck(value);
				parent.attributes.checked = value;
			} else {
				var allChecked = parent.childNodes.all(function(node){
					return node.ui.isChecked();
				});

				if (allChecked) {
					parent.ui.toggleCheck(true);
					parent.attributes.checked = true;
				}
			}

			this.fireEvent("node.checkchange", parent, value);

			this.updateParentSelection(parent.parentNode, value);
		},

		handleCheckChange: function(node, checked) {
			node.ui.toggleCheck(checked);
			node.attributes.checked = checked;

			node.fireEvent("checkchange", node, checked);

			this.toggleAllChildren(node, checked);
			this.updateParentSelection(node.parentNode, checked);
		},

		/**
		 * Get called when the root (the root directories) are loaded
		 * 
		 */
		onRootLoaded: function(){
			Signavio.Utils.defer(function() {
				this.expandToAndCheckPreSelection(this.initialSelection || []);
			}, this);
		},
		
		/**
		 * Called when the panel gets destroyed.
		 * Release all event.
		 * 
		 */
		onDestroy : function(){
			Signavio.ux.dialog.tree.ModelCheckPanel.superclass.onDestroy.call(this);

			this.getLoader().releaseAllEvents();
		},
		
		/**
		 * Expands the tree for the given element array
		 * @param {Array} elementArray
		 * @param {Boolean} anim
		 * @param {Function} finished
		 */
		expandToAndCheckPreSelection : function(elements, animate, finished){
			if (!(elements instanceof Array) && elements.length === 0) {
				if (finished instanceof Function) {
					finished();
				}

				return;
			}
			
			var parents = [];
			var that = this;
			
			// Define nodes which should be selected
			var nodes = elements.map(function(r){
				if(r instanceof Ext.data.Record) {
					return r.get("href");
				}

				// if(r instanceof Ext.data.Store) {
				// 	return r.getIdentifier();
				// }
			}).compact();
			
			// Get all parents which should be expanded
			elements.each(function(record) {
				var store;
				
				if(record instanceof Ext.data.Store) {
					store = record;
				} else {
					store = Signavio.Core.StoreManager.getStore(record.get("href"));
				}

				var parentRec = [];

				if(store) {
					parentRec = store.getRecords("parents") || [];
				}

				parentRec = parentRec.first();
				
				if (!parentRec) {
					return;
				}

				var rel = [];

				if(store === record) {
					rel = {
						href: store.getIdentifier()
					};
				}

				[].concat(rel, parentRec.get("rep"))
					.reverse()
					.each(function(parent, i){
						if (!parents[i]) {
							parents[i] = [];
						}

						if (!parents[i].include(parent.href)) {
							parents[i].push(parent.href); // Add uniq parent id
						}
					});
			});
			
			// Expand all child nodes which are included in the list of parent
			var expandAndCheckRecursively = function (parent, index) {
				index = index || 0;

				var expanding = false;
				
				parent.childNodes.each(function(node){
					if((parents[index] || []).include(node.attributes.identifier)){
						expanding = true;
						
						node.expand(false, animate, function() {
							expandAndCheckRecursively(node, index + 1);
						});
						// Select last folder
						if (index === parents.length-1 && !Ext.isDefined(node.attributes.checked)){
							that.getSelectionModel().select(node);
						}
					}

					if (!nodes.include(node.attributes.identifier)) {
						return;
					}

					// Check all nodes
					if (Ext.isDefined(node.attributes.checked)) {
						node.ui.toggleCheck(true);
						node.attributes.checked = true;
					} else {
						that.getSelectionModel().select(node);
					}
				});
				
				if (!expanding && finished){
					finished();
				}
			};
			
			expandAndCheckRecursively(this.root);
		},
		
		findChildNode : function(parent, id) {
			var children = parent.childNodes;
			
			for (var i = 0, length = children.length; i < length; i = i + 1) {
				var child = children[i];

				if (child.attributes.identifier === id) {
					return child;
				}
			}
		},
		
		uncheckAllExcept: function(models, parent) {
			parent = parent || this.root;

			var that = this;

			parent.childNodes.each(function(node) {
				switch(node.attributes.rel) {
				case Signavio.Const.REL.MODEL:
					if(!models.include(node.attributes.identifier)) {
						node.attributes.checked = false;
						node.ui.toggleCheck(false);
					} else if(!node.attributes.checked) {
						node.attributes.checked = true;
						node.ui.toggleCheck(true);
					}
					
					break;
				case Signavio.Const.REL.DIRECTORY:
					that.uncheckAllExcept(models, node);
				}
			});
		}
		
	});
	
	Signavio.ux.dialog.tree.FolderPanel = function(facade, attrs) {
		attrs = attrs || {};

		attrs.root = new Signavio.ux.dialog.tree.DefaultRoot(facade, {
			recordRel: [Signavio.Const.REL.DIRECTORY]
		});

		Signavio.ux.dialog.tree.FolderPanel.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.dialog.tree.FolderPanel, Signavio.ux.dialog.tree.Panel);
	
	Signavio.ux.dialog.tree.CategoryUIProvider = Ext.extend(Ext.tree.TreeNodeUI, {
		render	: function() {
			Ext.tree.TreeNodeUI.prototype.render.apply(this, arguments);
			if ((this.node.attributes||{}).color) {
				var iconEl = Ext.get(this.getIconEl());
				if (iconEl) {
					iconEl.addClass("x-category-tree-node-icon");
					iconEl.setStyle("background", this.node.attributes.color);	
				}
			}
		}
	});

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
 
ns("ux.dialog");

(function() {
	var ORIENTATION = {
		LANDSCAPE: "landscape",
		PORTRAIT: "portrait",
		POLICY: {
			AUTO: "auto",
			ALWAYS: "always",
			NEVER: "never"
		},
		CW: "cw",
		CCW: "ccw"
	};

	var EVENT;

	var FORMAT = {
		A4: "DIN_A4",
		A3: "DIN_A3",
		US_LETTER: "US_LETTER"
	};

	var CONTROL_WIDTH = 185;

	var DATA_EXTRACTOR = function(result) {
		if(!this.items) {
			return;
		}

		this.items.each(function(item) {
			if(!item.fetchValue) {
				return;
			}

			return item.fetchValue(result);
		});
	};

	var DATA_INJECTOR = function(data) {
		if(!this.items) {
			return;
		}

		this.items.each(function(item) {
			if(!item.loadValue) {
				return;
			}

			return item.loadValue(data);
		});
	};

	Signavio.ux.dialog.Print = function(facade, attrs) {
		attrs = attrs || {};

		EVENT = Signavio.Const.EVENT;

		this.facade = facade;

		this.setup(attrs);

		this.form = this.createGeneralForm(attrs);
		this.preview = this.createPreview(attrs);

		attrs.items = attrs.items || [this.form, this.preview];

		Signavio.ux.dialog.Print.superclass.constructor.call(this, attrs);

		this.setupEvents();
	};

	Ext.extend(Signavio.ux.dialog.Print, Ext.ux.Window, {

		getSVG: function() {
			var container = document.createElement("div");
			container.appendChild(this.facade.getCanvas().getSVGRepresentation());

			return container.innerHTML;
		},

		getJSON: function() {
			return this.facade.getSerializedJSON();
		},

		rawView: function(view) {
			var meta = this.facade.getModelMetaData();
			var id = view.replace("/view/", "");

			if(!meta.views) {
				return;
			}

			return meta.views.find(function(view) {
				return view.viewId === id;
			}).definition;
		},

		getPDF: function(clb) {
			clb = clb || Ext.emptyFn;

			this.body.mask(Ext.ux.getI18N("dialog.print.mask.create.pdf"), "disabled");

			var result = {
				models: [],
				directories: []
			};

			this.form.fetchValue(result);
			this.preview.fetchValue(result);

			var that = this;

			if(this.activeView) {
				result.viewId = this.activeView.get("href");
			}

			if(this.managed || this.disableSelection) {
				// Managed dialogs don't have influence on the selection of 
				// models and directories. 
				if(this.useJSON) {
					result.json = this.getJSON();

					var meta = this.facade.getModelMetaData();

					if(!meta["new"] && meta.modelId) {
						result.models.push(meta.modelId);
					}

					if(result.viewId) {
						result.view = this.rawView(result.viewId);

						delete result.viewId;
					}
				} else {
					result.models = [this.diagram.get("href").replace("/info", "")];
					result.directories = [];
				}
			}

			if(!result.json && result.models.length === 0 && result.directories.length === 0) {
				Ext.Msg.alert(this.title, Ext.ux.getI18N("dialog.print.error.no.models"));

				this.body.unmask();

				return;
			}

			this.requestPDF(result, function(error, openPDF) {
				that.body.unmask();

				if(error) {
					Ext.Msg.alert(that.title, Ext.ux.getI18N("dialog.print.error.creating.pdf"));

					return;
				}

				if(that.saveAsDefault && that.saveAsDefault.getValue()) {
					that.saveDefault(result, function() {
						openPDF();
						clb();
					});

					return;
				}

				openPDF();
				clb();
			});
		},

		setupEvents: function() {
			var that = this;

			this.on("orientation.changed", function(orientation) {
				that.preview.updateOrientation(orientation);
			});

			this.facade.registerOnEvent(EVENT.CANCEL_FILE_UPLOAD, function() {
				delete that.uploading;
			});

			this.on("resize", function(dialog) {
				that.preview.updateOrientation();

				that.form.setHeight(dialog.getInnerHeight());
			});

			this.on("show", function() {
				Signavio.Utils.defer(function() {
					that.preview.updateOrientation();
					that.saveAsDefault = that.createSaveDefaultButton();

					that.body.mask(Ext.ux.getI18N("dialog.print.mask.load.defaults"), "disabled");

					that.loadDefaults(that.form, that.preview);
				});
			});
		},

		setup: function(attrs) {
			var that = this;

			var maxHeight = 0.9 * (document.height||window.innerHeight||0);

			attrs.title = attrs.title || Ext.ux.getI18N("dialog.print.title");
			attrs.layout = attrs.layout || "column";
			attrs.cls = "pdf-export";
			attrs.modal = true;
			attrs.width = 1100;
			attrs.minWidth = 1100;
			attrs.height = Math.max(Math.min(850, maxHeight), 300);
			attrs.bodyStyle = "background:white;";
			attrs.views = attrs.views || [];
			attrs.buttons = attrs.buttons || [
				{
					text: Ext.ux.getI18N("dialog.print.button.create"),
					handler: function() {
						that.getPDF(function() {
							that.close();
						});
					}
				}
			];

			attrs.defaults = {
				imageSettings: {
					isLandscape: attrs.horizontal,
					policy: "auto",
					orientation: "cw",
					useMultiplePages: false,
					drawBlackAndWhite: false
				},
				disableAllHeaders: true,
				pageFormat: "DIN_A4",
				language: this.getDefaultLanguage(),
				containers: [],
				logoFileId: null
			};

			this.addEvents({
				"orientation.changed": true,
				"image.loading": true,
				"image.loaded": true,
				"image.changed": true,
				"image.grayscale": true,
				"image.preview.failed": true,
				"language.changed": true,
				"show.headers": true,
				"configure.models": true,
				"configure.page": true,
				"attributes.changed": true,
				"rotation.enabled": true,
				"rotation.disabled": true,
				"rotation.changed": true,
				"logo.removed": true,
				"logo.selected": true
			});
		},

		getDefaultLanguage: function() {
			var languages = this.getLanguages();

			if(languages.length > 0) {
				return languages[0].rel || languages[0];
			}
		},

		requestPDF: function(data, clb) {
			// sanitizing
			data.modelIds = data.models;
			delete data.models;

			data.directoryIds = data.directories;
			delete data.directories;

			data.directPrintDiagram = data.json;
			delete data.json;

			var query = Object.toQueryString(Ext.Ajax.extraParams);

			Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + "/pdfprint"+(query?'?'+query:''), {
				method: "POST",
				async: true,
				params: {
					printConfig: JSON.stringify(data)
				},
				success: function(data) {
					clb(false, function() {
						var params = [
							data.rep,
							Ext.Ajax.getSecurityParameter()
						].compact().map(function(param) {
							return Object.toQueryString(param);
						}).join("&");

						var uri = Signavio.Config.BACKEND_PATH + data.href + "?" + params + (query?'&'+query:'');

						var beforeUnload = window.onbeforeunload;
						window.onbeforeunload = null;
						window.location = uri;

						Signavio.Utils.defer(function() {
							window.onbeforeunload = beforeUnload;
						}, this, 500);
					});
				},
				error: function() {
					clb(true);
				}
			});
		},

		getDefault: function(clb) {
			var key = "pdf-export-defaults";
			var that = this;

			var retrieveValue = function(value) {
				if(value && typeof value === "string") {
					// I don't know why, but getConfig returns a string in Firefox
					// and an already parse Object in Chrome...
					//TODO find out why, fix the cause and remove the workaround!
					value = value.evalJSON(true);
				}

				return clb(value || Object.clone(that.defaults));
			};

			// Editor
			if(!this.facade.getConfig) {
				Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + "/configuration", {
					success: function(configs) {
						var config = configs.find(function(config) {
							return config.rep.name === key;
						});

						if (config) {
							retrieveValue(config.rep.value);
						} else {
							retrieveValue();
						}
					},
					error: function() {
						Ext.Msg.alert(that.title, "Die gespeicherten Einstellungen konnten nicht geladen werden.");

						retrieveValue();
					}
				});

				return;
			}

			// Everywhere else
			var value = this.facade.getConfig("department", key, "ALL");

			retrieveValue(value);
		},

		loadDefaults: function(form, preview) {
			var that = this;

			this.getDefault(function(defaults) {
				if(!defaults) {
					that.body.unmask();

					return;
				}

				form.loadValue(defaults);
				preview.loadValue(defaults);

				that.body.unmask();
			});
		},

		saveDefault: function(value, clb) {
			this.facade.setConfig("department", "pdf-export-defaults", value, "ALL", "STRING", clb);
		},

		isAdmin: function() {
			if(this.facade.isCurrentUserAdmin) {
				return this.facade.isCurrentUserAdmin();
			}

			// basically this means, if you're in the editor, you
			// are not considered an admin.
			return false;
		},

		createSaveDefaultButton: function() {
			if(this.managed || !this.isAdmin()) {
				return;
			}

			return new Ext.form.Checkbox({
				name: "savedefault",
				checked: false,
				boxLabel: Ext.ux.getI18N("dialog.print.save.defaults.label"),
				ctCls: "save-default",
				renderTo: this.footer,
				fetchValue: function(result) {
					result.saveAsDefault = this.getValue();
				}
			});
		},

		createOrientationControls: function(attrs, items) {
			var that = this;

			var landscape = new Ext.form.Radio({
				name: "orientation",
				fieldLabel: Ext.ux.getI18N("dialog.print.orientation.landscape"),
				checked: attrs.horizontal,
				fetchValue: function(result) {
					result.imageSettings.isLandscape = this.getValue();
				},
				loadValue: function(data) {
					this.setValue(data.imageSettings.isLandscape);
				},
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.fireEvent("orientation.changed", ORIENTATION.LANDSCAPE);
					}
				}
			});

			items.push(landscape);

			var portrait = new Ext.form.Radio({
				name: "orientation",
				fieldLabel: Ext.ux.getI18N("dialog.print.orientation.portrait"),
				checked: !attrs.horizontal,
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.fireEvent("orientation.changed", ORIENTATION.PORTRAIT);
					}
				},
				loadValue: function(data) {
					this.setValue(!data.imageSettings.isLandscape);
				}
			});
			
			items.push(portrait);

			var policy = new Ext.ux.form.ComboBox({
				fieldLabel: Ext.ux.getI18N("dialog.print.orientation.policy.label"),
				mode: "local",
				cls: "rotation-policy",
				readOnly: true,
				width: CONTROL_WIDTH,
				value: ORIENTATION.POLICY.AUTO,
				store: new Ext.data.SimpleStore({
					fields: ["value", "title"],
					reader: new Ext.data.ArrayReader({}, ["value", ["title"]]),
					data: [
						[ORIENTATION.POLICY.AUTO, Ext.ux.getI18N("dialog.print.orientation.policy.auto")],
						[ORIENTATION.POLICY.ALWAYS, Ext.ux.getI18N("dialog.print.orientation.policy.always")],
						[ORIENTATION.POLICY.NEVER, Ext.ux.getI18N("dialog.print.orientation.policy.never")]
					]
				}),
				fetchValue: function(result) {
					result.imageSettings.policy = this.getValue();
				},
				loadValue: function(data) {
					this.setValue(data.imageSettings.policy);

					orientation.setDisabled(data.imageSettings.policy !== ORIENTATION.POLICY.ALWAYS);
				},
				listeners: {
					select: function(comp, record) {
						var value = record.get("value");

						orientation.setDisabled(value !== ORIENTATION.POLICY.ALWAYS);

						if(value !== ORIENTATION.POLICY.ALWAYS) {
							that.fireEvent("rotation.disabled");

							return;
						}

						that.fireEvent("rotation.enabled");
						that.fireEvent("rotation.changed", orientation.getValue());
					}
				}
			});

			items.push(policy);

			var orientation = new Ext.ux.form.ComboBox({
				fieldLabel: Ext.ux.getI18N("dialog.print.orientation.label"),
				disabled: true,
				readOnly: true,
				cls: "rotation-style",
				width: CONTROL_WIDTH,
				value: ORIENTATION.CW,
				mode: "local",
				store: new Ext.data.SimpleStore({
					fields: ["value", "title"],
					reader: new Ext.data.ArrayReader({}, ["value", "title"]),
					data: [
						[ORIENTATION.CW, Ext.ux.getI18N("dialog.print.orientation.cw")],
						[ORIENTATION.CCW, Ext.ux.getI18N("dialog.print.orientation.ccw")]
					]
				}),
				fetchValue: function(result) {
					result.imageSettings.orientation = this.getValue();
				},
				loadValue: function(data) {
					if(!data.imageSettings.orientation) {
						return;
					}

					this.setValue(data.imageSettings.orientation);
				},
				listeners: {
					select: function(comp, record) {
						if(policy.getValue() !== ORIENTATION.POLICY.ALWAYS) {
							return;
						}

						that.fireEvent("rotation.changed", record.get("value"));
					}
				}
			});

			items.push(orientation);
		},

		createDistributionCombo: function() {
			var fields = ["value", "title"];

			return new Ext.ux.form.ComboBox({
				fieldLabel: Ext.ux.getI18N("dialog.print.paper.type.label"),
				mode: "local",
				cls: "paper-type",
				width: CONTROL_WIDTH,
				disabled: false,
				readOnly: true,
				value: FORMAT.A4,
				fetchValue: function(result) {
					result.pageFormat = this.getValue();
				},
				loadValue: function(data) {
					this.setValue(data.pageFormat);
				},
				store: new Ext.data.SimpleStore({
					fields: fields,
					data: [
						[FORMAT.A4, Ext.ux.getI18N("dialog.print.paper.type.a4")],
						[FORMAT.A3, Ext.ux.getI18N("dialog.print.paper.type.a3")],
						[FORMAT.US_LETTER, Ext.ux.getI18N("dialog.print.paper.type.us_letter")]
					],
					reader: new Ext.data.ArrayReader({}, fields)
				})
			});
		},

		createDistributionControls: function(items) {
			items.push(new Ext.form.Radio({
				name: "distribution",
				fieldLabel: Ext.ux.getI18N("dialog.print.distribution.single"),
				checked: true,
				fetchValue: function(result) {
					result.imageSettings.useMultiplePages = !this.getValue();
				},
				loadValue: function(data) {
					this.setValue(!data.imageSettings.useMultiplePages);
				}
			}));

			items.push(new Ext.form.Radio({
				name: "distribution",
				fieldLabel: Ext.ux.getI18N("dialog.print.distribution.multi"),
				loadValue: function(data) {
					this.setValue(data.imageSettings.useMultiplePages);
				}
			}));
		},

		createLayersControls: function(items) {
			var sg;
			items.push(new Ext.Panel({
				fetchValue: function(result){
					result.layerIds = sg.getSelectionModel().getSelections().map(function(rec){
						return rec.get("id");
					});
				},
				loadValue: function(data){

					var store = sg.getStore(),
						sm = sg.getSelectionModel();
						ids = data.layerIds || [];

					if (!ids.length) { return; }

					var set = function(){
						sm.selectRecords(store.getRange().findAll(function(rec){
							return ids.include(rec.get("id"));
						}))
					};

					store.on("load", set);
					set();
				},
				border: false,
				layout: "column",
				width: 390,
				items: [
					new Ext.form.Label({
						text: Ext.ux.getI18N("dialog.print.layersselection.label")+":",
						width: 205
					}),
					sg = new Ext.ux.grid.LayersSelectionGrid({
						height: 80
					})
				]}));
		},

		

		// TODO: make this method obsolete
		getLanguages: function() {
			var languages = []

			// Explorer
			if(this.facade.getLanguages) {
				languages = this.facade.getLanguages();
			}

			// Editor
			if(this.facade.getAllLanguages) {
				languages = this.facade.getAllLanguages();
			}

			if(!this.isPortal() && languages.length > 0) {
				return languages;
			}

			if(this.isPortal() && languages.length > 1) {
				return languages;
			}

			return [];
		},

		isPortal: function() {
			return Signavio.Config.APPLICATION === 'portal';
		},

		createGeneralControls: function(attrs, items) {
			var languages = this.getLanguages();
			var that = this;

			if(languages.length > 0) {
				var languageSwitch = Ext.ux.form.LanguageSwitch.create({
					languages: languages,
					fetchValue: function(result) {
						if(!this.getValue()) {
							return;
						}

						result.language = this.getValue();
					},
					loadValue: function(data) {
						if(!data.language) {
							return;
						}

						this.setValue(data.language);
						this.setFlag();
					},
					listeners: {
						select: function() {
							that.fireEvent("language.changed", this.getValue());
						}
					}
				});

				// This fixes an issue that only seems to appear under
				// native windows systems running firefox versions around 25
				// The language combo would be scaled too wide because of
				// the padding which is used inside.
				// It kinda smells like a bug in the engine for the
				// box model. But you can't be sure.
				languageSwitch.on("render", function() {
					var parentPadding = this.ownerCt.el.getPadding("lr");
					var parentWidth = this.ownerCt.el.getSize().width - parentPadding;
					var padding = this.ownerCt.labelWidth;
					var triggerWidth = this.trigger.getSize().width;
					var width = this.el.getSize().width + triggerWidth;
					var height = this.el.getSize().height;

					var space = parentWidth - padding;

					if(space - width < 0) {
						this.setSize(space - triggerWidth, height);
					}
				});

				items.push(languageSwitch);
			}

			items.push(new Ext.form.Checkbox({
				name: "bw",
				fieldLabel: Ext.ux.getI18N("dialog.print.black.and.white"),
				listeners: {
					check: function(comp, value) {
						that.fireEvent("image.grayscale", value);
					}
				},
				fetchValue: function(result) {
					result.imageSettings.drawBlackAndWhite = this.getValue();
				},
				loadValue: function(data) {
					this.setValue(data.imageSettings.drawBlackAndWhite);
				}
			}));

			items.push(new Ext.form.Checkbox({
				fieldLabel: Ext.ux.getI18N("dialog.print.show.headers"),
				name: "show-header",
				disabled: attrs.managed,
				fetchValue: function(result) {
					result.disableAllHeaders = !this.getValue();
				},
				loadValue: function(data) {
					this.setValue(!data.disableAllHeaders);
				},
				listeners: {
					check: function(field, value) {
						that.fireEvent("show.headers", value);
					}
				}
			}));

			var configure = new Signavio.ux.dialog.Link({
				text: Ext.ux.getI18N("dialog.print.button.configure"),
				cls: "toggle-read-only",
				hidden: attrs.managed,
				handler: function() {
					this.hide();

					that.fireEvent("configure.page", true);
				}
			});

			items.push(configure);

			configure.hide();

			this.on("show.headers", function(value) {
				if(attrs.managed) {
					return;
				}

				configure.setVisible(value);
			});

			var distribution = this.createDistributionCombo();
			items.push(distribution);
		},

		createFormItems: function(attrs) {
			var items = [];

			var description = Ext.ux.getI18N("dialog.print.label");

			if(attrs.managed) {
				description = Ext.ux.getI18N("dialog.print.label.managed");
			}

			items.push(new Ext.form.Label({
				text: description
			}));

			items.push(this.createSpacer(Ext.ux.getI18N("dialog.print.header.general")));
			this.createGeneralControls(attrs, items);

			if(!this.addBranding()) {
				items.push(this.createSpacer(Ext.ux.getI18N("dialog.print.header.logo")));
				this.createLogoUploadButton(attrs, items);
			}

			items.push(this.createSpacer(Ext.ux.getI18N("dialog.print.header.orientation")));
			this.createOrientationControls(attrs, items);

			items.push(this.createSpacer(Ext.ux.getI18N("dialog.print.header.distribution")));
			this.createDistributionControls(items);

			if (attrs.layers == true){
				items.push(this.createSpacer(Ext.ux.getI18N("dialog.print.layersselection.title")));
				this.createLayersControls(items);
			}

			if(attrs.selection && !attrs.disableSelection) {
				items.push(this.createSpacer(Ext.ux.getI18N("dialog.print.label.selected.models")));
				this.createModelTree(attrs, items);
			}

			return items;
		},

		selectionInInternal: function() {
			return  this.facade.getCurrentRootFolder() !== undefined &&
					this.facade.getCurrentRootFolder().get("rep").type === "internal";
		},

		checkLeafConditions: function(tree, node) {
			var count = 0;
			var preview = node;
			tree.root.cascade(function(child) {
				if(count > 1) {
					return;
				}

				if(!child.leaf || !child.ui.isChecked()) {
					return;
				}

				count = count + 1;
				preview = child;
			});

			if(count === 1) {
				this.loadPreviewImage(preview.attributes.identifier);
			}
		},

		checkSelectionConditions: function(tree, node) {
			if(!node.leaf) {
				return;
			}

			this.checkLeafConditions(tree, node);
		},

		isChecked: function(node) {
			if(!node) {
				return false;
			}

			if(node.isChecked) {
				return node.isChecked();
			}

			if(node.attributes) {
				return node.attributes.checked;
			}

			return false;
		},

		allChildrenSelected: function(parent) {
			if(parent.childNodes.length === 0) {
				return true;
			}

			var result = true;
			var that = this;

			parent.childNodes.each(function(node) {
				result = result && that.isChecked(node);
			});

			return result;
		},

		createViewSelection: function(selection, views, label) {
			var that = this;

			return new Signavio.ux.dialog.Link({
				text: Ext.ux.getI18N("dialog.print.label.select.view"),
				handler: function() {
					var win = new Signavio.ux.dialog.ViewSelection({
						title: Ext.ux.getI18N("dialog.print.label.select.view"),
						diagram: selection.first(),
						views: views,
						btnTitle: Ext.ux.getI18N("btnsave"),
						action: function(comp, view) {
							that.activeView = view;

							var tpl = new Template(Ext.ux.getI18N("dialog.print.label.view.selected"));

							label.getEl().dom.innerHTML = tpl.evaluate({
								view: view.get("rep").view.name
							});

							that.fireEvent("image.changed", view.get("href"));
						}
					});

					win.show();
				}
			});
		},

		createSelectionPreview: function(selection, views, managed) {
			var more = "";

			if(selection.length > 1) {
				more = " " + (new Template(Ext.ux.getI18N("dialog.print.label.more.models"))).evaluate({
					count: selection.length - 1
				});
			}

			var name = selection.first().get("rep").name;

			if(name.include("&amp;") || name.include("&lt;")) {
				name = name.unescapeHTML();
			}

			var model = new Ext.form.Label({
				text: name + more
			});

			var that = this;

			var currentView = new Ext.form.Label({
				cls: "current-view",
				text: ""
			});

			var viewSelection;
			if(selection.length === 1 && views.length > 0) {
				viewSelection = this.createViewSelection(selection, views, currentView);
			}

			var configure;

			if(!managed) {
				configure = new Signavio.ux.dialog.Link({
					text: Ext.ux.getI18N("dialog.print.button.configure"),
					handler: function() {
						that.fireEvent("configure.models");

						delete that.activeView;
					}
				});
			}

			return new Ext.Panel({
				border: false,
				cls: "model-selection",
				items: [model, viewSelection, configure, currentView].compact()
			});
		},

		createModelTree: function(attrs, items) {
			var that = this;

			var preview = this.createSelectionPreview(attrs.selection, attrs.views, attrs.managed);

			items.push(preview);

			if(attrs.managed) {
				return;
			}

			var tree = new Signavio.ux.dialog.tree.ModelCheckPanel({
				height: 250,
				anchor: "-30",
				onNodeCheckChange: function(node) {
					if(!node) {
						return;
					}

					that.checkSelectionConditions(this, node);
				},
				fetchValue: function(result) {
					var models = [];
					var directories = [];

					this.root.cascade(function(node) {
						if(!node.ui.isChecked()) {
							return;
						}

						if(!node.leaf && !that.allChildrenSelected(node)) {
							return;
						}

						if (node.attributes.rel === "mod") {
							models.push(node.attributes.identifier);
						} else {
							directories.push(node.attributes.identifier);
						}
					});

					result.models = models;
					result.directories = directories;
				},
				root: new Signavio.ux.dialog.tree.DefaultRoot(this.facade, {
					checked: false
				})
			}, attrs.selection);

			tree.setVisible(false);

			this.on("configure.models", function() {
				preview.hide();
				tree.setVisible(true);
			});

			items.push(tree);
		},

		createSpacer: function(text) {
			return new Signavio.ux.form.Spacer({
				text: text
			});
		},

		createGeneralForm: function(attrs) {
			var form = new Ext.form.FormPanel({
				border: false,
				labelWidth: 200,
				cls: "form",
				width: 440,
				items: this.createFormItems(attrs),
				fetchValue: function(result) {
					result.imageSettings = {};

					DATA_EXTRACTOR.call(this, result);
				},
				loadValue: DATA_INJECTOR,
				listeners: {
					render: function(comp) {
						Signavio.Utils.defer(function() {
							this.body.setWidth(comp.getInnerWidth());
						}, this);
					}
				}
			});

			return new Ext.Panel({
				width: 460,
				border: false,
				items: [form],
				cls: "form-container",
				fetchValue: DATA_EXTRACTOR,
				loadValue: DATA_INJECTOR
			});
		},

		getDummyProp: function() {
			return {
				stencil: function() {
					return {
						properties: Ext.emptyFn
					};
				},
				title: function() {
					return Ext.ux.getI18N("dialog.print.attribute.own");
				},
				config: function() {
					return {
						singleSelection: true,
						rootElementsOnly: true
					};
				}
			};
		},

		readableAttributeMapperValue: function(value) {
			var items = [];

			value.items.each(function(item) {
				if(items.include(item.title)) {
					return;
				}

				items.push(item.title);
			});

			return items.join(",<br />");
		},

		getAttributeMapper: function(list, type, value) {
			var prop = this.getDummyProp();
			var editor = new Ext.ux.propertyeditor.AttributeMapper(prop, this.facade);

			if(value) {
				editor.getValue = function() {
					return $H(value).toJSON();
				};
			}

			var that = this;

			editor.validProperty = function(property) {
				if(property.list) {
					return false;
				}

				if(property.type === "MetaDataComplex") {
					// It's a table! Run!
					return false;
				}

				if(property.type === "MetaDataStringInfo" && property.lineWrap) {
					// No rich text
					return false;
				}

				if(property.type.toLowerCase() === "text" && property.wrapLines) {
					// Yes, wrapLines, not lineWrap... Folks just always assume they are
					// the first to implement stuff. Why should we stick to definitions
					// that are already there when we can invent new stuff and make it
					// just slightly different from the stuff thats already there.
					return false;
				}

				return true;
			};

			editor.onSave = function(oldValue, newValue) {
				newValue = JSON.parse(newValue);

				if(!newValue.config) {
					newValue.config = {};
				}

				// flag for the backend processer that custom attributes
				// are selected by the user
				newValue.config.selectCustom = true;

				var actions = [
					{
						text: Ext.ux.getI18N("dialog.print.button.edit"),
						cls: "configurable",
						handler: function(list, entry) {
							that.showAttributeMapper(list, entry);
						}
					}
				];

				var newEntry = {
					showCaption: true,
					"class": "AttributeDataContainer",
					attributes: newValue,
					type: type,
					cls: "special",
					title: that.getAttributeName(type)
				};

				if(value) {
					var entry = list.find(function(e) {
						if(e.value["class"] !== "AttributeDataContainer") {
							return false;
						}

						return JSON.stringify(e.value.attributes) === JSON.stringify(JSON.parse(oldValue));
					});

					list.update(entry, that.getListValue(newEntry));
				} else {
					list.add(newEntry, actions);
				}
			};

			return editor;
		},

		getAttributeName: function(attribute) {
			return Ext.ux.getI18N("dialog.print.attribute." + attribute);
		},

		getAttributeStore: function() {
			var fields = ["active", "value", "title"];

			return new Ext.data.SimpleStore({
				fields: fields,
				reader: new Ext.data.ArrayReader({}, fields),
				data: [
					[true, "", ""],
					[true, "ownAttribute", this.getAttributeName("ownAttribute")],
					[true, "lastAuthor", this.getAttributeName("lastAuthor")],
					[true, "publishingDate", this.getAttributeName("publishingDate")],
					[true, "publishingStatus", this.getAttributeName("publishingStatus")],
					[true, "authors", this.getAttributeName("authors")],
					[true, "updateDate", this.getAttributeName("updateDate")],
					[true, "modelPath", this.getAttributeName("modelPath")],
					[true, "pageNumber", this.getAttributeName("pageNumber")],
					[true, "printDate", this.getAttributeName("printDate")],
					[true, "printedBy", this.getAttributeName("printedBy")]
				]
			});
		},

		getAttributeCombo: function(store) {
			var tpl = "" +
				'<tpl for=".">' +
					'<tpl if="active">' +
						"<div class='x-combo-list-item'>{title}</div>" +
					"</tpl>" +
					'<tpl if="!active">' +
						"<div class='x-combo-list-item item-inactive'>{title}</div>" +
					"</tpl>" +
				"</tpl>";

			return new Ext.ux.form.ComboBox({
				mode: "local",
				anchor: "-20",
				store: store,
				allowBlank: true,
				readOnly: true,
				cls: "pdf-attribute-selector-combo",
				ctCls: "configurable-container",
				listClass: "pdf-attribute-selector",
				tpl: new Ext.XTemplate(tpl)
			});
		},

		getListValue: function(value) {
			return {
				text: value.title,
				value: value,
				cls: value.cls
			};
		},

		getAttributeList: function(combo, store) {
			var that = this;

			var change = function(record, key, value) {
				store.suspendEvents();

				record.set(key, value);

				store.resumeEvents();
				store.fireEvent("datachanged");

				that.fireEvent("attributes.changed");
			};

			return new Signavio.ux.dialog.List({
				size: 3,
				labelCls: "configurable",
				emptyText: Ext.ux.getI18N("dialog.print.attribute.hint"),
				equals: function(a, b) {
					return a.value === b.value;
				},
				add: function(value, actions, clb) {
					var index = store.findBy(function(record) {
						return record.get("value") === value.type;
					});
					var record = store.getAt(index);
					var listValue = that.getListValue(value);

					listValue.actions = (actions || []).concat([
						{
							text: Ext.ux.getI18N("dialog.print.button.remove"),
							cls: "configurable",
							handler: function(list, entry) {
								list.remove(entry);

								change(record, "active", true);

								combo.setVisible(!list.full());
								combo.setWidth(combo.ownerCt.getInnerWidth() - 2 * Signavio.Config.COMPONENT_SPACING);
							}
						}
					]);

					Signavio.ux.dialog.List.prototype.add.call(this, listValue, clb);

					if(value["class"] === "ReportMetaDataContainer") {
						change(record, "active", false);
					}

					combo.setValue("");
					combo.setVisible(!this.full());
				}
			});
		},

		handleAttributeSelect: function(combo, list, record) {
			var type = record.get("value");

			if(!type) {
				return;
			}

			if(type === "ownAttribute") {
				var editor = this.getAttributeMapper(list, type);
				editor.onTriggerClick();

				combo.setValue("");

				return;
			}

			list.add({
				showCaption: true,
				"class": "ReportMetaDataContainer",
				type: type,
				title: record.get("title")
			});
		},

		showAttributeMapper: function(list, entry) {
			var type = entry.value.type;
			var value = entry.value.attributes;

			var editor = this.getAttributeMapper(list, type, value);
			editor.onTriggerClick();
		},

		listUpdate: function(list, entry) {
			if(entry.value["class"] !== "AttributeDataContainer") {
				return;
			}

			var label = list.getElement(entry);

			Signavio.Utils.defer(function() {
				// wait for the label to be rendered
			    new Ext.ToolTip({
					target: label,
					html: this.readableAttributeMapperValue(entry.value.attributes)
				});
			}, this);
		},

		createAttribute: function(width) {
			var store = this.getAttributeStore();
			var combo = this.getAttributeCombo(store);
			var list = this.getAttributeList(combo, store);

			var that = this;

			combo.on("select", function(field, record) {
				that.handleAttributeSelect(field, list, record);
			});

			list.on("rerender", function() {
				list.entries.each(function(entry) {
					that.listUpdate(list, entry);
				});
			});

			this.on("configure.page", function(value) {
				if(!value) {
					return;
				}

				Signavio.Utils.defer(function() {
					combo.syncSize();
				});
			});

			return new Ext.Panel({
				border: false,
				collapsible: false,
				columnWidth: width,
				layout: "anchor",
				cls: "attribute",
				items: [list, combo],
				fetchValue: function(result) {
					result.containers.push(list.getValues());
				},
				loadValue: function(data) {
					var values = data.containers.shift() || [];

					values.each(function(value) {
						var actions = [];

						if(value["class"] === "AttributeDataContainer") {
							actions.push({
								text: Ext.ux.getI18N("dialog.print.button.edit"),
								cls: "configurable",
								handler: function(list, entry) {
									that.showAttributeMapper(list, entry);
								}
							});

							value.cls = "special";
						}

						// translate the title of the attribute according to language
						value.title = that.getAttributeName(value.type);

						list.add(value, actions);
					});
				}
			});
		},

		createAttributes: function(number, cls) {
			var items = [];
			var that = this;

			number.times(function() {
				items.push(that.createAttribute(1/number));
			});

			var panel = new Ext.Panel({
				border: false,
				collapsible: false,
				anchor: "100%",
				layout: "column",
				cls: cls,
				items: items,
				fetchValue: function(result) {
					result.containers = result.containers || [];

					DATA_EXTRACTOR.call(this, result);
				},
				loadValue: DATA_INJECTOR
			});

			panel.setVisible(false);

			this.on("show.headers", function(value) {
				panel.setVisible(value);
				panel.doLayout();
			});

			return panel;
		},

		getImageUrl: function(revivision, language) {
			var queryParams = [
				Ext.Ajax.getSecurityParameter(),
				Ext.Ajax.extraParams
			].compact().map(function(param) {
				return Object.toQueryString(param);
			}).join("&");

			return Signavio.Config.BACKEND_PATH +
				revivision +
				"/png" +
				(language ? "/" + language : "") +
				"?" +
				queryParams;
		},

		getLanguage: function() {
			return this.currentSelectedLanguage;
		},

		createImage: function(src) {
			var that = this;
			var img = new Image();
			img.onload = function() {
				that.fireEvent("image.loaded", img);
			};
			img.src = src;

			return new Ext.Element(img);
		},

		getImage: function(revision, language) {
			this.fireEvent("image.loading");

			return this.createImage(this.getImageUrl(revision, language));
		},

		loadPreviewImage: function(rel) {
			this.fireEvent("image.changed", rel);
		},

		requestImage: function(preview, language) {
			this.fireEvent("image.loading");

			var that = this;

			var params = {
				type: "png",
				json: this.getJSON()
			};

			if(language) {
				params.suffix = language;
			}

			Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + "/preview", {
				method: "POST",
				async: true,
				params: params,
				success: function(data) {
					if(!data) {
						that.fireEvent("image.preview.failed");

						return;
					}

					var img = that.createImage("data:image/png;base64," + data);

					preview.body.replaceWith(img);
				},
				error: function() {
					that.fireEvent("image.preview.failed");
				}
			});
		},

		createPreviewImage: function(attrs) {
			var that = this;

			var preview = new Ext.Panel({
				border: false,
				collapsible: false,
				cls: "preview",
				html: "",
				disable: function() {
					this.addClass("disabled");

					this.getEl().update(Ext.ux.getI18N("dialog.print.label.preview.unavailable"));
				},
				enable: function() {
					this.removeClass("disabled");
				}
			});

			var currentLanguage;

			var load = function(src, language) {
				var img = that.getImage(src, language);
				preview.body.replaceWith(img);
			};

			this.on("language.changed", function(language) {
				currentLanguage = language;
			});

			if(Signavio.Utils.isModel(attrs.diagram) || attrs.trustComponent) {
				var lastImageSource = attrs.diagram.get("rep").revision;

				this.on("language.changed", function(language) {
					load(lastImageSource, language);
				});

				preview.on("render", function() {
					load(lastImageSource);
				});
			} else if(attrs.useJSON) {
				this.on("language.changed", function(language) {
					if(lastImageSource) {
						load(lastImageSource, language);
					} else {
						that.requestImage(preview, language);
					}
				});

				preview.on("render", function() {
					that.requestImage(this);
				});
			}

			this.on("image.grayscale", function(value) {
				if(value) {
					preview.addClass("grayscale");
				} else {
					preview.removeClass("grayscale");
				}
			});

			this.on("image.changed", function(src) {
				var img = that.getImage(src, currentLanguage);
				lastImageSource = src;

				preview.body.replaceWith(img);
			});

			this.on("image.loaded", function(img) {
				preview.body.initialWidth = img.width;
				preview.body.initialHeight = img.height;
			});

			this.on("rotation.enabled", function() {
				that.enableRotation(preview);
			});

			this.on("rotation.disabled", function() {
				that.disableRotation(preview);
			});

			this.on("rotation.changed", function(orientation) {
				preview.removeClass("rotate-cw");
				preview.removeClass("rotate-ccw");

				if(orientation === ORIENTATION.CW) {
					preview.addClass("rotate-cw");
				}

				if(orientation === ORIENTATION.CCW) {
					preview.addClass("rotate-ccw");
				}
			});
			
			return preview;
		},

		isHorizontal: function(image) {
			return image.getWidth() > image.getHeight();
		},

		isRotated: function(preview) {
			var el = preview.getEl();

			return el.hasClass("rotate-cw") || el.hasClass("rotate-ccw");
		},

		resetPreview: function(preview) {
			preview.body.setStyle("width", "initial");
			preview.body.setStyle("height", "initial");
		},

		disableRotation: function(preview) {
			preview.removeClass("rotate-cw");
			preview.removeClass("rotate-ccw");

			preview.body.setStyle("maxWidth", "100%");
			preview.body.setStyle("maxHeight", "100%");

			this.resetPreview(preview);
		},

		updateRotation: function(preview) {
			if(!this.isRotated(preview)) {
				return;
			}

			this.resetPreview(preview);
			this.enableRotation(preview);
		},

		enableRotation: function(preview) {
			var isHorizontal = this.isHorizontal(preview.body);

			var parent = preview.body.parent();
			var height = parent.getHeight();
			var width = parent.getWidth();

			if(isHorizontal) {
				var previewWidth = Math.min(height, preview.body.initialWidth);

				preview.body.setWidth(previewWidth);
				preview.body.setStyle("maxWidth", "initial");
			} else {
				var previewHeight = Math.min(width, preview.body.initialHeight);

				preview.body.setHeight(previewHeight);
				preview.body.setStyle("maxHeight", "initial");
				preview.body.setStyle("maxWidth", width);
			}
		},

		createDiagramName: function() {
			return {
				border: false,
				collapsible: false,
				columnWidth: 0.7,
				cls: "diagram-name",
				html: Ext.ux.getI18N("dialog.print.diagram.name")
			};
		},

		getLicenses: function() {
			// Explorer
			if(this.facade.getCurrentUser) {
				var user = this.facade.getCurrentUser();
				var info = user.getRecords("info")[0];

				if(!info) {
					return [];
				}

				return info.get("rep").licenses;
			}

			// Editor
			var meta = this.facade.getModelMetaData();
			return meta.licenses;
		},

		isTrial: function() {
			var licenses = this.getLicenses();

			var noTrial = licenses.any(function(license) {
				return Signavio.Config.MAIN_LICENSES.include(license.toLowerCase());
			});

			return !noTrial;
		},

		isAcademic: function() {
			if(this.facade.getConfig) {
				// Explorer
				return this.facade.getConfig().isAcademic;
			}

			// Editor
			return this.facade.getModelMetaData().mode === "Academic";
		},

		isArchiMate: function() {
			var licenses = this.getLicenses();

			return licenses.map(function(value) {
				return value.toLowerCase();
			}).include("archimate");
		},

		addBranding: function() {
			return this.isAcademic() || this.isTrial() || this.isArchiMate();
		},

		createLogoUploadButton: function(attrs, items) {
			var that = this;
			var text = Ext.ux.getI18N("dialog.print.button.upload");

			var button = new Ext.form.TriggerField({
				value: text,
				cls: "upload",
				readOnly: true,
				disabled: attrs.managed,
				triggerClass: "logo-select",
				width: CONTROL_WIDTH,
				fieldLabel: Ext.ux.getI18N("dialog.print.header.logo"),
				fetchValue: function(result) {
					if(!this.logo) {
						delete result.logoFileId;

						return;
					}

					result.logoFileId = this.logo.get("href");
				},
				loadValue: function(data) {
					if(!data.logoFileId) {
						return;
					}

					that.loadLogo(data.logoFileId);
				},
				onTriggerClick: function() {

					if (this.disabled){
						return;
					}
					
					var href;

					if(this.logo) {
						href = this.logo.get("href");
					}

					var dialog = that.getUploadDialog(href, function() {
						that.fireEvent("logo.removed");
					});
					dialog.show();

					dialog.on("file.selected", function(image) {
						that.fireEvent("logo.selected", image);
					});
				}
			});

			this.on("logo.selected", function(image) {
				button.logo = image;
				button.setValue(image.get("rep").name);
			});
			this.on("logo.removed", function() {
				delete button.logo;
				button.setValue(text);
			});

			var originalSize = new Ext.form.Checkbox({
				fieldLabel: Ext.ux.getI18N("dialog.print.logo.label"),
				disabled: attrs.managed,
				fetchValue: function(result) {
					result.keepOriginalLogoSize = this.getValue();
				},
				loadValue: function(data) {
					this.setValue(data.keepOriginalLogoSize === true);
				}
			});

			items.push(button, originalSize);
		},

		getUploadDialog: function(logo, onRemove) {
			return new Signavio.ux.dialog.FileUpload(this.facade, {
				title: Ext.ux.getI18N("dialog.print.button.upload"),
				allowedTypes: ["png", "jpg", "jpeg", "gif"],
				value: logo,
				buttons: [
					{
						text: Ext.ux.getI18N("dialog.print.button.remove.picture"),
						handler: function() {
							this.ownerCt.close();

							onRemove();
						}
					}
				]
			});
		},

		loadLogo: function(href) {
			var that = this;

			var update = function(rel, rep) {
				var record = new Signavio.Utils.DummyRecord({
					href: href,
					rel: rel,
					rep: rep
				});

				that.fireEvent("logo.selected", record);
			};

			// Explorer:
			if (Signavio.Core.StoreManager) {
				Signavio.Core.StoreManager.getStore(href, true, function(store) {
					var info;

					store.each(function(record) {
						if(record.get("rel") !== "info") {
							return;
						}

						info = record;
					});

					if(!info) {
						return;
					}

					update(info.get("rel"), info.get("rep"));
				});
			} else {
				// Editor:
				Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + href, {
					success: function(values) {
						var info = values.find(function(value) {
							return value.rel === "info";
						});

						if (!info) {
							return;
						}

						update(info.rel, info.rep);
					}
				});
			}
		},

		createLogo: function() {
			var branded = this.addBranding();

			var cls = ["logo"];

			if(branded) {
				cls.push("branded");
			}

			var panel = new Ext.Panel({
				border: false,
				collapsible: false,
				columnWidth: 0.3,
				cls: cls.join(" ")
			});

			if(branded) {
				return panel;
			}

			var logo = new Ext.form.Label({
				text: Ext.ux.getI18N("dialog.print.label.no.logo"),
				cls: "inactive"
			});
			panel.add(logo);

			var update = function(content) {
				panel.remove(logo);
				logo = content;
				panel.add(logo);
				panel.doLayout();
			};

			this.on("logo.removed", function() {
				update(new Ext.form.Label({
					text: Ext.ux.getI18N("dialog.print.label.no.logo"),
					cls: "inactive"
				}));
			});

			this.on("logo.selected", function(image) {
				update(new Signavio.ux.Image({
					src: Signavio.Config.BACKEND_PATH + image.get("href") + "/content",
					maxHeight: 20,
					maxWidth: 100
				}));
			});

			return panel;
		},

		createHeader: function(attrs) {
			return new Ext.Panel({
				border: false,
				anchor: "100%",
				collapsible: false,
				height: 30,
				cls: "header",
				layout: "column",
				items: [
					this.createDiagramName(),
					this.createLogo(attrs)
				],
				fetchValue: DATA_EXTRACTOR,
				loadValue: DATA_INJECTOR
			});
		},

		createPage: function(attrs) {
			var preview = this.createPreviewImage(attrs);
			var header = this.createHeader(attrs);
			var top = this.createAttributes(3, "top-bar");
			var bottom = this.createAttributes(3, "bottom-bar");

			var that = this;
			var mask;

			var page = new Ext.Panel({
				border: false,
				collapsible: false,
				layout: "anchor",
				cls: "page-preview",
				padding: 40,
				items: [header,	top, preview, bottom],
				landscape: function() {
					var width = this.ownerCt.getInnerWidth() - this.padding;
					var height = width / 1.41;

					return this.setSize(width, height);
				},
				portrait: function() {
					var minHeight = 700;

					var height = Math.max(this.ownerCt.getInnerHeight() - this.padding, minHeight);
					var width = height / 1.41;

					return this.setSize(width, height);
				},
				fetchValue: DATA_EXTRACTOR,
				loadValue: DATA_INJECTOR,
				updatePreview: function() {
					var pad = Signavio.Config.COMPONENT_SPACING;
					var height = 0, padding = pad;

					if(!preview.rendered) {
						return;
					}

					[header, top, bottom].each(function(item) {
						if(!item.rendered) {
							return;
						}

						var size = item.getSize();

						height = height + size.height;

						if(item !== bottom) {
							padding = padding + size.height;
						}
					});

					height = page.getSize().height - height - pad;

					preview.body.parent().setStyle("height", height + "px");

					that.updateRotation(preview);

					preview.setPosition(0, padding);
				},
				listeners: {
					render: function() {
						if(attrs.horizontal) {
							this.landscape();
						} else {
							this.portrait();
						}

						Signavio.Utils.defer(function() {
							that.fireEvent("configure.page", false);
						});
					},
					resize: function() {
						if(!mask) {
							return;
						}

						// this is pretty ugly, but the mask element does not
						// contain the message..
						var message = mask.dom.nextSibling;
						var el = new Ext.Element(message);

						el.center(this.getEl());
					}
				}
			});

			this.on("show.headers", function(value) {
				if(!value) {
					page.addClass("no-headers");
				} else {
					page.removeClass("no-headers");
				}

				page.updatePreview();
			});

			this.on("attributes.changed", page.updatePreview);
			this.on("image.loading", function() {
				preview.enable();
				mask = page.getEl().mask(Ext.ux.getI18N("dialog.print.mask.load.preview"), "disabled");
			});
			this.on("image.loaded", function() {
				page.updatePreview();
				page.getEl().unmask();
				mask = null;
			});
			this.on("image.preview.failed", function() {
				page.getEl().unmask();
				preview.disable();
			});
			this.on("configure.page", function(configure) {
				if(!configure) {
					return page.addClass("read-only");
				}

				page.removeClass("read-only");
				page.updatePreview();

				Signavio.Utils.defer(function() {
					page.doLayout();
				});
			});

			return page;
		},

		createPreview: function(attrs) {
			var page = this.createPage(attrs);

			return new Ext.Panel({
				border: false,
				columnWidth: 1,
				cls: "attributes",
				items: page,
				listeners: {
					render: function(comp) {
						comp.setHeight(comp.ownerCt.getInnerHeight());
					}
				},
				fetchValue: DATA_EXTRACTOR,
				loadValue: DATA_INJECTOR,
				updateOrientation: function(orientation) {
					if(!page.rendered) {
						return;
					}

					this.setHeight(this.ownerCt.getInnerHeight());

					orientation = orientation || this.orientation;
					this.orientation = orientation;

					if(orientation === ORIENTATION.LANDSCAPE) {
						page.landscape();
					} else {
						page.portrait();
					}

					page.updatePreview();
				}
			});
		}
	});
}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

ns("ux.dialog");

(function() {

	var RESOURCE = {
		UPLOAD: "upload",
		INTERNAL: "internal",
		EXTERNAL: "external"
	};

	Signavio.ux.dialog.FileUpload = function(facade, attrs) {
		attrs = attrs || {};

		this.facade = facade;

		this.addEvents({
			"file.selected": true,
			"upload.type.changed": true
		});

		// Use flag to change texts within dialog (e.g. replace "file/picture" with "picture")
		this.domainKey = attrs.domainKey ? "." + attrs.domainKey : "";

		attrs.disableUpload = attrs.disableUpload || this.fileUploadDisabled(facade);

		var form = this.createForm(attrs);

		var that = this;

		attrs.items = attrs.items || form;
		attrs.title = attrs.title || this.getI18N("title");
		attrs.width = 400;
		attrs.modal = true;
		attrs.buttons = [].concat(attrs.buttons || []).concat([
			{
				text: attrs.saveText || Ext.ux.getI18N("btnsave"),
				handler: function() {
					form.getValue(function(value) {
						that.fireEvent("file.selected", value, that.isUrl(value));

						that.close();
					});
				}
			}
		]);

		attrs.cls = "file-upload";

		Signavio.ux.dialog.FileUpload.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.dialog.FileUpload, Ext.ux.Window, {

		fileUploadDisabled: function(facade) {
			// TODO: unify if explorer and everything
			// else share the same facade
			var enabled = true;

			if(facade.getConfig) {
				var config = facade.getConfig();

				enabled = enabled && facade.getConfig("department", "fileUpload") !== false;
				enabled = enabled && !this.fileQuotaReached(config);

				return !enabled;
			}

			return !facade.getModelMetaData().fileupload;
		},

		fileQuotaReached: function(config) {
			if(config.allFilesByteQuota === 0) {
				return true;
			}

			var percentUsed = 100 * (config.usedFileQuotaBytes / config.allFilesByteQuota);

			return Math.round(percentUsed) === 100;
		},

		createForm: function(attrs) {
			var info = this.getInfo(attrs);
			var spacer = new Signavio.ux.form.Spacer({
				text: this.getI18N("label.choose.spacer")
			});

			return new Ext.Panel({
				border: false,
				cls: "form",
				getValue: function(clb) {
					this.items.each(function(item) {
						if(!item.getFile) {
							return;
						}

						item.getFile(clb);
					});
				},
				items: [info, spacer].concat(this.createFormItems(attrs))
			});
		},

		getConfig: function() {
			// Merge into one, when Explorer and everything else
			// share one facade
			if(this.facade.getConfig) {
				return this.facade.getConfig();
			}

			return this.facade.getModelMetaData();
		},

		getMaxSize: function() {
			var config = this.getConfig();

			return config.singleFileByteQuota;
		},

		getI18N: function(key) {
			if(!key.startsWith(".")) {
				key = [".", key].join("");
			}

			var field = ["dialog.upload", this.domainKey, key].join("");
			var base = ["dialog.upload", key].join("");

			return Ext.ux.getI18N(field) || Ext.ux.getI18N(base);
		},

		getDescription: function(attrs) {
			if(attrs.disabled) {
				return this.getI18N("label.disabled");
			}

			if(attrs.disableUpload) {
				return this.getI18N("label.upload.disabled");
			}

			return this.getQuotaInfo() + " " + this.getMaxSizeInfo();
		},

		getMaxSizeInfo: function() {
			return this.getI18N("label.max.size")
				+ Signavio.Utils.BeautifySize(this.getMaxSize())
				+ ".";
		},

		getUsedQuota: function() {
			var config = this.getConfig();

			return Signavio.Utils.BeautifySize(config.usedFileQuotaBytes);
		},

		getMaxQuota: function() {
			var config = this.getConfig();

			return Signavio.Utils.BeautifySize(config.allFilesByteQuota);
		},

		getQuotaInfo: function() {
			var used = this.getUsedQuota();
			var max = this.getMaxQuota();

			var tpl = new Template(this.getI18N("label.quota.info"));

			return tpl.evaluate({
				used: used,
				available: max
			});
		},

		getInfo: function(attrs) {
			return new Ext.form.Label({
				text: this.getDescription(attrs),
				cls: "description"
			});
		},

		createUploadForm: function(attrs) {
			var file = new Ext.form.TextField({
				inputType: "file",
				fieldLabel: Ext.ux.getI18N("dialog.upload.label.file"),
				name: "file",
				cls: "x-upload-fiel-textfield",
				listeners: {
					render: function(comp) {
						if(!attrs.allowedTypes) {
							return;
						}

						comp.getEl().dom.setAttribute("accept", attrs.allowedTypes.join(","));
					}
				}
			});

			var folderPicker = new Signavio.ux.form.FolderPicker(this.facade, {
				name: "directory",
				disabled: attrs.update,
				fieldLabel: Ext.ux.getI18N("dialog.upload.label.file.destination")
			});

			var securityParam = Signavio.Utils.getSecurityParameterField();

			var that = this;

			var component = new Ext.form.FormPanel({
				disabled: attrs.disabled || attrs.disableUpload,
				border: false,
				fileUpload: true,
				labelWidth: 150,
				cls: "form",
				getUrl: function() {
					var url = Signavio.Config.BACKEND_PATH + "/file";

					if(attrs.update) {
						return url + "/" + attrs.update.get("href").replace("/file/", "");
					}

					return url;
				},
				uploadFile: function(clb) {
					var title = attrs.title, message;

					if(!attrs.update && !folderPicker.getValue()) {
						message = that.getI18N("error.no.folder.selected");

						that.showMessage(title, message);

						return;
					}

					if(!file.getValue()) {
						message = that.getI18N("error.no.file.selected");

						that.showMessage(title, message);

						return;
					}

					var folder = folderPicker.getEl().dom.value;
					folderPicker.getEl().dom.value = folderPicker.getValue();

					var form = this.getForm();

					that.doUpload(form, function(response) {
						folderPicker.getEl().dom.value = folder;

						clb(response);
					});
				},
				items: [
					file,
					folderPicker,
					securityParam
				]
			});

			this.on("upload.type.changed", function(type) {
				component.setDisabled(type !== RESOURCE.UPLOAD);
			});

			return component;
		},

		doUpload: function(form, clb) {
			form.errorReader = {
				read: function(e) {
					return {
						success: e.responseText.toLowerCase().replace(/<.*?pre.*?>/g, '').startsWith("{"),
						records: []
					};
				}
			};

			var that = this;

			that.body.mask(this.getI18N("action.upload"), "disabled");

			form.submit({
				url: form.getUrl(),
				waitMsg: this.getI18N("action.upload"),
				method: "POST",
				success: function(form, action) {
					that.body.unmask();

					var response = action.response;

					// TODO: TEST IN ALLEN BROWSERN
					// Might cause errors in the future of if special characters are transported
					// or strict mode is used
					var div = document.createElement("div");
					div.innerHTML = response.responseText;

					that.onUploadSuccess(JSON.parse(div.textContent || div.innerHTML), clb);
				},
				failure: function() {
					that.body.unmask();

					that.onUploadError(clb);
				}
			});
		},

		showMessage: function(title, message, clb) {
			Ext.MessageBox.show({
				title: title,
				msg: message,
				modal: true,
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.INFO,
				fn: function() {
					if(!clb) {
						return;
					}

					clb();
				}
			});
		},

		showErrorMessage: function(error) {
			var title = this.getI18N("error.file.too.big.title");

			switch(error) {
			case "file_size_violates_single_file_quota":
				this.showMessage(title, this.getI18N("error.file.too.big.single"));
				break;
			case "file_size_violates_all_files_quota":
				this.showMessage(title, this.getI18N("error.file.too.big.all"));
				break;
			}
		},

		onUploadSuccess: function(response, clb) {
			if(response.error) {
				return this.showErrorMessage(response.error);
			}

			clb(response);
		},

		onUploadError: function(clb) {
			var title = Ext.ux.getI18N("dialog.upload.error.file.too.big.title");
			var message = this.getI18N("error.file.too.big.description");

			this.showMessage(title, message, clb);
		},

		isAllowedType: function(allowedTypes, record) {
			if(!allowedTypes || !Signavio.Utils.isFile(record)) {
				return true;
			}

			var rep = record.get("rep");
			var mimeType = rep.mimeType;
			var extension = rep.extension;

			return allowedTypes.include(mimeType) || allowedTypes.include(extension);
		},

		createFilePicker: function(attrs) {
			var filter = attrs.filter || [
				Signavio.Const.REL.DIRECTORY,
				Signavio.Const.REL.FILE
			];

			var that = this;

			var filterFn = function(record) {
				// Editor facade does not have this method, but then this record also does not show
				// up in the folder store in the editor... what is going on here!?
				if(that.facade.getTrashRecord && Signavio.Utils.isTrashFolder(record, that.facade)) {
					return false;
				}

				if(!that.isAllowedType(attrs.allowedTypes, record)) {
					return false;
				}

				return true;
			};

			var component = new Signavio.ux.dialog.tree.Panel({
				height: 200,
				filterFn: filterFn,
				getFile: function() {
					var record = this.getSelectedRecord();

					if(!Signavio.Utils.isFile(record)) {
						return;
					}

					if(!record.data) {
						return new Signavio.Utils.DummyRecord(record);
					}

					return record;
				},
				root: new Signavio.ux.dialog.tree.DefaultRoot(this.facade, {
					isChildLeaf: Signavio.Utils.isFile,
					recordRel: filter,
					filterFn: filterFn
				})
			});

			this.on("upload.type.changed", function(type) {
				component.setDisabled(type !== RESOURCE.INTERNAL);
			});

			return component;
		},

		createFile: function(attrs, items) {
			var that = this;

			var fileSwitch = new Ext.form.Radio({
				disabled: attrs.disabled,
				checked: false,
				name: "upload.type",
				boxLabel: this.getI18N("label.existing.file"),
				getFile: function(clb) {
					if(!this.getValue()) {
						return;
					}

					var file = filePicker.getFile();

					if(!file) {
						var title = attrs.title;
						var message = that.getI18N("error.no.image.selected");

						that.showMessage(title, message);

						return;
					}

					clb(file);
				},
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.fireEvent("upload.type.changed", RESOURCE.INTERNAL);
					}
				}
			});

			this.on("upload.type.changed", function(type) {
				if(type !== RESOURCE.INTERNAL || fileSwitch.getValue()) {
					return;
				}

				fileSwitch.setValue(true);
			});

			var filePicker = this.createFilePicker(attrs);

			this.on("show", function() {
				if(attrs.disabled) {
					return;
				}

				if(that.isFile(attrs.value) || (attrs.disableUpload && !that.isUrl(attrs.value))) {
					fileSwitch.setValue(true);

					filePicker.on("tree.loaded", function() {
						filePicker.expandTo(attrs.value);
					});
				}
			});

			items.push(fileSwitch, filePicker);
		},

		isFile: function(value) {
			return value && !this.isUrl(value);
		},

		createUpload: function(attrs, items) {
			var that = this;

			var uploadForm = this.createUploadForm(attrs);
			var uploadSwitch = new Ext.form.Radio({
				disabled: attrs.disabled || attrs.disableUpload,
				checked: false,
				name: "upload.type",
				hidden: attrs.uploadOnly,
				boxLabel: this.getI18N("label.new.file"),
				getFile: function(clb) {
					if(!this.getValue()) {
						return;
					}

					uploadForm.uploadFile(function(file) {
						if(!file) {
							return;
						}

						clb(new Signavio.Utils.DummyRecord(file));
					});
				},
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.fireEvent("upload.type.changed", RESOURCE.UPLOAD);
					}
				}
			});

			this.on("show", function() {
				if(attrs.disabled || attrs.disableUpload) {
					return;
				}

				if(!attrs.value) {
					uploadSwitch.setValue(true);
				}

				// Editor
				if(!that.facade.getConfig) {
					Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + "/config", {
						success: function(config) {
							if(!that.fileQuotaReached(config)) {
								return;
							}

							uploadForm.disable();
							uploadSwitch.disable();

							that.fireEvent("upload.type.changed", RESOURCE.INTERNAL);
						}
					});
				}
			});

			items.push(uploadSwitch, uploadForm);
		},

		isUrl: function(value) {
			if(!Ext.isArray(value)) {
				return false;
			}

			value = value[0];

			return value && Ext.isDefined(value.url) && Ext.isDefined(value.label);
		},

		createUrlForm: function(attrs) {
			// use a url list field but suppress the list property, since multiple links make no sense here
			var component = new Ext.ux.form.UrlLinkFieldList({
				disabled: !attrs.allowExternals,
				anchor: "100%",
				emptyListText: this.getI18N("label.external.empty"),
				cls: "external-link-field",
				// prevent adding elements to the "list" since a list doesn't make sese here and is suppressen in css
				onTriggerClick: function () {
					return;
				}
			});

			if(this.isUrl(attrs.value) && attrs.allowExternals) {
				component.on("render", function() {
					component.setRawValue(attrs.value[0]);
				});
			}

			this.on("upload.type.changed", function(type) {
				component.setDisabled(type !== RESOURCE.EXTERNAL);
			});

			return component;
		},

		createUrl: function(attrs, items) {
			var that = this;

			var urlForm = this.createUrlForm(attrs);
			var urlSwitch = new Ext.form.Radio({
				name: "upload.type",
				boxLabel: this.getI18N("label.external.file"),
				disabled: !attrs.allowExternals,
				getFile: function(clb) {
					if(!this.getValue()) {
						return;
					}

					var value = urlForm.getValue();

					if(!value || value.length === 0) {
						var title = attrs.title;
						var message = Ext.ux.getI18N("dialog.upload.error.no.url");

						that.showMessage(title, message);

						return;
					}

					clb(value);
				},
				listeners: {
					check: function(comp, value) {
						if(!value) {
							return;
						}

						that.fireEvent("upload.type.changed", RESOURCE.EXTERNAL);
					}
				}
			});

			this.on("show", function() {
				if(that.isUrl(attrs.value) && attrs.allowExternals) {
					urlSwitch.setValue(true);
				}
			});

			items.push(urlSwitch, urlForm);
		},

		createFormItems: function(attrs) {
			var items = [];

			this.createUpload(attrs, items);

			if(attrs.uploadOnly) {
				return items;
			}

			items.push(new Signavio.ux.form.Spacer({
				text: this.getI18N("label.spacer.or")
			}));

			this.createFile(attrs, items);

			if(!attrs.allowExternals) {
				// Hide the third option and not only disable it.
				return items;
			}

			items.push(new Signavio.ux.form.Spacer({
				text: this.getI18N("label.spacer.or")
			}));

			this.createUrl(attrs, items);

			return items;
		}
	});
}());
ns("ux.dialog");

(function() {
	
	Signavio.ux.dialog.ViewSelection = function(attrs) {
		attrs = attrs || {};

		var that = this;

		this.getTitle = function() {
			return attrs.title || "";
		};

		attrs.views = attrs.views || [];
		attrs.showFor = attrs.showFor || [];

		attrs = this.setup(attrs);

		this.addSettings = attrs.addSettings || function() {
			return [];
		};

		attrs.buttons = [
			{
				text: attrs.btnTitle,
				handler: function() {
					var selectedView = that.getCurrentViewId(topPanel.getDataView(), viewSelector.getDataView());

					attrs.action(that, selectedView, topPanel.getOptions());
					
					this.ownerCt.close();
				}
			}
		];

		var showViews = attrs.views.length !== 0;
		var topPanel = this.createTopPanel(attrs, showViews);
		var viewSelector = this.createViewSelector(attrs.views);
		
		topPanel.getDataView().on("selectionchange", function(comp, selection) {
			that.handleSelectionChange(viewSelector.getDataView(), selection);
		});
		viewSelector.getDataView().on("selectionchange", function(comp, selection) {
			that.handleSelectionChange(topPanel.getDataView(), selection);
		});

		attrs.items = [topPanel, viewSelector];
		
		if(!showViews) {
			viewSelector.hide();
		}

		// Description has been generated by us.
		// No need for the standard.
		delete attrs.description;

		Signavio.ux.dialog.ViewSelection.superclass.constructor.call(this, attrs);

		this.on("show", function() {
			if(showViews) {
				this.addClass("with-views");
			}

			topPanel.getDataView().select(0);
			this.syncSize();
		});
	};
	
	Ext.extend(Signavio.ux.dialog.ViewSelection, Ext.ux.Window, {
		
		handleSelectionChange: function(dataView, selection) {
			if(selection.length === 0) {
				return;
			}

			var currentSelection = dataView.getSelectedIndexes().first();
			
			if(Ext.isDefined(currentSelection)) {
				dataView.deselect(currentSelection);
			}
		},

		setup: function(attrs) {
			attrs.resizable = false;
			attrs.minimizable = false;
			attrs.modal = true;
			attrs.width = 500;
			attrs.title = this.getTitle();
			attrs.layout = "anchor";
			attrs.cls = "y-wizard view-selection";

			attrs.action = attrs.action || Ext.emptyFn;
			attrs.languages = attrs.languages || [];

			return attrs;
		},
		
		getHeight: function(component) {
			if(component.getEl()) {
				if(component.getHeight) {
					return component.getHeight();
				}
				
				if(component.getSize) {
					return component.getSize().height;
				}
			}
			
			return 0;
		},
		
		updateHeight: function(component) {
			var height = 0;
			var that = this;

			component.items.each(function(item) {
				height += that.getHeight(item);
			});
			
			if(this.getHeight(component) !== height) {
				component.setHeight(height);
			}
		},
		
		createTopPanel: function(attrs, withViews) {
			var diagram = attrs.diagram;
			var languages = attrs.languages;
			var description = attrs.description;

			var originalView = this.getOriginalView(diagram.data, withViews);
			var options = this.getOptions(languages, description, withViews);
			
			return new Ext.Panel({
				anchor: "100%",
				layout: "column",
				cls: "top-panel",
				border: false,
				items: [options, originalView],
				getDataView: originalView.getDataView,
				getOptions: function() {
					return options.getValue();
				},
				listeners: {
					show: this.updateHeight.bind(this)
				}
			});
		},
		
		getSettings: function(languages) {
			var languageSelector = this.getLanguageSelector(languages);
			var items = [
				new Signavio.ux.form.Spacer({
					text: Ext.ux.getI18N("dialog.view.selection.label.settings")
				})
			];
			
			var settings = new Ext.form.FormPanel({
				items: items,
				border: false,
				layout: "form",
				labelWidth: languages.length === 0 ? 265 : 130,
				getValue: function() {
					if(languageSelector) {
						return {
							language: languageSelector.getValue()
						};
					}
					
					return {};
				}
			});

			settings.setVisible(false);

			if(languageSelector) {
				settings.add(languageSelector);
			}

			var addOns = this.addSettings(settings);

			addOns.each(function(addOn) {
				settings.add(addOn.element);
			});

			if(addOns.length > 0 || languageSelector) {
				settings.setVisible(true);
			}

			settings.getValue = function() {
				var value = {};

				if(languageSelector) {
					value.language = languageSelector.getValue();
				}

				addOns.each(function(addOn) {
					value[addOn.key] = addOn.value();
				});

				return value;
			};

			return settings;
		},
		
		getOptions: function(languages, description, withViews) {
			var items = [];

			if(description) {
				items.push(new Ext.form.Label({
					text: description
				}));
			}
			
			var settings = this.getSettings(languages);

			// only add settings, if there are settings
			if($H(settings.getValue()).keys().length !== 0) {
				items.push(settings);
			}
						
			if(withViews) {
				items.push(new Ext.form.Label({
					text: Ext.ux.getI18N("dialog.view.selection.label.multiple.views")
				}));
			}
			
			if(items.length === 0) {
				items = null;
			}
			
			return new Ext.Panel({
				columnWidth: 1,
				border: false,
				items: items,
				getValue: function() {
					return settings.getValue();
				}
			});
		},
		
		getLanguageSelector: function(languages) {
			if(languages.length === 0) {
				return;
			}
			
			return Ext.ux.form.LanguageSwitch.create({
				languages: languages,
				value: languages.first().rel || languages.first(),
				anchor: "100%",
				suppressGroups: true
			});
		},
		
		getOriginalView: function(record, withViews) {
			Ext.apply(record.rep, {
				view: {
					name: withViews ? Ext.ux.getI18N("dialog.view.selection.label.original") : record.rep.name
				},
				picture: Signavio.Config.BACKEND_PATH +
					(record.rep.revision || record.href) +
					Signavio.Const.THUMBNAIL +
					"?" +
					Object.toQueryString(Ext.Ajax.getSecurityParameter())
			});
			
			var dataView = this.getDataView([record]);
			
			return new Ext.Panel({
				width: 150,
				cls: "original-view",
				border: false,
				items: dataView,
				getDataView: function() {
					return dataView;
				}
			});
		},
		
		createViewSelector: function(views) {
			var dataView = this.getDataView(views);
			
			return new Ext.Panel({
				height: 130,
				anchor: "20",
				border: false,
				cls: "view-selector",
				items: dataView,
				bodyStyle: "overflow-x: auto",
				getDataView: function() {
					return dataView;
				}
			});
		},
		
		getDataView: function(views) {
			var ICON_WIDTH = 105;
			
			return new Ext.DataView({
				multiSelect: false,
				tpl: this.getViewTpl(),
				overClass: "x-view-over",
				itemSelector: "div.thumb-wrap",
				width: ICON_WIDTH * views.length,
				anchor: "100% 100%",
				store: this.getViewStore(views),
				prepareData: this.prepareData,
				singleSelect: true
			});
		},
		
		prepareData: function(data) {
			var info = Object.clone(data);
			info.rep = Object.clone(data.rep);
			
			info.rep.shortName = Signavio.Utils.SplitIntoTwoLines((info.rep.view.name || ""), (90*2));
			
			if(!info.rep.picture) {
				info.rep.picture = Signavio.Config.BACKEND_PATH +
					info.href +
					Signavio.Const.THUMBNAIL +
					"?" +
					Object.toQueryString(Ext.Ajax.getSecurityParameter());
			}
			
			return info;
		},
		
		getViewTpl: function() {
			return new Ext.XTemplate(
				'<tpl for=".">',
					'<div class="thumb-wrap" id="{href}" storeindex="{#}" unselectable="on">',
					// '<div class="thumb-wrap" id="{href}">',
					// '<div class="thumb-wrap">',
						'<tpl for="rep">',
							'<div class="thumb view">',
								'<img src="{picture}" title="{name}" class="x-thumb-icon" alt="{name}" />',
							'</div>',
							'<span class="x-editable" title="{[values.name != values.shortName ? values.name : "" ]}">',
								'{[values.shortName||"&nbsp;"]}',
							'</span>',
						'</tpl>',
					'</div>',
				'</tpl>',
				'<div class="x-clear"></div>'
			);
		},
		
		getViewStore: function(views) {
			var store = new Ext.data.SimpleStore({
				fields: this.getFields(),
				data: []
			});
			
			store.add(this.createRecords(views));
			
			return store;
		},
		
		getFields: function() {
			return [
				{ name: "href" },
				{ name: "rep" },
				{ name: "rel" }
			];
		},
		
		createRecords: function(views) {
			return (views || []).map(function(view) {
				return new Signavio.Utils.DummyRecord(view);
			});
		},
		
		getCurrentViewId: function(originalView, alternativeViews){
			var original = originalView.getSelectedRecords().first();
			var alternative = alternativeViews.getSelectedRecords().first();
			
			if(original) {
				return original;
			}

			if(alternative) {
				return alternative;
			}
			
			return null;
		}
	});

}());
/**
 *  (c) 2010 Signavio GmbH
 *
 *  @author Willi Tscheschner
 *
 *  UX is a shared javascript library which provides common
 *  functionalities for all applications in the Signavio Process Editor
 *
 */


new function(){


	/**
	 * URL for the ROOT image folder
	 */
	Ext.IMAGE_URL = "/images";

	/**
	 * Fixes for the user agent
	 */

	// IE
	Ext.getIEdocumentMode = function() {
		return (document||{}).documentMode;
	}
	
	// IE11 onwards does not have the MSIE in the userAgent
	Ext.isIE11 = Ext.getIEdocumentMode() === 11 && !!navigator.userAgent.match(/Trident.*rv:\d\d\./);
	Ext.isIE = Ext.isIE || Ext.isIE11;
	Ext.isIE8 = Ext.isIE && Ext.getIEdocumentMode() == 8; //String(window.navigator.userAgent).include("MSIE 8.");
	Ext.isIE9 = Ext.isIE && Ext.getIEdocumentMode() == 9; //String(window.navigator.userAgent).include("MSIE 9.");
	Ext.isIE10 = Ext.isIE && Ext.getIEdocumentMode() == 10; //String(window.navigator.userAgent).include("MSIE 10.");

	// Fix recognition of IE7 in Ext
	if(Ext.isIE7) {
		if(Ext.getIEdocumentMode() && Ext.getIEdocumentMode() != 7) {
			Ext.isIE7 = false;
		}
	}

	Ext.isIE6 = Ext.isIE6 && !Ext.isIE8 && !Ext.isIE9 && !Ext.isIE10;

	if (Ext.isIE){

		// Check for IE9 compatiblity view
		// IE 9 no Compatibility -> "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)"
		// IE 9    Compatibility -> "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0)"
		Ext.isIECompatibility = parseInt((window.navigator.userAgent.match(/Mozilla\/([0-9.]+)/i)||[])[1]) <= 4 &&
								parseInt((window.navigator.userAgent.match(/Trident\/([0-9.]+)/i)||[])[1]) >= 5;
	}

	// Chrome
	Ext.isChrome = String(window.navigator.userAgent).include("Chrome/");

	// Firefox
	Ext.isFF3 = String(window.navigator.userAgent).include("Firefox/3.6");
	Ext.isFF = String(window.navigator.userAgent).include("Firefox") && !Ext.isFF3;

	/**
	 * Returns the browser version of the current client
	 * @returns {Float}
	 */
	Ext.getBrowserVersion = function(){
		if (Ext.isIE){
			return Ext.getIEdocumentMode() || parseFloat(window.navigator.userAgent.match(/MSIE ([0-9\.]+)/i)[1]);
		}
		return parseFloat(window.navigator.userAgent.split("/")[3]);
	};

	/**
	 * IE9 Fixes
	 */
	if (Ext.isIE9 /*|| Ext.isIECompatibility*/){
		(function(){
			// @overwrite
			Element.hasClassName = Element.Methods.hasClassName = function(element, className) {
			    if (!(element = $(element))) return;
			    var elementClassName = element.getAttribute("class") || "";
			    return (elementClassName.length > 0 && (elementClassName == className ||
			      new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
			};

			// @overwrite
			var inHtml = Ext.DomHelper.insertHtml;
			Ext.DomHelper.insertHtml = function(foo, bar, html){
				html = html.gsub("ext:qtip=", "title="); // IE9 doesn't support insertion of namespace conform xml attributes
				html = html.gsub("ext:tree-node-id=", "tree-node-id=");
				return inHtml.call(this, foo, bar, html);
			};

			// Implementation of a missing function
			if (window.Range && !(Range.prototype.createContextualFragment instanceof Function)){
				Range.prototype.createContextualFragment = function(html){
	        		var node = document.createElement("div");
	        		node.innerHTML = html;
	        		return node.children[0];
	        	};
	        }

			// Implementation for missing setValue-Method for HTMLInputElement
			HTMLInputElement.prototype.setValue = function(value){
				if (this.type === "checkbox"){
					this.checked = value;
				}
			};

			(function() {
				// Used with IE9 jQuery 1.4.1 and Prototype 1.6 influence each 
				// other in a way that document.documentElement and document.body 
				// are missing. However, jQuery needs these two in order for the 
				// width/height methods to be working.
				//
				// Source: http://bugs.jquery.com/ticket/6431
				if(window.DocumentFragment && !DocumentFragment.prototype.documentElement) {
					DocumentFragment.prototype.documentElement = {};
				}

				if(window.DocumentFragment && !DocumentFragment.prototype.body) {
					DocumentFragment.prototype.body = {};
				}
			}());

			// Remove namespace awareness of node ids
			Ext.tree.TreeEventModel.prototype.getNode = function(e){
		        var t;
		        if(t = e.getTarget('.x-tree-node-el', 10)){
		            var id;
		            if (Ext.fly(t, '_treeEvents').dom.getAttributeNS instanceof Function){
		            	id = Ext.fly(t, '_treeEvents').dom.getAttributeNS(null, 'tree-node-id');
		            } else {
		            	id = Ext.fly(t, '_treeEvents').dom.getAttribute('tree-node-id');
		            }
		            if(id){
		                return this.tree.getNodeById(id);
		            }
		        }
		        return null;
		    };

		    // @overwrite
		    var update = Ext.Element.prototype.update;
		    Ext.Element.prototype.update = function(html, foo, bar){
		    	update.call(this, String(html||"").gsub(decodeURI("%EF%BF%BFu201e"), "Ä"), foo, bar);
		    };

            // Fix use of ext namespaces
            Ext.Template.prototype.overwrite = function(el, values, returnElement){
                el = Ext.getDom(el);
                el.innerHTML = this.applyTemplate(values).gsub(" ext:qtip=", " title=");
                return returnElement ? Ext.get(el.firstChild, true) : el.firstChild;
            };

		}());
	}

	/**
	 * IE10 Fixes
	 */

	if (Ext.isIE10 || Ext.isIE11){

		// @overwrite
		Element.hasClassName = Element.Methods.hasClassName = function(element, className) {
		    if (!(element = $(element))) return;
		    var elementClassName = element.getAttribute("class") || "";
		    return (elementClassName.length > 0 && (elementClassName == className ||
		      new RegExp("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
		};

		// Implementation of a missing function
		if (window.Range && !(Range.prototype.createContextualFragment instanceof Function)){
			Range.prototype.createContextualFragment = function(html){
        		var node = document.createElement("div");
        		node.innerHTML = html;
        		return node.children[0];
        	};
        }

		// @overwrite
		var inHtml = Ext.DomHelper.insertHtml;
		Ext.DomHelper.insertHtml = function(foo, bar, html){
			html = html.gsub("ext:qtip=", "title="); // IE10 doesn't support insertion of namespace conform xml attributes
			html = html.gsub("ext:tree-node-id=", "tree-node-id=");
			return inHtml.call(this, foo, bar, html);
		};

		// Implementation for missing setValue-Method for HTMLInputElement
		HTMLInputElement.prototype.setValue = function(value){
			if (this.type === "checkbox"){
				this.checked = value;
			}
		};


		// Remove namespace awareness of node ids
		Ext.tree.TreeEventModel.prototype.getNode = function(e){
	        var t;
	        if(t = e.getTarget('.x-tree-node-el', 10)){
	            var id;
	            if (Ext.fly(t, '_treeEvents').dom.getAttributeNS instanceof Function){
	            	id = Ext.fly(t, '_treeEvents').dom.getAttributeNS(null, 'tree-node-id');
	            } else {
	            	id = Ext.fly(t, '_treeEvents').dom.getAttribute('tree-node-id');
	            }
	            if(id){
	                return this.tree.getNodeById(id);
	            }
	        }
	        return null;
	    };

        // Fix use of ext namespaces
        Ext.Template.prototype.overwrite = function(el, values, returnElement){
            el = Ext.getDom(el);
            el.innerHTML = this.applyTemplate(values).gsub(" ext:qtip=", " title=");
            return returnElement ? Ext.get(el.firstChild, true) : el.firstChild;
        };

	}
	/**
	 * Chrome Fixes
	 */
	if (Ext.isChrome || Ext.isSafari){
		(function(){

			// Fixes for Chrome Bug
			// http://code.google.com/p/chromium/issues/detail?id=58493

			// Check if there exists the bug in the current chrome version
//			var parseNode = (new DOMParser()).parseFromString("<div ext:qtip='tooltip'></div>", "text/xml");
//			if (parseNode.getElementsByTagName("parsererror").length == 0){
//
//				(function(){
//					var inHtml = Ext.DomHelper.insertHtml;
//					Ext.DomHelper.insertHtml = function(foo, bar, html){
//						html = html.gsub(" ext:", " xmlns:ext=\"http://b3mn.org/2007/ext\" ext:");
//						return inHtml.call(this, foo, bar, html);
//					};
//				}());
//
//				return;
//			}

			// @overwrite
			var inHtml = Ext.DomHelper.insertHtml;
			Ext.DomHelper.insertHtml = function(foo, bar, html){
				html = html.gsub("ext:qtip=", "title=");
				html = html.gsub("ext:tree-node-id=", "tree-node-id=");
				return inHtml.call(this, foo, bar, html);
			};

			// Remove namespace awareness of node ids
			Ext.tree.TreeEventModel.prototype.getNode = function(e){
		        var t;
		        if(t = e.getTarget('.x-tree-node-el', 10)){
		            var id = Ext.fly(t, '_treeEvents').dom.getAttributeNS(null, 'tree-node-id');
		            if(id){
		                return this.tree.getNodeById(id);
		            }
		        }
		        return null;
		    };

		    // Fix use of ext namespaces
		    Ext.Template.prototype.overwrite = function(el, values, returnElement){
		        el = Ext.getDom(el);
		        el.innerHTML = this.applyTemplate(values).gsub(" ext:qtip=", " title=");
		        return returnElement ? Ext.get(el.firstChild, true) : el.firstChild;
		    };

		}());
	}


	/**
	 * General Ext Bugfix Section
	 */


	/**
	 * Sometimes it happens that the wrap element was not in the
	 * dom anymore, but the method get still called, which leads
	 * into problems (mainly in IE9). So now, a parent exist
	 * check get performed prior.
	 *
	 */
	Ext.Element.prototype.fxUnwrap = function(wrap){
		if (wrap.dom.parentNode){
			Ext.Fx.fxUnwrap.apply(this, arguments);
		}
	};

	/**
	 * Sometimes it happens that no anchor exists, so when calling
	 * focus on it, it simply drops into the empty catch block, which
	 * is somewhat desired behaviour. However, firebug breaks on it
	 * since it's an evil bug and prevents the page from loading.
	 *
	 */
	Ext.tree.TreeNodeUI.prototype.focus = function(){
	    if(!this.node.preventHScroll){
	        try{this.anchor.focus();
	        }catch(e){}
	    }else if(!Ext.isIE){
	        try{
	            var noscroll = this.node.getOwnerTree().getTreeEl().dom;
	            var l = noscroll.scrollLeft;
	            this.anchor && this.anchor.focus();
	            noscroll.scrollLeft = l;
	        }catch(e){}
	    }
	};

	Ext.form.NumberField.create = function(args) {
		args = args || {};

		var fallback = args.decimalSeparator;
		var language = Signavio.Utils.getApplicationLanguage();
		var separator = Signavio.Utils.getDecimalSeparator(language, fallback);

		args.decimalSeparator = separator;

		if(args.allowNegative === false) {
			// If you are quick enough you can trick negative values
			// into the field even if the allowNegative flag ist set
			// to false. This function ensures that really no negative
			// values get into the field.
			args.parseValue = function(value) {
                value = Ext.form.NumberField.prototype.parseValue.call(this, value);

                if(value < 0) {
                    value = -value;
                }

                return isNaN(value) ? "" : value;
            };
		}

		return new Ext.form.NumberField(args);
	};

	/**
	 * The Date.formatCodeToRegex function returns an erroneous regex
	 * group for the format parameter 'z'. This should fix it
	 */
	Date.originalFormatCodeToRegex = Date.formatCodeToRegex;
	Date.formatCodeToRegex = function(character, currentGroup) {
		var date = Date.originalFormatCodeToRegex(character, currentGroup);
		if (character === "z") {
			date.s += ")";
		}
		return date;
	};
	
	/**
	 * A get method which returns the first record with an exact match of field and value 
	 * or undefined if no record could be found.
	 * 
	 * @param field name of the field
	 * @param value the value to be matched
	 */
	Ext.data.Store.prototype.get = function(field, value) {
		return this.getRange().find(function(r) {
			return r.get(field) === value;
		});
	};
    
    /**
     * Returns the range for the given start and end and bypasses any filter.
     *
     * @param start start index
     * @param end end index
     */
    Ext.data.Store.prototype.getRawRange = function(start, end) {
    	if (this.snapshot) {
    		return this.snapshot.getRange(start, end);
    	} else {
    		return this.getRange(start, end);
    	}
    };

    if(!Ext.data.Store.prototype.select) {
    	Ext.data.Store.prototype.select = function(clb) {
    		var result = [];

    		this.each(function(record) {
    			if(clb(record) !== true) {
    				return;
    			}

    			result.push(record);
    		});

    		return result;
    	};
    }

    if(!Ext.data.Store.prototype.touch) {
    	Ext.data.Store.prototype.touch = function(ref) {
			var args = $A(arguments).slice(1);

			this.suspendEvents();

			args.each(function(record) {
				record.set(ref, Object.clone(record.get(ref)));
			});

			this.resumeEvents();
    	};
    }

    if(!Ext.data.Store.prototype.first) {
    	Ext.data.Store.prototype.first = function(clb) {
    		var index = this.findBy(clb);

    		return this.getAt(index);
    	};
    }

    if(!Ext.data.Store.prototype.contains) {
    	Ext.data.Store.prototype.contains = function(record) {
    		var href = record.get("href");

    		return !!this.first(function(r) {
				return r.get("href") === href;
    		});
    	};
    }

    if(!Ext.data.Store.prototype.getRecords) {
    	Ext.data.Store.prototype.getRecords = function(rel) {
    		var records = [];

    		if(rel && !(rel instanceof Array)) {
    			rel = [rel];
    		}
			
			(this.snapshot || this.data).each(function(record){
				if(rel && !rel.include(record.get("rel"))) {
					return;
				}

				records.push(record);
			});

			return records;
    	};
    }
    
    /**
     * Just updates the value for the given name and bypasses all callbacks and events.
     * WARNING: Just use this function if you know, what you do!
     *
     * @param name key of the field
     * @param value the new value
     */
    Ext.data.Record.prototype.setRaw = function(name, value) {
        this.data[name] = value;
    };
    
    /**
     * Extension of the original select method that allows to prevent the method from firing a select event.
     * This is useful if you want to select a color in the palette from your code.
     * @param {String} color the color to select
     * @param {Boolean} preventEvents true if no events shall be fired
     */
    Ext.ColorPalette.prototype.select = function(color, preventEvents) {
        color = color.replace("#", "");
        if(color != this.value || this.allowReselect){
            var el = this.el;
            if(this.value){
                var oldChild = el.child("a.color-"+this.value);
                if (oldChild) {
                    oldChild.removeClass("x-color-palette-sel");
                }
            }
            var child = el.child("a.color-"+color);
            if (child) {
                child.addClass("x-color-palette-sel");
            }
            this.value = color;
            if (!preventEvents) {
                this.fireEvent("select", this, color);
            }
        }
    };
    
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" == typeof window.Ext){ window.Ext = {}; }
if ("undefined" == typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" == typeof Ext.ux.form){ Ext.ux.form = {}; }

new function(){
	
	/**
	 * Class for a generic combo box
	 * 
	 * @class
	 * @param attr
	 * @return
	 */
	Ext.ux.form.ComboBox = function(attr){

		if (!attr.store && attr.url){
			var store = new Ext.data.JsonStore({
				url: attr.url,
			    fields: ['value', 'title']
			});
			// Set proxy for GET-Method
			store.proxy = new Ext.data.HttpProxy({url: attr.url, method:"GET"});
			store.relayEvents(store.proxy,  ["loadexception"]);
			
			// If optional, add an empty record
			if (attr.allowBlank) {
				store.reader.readRecords  = function(o){
					o.unshift({value:"", title:""});
					return Ext.data.JsonReader.prototype.readRecords.apply(this, [o]);
				}
			}
			attr.store = store;
		}	
								
		// Call super
	    Ext.ux.form.ComboBox.superclass.constructor.call(this, attr);	    
	};
	
	Ext.extend(Ext.ux.form.ComboBox, Ext.form.ComboBox, {
		
		loadingText: "<i>Loading...</i>",
		exceptionText: "Data could not been loaded.",
		selectOnFocus: true,
	    displayField:'title',
		valueField: 'value',
	    triggerAction: 'all',
		queryParam: 'q',
		minChars: 2,
		
		/**
		 * @cfg {Boolean} preventFromDisable
		 * If set to true, the Button can't be disabled.
		 */
		preventFromDisable  : false,
		
		/**
		 * @cfg {Boolean} preventFromEnable
		 * If set to true, the Button can't be enabled.
		 */
		preventFromEnable	: false,
		
		
		/**
		 * Returns the value of the combo box
		 * Workaround for applying user defined values to the field, overriding
		 * Ext's default way.
		 */
		getValue : function(){
			if(!this.forceSelection){
				var value = Ext.form.ComboBox.superclass.getValue.call(this);
                if(value != this.lastSelectionText) {
                	this.setValue(value);
                }
			}
			if(this.valueField){
            	return typeof this.value != 'undefined' ? this.value : '';
            } else {
            	return Ext.form.ComboBox.superclass.getValue.call(this);
            }
		},
		
//		getValue: function(){
//			if (!this.forceSelection&&!this.value)
//				return Ext.form.ComboBox.superclass.getValue.call(this);
//			return Ext.ux.form.ComboBox.superclass.getValue.call(this);
//		},
		
	    onLoad : function(){
	        if(!this.hasFocus){
	            return;
	        }
	        if(this.store.getCount() > 0){
	            this.expand();
	            this.restrictHeight();
	            if(this.lastQuery == this.allQuery){
	                if(this.editable){
	                    this.el.dom.select();
	                }
	                if(!this.selectByValue(this.value, true)){
	                    this.select(0, true);
	                }
	            } else {
					if (this.selectedIndex !== -1 || this.forceSelection){
						this.selectNext();
					}
	                if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
	                    this.taTask.delay(this.typeAheadDelay);
	                }
	            }
	        }else{
	            this.onEmptyResults();
	        }
	        //this.el.focus();
	    },
	    
	    /**
	     * Get called if an exception is raised while loading the data
	     */
	    onLoadException: function(){
	    	if (this.exceptionText){
	    		 this.innerList.update('<div class="x-exception-indicator">'+this.exceptionText+'</div>');
	    	}
	    },

	    onViewClick : function(doFocus){
	        var index = this.view.getSelectedIndexes()[0];
	        var r = this.store.getAt(index);
	        if(r){
	            this.onSelect(r, index);
	        } else if (!this.forceSelection) {
				this.setValue(Ext.form.ComboBox.superclass.getValue.call(this));
				this.collapse();
			}
	        if(doFocus !== false){
	            this.el.focus();
	        }
	    },
		
	    // private
	    onTypeAhead : function(){
	        if(this.store.getCount() > 0){
	            var r = this.store.getAt(0);
	            var newValue = r.data[this.displayField];
	            var len = newValue.length;
	            var selStart = this.getRawValue().length;
	            if(newValue && selStart != len){
	                this.setRawValue(newValue);
	                this.selectText(selStart, newValue.length);
	            }
	        }
	    },
	    
	    /**
		 * Set true to prevent the button from being disabled
		 * @param {Boolean} prevent
		 */
		setPreventFromDisable : function(prevent) {
			this.preventFromDisable = prevent;
		},
		
		/**
		 * Set true to prevent the button from being enabled
		 * @param {Boolean} prevent
		 */
		setPreventFromEnable : function(prevent) {
			this.preventFromEnable = prevent;
		},
		
		/**
		 * Convenient method to check if the button can be disabled.
		 * @returns {Boolean}
		 */
		getPreventFromDisable : function() {
			return this.preventFromDisable;
		},		
		
		/**
		 * Convenient method to check if the button can be enabled.
		 * @returns {Boolean}
		 */
		getPreventFromEnable : function() {
			return this.preventFromEnable;
		},		
		
		/**
	     * Convenient function for setting disabled/enabled by boolean. If preventFromDisable is true, it is not
	     * possible to disable the button.
	     * @override
	     * @param {Boolean} disabled
	     */
	    setDisabled : function(disabled){
        	this[disabled && !this.preventFromDisable ? "disable" : "enable"]();
	    },
	    
	    /**
	     * Disables the button if it's not forbidden
	     * @returns {Ext.ux.Toolbar.Button} this
	     */
	    disable : function() {
	    	if (!this.preventFromDisable) {
		    	if(this.rendered){
		            this.onDisable();
		        }
		        this.disabled = true;
		        this.fireEvent("disable", this);
	    	} 
	        return this;

	    },
	    
	    /**
	     * Enables the button if it's not forbidden
	     * @returns {Ext.ux.Toolbar.Button} this
	     */
	    enable : function() {
	    	if (!this.preventFromEnable) {
	    		if(this.rendered){
		            this.onEnable();
		        }
		        this.disabled = false;
		        this.fireEvent("enable", this);
	    	}
	    	return this;
	    },
	    /**
	     * Overwrites the bindStore method to enable loading exception indication
	     * @param store
	     * @param initial
	     */
	    bindStore: function(store, initial){
	    	if (this.exceptionText){
		    	if(this.store && !initial){
		            this.store.un('loadexception', this.onLoadException, this);
		    	}
		    	if(store){
		            store.on('loadexception', this.onLoadException, this);
		    	}
	    	}
	    	Ext.ux.form.ComboBox.superclass.bindStore.apply(this, arguments);
	    	if (this.exceptionText){
	    		if(this.store){
	    			 this.store.un('loadexception', this.collapse, this);
		    	}
	    	}
	    }
    });
	
}();
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

 if(!Ext) { var Ext = {}; }
 if(!Ext.ux) { Ext.ux = {}; }
 if(!Ext.ux.form) { Ext.ux.form = {}; }
 
 (function() {
 
     Ext.ux.form.ComboFieldList = function(attr) {
         
         this.values = [];
         
         Ext.ux.form.ComboFieldList.superclass.constructor.call(this, attr);
     };
     
     Ext.extend(Ext.ux.form.ComboFieldList, Ext.ux.form.ComboBox, {
         
         ctCls: "x-form-textfield-list",
         
         exists: function(value) {
             var existing = this.values.find(function(el) {
                 if(el[1] === value) {
                     return true;
                 }
             });  
            
             return !!existing;
         },
         
         addValue: function(value) {
             if(!this.exists(value)) {
                 var index = this.store.findBy(function(record) {
                     if(record.get("value") === value) {
                         return true;
                     } 
                 });
                 
                 var record = this.store.getAt(index);
                 
                 if(record) {
                     this.values = this.values.concat([[record.get("title"), record.get("value")]]);
                 }
             }
         },
         
         onRender: function() {
             Ext.ux.form.ComboFieldList.superclass.onRender.apply(this, arguments);
             
             this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {
                tag: 'div',
                style: 'margin: 1px 0px 0px 0px; display:none;' + this.listStyle
            }));
            
            if(!this.itemFieldTpl) {
                this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty"></span></tpl>',
                							'<tpl for=".">',
                								'<span class="y-filter-combo-list">{[Signavio.Utils.escapeHTML(values[0])]} ', 
                									'<span class="x-smaller">', 
                                                        '(', 
                                                            '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>',
                                                        ')',
                                                    '</span>', 
                								'</span>',
                							 '</tpl>');
            }
            
            this.updateView();
            
            var wrap = this.wrap.boxWrap();
			wrap.child(".x-box-mc");
         },
         
         onUpdateView: Ext.emptyFn,
         
        updateView: function() {
            if(!this.itemFieldTpl || !this.itemField) {
                return;
            }
            
            this.itemFieldTpl.overwrite(this.itemField, this.values || []);
            this.itemField.setDisplayed((this.values || []).length > 0);
            
            this.updateEvents();
            
            if(this.ownerCt && this.ownerCt.updateSize) {
                this.ownerCt.updateSize();
            }
            
            this.onUpdateView();
        },
        
        updateEvents: function() {
        
            var getId = function(el){
                return parseInt(el.getAttribute("href").split('#').last());
            };
            
            this.itemField.select("a.x-remove").on("click", function(e, t) {
                Event.stop(e);
                
                var index = getId(t);
                this.remove(index);
                this.updateView();
            }.bind(this));
            
        },
        
        remove: function(index) {
            delete this.values[index];
            this.values = this.values.compact();
        },
        
        onSelect: function(record) {
            Ext.ux.form.ComboFieldList.superclass.onSelect.call(this, record);

            var value = record.get("value");
            
            this.setRawValue("");
            this.setValue(value);  
        },

        getValue: function(){
			return this.values.clone();
		},
        
        setValue: function(value) {
            if(value instanceof Array) {
                this.values = value.clone();
            } else {
                this.addValue(value);
            }
            
            this.updateView();
        }
         
     });
 
 })();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { window.Ext = {}; }
if(!Ext.form) { Ext.form = {}; }

(function() {
   
    Ext.form.ComplexTextField = Ext.extend(Ext.form.TriggerField,  {
        
        defaultAutoCreate : {tag: "textarea", rows:1, style:"height:16px;overflow:hidden;" },
    
        /**
         * If the trigger was clicked a dialog has to be opened
         * to enter the values for the complex property.
         */
        onTriggerClick : function(){
            
            if(this.disabled){
                return;
            }   

            var selection = (this.facade.getSelection().length > 0 ? this.facade.getSelection()[0] : this.facade.getCanvas());
            
            if (this.dataSource){
                var values = this.events.dialogclosed.listeners[0].scope.scope.shapeSelection.commonPropertiesValues, 
                    property = this.dataSource.getAt(this.row).get("gridProperties").property,
                    buttons = [];
                
                if (ORYX.CONFIG.MULTI_LANGUAGES_ENABLED && property.language()){
                    var oprop = property.origin();
                    $H(ORYX.CONFIG.MULTI_LANGUAGES||{}).keys().any(function(lang){
                        var key = oprop.prefix() + "-" + oprop.id() + (lang == ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT ? "" : "_" + lang );
                        if (property.language() != lang && (values[key]||"") != oprop.value()){
                            buttons.push({
                                icon: ORYX.CONFIG.EXPLORER_PATH + "/src/img/flags/" + ORYX.CONFIG.MULTI_LANGUAGES[lang],
                                iconCls: "x-dummy",
                                text: " <img src='"+Ext.IMAGE_URL+"/famfamfam/bullet_go.png' style='margin-bottom:-5px;margin-left:-13px;margin-right:-5px;position:relative;'/>",
                                handler: function(){
                                    grid.setValue([grid.getValue()||"", Ext.ux.Richtext.encode(values[key], selection.getFormat(key))||undefined].compact().join("\n"));
                                    // If the grid is an advanced richtext grid, log the changes after setting the value 
                                    if ("function" === typeof grid.logKeys) {
                                        grid.logKeys();
                                    }
                                }
                            });
                        }
                    }.bind(this));
                }
            }
            
            /*
             * Create an advanced editor grid if richtext step 2 is enabled
             */
            if (ORYX.CONFIG.RICHTEXT_2_ENABLED) {
                var id = this.property ? this.property.id() : this.dataSource.getAt(this.row).data.gridProperties.propId;
                var json = (selection.getFormat(id)||[]);
                var grid = new Ext.ux.form.RichtextEditor({
                    enableSourceEdit: false,
                    anchor          : '100% 100%',
                    value           : (this.value === '' ? '<br/>' : Ext.ux.Richtext.encode(this.value, json)),
                    modal           : true,
                    ctCls           : 'y-richtext-editor' + (Ext.isIE9 ? ' y-richtext-editor-ie9' : Ext.isChrome ? ' y-richtext-editor-chrome' : ''),
                    listeners       : {
                        initialize  : function(comp) {
                            this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
                        }.bind(this),
                        destroy     : function() {
                            this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
                        }.bind(this)
                    },
                    // Add the multi language support button to the richtext editor's toolbar
                    tbar            : (buttons && buttons.length > 0) ? buttons : undefined
                });
            } else {
                // Else create only a normal text area
                var grid = new Ext.form.TextArea({
                    anchor      : '100% 100%',
                    value       : this.value,
                    listeners   : {
                        focus: function(){
                            if (this.facade)
                                this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
                        }.bind(this)
                    }
                });
            }
            
            
            var dialog = this.getEditorWindow(grid, buttons);
            
            if (!dialog) {
                return;
            }
            dialog.show();      
            grid.render();
            
            if (this.grid)
                this.grid.stopEditing();
            grid.focus( false, 100 );
            
        },
        
        /**
         * Returns a new window for editing text blocks.
         * If richtext 2 functionality is enabled, an advanced editor is used, else only a basic editor.
         * @param grid
         * @param buttons
         * @returns {Ext.Window}
         */
        getEditorWindow : function(grid, buttons) {
            if (ORYX.CONFIG.RICHTEXT_2_ENABLED) {
                // Advanced Richtext Dialogue
                var dialog = new Ext.Window({ 
                    layout      : 'anchor',
                    autoCreate  : true, 
                    // Get the title of the property to change
                    title       : (this.dataSource ? this.dataSource.getAt(this.row).get("gridProperties").property.title() : ORYX.I18N.PropertyWindow.text), 
                    height      : 500,
                    width       : 650,
                    minWidth    : 600,
                    modal       : true, 
                    shadow      : true,
//                  tbar        : (buttons && buttons.length > 0) ? buttons : undefined,
                    keys:[{
                        key : 27,
                        fn  : function(){
                                dialog.hide();
                        }.bind(this)
                    }],
                    items       :[grid],
                    listeners   :{
                        hide: function(){
                            dialog.destroy();
                        }.bind(this)
                    },
                    tools       : [
                                   {
                                       id       : "maximize",
                                       handler  : function(foo, bar, panel) {
                                           panel.maximize();
                                       }
                                   }, {
                                       id       : "restore",
                                       hidden   : true,
                                       handler  : function(foo, barr, panel) {
                                           panel.restore();
                                       }
                                   }
                    ],
                    
                    buttons     : [{
                        /*
                         * The OK Button in the richtext editor
                         */
                        text: ORYX.I18N.PropertyWindow.ok,
                        handler: function(){     
                            // Get the plain text to display in the property window
                            //XXX
                            var content = Ext.ux.Richtext.decode(grid.body);
                            
                            this.value = content.text;
                            this.newFormat = content.format;
                            this.setValue(this.value);
                            
                            if (this.dataSource) {
                                this.dataSource.getAt(this.row).set('value', this.value);
                                this.dataSource.commitChanges();
                            }

                            this.fireEvent('dialogClosed', this.value, this.newFormat);
                            dialog.hide();
                        }.bind(this)
                    }, {
                        /*
                         * The Cancel Button in the richtext editor
                         */
                        text: ORYX.I18N.PropertyWindow.cancel,
                        handler: function(){
                            //this.setValue(this.value);
                            dialog.hide();
                        }.bind(this)
                    }]
                });     
            } else {
                // Basic Dialogue
                var dialog = new Ext.Window({ 
                    layout      : 'anchor',
                    autoCreate  : true, 
                    title       : ORYX.I18N.PropertyWindow.text, 
                    height      : 500, 
                    width       : 500, 
                    modal       : true,
                    collapsible : false,
                    fixedcenter : true, 
                    shadow      : true, 
                    proxyDrag   : true,
                    tbar        : (buttons && buttons.length > 0) ? buttons : undefined,
                    keys:[{
                        key : 27,
                        fn  : function(){
                                dialog.hide();
                        }.bind(this)
                    }],
                    items       :[grid],
                    listeners   :{
                        hide: function(){
                            this.fireEvent('dialogClosed', this.value);
                            dialog.destroy();
                        }.bind(this)                
                    },
                    buttons     : [{
                        text: ORYX.I18N.PropertyWindow.ok,
                        handler: function(){     
                            // store dialog input
                            var value = grid.getValue();
                            this.setValue(value);
                            
                            if (this.dataSource) {
                                this.dataSource.getAt(this.row).set('value', value);
                                this.dataSource.commitChanges();
                            }
        
                            dialog.hide();
                        }.bind(this)
                    }, {
                        text: ORYX.I18N.PropertyWindow.cancel,
                        handler: function(){
                            this.setValue(this.value);
                            dialog.hide();
                        }.bind(this)
                    }]
                });     
            }
            return dialog;
        }
    });
    
}());
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */
ns("ux.form", "Ext");

(function(){
	
	var GlossaryListItemTpl = "" +	
		'<tpl for=".">'+
			'<div class="x-inline">' +
				'<tpl if="values.data.href">'+
					'<div class="x-glossary-color" style="background-color: {[values.data.rep.color]}"></div>' +
					'<div class="{[values.data.rep.category ? "x-"+values.data.rep.category.toLowerCase()+" x-image" : ""]} x-glossary-title">'+
						'{[Signavio.Utils.escapeHTML(this.translate(values.data.rep))]} '+
					'</div>'+
					'<span class="x-smaller">' +
						'(<a href="' + Signavio.Config.BACKEND_PATH + '/glossary#gitem={[values.data.rep.id]}" class="x-open" target="_blank" tabindex="-1">' +
							Ext.ux.getI18N("btnOpen") +
						'</a>, ' +
						'<a href="#{[values.data.rep.id]}" class="x-remove" tabindex="-1">' +
							Ext.ux.getI18N("btnRemove") +
						'</a>)' +
					'</span>'+
				'</tpl>'+
				'<tpl if="!values.data.href">'+	
					'<div class="x-glossary-color" style="background-color: {[values.data.rep.color]}"></div>' +
					'<div class="{[values.data.rep.category ? "x-"+values.data.rep.category.toLowerCase()+" x-image" : ""]} x-glossary-title">'+
						'{[Signavio.Utils.escapeHTML(this.translate(values.data.rep))]} '+
					'</div>'+
					'<span class="x-smaller">' +
						'(' + Ext.ux.getI18N("createGlossaryNew") + ', ' +
						'<a href="#{[values.data.rep.random]}" class="x-remove" tabindex="-1">' +
							Ext.ux.getI18N("btnRemove") +
						'</a>)' +
					'</span>'+
				'</tpl>'+
				'<tpl if="xindex!==xcount">, </tpl>'+
			'</div>'+
		'</tpl>';
	
	
	/**
	 * A factory to generate certain fields by its type
	 * 
	 * @class Ext.ux.form.FieldFactory
	 */
	Ext.ux.form.FieldFactory = {
			
		/**
		 * Generate a field by its type
		 * 
		 * @param {Object} type
		 * @param {Object} option
		 */
		generate: function(type, option){
			option = option || {};
			
			if (this["generate"+type] instanceof Function){
				return this["generate"+type](option);
			}
			
			return this.generateMetaDataStringInfo(option);
		},
		
		/**
		 * Type: String
		 * @param {Object} option
		 */
		generateMetaDataStringInfo: function(option){
			// return simple text field if single line
			if (!option.lineWrap) {
				return new Ext.form.TextField(Ext.apply({}, option));
			}
			
			// return normal text area if no richtext is available
			if (!option.richtextEnabled) {
				return new Ext.form.TextArea(Ext.apply({}, option));
			}
			
			
			// return a richtext editor for multiline meta data
			var rt = new Ext.ux.form.RichtextEditor(Ext.apply({
        		enableSourceEdit: false,
        		anchor			: '100% 100%',
        		modal			: true,
        		ctCls			: 'y-richtext-editor' + (Ext.isIE9 ? ' y-richtext-editor-ie9' : Ext.isChrome ? ' y-richtext-editor-chrome' : ''),
        		listeners	: {
        			render : function(rt) {
        				var editingWindow = rt.editingWindow || rt.ownerCt;
        				
        				rt.getToolbar().add({
        					icon		: "/images/fugue/icons/selection-input.png",
        					iconCls		: "x-dummy",
        					cls			: "x-btn-icon y-horizontal-menu-button",
        					tabIndex	: -1,
        					tooltip 	: {
        						title		: Ext.ux.getI18N("richtext.simpleeditingmodetitle"),
        						text		: Ext.ux.getI18N("richtext.simpleeditingmodedesc")
        					}, 
        					handler		: function () {
        						// Display a warning that all formats could be lost
        						Ext.MessageBox.show({
        							title	: Ext.ux.getI18N("richtext.simpleeditingmodetitle"),
        							msg		: Ext.ux.getI18N("richtext.simpleeditingmodewarning"),
        							buttons	: Ext.MessageBox.OKCANCEL,
        							fn		: function(btn) {
        								if (btn === "ok") {
        									// Create a new simple editor
											var owner = rt.ownerCt;
											var value = Ext.ux.Richtext.decode(rt.body).text;
        									var simpleEditor = new Ext.form.TextArea(Ext.apply({style:"height:"+rt.container.getHeight()+"px;", labelStyle:rt.labelStyle}, option));
    										
    										// Replace the richtext editor in UI with a simple text area, if in extra panel
    										if (owner.ownerCt instanceof Ext.ux.form.TranslationField) {
    											// create a new translation field
    											var ownerTrans = owner.ownerCt;
    											var transField = new Ext.ux.form.TranslationField({
													field: simpleEditor,
													editing: editingWindow.editing,
													language: rt.language || undefined,
													anchor: "100%"
												});
												var oldPos = editingWindow.translation.items.items.indexOf(ownerTrans);
												// add the translation field
												editingWindow.translation.remove(ownerTrans);
												editingWindow.translation.add(transField);
												// move the new translation field to its position
												var its = editingWindow.translation.items.items;
												its.splice(oldPos, 0, its.splice(its.length-1, 1)[0]);
    										} else {
												owner.items.replace(rt.id, simpleEditor)
												rt.el.parent().parent().parent().remove();
    										}
											// add to window form fields so it can be saved
											editingWindow.fields.remove(rt);
											editingWindow.addField(simpleEditor);
											// show it
        									editingWindow.render();
											// Apply the plain text of the richtext editor to the simple editor (after render!)
											simpleEditor.setValue(value);
    										// Refresh the containing window
    										editingWindow.syncSize();
    										if (typeof editingWindow.updateSize === 'function') {
    											editingWindow.updateSize();
    										}
    										// Focus
    										simpleEditor.focus( false, 100 );
        								}
        							}.bind(this),
        							icon	: Ext.MessageBox.WARNING
        						});
        					}.bind(this)
        				});
        				
        				// Add focus listener to throw a mousedown event outside the iframe
        				Event.observe(rt.win, 'focus', function() {
        					// ALL BROWSERS EXCEPT IE < 9
        					if (document.createEvent instanceof Function) {
	        					var ev = document.createEvent('MouseEvents');
	        					ev.initMouseEvent("mousedown", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
	        					ev._fake = true;
	        					Ext.apply(ev, {});
	        					rt.el.dom.dispatchEvent(ev);
        					} else {
        						var ev = document.createEventObject();
        						rt.el.dom.fireEvent("onMouseDown", ev);
        					}
        					
        				}.bind(this));
        			}.bind(this)
        		}
        	}, option));

			rt.editingwindow = option.editingWindow;
			
			rt.setValue(option.value);
			
			return rt;	
		},
		
		/**
		 * Type: String
		 * List: true
		 * @param {Object} option
		 */
		generateMetaDataStringInfoList: function(option){
			return new Ext.ux.form.TextFieldList(Ext.apply({}, option));
		},
		
		/**
		 * Type: Boolean
		 * @param {Object} option
		 */
		generateMetaDataBoolean: function(option){
			return new Ext.form.Checkbox(Ext.apply({
					cls: "x-checkbox-left",
					checked: option.value || false
				}, option));
		},
		
		/**
		 * Type: Enum
		 * @param {Object} option
		 */
		generateMetaDataChoiceInfo: function(option){
			return new Ext.form.ComboBox(Ext.apply({
		     			forceSelection	: true,
		     			mode			: 'local',
		     			allowBlank		: false,
		     			valueField		: "href",
		     			displayField	: "rep",
		     			displayField2	: "type",
		     			triggerAction	: 'all',
		     			lazyRender		: true,
		     			lazyInit		: false
		     		}, option));
		},
		
		/**
		 * Type: Glossary Link
		 * @param {Object} option
		 */
		generateMetaDataGlossaryLink: function(option){
			return new Ext.ux.form.GlossaryField(Ext.apply({
				onNewRecord: function(rec){
					this.records = [rec];
					this.updateView();
					
					// Try to focus the next field
					var next = this.container.parent().next();
					var focusEl;
					if (next) {
						focusEl = next.child('.x-form-field');
					} else {
						// Fix for focus: now that we're using the Ext.ux.Window, the first button is a link button, focussing it like this breaks it
						focusEl = this.ownerCt.buttons[1];
					}
					
					Signavio.Utils.defer(function() {
						focusEl.focus();
					}, this);
				},
				getValue: function(){
					if(this.records && this.records.length === 1) {
						return this.records[0].get("href") || this.records[0].get("rep");	
					}

					return this.getRawValue();
				},
				initValue: function(){
					if (this.value instanceof Object && this.value.title && this.value.id) {
						this.records = [Signavio.Core.RecordCreator.create("gitem", Signavio.Glossary.Config.GLOSSARY_URL + "/" + this.value.id, this.value)];
						this.value = this.value.title;
					} else if(this.value instanceof Ext.data.Record && this.dataField) {
						this.value = this.value.get("rep")[this.dataField];				
					}

					Ext.ux.form.GlossaryField.superclass.initValue.apply(this, arguments);	
				},
				onRender:function(){
					Ext.ux.form.GlossaryField.superclass.onRender.apply(this, arguments);	
					
					this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {
						tag:"div",
						style:"margin:1px 0px 3px 0px;display:none;",
						cls:'x-field-wrap'
					}));

					this.itemFieldTpl = new Ext.XTemplate(GlossaryListItemTpl, {
						translate: function(values){
							return this.translate(values, "title");
						}.bind(this)});
					
					this.updateView();
				},
				updateView: function(){
					if (this.records&&this.records.length === 1){
						this.itemFieldTpl.overwrite(this.itemField, this.records);
						this.itemField
							.select("a.x-remove")
							.update(Ext.ux.getI18N("btnReset"))
							.on("click", function(evt) {
								Event.stop(evt);
								this.setValue("");
								this.records = [];
								this.updateView();
								this.focus();
							}.bind(this));

						this.el.setDisplayed(false);
						this.itemField.setDisplayed(true);
					} else {
						this.itemField.update("");
						this.itemField.setDisplayed(false);
						this.el.setDisplayed(true);
					}
					this.collapse();
				}
			}, option))
		},
		
		/**
		 * Type: Glossary Link
		 * List: true
		 * @param {Object} option
		 */
		generateMetaDataGlossaryLinkList: function(option){
			return new Ext.ux.form.GlossaryField(Ext.apply({
				cls			: "x-MetaDataGlossaryLinkList",
				triggerClass: "x-form-add-trigger",
      			hideTrigger	: false,
				records		: [],
				initValue: function(){
					if (this.value instanceof Array){
						this.records = this.value.map(function(rec){ return Signavio.Core.RecordCreator.create("gitem", "/glossary/"+rec.id, rec)});
						this.value = "";
					}
					Ext.ux.form.GlossaryField.superclass.initValue.apply(this, arguments);
				},
				onRender: function(){
					Ext.ux.form.GlossaryField.superclass.onRender.apply(this, arguments);	    
					
					if (!this.valueList) {
						this.valueList = new Ext.XTemplate("<div class='x-value-list'></div>").append(this.container, {}, true);
					}

					if (!this.valueTpl) {
						this.valueTpl = new Ext.XTemplate(GlossaryListItemTpl, {
							translate: function(values){
								return this.translate(values, "title");
							}.bind(this)
						});	
					}

					this.valueTpl.compile();
					
					if (this.hideInput) {
						this.wrap.setDisplayed(false);
						this.container.parent().first().setDisplayed(false);
					}

					this.updateValueList();
				},
				updateView: Ext.emptyFn,
				updateValueList: function(){
					this.valueTpl.overwrite(this.valueList, this.records || []);
					this.valueList
						.select("a.x-remove")
						.on("click", function(evt, t){
							Event.stop(evt);
							var id = t.getAttribute("href").split("#").last();

							this.records = this.records.without(this.records.find(function(rec){
								return rec.get("rep").id === id || rec.get("rep").random === id;
							}));
							this.updateValueList();
						}.bind(this)
					)
					
					this.valueList.setDisplayed((this.records||[]).length !== 0);
					
					if (this.ownerCt && this.ownerCt.updateSize){
						this.ownerCt.updateSize();
					}
					
					this.updateView();
					
					this.hiddenItems = this.records.pluck("data").pluck("href");
				},
				onNewRecord: function(record){
					// Update
					this.updateValueList();
					this.setValue();
				}
			}, option))
		},
		
		/**
		 * Type: URL
		 * @param {Object} option
		 */
		generateMetaDataUrl: function(option){
			return new Ext.ux.form.UrlLinkFieldList(Ext.apply({
				data: [option.value].compact(),
				hideTrigger: true,
				listStyle: "margin:2px 0px 4px 0px;white-space:nowrap;",
				onTriggerClick: function(){
					Ext.ux.form.UrlLinkFieldList.prototype.onTriggerClick.apply(this, arguments);
					
					// Try to focus the next field
					var next = this.container.parent().next();
					var focusEl;
					if (next) 
						focusEl = next.child('.x-form-field');
					else 
						// Fix for focus: now that we're using the Ext.ux.Window, the first button is a link button, focussing it like this breaks it
						focusEl = this.ownerCt.buttons[1];
					
					//focusEl.focus();
					if (focusEl) 
						window.setTimeout(focusEl.focus.bind(focusEl), 100);
				},
				onUpdateView: function(){
					if (!this.el || !this.fel) {
						return
					}
					var visible = this.data.length === 0;
					this.el.setDisplayed(visible);
					this.fel.el.setDisplayed(visible);
					if (this.ownerCt && this.ownerCt.updateSize) {
						this.ownerCt.updateSize();
					}
				},
				onStartEdit: function(){
					this.el.setDisplayed(true);
					this.fel.el.setDisplayed(true);
					this.itemField.setDisplayed(false);
				},
				onStopEdit: function(){
					this.el.setDisplayed(false);
					this.fel.el.setDisplayed(false);
					this.itemField.setDisplayed(true);
				},
				onRemove: function(){
					this.fel.focus(false, true);
				},
				getValue: function(){
					return Ext.ux.form.UrlLinkFieldList.prototype.getValue.call(this)[0] || "";
				}
			}, option));
		},
		
		/**
		 * Type: URL
		 * List: true
		 * @param {Object} option
		 */
		generateMetaDataUrlList: function(option){
			return new Ext.ux.form.UrlLinkFieldList(Ext.apply({
						data : option.value || []
					}, option))
		}
	}

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/


ns("ux.form");

(function() {

	Signavio.ux.form.FolderPicker = function(facade, attrs) {
		attrs = attrs || {};
		
		this.facade = facade;

		this.setupFolders(attrs);

		attrs.store = attrs.store || new Ext.data.SimpleStore({
			fields: [
				{ name: "title" },
				{ name: "value" }
			],
			data: this.gatherFolderInfo(attrs.folderStore, attrs.rootFolder)
		});

		delete attrs.rootFolder;

		var that = this;
		
		attrs.valueField = "value";
		attrs.displayField = "title";
		attrs.mode = "local";
		attrs.selectOnFocus = true;
		attrs.editable = attrs.editable || false;
		attrs.readonly = true;
		attrs.emptyText = Ext.ux.getI18N("component.folder.picker.empty");
		attrs.cls = ["folder-picker", attrs.cls].compact().join(" ");
		attrs.anchor = attrs.anchor || "100%";
		
		attrs.tpl = new Ext.XTemplate('<tpl for=".">' +
			'<div class="x-combo-list-item">' +
				'{[ values.value === "custom" ? "<a href=\'\' onclick=\'return false;\'>" : ""]}' +
					'{[ this.escape(values.title) ]}' +
				'{[ values.value === "custom" ? "</a>" : ""]}' +
			'</div>' +
		'</tpl>', {
			escape: function(value) {
				return that.escape(value);
			}
		});
		
		if(attrs.value) {
			this.oldValue = attrs.value;
		} else {
			attrs.value = this.getCurrentFolder();
		}
		
		Signavio.ux.form.FolderPicker.superclass.constructor.call(this, attrs);

		this.on("select", function(comp, record) {
			that.handleSelect(record, {
				trashRecord: attrs.trashRecord,
				folderStore: attrs.folderStore
			});
		});
	};
	
	Ext.extend(Signavio.ux.form.FolderPicker, Ext.ux.form.ComboBox, {
		
		unescape: function(value) {
			if(!value) {
				return "";
			}

			if(value.include("&amp;") || value.include("&lt;")) {
				return value.unescapeHTML();
			}

			return value;
		},

		getCurrentFolder: function() {
			// Explorer
			if(this.facade.getCurrentFolderStore) {
				var store = this.facade.getCurrentFolderStore();
				var info = store.getRecords("info")[0];

				if(!info) {
					return;
				}

				return info.get("href").replace("/info", "");
			}

			// Editor
			return this.facade.getModelMetaData().parent;
		},

		escape: function(value) {
			value = this.unescape(value);

			return value.escapeHTML();
		},

		ensure: function(attrs, key, accessor) {
			if(this.facade[accessor]) {
				attrs[key] = attrs[key] || this.facade[accessor]();
			}

			return !!attrs[key];
		},

		// TODO: remove this method when explorer and editor
		// share one component. It just loads the current folder
		// store in the editor. This should not be neccissary when
		// the facade of the explorer is available
		loadFolderStore: function(folder) {
			var that = this;

			var store = new Ext.data.SimpleStore({
				fields: [
					{ name: "title" },
					{ name: "value" }
				]
			});

			Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + folder, {
				success: function(response) {
					var info = response.find(function(record) {
						return record.rel === "info";
					});

					// folder of the diagram
					that.currentFolder = {
						name: info.rep.name,
						id: folder,
						isRoot: !!info.rep.type
					};

					// find the current root folder (private or public)
					if (info.rep.type) { // diagram in root folder
						that.rootFolder = that.currentFolder;
					} else { // diagram in child folder
						var parents = response.find(function (record) {
							return record.rel === 'parents';
						});
						if (parents && parents.rep) {
							var rootFolder = parents.rep.find(function (folder) {
								return folder.rep.type;
							});
							if (rootFolder && rootFolder.rep) {
								that.rootFolder = {
									name: rootFolder.rep.name,
									id: rootFolder.href
								};
							}
						}
					}

					// load the folder data
					var data = that.createData(info.rep, folder);
					store.loadData(data);
				}
			});

			return store;
		},

		setupFolders: function(attrs) {
			if(!this.ensure(attrs, "folderStore", "getCurrentFolderStore")) {
				var folder = this.facade.getModelMetaData().parent;
				attrs.store = this.loadFolderStore(folder);
			}

			this.ensure(attrs, "rootFolder", "getCurrentRootFolder");
			this.ensure(attrs, "trashRecord", "getTrashRecord");
		},

		createData: function(folderInfo, folderId) {
			var data = [];
			var name = this.unescape(folderInfo.name);
			
			if(folderInfo.type) {
				// only root dirs have type attribute
				if(this.rootFolder.id !== folderId) {
					data = [
						[Ext.ux.getI18N("component.types." + folderInfo.type) || name, folderId]
					];
				}
				
				if(!this.currentFolder.isRoot) {
					data = data.concat([
						[this.currentFolder.name, this.currentFolder.id]
					]);
				}
				
			} else {
				if(folderId !== this.currentFolder.id && !this.currentFolder.isRoot) {
					data = [
						[name, folderId],                       // currently selected folder
						[this.currentFolder.name, this.currentFolder.id],  // current folder
					];
				} else {
					data = [
						[name, folderId]    // current folder
					];
				}
			}
			
			return [[this.rootFolder.name, this.rootFolder.id]].concat(
				data,
				[[Ext.ux.getI18N("component.folder.picker.custom"), "custom"]
			]);
		},
		
		gatherFolderInfo: function(folderStore, rootFolder) {
			var records = folderStore.getRecords("info");
			
			var folderInfo = records.invoke("get", "rep")[0];
			var folderId = records.invoke("get", "href")[0];
			
			if(folderId.endsWith("/info")) {
				folderId = folderId.replace("/info", "");
			}
			
			if(folderInfo.type) {
				this.currentFolder = {
					name: Ext.ux.getI18N("component.types." + folderInfo.type),
					id: folderId,
					isRoot: true
				};
			} else {
				this.currentFolder = {
					name: folderInfo.name,
					id: folderId,
					isRoot: false
				};
			}
			
			var rootInfo = rootFolder.get("rep");
			var rootName = Ext.ux.getI18N("component.types." + rootInfo.type);
			
			this.rootFolder = {
				name: rootName,
				id: rootFolder.get("href")
			};
			
			return this.createData(folderInfo, folderId);
		},

		showFolderWindow: function(option) {
			var oldValue = this.oldValue;
			this.oldValue = this.getValue();

			var folderTree = this.getFolderTree(option.trashRecord, option.folderStore);
			
			var label = new Ext.form.Label({
				cls		: "y-wizard-description-label",
				text    : Ext.ux.getI18N("component.folder.picker.description")
			});
			
			var invalid = true;
			
			var win = new Ext.ux.Window({
				title: Ext.ux.getI18N("component.folder.picker.head"),
				width: 500,
				modal: true,
				cls: "file-upload",
				cancelButton: {
					text: Ext.MessageBox.buttonText.cancel,
					handler: function() {
						this.setValue(oldValue || "");
						
						win.close();
					}.bind(this)
				},
				buttons: [
					{
						text: Ext.MessageBox.buttonText.ok,
						handler: function() {
							invalid = false;
							var selectedRecord = folderTree.getSelectedRecord();
							
							if(selectedRecord) {
								this.updateSelectedFolder(selectedRecord);
								win.close();
							}
						}.bind(this)
					}
				],
				items: [label, folderTree]
			});
			
			win.on("close", function() {
				if(!invalid) {
					return;
				}

				this.setValue(oldValue || "");
				this.oldValue = oldValue;
			}.bind(this));
			
			win.show();
		},
		
		handleSelect: function(record, option) {
			if(record.get("value") !== "custom") {
				return;
			}
			
			this.showFolderWindow(option);
		},
		
		updateSelectedFolder: function(record) {
			this.oldValue = record.get("href");

			var data = this.createData(record.get("rep"), record.get("href"));
			
			this.store.loadData(data);
			this.setValue(record.get("href"));
		},
		
		getFolderTree: function(trashRecord, folderStore) {
			return new Signavio.ux.dialog.tree.FolderPanel(this.facade, {
				data: [folderStore],
				height: 250
			});
		},
		
		getJSON: function() {
			return this.getValue();
		}
		
	});

}());
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */
ns("ux.form", "Ext");
ns("ux.data", "Ext");

(function() {
	
	Ext.ux.data.RecordCreator = {}
	
	/**
	 * Creates a new record, including 'rel', 'href', and 'rep' attributes
	 * @param {String} rel
	 * @param {String} href
	 * @param {Object} rep
	 * @static
	 */
	Ext.ux.data.RecordCreator.create = function(rel, href, rep){
					
		var Rec = Ext.data.Record.create(["rel", "href", "rep"]);

		var record = new Rec({
			rel	: rel,
			href: href,
			rep	: rep
		});
		return record;
	}	
	

	/**
	 * Implements a json reader to read
	 * glossary items
	 * 
	 * @class Ext.ux.data.GlossaryReader 
	 * @param {Object} meta
	 */
	Ext.ux.data.RecordReader = function(meta){
		meta = meta || {};
		this.rels = meta.rels || this.rels;
		Ext.ux.data.RecordReader.superclass.constructor.call(this, meta, ['rep','href','rel']);
	};
	Ext.extend(Ext.ux.data.RecordReader, Ext.data.JsonReader, {
		
		// Define the filter depending on the "rel"-attribute
		rels: ["gitem"],
		
		/**
		 * Specific implementation to 
		 * read the json with the defined attributes
		 * 
		 * @param {Object} response
		 */
		read : function(response){
			var json = response.responseText;
			var o = eval("("+json+")");
			if(!o) {
				throw {message: "JsonReader.read: Json object not found"};
			}
			var Record = this.recordType;
			var records = [], total = 0;
			o.each(function(rec){
				if (this.rels.include(rec.rel)) {
					records.push(new Record(rec));
				} 
				if (rec.rel == "info" && rec.rep.size){
					total = rec.rep.size;
				}
			}.bind(this))
			return {
				success : true,
				records : records,
				totalRecords : total || records.length
			}
		}
	});

	/**
	 * Class for remote glossary entry search
	 * 
	 * @class
	 * @param attr
	 * @return
	 */
	Ext.ux.form.GlossaryField = function(attr){

		// Set paging parameter to offset
		Ext.PagingToolbar.prototype.paramNames.start = "offset";
		
		// Set attr
		attr = attr || {};

		// Set default request params
		var params = {
			select	: "title",
			include	: "all"
		};
		
		if (attr.linkableType){
			params.category  = attr.linkableType
		}
		
		if (typeof attr.showEmptyItems !== "undefined") {
			this.showEmptyItems = attr.showEmptyItems;
		}
		
		// Get cached or new category store
		attr.categoryStore = Ext.StoreMgr.get('category');
		if (!attr.categoryStore) {
			attr.categoryStore = new Ext.data.Store({
				baseParams: {},
				id : 'category',
				proxy: new Ext.data.HttpProxy({
					useAjax	: true,
					method	: "GET",
					headers	: {
						accept:"application/json"
					},
					url		: Signavio.Config.BACKEND_PATH + '/glossary'
				}),
				reader: new Ext.ux.data.RecordReader({rels:'cat'})
			});

			attr.categoryStore.load();
		}
		
		/*
		 * Get cached or new store for only these categories that the user may edit.
		 * AND: Only get this store at all if showEmptyItems is set, otherwise it is not needed.
		 */
		if (this.showEmptyItems) {
			attr.writableCategoryStore = Ext.StoreMgr.get('writableCategories');
			if (!attr.writableCategoryStore) {
				attr.writableCategoryStore = new Ext.data.Store({
					baseParams: {},
					id : 'writableCategories',
					proxy: new Ext.data.HttpProxy({
						useAjax	: true,
						method	: "GET",
						headers	: {
							accept:"application/json"
						},
						url		: Signavio.Config.BACKEND_PATH + '/glossarycategory?allCategories=true&withWritePrivOnly=true'
					}),
					reader: new Ext.ux.data.RecordReader({rels:'cat'})
				});
				
				attr.writableCategoryStore.load();
			}
		}
		
		// Set the new store
		attr.store = new Ext.data.Store({
			baseParams: params,
			proxy: new Ext.data.HttpProxy({
				useAjax: true,
				method: "GET",
				headers: {
					accept:"application/json"
				},
				url: Signavio.Config.BACKEND_PATH + '/glossary'
			}),
			reader: new Ext.ux.data.RecordReader({
				rels:'gitem'
			})
		});
		
		// Set the template
	
		attr.tpl = new Ext.XTemplate(
			'<tpl for=".">',
				'<div class="search-item">',
					'<span class="x-{[values.rep.category.toLowerCase()]} x-glossary-color" style="float:left;background:{values.rep.color}"></span>',
					'<tpl if="values.href">',
						'<tpl for="rep">',
							'{[Signavio.Utils.escapeHTML(this.translate(values))]}',
						'</tpl>',
					'</tpl>',
					'<tpl if="!values.href">',
						'<tpl for="rep">',
							'{emptyTitle}',
						'</tpl>',
					'</tpl>',
				'</div>',
			'</tpl>', {
				translate: function(values){
					return this.translate(values, "title") || "&nbsp;";
				}.bind(this)
			}
		);

		// Overwrite some attributes
		attr.cls = "x-glossary-support";

		// Call super
		Ext.ux.form.GlossaryField.superclass.constructor.call(this, attr);
	};
	
	Ext.extend(Ext.ux.form.GlossaryField, Ext.form.ComboBox, {
		typeAhead		: false,
		forceSelection	: true,
		lazyRender		: false,
		lazyInit 		: false,
		listClass 		: 'x-glossary-support',
		displayField	: 'rep.title',
		loadingText		: 'Searching...',
		emptyTextList	: '<div class="x-no-entry">'+Ext.ux.getI18N("noglossary_entry")+'</div>',
		queryDelay		: 100,
		minChars		: 2,
		pageSize		: 10,
		preventScrollbars:true,
		queryParam		: "q",
		hideTrigger		: true,
		resizable 		: true,
		itemSelector	: 'div.search-item',

		// Callback if a new element has to be created
		onCreateNew		: null,
		
		// Show a set of empty category items to create new one
		showEmptyItems	: true,
		
		// Define the set on items which should not been shown
		hiddenItems		: [],

		/**
		 * Translates the value with the given key
		 * @param values
		 * @param key
		 * @returns {Object}
		 */
		translate		: function(values, key){

			var langs = this.languages,
				lang  = this.language;

			if (!langs || langs.length < 2){
				return values[key];
			}

			if (!lang){
				lang = langs.first();
			}

			// Get the multi languaged title
			if (langs && lang && langs.length > 1){
				[].concat(lang, langs).each(function(l){
					if (values[key+(l==langs.first()?"":"_"+l)]){
						key = (key+(l==langs.first()?"":"_"+l));
						throw $break;
					}
				});
			}
			
			return values[key];
		},

		// @overwrite
		initEvents 		: function(){
			Ext.ux.form.GlossaryField.superclass.initEvents.call(this);
			
			// Overwrite tab behavior
			this.keyNav.tab = function(){
				if (this.selectedIndex >= 0){
					this.onViewClick(false);
				} else {
					this.collapse();
				}
				return true;
			}
			
			if (this.zindex){
				this.list.setZIndex(this.zindex);	
			}
		},
		
		/**
		 * Callback which will be called if a new 
		 * glossary has been added to the list
		 * 
		 * @param {Object} record
		 */
		onNewRecord: Ext.emptyFn,
		
		// @overwrite
		getValue: function(){
			return (this.records||[]).map(function(rec){
				return rec.get("href") || rec.get("rep")
			}) ;
		},
		
		disableBlur : function(){
			this.disabledBlur = true;
			this.validateBlur = function(){
				return false;
			};
		},
		
		collapseIf: function(){
			if (!this.disabledBlur){
				Ext.ux.form.GlossaryField.superclass.collapseIf.apply(this, arguments);
			}
		},
		
		enableBlur: function(){        
			delete this.disabledBlur;
			this.validateBlur 	= Ext.form.ComboBox.prototype.validateBlur.bind(this);
		},
		
		// @overwrite
		onSelect: function(record){
			
			if (record && !record.get("href") && this.onCreateNew instanceof Function && this.onCreateNew(record) === false){
				return;
			}
			
			// Strip title
			var title = Signavio.Utils.unescapeHTML(this.translate(record.get("rep"),"title")||this.translate(record.get("rep"),"name")||"");
		
			// If forceselection
			if (this.forceSelection){
				// Set value
				this.lastSelectedCursor = 0;
				this.setValue(title);
			} else {
				// Otherwise try to replace 
				var text = this.getRawValue();
				var cursor = this.getCursorPosition();
				var newText = Signavio.Utils.replaceCommonSubString(text, title, cursor);
				
				var pos = 0, ref = newText.toLowerCase();
				Signavio.Utils.tokenize(title).each(function(token){
					pos = Math.max(ref.indexOf(token.toLowerCase(), pos) + token.length, 0) || pos;
				})
				
				this.lastSelectedCursor = pos;
				this.setValue(newText);
			}
			
			// Collapse
			this.collapse();
			this.selectedIndex = -1;
			
			// Check
			if (!this.records) {
				this.records = [];
			}
			
			// Add, if uniq
			if (!this.records.any(function(r){ 
				return record.get("href") && r.get("href") === record.get("href");
			})) {
				this.records.push(record);
			}
			
			this.onNewRecord(record);
		},
		
		/**
		 * Returns the position of the cursor
		 * @return {int}
		 */
		getCursorPosition: function(){
			var input = this.el.dom;
			if (input && typeof input.selectionStart !== "undefined") {
				return input.selectionStart;
			} else {
				return input.value.length;
			}
		},

		// @private
		initList: function(){
			Ext.ux.form.GlossaryField.superclass.initList.apply(this, arguments);

			if (this.emptyTextList) {
				this.view.emptyText = this.emptyTextList;
			}

			if (this.view) {
				this.view.onMouseOut = function(e){
					if(this.lastItem){
						try {
							if(!e.within(this.lastItem, true)){
								Ext.fly(this.lastItem).removeClass(this.overClass);
								delete this.lastItem;
							}
						} catch(error){ }
					}
				}.bind(this.view);
			}

			
			// If toolbar
			if (this.pageTb){
				// Remove all items
				var tb = this.pageTb;
				this.pageTb.items.each(function(item){
					if (!(item == tb.first||item == tb.prev||item == tb.next||item == tb.last)){
						item.hide();
					}
				})
				
				// Add text
				var te = tb.addText("");
				var index = 2;
				tb.tr.insertBefore(te.el.parentNode, tb.tr.childNodes[index]);
				tb.items.remove(te);
				tb.items.insert(index, te);
				tb.displayMsg = "{0}/{1}"
				tb.displayEl = Ext.fly(te.el).createChild({
					cls: 'x-paging-info',
					style: {
						display: "inline",
						position: "relative",
						left: "0",
						top: "0"
					}
				}); // Text will be automatically updated through original class
				
				// Add spacer
				var sp = tb.addFill();
				tb.tr.insertBefore(sp.el.parentNode, tb.tr.childNodes[++index]);
				tb.items.remove(sp);
				tb.items.insert(index, sp);
				
				var count = this.pageSize, me = this;
				tb.updateInfo = function(){
					if(this.displayEl){
						var msg = this.store.getTotalCount() <= count ?
							"" :
							String.format(
								this.displayMsg,
								Math.ceil((this.cursor+1)/count), Math.ceil(this.store.getTotalCount()/count)
							);
					   this.displayEl.update(msg);
					   if (!msg){
							me.assetHeight -= !this.hidden ? 23 : 0;
							this.hide();
					   } else {
							me.assetHeight += this.hidden ? 23 : 0;
							this.show();
					   }
					}
				}
			}

			if (!this.pageSize)
				this.pageSize = 10;
		},

		// @overwrite
		onDestroy : function(){
			if(this.textSizeEl){
				Ext.removeNode(this.textSizeEl);
			}

			if (this.view&&this.view.lastItem) {
				delete this.view.lastItem;
			}

			Ext.ux.form.GlossaryField.superclass.onDestroy.call(this);
		},

		// @overwrite        
		onBeforeLoad : function(){
			if(!this.hasFocus){
				return;
			}

			if (!this.innerList.child("div.loading-indicator")) {
				if (this.store.getCount()>0) {
					this.innerList.createChild({tag: 'div', cls: 'loading-indicator', html: this.loadingText});
				} else {
					this.innerList.update(this.loadingText ? '<div class="loading-indicator">'+this.loadingText+'</div>' : '');
				}
			}
			if (this.selectedIndex>=0){
				this.lastSelectedRecord = this.store.getAt(this.selectedIndex);
			} else {
				delete this.lastSelectedRecord;
			}

			this.restrictHeight();
		},
		
		getSearchQuery: function(){
			return (this.getRawValue()||"").trim();
		},
		
		// @overwrite
		initQuery : function(){
			if (this.list) {
				this.doQuery(this.getSearchQuery());				
			}
		},

		// @overwrite
		doQuery : function(q, forceAll,includeAll){
			if(!this.store) {
				return;
			}
			if(q === undefined || q === null){
				q = '';
			}
			var qe = {
				query: q,
				forceAll: forceAll,
				combo: this,
				cancel:false
			};

			if(this.fireEvent('beforequery', qe)===false || qe.cancel){
				return false;
			}
			q = qe.query;
			forceAll = qe.forceAll;
			var qq = (q||"").strip().split(/\s+/).findAll(function(r){ return r.length >= this.minChars }.bind(this))
			if(forceAll === true || qq.length > 0){
				qq = qq.join(" ");
				if(this.lastQuery !== qq){
					this.lastQuery = qq;
					if(this.mode == 'local'){
						this.selectedIndex = -1;
						if(forceAll){
							this.store.clearFilter();
						}else{
							this.store.filter(this.displayField, q);
						}
						this.onLoad();
					}else{
						this.store.baseParams[this.queryParam] = qq;
						var params = this.getParams(qq);
						if (includeAll === true){
							params.include = "all";
						}
						this.store.load({
							params: params
						});
						this.expand();
					}
				}else{
					this.selectedIndex = -1;
					this.onLoad();
				}
			}
		},

		/**
		 * Filters the store by the hidden items
		 * 
		 */
		filterStore : function(){
			this.store.filterBy(function(r){
				return !this.hiddenItems.include(r.get("href"));
			}.bind(this));
			this.store.data.length = Math.min(this.pageSize, this.store.data.length);
			this.store.fireEvent("datachanged", this.store);
		},
		
		// @overwrite
		onLoad : function(){
			if(!this.hasFocus){
				return;
			}
			
			// Filter the store by the hidden items
			this.filterStore();
			
			if(this.store.getCount() > 0){
				this.expand();
				this.restrictHeight();
				if(this.lastQuery == this.allQuery){
					if(this.editable){
						this.el.dom.select();
					}
					/*if(!this.selectByValue(this.value, true)){
						this.select(0, true);
					}*/
				} else {
					//this.selectNext();
					if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
						this.taTask.delay(this.typeAheadDelay);
					}
				}

				var index = 0;
				if (this.lastSelectedRecord) {
					index = this.store.find("href", this.lastSelectedRecord.get("href"));
				}
				this.select(index, true);

			}else{
				this.onEmptyResults();
			}
			//this.el.focus();
		},

		/**
		 * Creates the set on empty items
		 * 
		 */
		createEmptyItems: function(){
			
			this.selectedIndex = -1;
			
			// Get latest text snipped
			var text = this.getRawValue();
			var cursor = this.getCursorPosition();
			var lCursor = this.lastSelectedCursor || 0;
			text = text.slice(lCursor <= cursor ? lCursor : 0);
			text = text.strip().replace(/\s+/g, " ");
			
			// Add new create elements
			if (text) {			
				this.writableCategoryStore	// Get the store of writable categories
					.data.items				// Get all categories
					.pluck("data")			// Get the name
					.each(function(categoryData){
						/*
						 * Only suggest the category that is allowed to be linked
						 * by this shape AND any of its subcategories.
						 */
						if (this.linkableType && this.linkableType !== categoryData.href && 
												 this.linkableType !== categoryData.rep.parentCategory){
							return;
						}
						var title = categoryData.rep.name;
						var color = categoryData.rep.color;
						title = new Template(Ext.ux.getI18N("createGlossaryOnTheFly")).evaluate([Signavio.Utils.escapeHTML(text), Ext.ux.getI18N(title) || title]);
						this.store.add(new Ext.ux.data.RecordCreator.create("gitem", "", {title:text, emptyTitle:title, category:categoryData.href, color:color, random: String((new Date()).getTime())}));
				}.bind(this));
			
				// Prepend empty text if not already set
				if (this.view.el.dom.textContent !== Ext.ux.getI18N("noglossary_entry")) {
					this.view.el.createChild(this.emptyTextList, this.view.el.first())	
				}
			}
		},
		
		// @overwrite
		onEmptyResults : function(){
			// Creates the set on empty items
			if (this.showEmptyItems)
				this.createEmptyItems();
			// Update height
			this.restrictHeight();

		},
		
		// @overwrite
		onTypeAhead : function(){
			if(this.store.getCount() > 0){
				var r = this.store.getAt(0);
				var newValue = Signavio.Utils.extractValue(r, this.displayField);
				var len = newValue.length;
				var selStart = this.getRawValue().length;
				if(selStart != len){
					this.setRawValue(newValue);
					this.selectText(selStart, newValue.length);
				}
			}
		},
		
		// @overwrite
		getParams : function(q){
			var p = {};
			if(this.pageSize){
				p.offset = 0;
				p.limit = this.pageSize + (this.hiddenItems||[]).length;
			}
			return p;
		}
	})
	
}());
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

 if(!Ext) { var Ext = {}; }
 if(!Ext.ux) { Ext.ux = {}; }
 if(!Ext.ux.form) { Ext.ux.form = {}; }
 
(function() {
     
    Ext.ux.form.GlossaryList = function(attr) {
     
        attr.listeners = Ext.apply({}, {
            specialkey: function(t, e) {
                if(e.getKey() === e.ENTER) {
                    t.onTriggerClick();
                    
                    return false;
                } else if (e.getKey() === e.ESC) {
                    t.stopEditing();
                }
            }
        }, attr.listeners);
        
        this.data = [];
        
        Ext.ux.form.GlossaryList.superclass.constructor.call(this, attr);
    };
     
    Ext.extend(Ext.ux.form.GlossaryList, Ext.ux.form.GlossaryField, {
         
        data: [],
        hideTrigger: false,
        triggerClass: "x-form-add-trigger",
        ctCls: "x-form-textfield-list",
         
        onTriggerClick: function() {
            var index = this.editing !== undefined ? this.editing : this.data.length;
            var value = this.currentValue;
            
            if(!value) {
                return;
            }
            
            if(this.editing !== undefined) {
                this.data[this.editing] = value;
                this.stopEditing();
            } else {
                if(!this.exists(value)) {
                    this.data.push(value);
                }
            }
            
            this.setRawValue("");
            this.updateView();
            
            var ni = (this.itemField.query("li") || [])[index];
            if(ni && this.ownerCt) {
                Ext.fly(ni).scrollIntoView(this.ownerCt.body);
            }
            
            delete this.currentValue;
            window.setTimeout(this.focus.bind(this), 10);
        },
        
        exists: function(value) {
            var existing;
            
            if(value instanceof Array) {
                existing = this.data.find(function(el) {
                    if(el[0] === value[0]) {
                        return true;
                    }
                });  
            }
            
            return !!existing;
        },
         
        isGlossaryEntry: function(value){
            return typeof value === "string" && !!value.match(/\glossary\:\/\/.+\/[\w\W]+\;\;/g);
        },

        glossaryId: function(grecord) {
            if(typeof grecord === "string") {
            	if (!!grecord.match(/\glossary\:\/\/.+\/[\w\W]+\;\;/g)){
            		return (grecord||"").split(";;").invoke("replace", /\glossary\:\/\//g, "").invoke("replace", /\/[\w\W]+/g, "").first();
            	} else if (grecord.startsWith("/glossary/")){
            		return (grecord||"").replace("/glossary/", "");
            	}
            }
            
            return "";
        },
        
        glossaryTitle: function(grecord) {
            if(typeof grecord === "string" && !!grecord.match(/\glossary\:\/\/.+\/[\w\W]+\;\;/g)) {
            	return (grecord||"").replace(/;;$/, "").replace(/\glossary\:\/\/.+?\//g, "");
            }
            return "";
        },
        
        getInGlossarySchema: function(id, title) {
            id = (id||"").replace(/([\/]|glossary)/g, "");
            return "glossary://" + id + "/" + title + ";;";
        },
         
        initValue: function() {
            var href, title;
            
            if (this.value !== undefined && this.isGlossaryEntry(this.value)){
                href = this.value;
                
                this.value = this.glossaryTitle(this.value);
                
                title = this.value;
            } else {
                Ext.ux.form.GlossaryList.superclass.initValue.apply(this, arguments);
                return;
            }
            
            if(typeof this.value === "string") {
                this.value = this.value ? [href, title] : [];
            }
            
            if(this.value instanceof Array) {
                this.data = this.value;
                
                var value = this.value;
                this.value = "";
            }
            
            if(value) {
                this.data = value;
                this.updateView();
            }
        },
         
        onShow: function() {
            Ext.ux.form.GlossaryList.superclass.onShow.apply(this, arguments);
            
            if(!this.width) {
                delete this.lastSize;
                this.setWidth(this.width);
            }  
        },
         
        onRender: function() {
            Ext.ux.form.GlossaryList.superclass.onRender.apply(this, arguments);
            
            if(!this.itemFieldTpl) {
                this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty"></span></tpl>',
                							'<tpl for=".">',
                								'<span class="y-filter-combo-list">{[Signavio.Utils.escapeHTML(values[1])]} ', 
                									'<span class="x-smaller">', 
                                                        '(', 
                                                            '<a href="#{[xindex-1]}" class="x-edit" tabindex="-1">{[(Ext.ux.getI18N("btnEdit"))]}</a>, ', 
                                                            '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>',
                                                        ')',
                                                    '</span>', 
                								'</span>',
                							 '</tpl>');
            }
            
            
            if (!this.itemField){
	            this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {
	                tag: 'div',
	                cls: 'x-glossary-list-root',
	                style: 'margin: 1px 0px 0px 0px; display:none;' + this.listStyle
	            }));
	            

	            this.updateView();
	            
	            var wrap = this.wrap.boxWrap();
				wrap.child(".x-box-mc");
            }            
        },
         
        onUpdateView: Ext.emptyFn,
         
        updateView: function() {
            if(!this.itemFieldTpl || !this.itemField) {
                return;
            }
            
            this.itemFieldTpl.overwrite(this.itemField, this.data || []);
            this.itemField.setDisplayed((this.data || []).length > 0);
            
            this.updateEvents();
            
            if(this.ownerCt && this.ownerCt.updateSize) {
                this.ownerCt.updateSize();
            }
            
            this.onUpdateView();
        },
         
        updateEvents: function() {
        
            var getId = function(el){
                return parseInt(el.getAttribute("href").split('#').last());
            };
            
            this.itemField.select("a.x-remove").on("click", function(e, t) {
                Event.stop(e);
                
                var index = getId(t);
                this.remove(index);
                this.updateView();
            }.bind(this));
            
            this.itemField.select("a.x-edit").on("click", function(e, t) {
                Event.stop(e);
                
                var index = getId(t);
                this.startEditing(index);
            }.bind(this));
        },
        
        remove: function(index) {
            delete this.data[index];
            this.data = this.data.compact();
        },
         
        onStartEdit: Ext.emptyFn,
         
        startEditing: function(index) {
            this.editing = index;
            
            var el = this.itemField.query(".y-filter-combo-list")[index];
            Ext.fly(el).addClass("x-editing");
            
            var value = this.data[index].first();
            var rawValue = this.data[index].last();
            
            this.currentValue = [value, rawValue];
            
            this.setValue(value);
            this.setRawValue(rawValue);
            
            window.setTimeout(this.focus.bind(this), 10);
            
            this.onStartEdit();             
        },
         
        onStopEdit: Ext.emptyFn,
         
        stopEditing: function() {
            if(this.editing === undefined) {
                return;
            }  
            
            var el = this.itemField.query(".y-filter-combo-list")[this.editing];
            Ext.fly(el).removeClass("x-editing");
            
            delete this.editing;
            
            this.setRawValue("");
            this.onStopEdit();
        },
        
        cancelEdit: function(remainVisible) {
            if(this.editing) {
                if(!remainVisible) {
                    this.hide();
                }
            }
        },
         
        onSelect: function(record) {
            if(record && !record.get("href")) {
                return;
            }  
            
            var href = record.get("href");
            var rep = record.get("rep");
            
            var title = Signavio.Utils.unescapeHTML(record.get("rep").title||record.get("rep").name||"");
            
            this.setRawValue(title);            
            this.currentValue = [href, title];
            
            Ext.ux.form.GlossaryList.superclass.onSelect.call(this, record);
        },

        getValue: function(){
			return this.data;
		},
        
        setValue: function(value) {
            if(value && value instanceof Array) {
                value.each(function(el) {
                	if (!el){ return; }
                    if(!(el instanceof Array) && "string" == typeof el) {
                        el = ["/glossary/" + this.glossaryId(el), this.glossaryTitle(el)];
                    }
                    
                    if(!this.exists(el)) {
                        this.data.push(el);
                    }
                }.bind(this));

                this.updateView();
            }
        }
         
     });
     
 })();
/**
 * Copyright (c) 2009
 * Signavio GmbH
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 * @author Willi Tscheschner
 * 
 *  Class for remote glossary entry search
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.form){ Ext.ux.form = {} }

new function(){

/**
	 * Class for remote glossary entry search
	 * 
	 * @class
	 * @param attr
	 * @return
	 */
	Ext.ux.form.GlossarySearchFieldBox = function(attr){
		
		// Set paging parameter to offset
		Ext.PagingToolbar.prototype.paramNames.start = "offset";
		
		// Set attr
	    attr = attr || {};
	    
	    var params = {
	    	select: "title",
	    	originId: attr.parentDir,
	    	operator: 'OR',
	    	language: attr.language,
	    	include: "all",
	    	stencilId: attr.stencil,
	    	stencilsetNamespace: attr.ssns
	    };
	    
//	    if (attr.categories){
//	    	params.category = attr.categories;
//	    }
	    	    
		// Set the new store
		attr.store = new Ext.data.Store({
							baseParams: params,
				            proxy: new Ext.data.HttpProxy({
				            	useAjax	: true,
				            	method	: "GET", 
				            	headers	: {accept:"application/json"},
				                url		: Signavio.Config.BACKEND_PATH + '/glossary'
				            }),
				            reader: new Signavio.Helper.RecordReader()
				        });
		
		// Set the template
		/*attr.tpl = new Ext.XTemplate(
				            '<tpl for="."><div class="search-item">',
			            	'<tpl for="rep">',
				                '<h3>{title}</h3>',
				                '{[Signavio.Helper.TruncateByWidth(values.description, 500, "...")]}',
			                '</tpl>',
			            '</div></tpl>'
			        );*/
		attr.tpl = new Ext.XTemplate(
				            '<tpl for="."><div class="search-item">',
							'<div class="x-{[(values.rep.category||"").toLowerCase()]} x-glossary-color" style="background-color:{values.rep.color}" title="{values.rep.categoryName}"></div>',
			            	'<tpl for="rep">{[Signavio.Utils.escapeHTML(this.translate(values)||"")]}</tpl>',
				            '</div></tpl>'
			        	, {
				            	translate: function(values){
									var langs = attr.languages,
										lang  = attr.language,
										key = "title";
									
									// Get the multi languaged title
									if (langs && lang && langs.length > 1){
										[].concat(lang, langs).each(function(l){
											if (values[key+(l==langs.first()?"":"_"+l)]){
												key = (key+(l==langs.first()?"":"_"+l));
												throw $break;
											}
										});
									}
									return values[key];
				            	}
				            });
		// Overwrite some attributes
		attr.style = "";
		attr.cls = "x-glossary-support";
		
		// Define dom element
		this.defaultAutoCreate = {
		        tag: attr.renderAsTextArea ? "textarea" : "input",
		        autocomplete: "off",
		        style:"visibility:hidden;"
		    };
		
		// Set attr
		this.renderAsTextArea = attr.renderAsTextArea;
    	
    	// Custom attributes used when auto-sizing the field.
    	this.growPad = Signavio.Config.GROWING_TEXT_AREA.VERTICAL_PADDING;
    	this.growPadHorizontal = Signavio.Config.GROWING_TEXT_AREA.HORIZONTAL_PADDING;
    	this.growAppend = Signavio.Config.GROWING_TEXT_AREA.GROW_APPEND;
    	
		/* Since the GlossarySearchField does not have a TextArea superclass,
		 * keep track of these TextArea-specific attributes manually. 
		 **/
		attr.growMin = Math.max(attr.growMin || 0);
    	attr.growMinHorizontal = Math.max(attr.growMinHorizontal || 0);
    	attr.growMax = Signavio.Config.GROWING_TEXT_AREA.GROW_MAX;


		this.growHorizontally = attr.growHorizontally;
		
		// Call super
		Ext.ux.form.GlossarySearchFieldBox.superclass.constructor.call(this, attr);
	    
	};
	Ext.extend(Ext.ux.form.GlossarySearchFieldBox, Ext.form.ComboBox, {
        lazyRender		: false,
        listClass 		: 'x-glossary-support',
        listWidth 		: 200,
        displayField	: 'href',
        typeAhead		: false,
        pageSize		: 10,
        lazyInit 		: false,
        queryDelay		: 100,
        minChars		: 2,
        preventScrollbars:true,
        queryParam		: "q",
        hideTrigger		: true,
        resizable 		: true,
        itemSelector	: 'div.search-item',
        onSelect		: function(record){ // override default onSelect to do redirect

        },
        
        initList: function(){
        	Ext.ux.form.GlossarySearchFieldBox.superclass.initList.apply(this, arguments);
			
        	if (this.emptyTextList) {
        		this.view.emptyText = this.emptyTextList;
        	}
        	
        	if (this.view) {
        		this.view.onMouseOut = function(e){
	                if(this.lastItem){
	                	try {
	                		if(!e.within(this.lastItem, true)){
	                			Ext.fly(this.lastItem).removeClass(this.overClass);
	                			delete this.lastItem;
	                		}
	                	} catch(error){ }
	                }
	            }.bind(this.view);
        	}
			
			if (this.pageTb){
				// Remove all items
				var tb = this.pageTb;
				this.pageTb.items.each(function(item){
					if (!(item == tb.first||item == tb.prev||item == tb.next||item == tb.last)){
						item.hide();
					}
				})
				
				// Add text
				var te = tb.addText("");
				var index = 2;
				tb.tr.insertBefore(te.el.parentNode, tb.tr.childNodes[index]);
				tb.items.remove(te);
				tb.items.insert(index, te);
				tb.displayMsg = "{0}/{1}"
				tb.displayEl = Ext.fly(te.el).createChild({cls:'x-paging-info', style:{display:"inline",position:"relative",left:"0",top:"0"}}); // Text will be automatically updated through original class
				
				// Add spacer
				var sp = tb.addFill();
				tb.tr.insertBefore(sp.el.parentNode, tb.tr.childNodes[++index]);
				tb.items.remove(sp);
				tb.items.insert(index, sp);
				
				var count = this.pageSize, me = this;
				tb.updateInfo = function(){
			        if(this.displayEl){
			            var msg = this.store.getTotalCount() <= count ?
			                "" :
			                String.format(
			                    this.displayMsg,
			                    Math.ceil((this.cursor+1)/count), Math.ceil(this.store.getTotalCount()/count)
			                );
			           this.displayEl.update(msg);
					   if (!msg){
						   	me.assetHeight -= !this.hidden ? 23 : 0;
					   		this.hide();
					   } else {
						   	me.assetHeight += this.hidden ? 23 : 0;
					   		this.show();
					   }
					   me.restrictHeight();
        			}
				}

				tb.updateInfo(); // Hide toolbar initially
			}
        	
        	//this.pageSize = 10;
        },
        
        onRender: function(){
        	Ext.ux.form.GlossarySearchFieldBox.superclass.onRender.apply(this, arguments);
    	            	
            if(this.grow){
                this.textSizeEl = Ext.DomHelper.append(document.body, {
                    tag: "pre", cls: "x-form-grow-sizer"
                });
                if(this.preventScrollbars){
                    this.el.setStyle("overflow", "hidden");
                }
                //this.el.setHeight(this.growMin);
            }    
        },
        
        onDestroy : function(){
            if(this.textSizeEl){
                Ext.removeNode(this.textSizeEl);
            }
            
            if (this.view&&this.view.lastItem) {
            	delete this.view.lastItem;
            }
    	    
            Ext.ux.form.GlossarySearchFieldBox.superclass.onDestroy.call(this);
        },

    	
        // private
        onKeyUp : function(e){
        	Ext.ux.form.GlossarySearchFieldBox.superclass.onKeyUp.apply(this, arguments);
        	
        	// IF textarea AND the key code is an ENTER, DELETE, or REMOVE key
            if(this.renderAsTextArea && (e.getKey() == e.ENTER || e.getKey() ==  e.DELETE || e.getKey() == 8 || true)){    
            	// Update textarea size
    			this.autoSize();
            }
        },
        
        // private
        onBlur : function(evt, target){
        	
        	// Workaround for IE9:
        	// If click on the list, the blur event
        	// was raised, which now will be stopped.
        	if ((Ext.isIE9 || Ext.isIE10) && target === this.el.dom){
        		Event.stop(evt.browserEvent);
        		return;
        	}
        	
            this.beforeBlur();
            if(!Ext.isOpera && this.focusClass){ // don't touch in Opera
                this.el.removeClass(this.focusClass);
            }
            this.hasFocus = false;
            if(this.validationEvent !== false && this.validateOnBlur && this.validationEvent != "blur"){
                this.validate();
            }
            var v = this.getValue();
            if(String(v) !== String(this.startValue)){
                this.fireEvent('change', this, v, this.startValue);
            }
            this.fireEvent("blur", this);
        },

        
        onBeforeLoad : function(){
            if(!this.hasFocus){
                return;
            }
            
            if (!this.innerList.child("div.loading-indicator")) {
            	if (this.store.getCount()>0) {
            		this.innerList.createChild({tag: 'div', cls: 'loading-indicator', html: this.loadingText});
            	} else {
            		this.innerList.update(this.loadingText ? '<div class="loading-indicator">'+this.loadingText+'</div>' : '');
            	}
            } 
            if (this.selectedIndex>=0){
            	this.lastSelectedRecord = this.store.getAt(this.selectedIndex);
            } else {
            	delete this.lastSelectedRecord;
            }
            
            this.restrictHeight();
        },

    	/**
    	 * @Overwrite
    	 */
        initQuery : function(){
        	if (this.list)
        		this.doQuery(this.getRawValue());
        },
		
	    getParams : function(q){
	        var p = {};
	        if(this.pageSize){
	            p.offset = 0;
	            p.limit = this.pageSize;
	        }
	        return p;
	    },
		
    	/**
    	 * @Overwrite
    	 */
        doQuery : function(q, forceAll){
        	if(!this.store) {
        		return;
        	}
            if(q === undefined || q === null){
                q = '';
            }
            var qe = {
                query: q,
                forceAll: forceAll,
                combo: this,
                cancel:false
            };
            if(this.fireEvent('beforequery', qe)===false || qe.cancel){
                return false;
            }
            q = qe.query;
            forceAll = qe.forceAll;
            var qq = (q||"").split(/\s+/).findAll(function(r){ return r.length >= this.minChars }.bind(this))
            if(forceAll === true || qq.length > 0){
            	qq = qq.join(" ");
                if(this.lastQuery !== qq){
                    this.lastQuery = qq;
                    if(this.mode == 'local'){
                        this.selectedIndex = -1;
                        if(forceAll){
                            this.store.clearFilter();
                        }else{
                            this.store.filter(this.displayField, q);
                        }
                        this.onLoad();
                    }else{
                        this.store.baseParams[this.queryParam] = qq;
                        this.store.load({
                            params: this.getParams(qq)
                        });
                        this.expand();
                    }
                }else{
                    this.selectedIndex = -1;
                    this.onLoad();
                }
            }
        },
        
    	/**
    	 * @Overwrite
    	 */
        onLoad : function(){
            if(!this.hasFocus){
                return;
            }
            if(this.store.getCount() > 0){
                this.expand();
                this.restrictHeight();
                if(this.lastQuery == this.allQuery){
                    if(this.editable){
                        this.el.dom.select();
                    }
                    /*if(!this.selectByValue(this.value, true)){
                        this.select(0, true);
                    }*/
                }else{
                	
                    //this.selectNext();
                    if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
                        this.taTask.delay(this.typeAheadDelay);
                    }
                }
                
                var index = -1;
                if (this.lastSelectedRecord) {
                	index = this.store.find("href", this.lastSelectedRecord.get("href"));
                }
            	this.select(index, true);
            	
            }else{
                this.onEmptyResults();
            }
            //this.el.focus();
        },
        
        onEmptyResults : function(){
        	this.restrictHeight()
        },

        
    	/**
    	 * @Overwrite
    	 */
        initEvents : function(){
            Ext.form.ComboBox.superclass.initEvents.call(this);

            this.keyNav = new Ext.KeyNav(this.el, {
                "up" : function(e){
            		if (this.selectedIndex == 0) {
            			this.select(-1);
            		} else if (this.selectedIndex > 0) {
	                    this.inKeyMode = true;
	                    this.selectPrev();
            		}
                },

                "down" : function(e){
                	if (this.store.getCount() > 0) {
	                    if(!this.isExpanded()){
	                        this.onTriggerClick();
	                    }else {
	                        this.inKeyMode = true;
	                        this.selectNext();
	                    }
                	}
                },

                "enter" : function(e){
                	if (this.selectedIndex >= 0 && this.isExpanded()) {
	                    this.onViewClick();
	                    this.delayedCheck = true;
	    				this.unsetDelayCheck.defer(10, this);
                	}
                	
                	if (e.ctrlKey || e.metaKey) {
                		this.onBlur();
                	}
                },

                "esc" : function(e){
                	if (this.isExpanded()) {
                		this.collapse();
                	} else {
                		this.onBlur();
                	}
                },

                "tab" : function(e){
                    this.onViewClick(false);
                    return true;
                },

                scope : this,

                doRelay : function(foo, bar, hname){
                    if (hname == 'down' && this.scope.store.getCount() > 0){
                    	return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    } else if (hname == 'down') {
                    	return true;
                    }
                    if (hname == 'up' && this.scope.selectedIndex < 0) {
                    	return true;
                    }
                    if (hname == 'enter' && this.scope.isExpanded() && this.scope.selectedIndex >= 0) {
                        return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    }
                    if (hname == 'esc') {
                        return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    }
                    if (hname != 'enter' && this.scope.isExpanded()) {
                        return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    }
                    return true;
                },

                forceKeyDown : true
            });
            this.queryDelay = Math.max(this.queryDelay || 10,
                    this.mode == 'local' ? 10 : 250);
            this.dqTask = new Ext.util.DelayedTask(this.initQuery, this);
            if(this.typeAhead){
                this.taTask = new Ext.util.DelayedTask(this.onTypeAhead, this);
            }
            if(this.editable !== false){
                this.el.on("keyup", this.onKeyUp, this);
            }
            if(this.forceSelection){
                this.on('blur', this.doForce, this);
            }
            
            // FIXED: Fixed the problem, that the click event was too late
            // processed, so the onChange and onBlur was called before onSelect
            // was called (mainly in Chrome)
            this.list.dom.addEventListener("mousedown", function(e){
            	Event.stop(e)
            }, false);

            this.footer.dom.addEventListener("mousedown", function(e){
            	Event.stop(e)
            }, false);
        },
        
        /**
         * Automatically grows the field to accomodate the height of the text up to the maximum field height allowed.
         * This only takes effect if grow = true, and fires the autosize event if the height changes.
         */
        autoSize : function(){
            if(!this.grow || !this.textSizeEl){
                return;
            }
            var el = this.el;
            var v = el.dom.value;
            var ts = this.textSizeEl;
            if (!ts||!el){ return }
            ts.innerHTML = '';
            ts.appendChild(document.createTextNode(v));
            v = ts.innerHTML;

            if (!this.growHorizontally) {
	            try {
	            	Ext.fly(ts).setWidth(this.el.getWidth());
	            } catch(e) { }
            }
            
            if(v.length < 1){
                v = "&#160;&#160;";
            }else{
                if(Ext.isIE){
                    //v = v.replace(/\n/g, '<p>&#160;</p>');
                }
                v += this.growAppend;
            }
            ts.innerHTML = v;
            var h = Math.min(this.growMax, Math.max(ts.offsetHeight + this.growPad, this.growMin));
            if(h != this.lastHeight){
                this.lastHeight = h;
                this.el.setHeight(h);
                this.fireEvent("autosize", this, h);
                if (this.list) {
                	this.list.alignTo(this.el, this.listAlign);
                }
            }
            
            if (this.growHorizontally) {
                var w = Math.min(this.growMax, Math.max(ts.offsetWidth + this.growPadHorizontal, this.growMinHorizontal));
                if(w != this.lastWidth){
                    this.lastWidth = w;
                    this.el.setWidth(w);
                    if (this.list) {
                    	this.list.alignTo(this.el, this.listAlign);
                    }
                }
            }
        }
    }); 
}();
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

ns("ux.form", "Ext");

(function() {
	
	var Language = Ext.data.Record.create([
		{ name: "title", mapping: "title" },
		{ name: "value", mapping: "value" }
	]);
	
	Ext.ux.form.LanguageSwitch = {
		create: function(attr) {
			attr = attr || {};
			
			if(attr.multi) {
				return new Ext.ux.form.LanguageSwitchMulti(attr);
			}
			
			return new Ext.ux.form.LanguageSwitchCombo(attr);
		}
	};
	
	Ext.ux.form.LanguageSwitchMulti = function(attr) {
		attr = attr || {};
		
		attr.languages = attr.languages || [];
		attr.name = attr.name || "";
		attr.items = this.setupItems(attr.name, attr.languages);
		attr.bodyStyle = attr.bodyStyle || "padding: 0px";
		
		Ext.ux.form.LanguageSwitchMulti.superclass.constructor.call(this, attr);
	};
	
	Ext.extend(Ext.ux.form.LanguageSwitchMulti, Ext.Panel, {
		setupItems: function(group, languages) {
			return languages.sort(this.sortFn)
							.map(this.mapFn)
							.compact()
							.map(function(language) {
				
				var parts = language.split("_");
				
				var lang = parts.first();
				var country = parts.last();
				
				var title = Ext.ux.getI18N('multilanguage.language.' + lang);
				title += " (" + Ext.ux.getI18N('multilanguage.country.' + country) + ")";
				
				return new Ext.form.Checkbox({
					boxLabel: "<img src='" + Signavio.Config.IMAGE_PATH + '/flags/' + country + ".png' /> " + title,
					checked: true,
					name: group,
					value: language
				});
			});
		},
	
		sortFn: function(a, b) {
			if("undefined" !== typeof a.position) {
				return a.position - b.position;
			}
			
			return 0;
		},
		
		mapFn: function(language) {
			if("string" === typeof language) {
				return language;
			}
			
			if("object" === typeof language) {
				return language.rel;
			}
			
			return null;
		},
		
		check: function(language) {
			this.items.each(function(checkbox) {
				if(checkbox.value === language) {
					checkbox.setValue(true);
				}
			});
		},
		
		enableAll: function() {
			this.items.each(function(checkbox) {
				checkbox.enable();
			});
		},
		
		disable: function(language) {
			this.items.each(function(checkbox) {
				if(checkbox.value === language) {
					checkbox.disable();
				}
			});
		},
		
		getRemainder: function() {
			var result = [];
			
			this.items.each(function(checkbox) {
				if(checkbox.getValue() && !checkbox.disabled) {
					result.push(checkbox.value);
				}
			});
			
			return result;
		}
	});
	
	Ext.ux.form.LanguageSwitchCombo = function(attr) {
		attr = attr || {};
		
		this.setup(attr);
		this.__class__ = Ext.ux.form.LanguageSwitchCombo;
		
		Ext.ux.form.LanguageSwitchCombo.superclass.constructor.call(this, attr);
	};
	
	Ext.extend(Ext.ux.form.LanguageSwitchCombo, Ext.ux.form.ComboBox, {

		setup: function(attr) {
			attr.languages = this.parseLanguages(attr.languages || []);
			attr.store = this.createStore(attr);
			attr.value = attr.value || attr.languages.first() || "";
			attr.cls = ["x-language-switch", attr.cls].compact().join(" ");
			attr.ctCls = ["x-language-switch-ct", attr.ctCls].compact().join(" ");
			attr.itemCls = ["x-language-switch-item", attr.itemCls].compact().join(" "),
			attr.mode = attr.mode || "local";
			attr.readOnly = true;
			attr.fieldLabel = Ext.ux.getI18N("multilanguage.label");
			attr.disabled = attr.languages.length === 0;

			attr.tpl = this.getTemplate(attr.disabled);
		},

		getTemplate: function(disabled) {
			if(disabled) {
				return '' +
					'<tpl for=".">' +
						'<div class="x-combo-list-item">' +
							"Keine Sprachen verfügbar" +
						'</div>' +
					'</tpl>';
			}

			return '' +
				'<tpl for=".">' +
					'<div class="x-combo-list-item">' +
						'<img src="' +
							Signavio.Config.IMAGE_PATH +
							'/flags/{[values.value.split("_").last()]}.png" style="width: 16px; height: 11px;"/> ' +
						'{title}' +
					'</div>' +
				'</tpl>';
		},

		setSize: function() {
			this.__class__.superclass.setSize.apply(this, arguments);
		},

		parseLanguages: function(languages) {
			return languages.sort(function(a, b) {
				if(Ext.isDefined(a.position)) {
					return a.position - b.position;
				}

				return 0;
			}).map(function(language) {
				if("string" === typeof language) {
					return language;
				}

				if("object" === typeof language) {
					return language.rel;
				}

				return null;
			}).compact();
		},

		onRender: function(){
			this.__class__.superclass.onRender.apply(this, arguments);
			this.setFlag();
		},

		setFlag: function(){
			if (!this.flag){
				this.flag = this.wrap.createChild({
					cls:"x-language-switch-flag"
				});
			}

			var lang = this.getValue();
			var url = Signavio.Config.IMAGE_PATH + '/flags/' + lang.split("_").last() + '.png';

			this.flag.setStyle("background-image", "url('" + url + "')");
		},

		onSelect: function(){
			this.__class__.superclass.onSelect.apply(this, arguments);

			this.setFlag();
		},

		createStore: function(attr) {
			return new Ext.data.SimpleStore({
				fields: this.createFields(),
				data: this.generateData(attr.languages),
				reader: this.createReader()
			});
		},

		createFields: function() {
			return [{ name: "value" }, { name: "title" }];
		},

		createReader: function() {
			return new Ext.data.ArrayReader({}, Language);
		},

		generateData: function(languages) {
			return languages.map(function(language) {
				var parts = language.split("_");

				var lang = parts.first();
				var country = parts.last();

				var title = Ext.ux.getI18N('multilanguage.language.' + lang);
				title += " (" + Ext.ux.getI18N('multilanguage.country.' + country) + ")";

				return [language, title];
			});
		}
	});

}());
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.form) {Ext.ux.form = {}; }

(function() {
	
	var PREVIEW_WIDTH = 450;
	
	Ext.ux.form.TranslationField = function(attr) {
		attr.field.translation = this;
		this.origin = this.createInfo(attr.field, attr.editing);
		this.target = this.wrap(attr.field, this.origin, attr.editing);
		
		this.setup(attr);
		
		attr.items = [this.origin, this.target].compact();

		Ext.ux.form.TranslationField.superclass.constructor.call(this, attr);
	};
	
	Ext.extend(Ext.ux.form.TranslationField, Ext.Panel, {
		isFormField: true,
		
		setup: function(attr) {
			attr.layout = attr.layout || "column";
			attr.border = typeof attr.border !== "undefined" ? attr.border : false;
		},
		
		hideOrigin: function(){
			if (this.origin){
				this.remove(this.origin);
			}
			if (this.target){
				this.target.columnWidth = 1;
				if (this.field.multilanguage !== true){
					this.target.el.setStyle("margin-left", "0");
				}
			}
		},
		
		createInfo: function(field, editing) {
			if(!editing || field.multilanguage !== true) {
				// If we are currently not editing a field value
				// the info panel isn't necessary
				
				return null;
			}
			
			var me = this;
			
			return new Ext.Panel({
				columnWidth: 0.5,
				border: false,
				html: "",
				cls: "y-translation-info " + this.computeClasses(field),
				style: "margin-right: 10px;",
				afterRender: function(){ // Update view
					Ext.Panel.prototype.afterRender.apply(this, arguments);
					me.setOrigin(me.ownerCt.languages.first());
				}
			});
		},
		
		processValue: function(value, field) {			
			if((field || this.field) instanceof Ext.ux.form.UrlLinkFieldList) {
				if (value instanceof Array && value.length){
					value = value.map(function(link) {
						var rep = link instanceof Ext.data.Record ? link.get("rep") : link;
						
						return "<a href='" + rep.url + "' target='_blank'>" + (rep.label||rep.url) + "</a>";
					});
					return "<div class='x-url-link-field-list'><ol><li>"+value.join("</li><li>")+"</li></ol></div>";
				}
				return "<div class='x-url-link-field-list-empty'>Keine Verlinkungen definiert.</div>";
			} else if((field || this.field) instanceof Ext.ux.form.TextFieldList) {
				if (value instanceof Array && value.length){
					return "<div class='x-form-textfield-list'><ol><li>"+value.join("</li><li>")+"</li></ol></div>";
				}
				return "<div class='x-url-link-field-list-empty'>Keine Einträge definiert.</div>";
			}
			return value;
		},
		
		computeClasses: function(field) {
			if(field instanceof Ext.ux.form.RichtextEditor) {
				return "y-translation-richtext";
			}

			if(field instanceof Ext.form.TextArea) {
				return "y-translation-textarea";
			}
			
			if(field instanceof Ext.ux.form.TextFieldList){
				return "y-translation-list";
			}

			if(field instanceof Ext.form.TextField) {
				return "y-translation-text";
			}
			
			return "";
		},
		
		wrap: function(field, info, editing) {
			field.anchor = "100%";
			this.fakeField(field, info, editing);
			
			return new Ext.Panel({
				columnWidth: info ? 0.5 : 1,
				style 	: editing && field.multilanguage !== true ? "margin-left: 50%;": "",
				layout	: "anchor",
				border	: false,
				items	: field,
				cls		: "y-translation-field"
			});
		},
		
		fakeField: function(field, info, editing) {
			this.fieldLabel = field.fieldLabel;
			this.hideLabel = field.hideLabel || false;
			if ("undefined" != typeof field.labelSeparator){ this.labelSeparator = field.labelSeparator; }

			this.getValue = field.getValue.bind(field);
			this.setValue = field.setValue.bind(field);
			this.focus = field.focus.bind(field);
			
			// Update dirty flag
			field.on("blur", this.updateDirtyFlag, this);
			
			// Update view on render
			var me = this;
			field.render = field.render.createSequence(function(v){ 
				var lang = me.language;
				me.language = me.ownerCt.languages.first(); // Use the old language for caching the current value
				me.setTarget(lang);
				return this;
			});
			
//			var setSize = field.setSize.bind(field);
//			field.setSize = function(width, height) {
//				var padding = editing ? PREVIEW_WIDTH : 0;
//				
//				width = width - padding;
//				
//				setSize(width, height);
//				
//				if(info) {
//					info.setSize(padding, height);
//				}
//			};
		},
		
		setOrigin: function(lang) {
			if (!this.origin){ return; }
			var value = this.field.values || {};
			this.origin.body.update(this.processValue(value[lang]||""));
		},
		
		setTarget: function(lang) {
			
			if (lang && this.field){ // Set language to the field (some fields are using those language information, like GlossaryField)
				this.field.language = lang; 
			}
			
			if (this.field.multilanguage !== true){ return; }
			
			if (!this.values) {
				this.values = Ext.apply({}, this.field.values||{}); 
			} else {
				var oldLanguage = this.language;
				if (oldLanguage){
					var value = this.getValue();
					
					if (value && this.field instanceof Ext.ux.form.RichtextEditor){
						value = Ext.ux.Richtext.decode(this.field.body).text;
					}
					
					if (value != false && (!(value instanceof Array) || value.length > 0)){
						this.values[oldLanguage] = this.getValue();
					} else {
						delete this.values[oldLanguage];
					}
				}
			}
			this.language = lang;
			
			if (this.field instanceof Ext.ux.form.TextFieldList){
				if (this.values[lang] instanceof Array && this.values[lang].length > 0){
					this.field.data = [].concat(this.values[lang].map(function(r){
											return r instanceof Ext.data.Record ? 
													r.data.rep : 
													r;
										}));
				} else {
					this.field.data = [];
				}
				if (this.field.el){
					this.field.setRawValue("");
				}
				this.field.updateView();
			} else {
				this.setValue(this.values[lang]||"");
			}	
			
			this.updateDirtyFlag();
		},
		
		updateDirtyFlag: function(){
			if (this.field && (this.field.wrap || this.field.el)){
				var el = this.field.wrap || this.field.el,
					value = this.getValue(), boo = {};
				
				if (this.field instanceof Ext.ux.form.RichtextEditor) {
					boo = this.field.body;
				}
				
				// Find any existing values in any language
				if($H(this.values).values()
						// Without the current language
						.without(this.values[this.language]).flatten()
						// Without empty line breaks (initial value)
						.find(function(v) {
							if ("string" == typeof v)
								return (v||"").trim();
							return v;
						}) && value == false) {
							el.addClass("x-dirty");
							boo.className = "x-no-background";
				} else {
					el.removeClass("x-dirty");
					boo.className = "";
				}
			}
		}
		
	});
	
}());
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Philipp Giese
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.form) {Ext.ux.form = {}; }

(function() {
	
	Ext.ux.form.TranslationForm = function(attr) {
		attr = attr || {};
		
		this.setup(attr);
		
		this.listeners = attr.listeners;

		var fields = this.createFields(attr.items, attr.editing, attr.language);
		var switches = this.createLanguageSwitches(attr.languages, attr.language, attr.editing);
		
		attr.items = [this.getLabel(), switches].concat(fields);
		
		Ext.ux.form.TranslationForm.superclass.constructor.call(this, attr);
	};
	
	Ext.extend(Ext.ux.form.TranslationForm, Ext.form.FormPanel, {
		
		setup: function(attr) {
			// Ext component configuration
			attr.border = Ext.isDefined(attr.border) ? attr.border : false;
			attr.labelAlign = attr.labelAlign || "right";
			attr.labelWidth = attr.labelWidth || 150;
			attr.autoWidth = Ext.isDefined(attr.autoWidth) ? attr.autoWidth : true;
			attr.cls = "y-translation-form " + (attr.cls || "");
			attr.listeners = attr.listeners || {};
			
			// Translation component configuration
			attr.languages = attr.languages || [];
		},
		
		updateSize: function(){
			var win = this.ownerCt,
				bodyWidth = win.getInnerWidth() - win.body.getPadding("lr"),
				width = bodyWidth - win.labelWidth - 25;
			
			this.items.each(function(item){
				if (item.initialConfig.html){ // <-- Set width of label 
					item.setWidth(bodyWidth-50);
				} else {
					item.setWidth(width);
				}
			});
		},
		
		createSwitch: function(languages, onSelect, language) {
			return Ext.ux.form.LanguageSwitch.create({
				languages: languages,
				mode: "local",
				anchor: "100%",
				value: language,
				listeners: {
					select: onSelect
				}
			});
		},

		createHelpers: function() {
			var that = this;

			var remove = new Ext.LinkButton({
				text: Ext.ux.getI18N("glossary.multilanguage.remove_origin_column"),
				cls	: 'x-remove-column-link',
				click: function() {
					// Remove the left column
					that.removeOriginColumn();
				}
			});

			var copy = new Ext.LinkButton({
				text: Ext.ux.getI18N("glossary.multilanguage.copy_link_title"),
				cls: 'x-copy-content-link',
				click: function() {
					that.copyContentToLeftSide();
				}
			});

			this.origin.add(remove);
			this.origin.add(copy);

			this.origin.getRemoveButton = function() {
				return remove;
			};

			this.origin.getCopyButton = function() {
				return copy;
			};
		},

		resizeHelpers: function(remove, copy, languageSwitch) {
			if(!remove.rendered || !copy.rendered || !languageSwitch.rendered) {
				return;
			}

			var availableWidth = this.origin.getSize().width - languageSwitch.getSize().width;
			var padding = 10;
			var width = availableWidth / 2 - padding;

			var removeText = Ext.ux.getI18N("glossary.multilanguage.remove_origin_column");

			// set new link text
			remove.el.dom.textContent = Signavio.Helper.TruncateByWidth(removeText, width, "…");
			//IE7/IE6
			remove.el.dom.innerText = Signavio.Helper.TruncateByWidth(removeText, width, "…");
			remove.el.dom.title = removeText;

			var copyText = Ext.ux.getI18N("glossary.multilanguage.copy_link_title");

			copy.el.dom.textContent = Signavio.Helper.TruncateByWidth(copyText, width, "…");
			//IE7/IE6	
			copy.el.dom.innerText = Signavio.Helper.TruncateByWidth(copyText, width, "…");
			copy.el.dom.title = copyText + ". " + Ext.ux.getI18N("glossary.multilanguage.copy_link_tt");
		},

		copyContentToLeftSide: function(){
			
			if (!Ext.isDefined(this.originData)) {
				return;
			};
			
			// proove which lanugage was selected
			var originLanguage = this.origin.getValue();
			var targetLanguage = this.target.getValue();
			// is selected language the standard-langauge
			var isOriginDefault = (originLanguage === this.languages.first());			
			
			var fields = [];
			// find all field items
			this.items.each(function(item){
				if (item.isFormField && item.isFormField){
					fields.push(item);
				}
			});
			// iterate over all fields and get the value and copy it to the target field
			fields.each(function(field){
				// it is a true field
				if (!field.field){
					return;
				}

				var fieldId = field.field.dataField;
				var originValue = "";
				var searchKey = isOriginDefault ? fieldId : fieldId + "_" + originLanguage;
				// search current value for this field
				if (fieldId.startsWith("metaDataValues.")){
					// search in metadatainfos
					searchKey = searchKey.replace("metaDataValues." , "");
					originValue = this.originData.metaDataValues[searchKey];
					
				}else{
					// search in globaldata
					originValue = this.originData[searchKey] || "";
				}
				
				// special case url-link-list 
				if (originValue && field.field instanceof Ext.ux.form.UrlLinkFieldList){
					// delete all ids from new url-links
					var values = [];
					// delete id to force a new server-sided creation for this link
					originValue.each(function(value){
						var newValue =  Object.clone(value);
						
						if (newValue.id && newValue.url){	
							delete newValue.id;
						}

						values.push(newValue);
					});
					
					originValue = values;
				}
				
				// special case richtexteditor
				if (originValue && field.field instanceof Ext.ux.form.RichtextEditor){
					var originValueFormats = this.originData.formats[searchKey] || {};
					
					originValue = Ext.ux.Richtext.encode(originValue, originValueFormats) || "";
				}
				
				// set value to the specific-lanugage target
				try {
					delete field.language // hack: set lanugage to undefined to set the new target value 
					
					field.values[targetLanguage] = originValue;						
					field.setTarget(targetLanguage);						
				}catch(e) {
					return;
				}				
			}.bind(this));	
		},
		
		createLanguageSwitches: function(languages, language, editing) {
			var origin;
			var that = this;
			
			if(editing) {
				origin = this.createSwitch(languages, function(me, record) {
					var value = record.get("value");
					var fields = [];
					// find all field items
					that.items.each(function(item){
						if (item.isFormField && typeof item.setOrigin === 'function'){
							fields.push(item);
						}
					});
					
					fields.each(function(field) {
						field.setOrigin(value);
					});
				});

				this.origin = this.wrap(origin, {
					columnWidth: 0.5
				});

				origin.on("render", function() {
					var remove = that.origin.getRemoveButton();
					var copy = that.origin.getCopyButton();

					that.origin.on("resize", function() {
						that.resizeHelpers(remove, copy, origin);
					});

					Signavio.Utils.defer(function() {
						that.resizeHelpers(remove, copy, origin);
					});
				});

				this.createHelpers(origin);
			}
			
			var target = this.createSwitch(languages, function(me, record) {
				var value = record.get("value");

				var fields = [];
				// find all field items
				that.items.each(function(item){
					if (item.isFormField && typeof item.setTarget === 'function'){
						fields.push(item);
					}
				});

				fields.each(function(field) {
					field.setTarget(value);
				});
			}, language);
			
			this.target = this.wrap(target, {
				columnWidth: origin ? 0.5 : 1
			});
			
			return new Ext.Panel({
				border: false,
				layout: "column",
				fieldLabel: Ext.ux.getI18N("glossary.new.languageswitch"),
				isFormField: true,
				items: [this.origin, this.target].compact()
			});
		},
		
		removeOriginColumn : function() {

			// Get all items
			this.items.each(function(item){
				if (item.hideOrigin){
					item.hideOrigin();
				}
			});
			
			if (this.origin){
				this.origin.ownerCt.remove(this.origin);
				
				if (this.target) {
					this.target.columnWidth = 1;
				}
			}

			// Update the translation form
			this.ownerCt.doLayout();
			this.updateSize();
		},
		
		wrap: function(field, attr) {
			return new Ext.Panel(Ext.apply({
				items: field,
				border: false,
				getValue: function() {
					return field.getValue();
				}
			}, attr || {}));
		},
		
		createFields: function(items, editing, language) {
			return (items || []).map(function(item) {
				return new Ext.ux.form.TranslationField({
					field: item,
					editing: editing,
					language: language || undefined,
					anchor: "100%"
				});
			}.bind(this));
		},
		
		getLabel: function(){
			return new Ext.Panel({
				html: Ext.ux.getI18N("glossary.form.description"),
				border: false,
				cls: "y-translation-hint"
			});
		}
		
	});
	
}());
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Christian Wiggert
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" == typeof window.Ext){ window.Ext = {}; }
if ("undefined" == typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" == typeof Ext.ux.form){ Ext.ux.form = {}; }

new function(){
    /**
     * This form element encapsulates a list of check boxes or radio buttons.
     * The different entries are submitted in a store with 'title' and 'value'.
     * Add the config option 'multiSelect: false' to use radio buttons instead of 
     * check boxes.
     * 
     * The RadioGroup raises a 'change' event in case the selection of one of the items
     * radio buttons / checkboxes changed.
     *
     * @class
     * @param attr
     * @return
     */
    Ext.ux.form.RadioGroup = function(attr) {
        this.multiSelect = attr.multiSelect || false;
        this.store = attr.store || new Ext.data.SimpleStore({
            fields: ['title', 'value'],
            data: []
        });
        this.groupName = Math.ceil(Math.random() * 100000);
        this.value = attr.values || [];
        this.oldValue = [].concat(this.value);
        attr.border = attr.border || false;
        attr.layout = attr.layout || 'form';
        attr.baseCls = attr.baseCls || 'x-form-item';
        attr.cls = 'y-form-radiogroup ' + (attr.cls || '');
        attr.autoWidth = typeof attr.autoWidth !== 'undefined' ? attr.autoWidth : false;
        attr.autoHeight = typeof attr.autoHeight !== 'undefined' ? attr.autoHeight : false;
        attr.fieldLabel = attr.fieldLabel || '';
        attr.items = this.store.data.items.length > 0 ? [] : [new Ext.form.Label()];
        var first = true;
        this.store.each(function(entry) {
            var config = {};
            if (first && !attr.hideLabel) {
                config.fieldLabel = attr.fieldLabel;
                first = false;
            } else {
                config.labelSeparator = '';
            }
            config.boxLabel = entry.get('title');
            config.value = entry.get('value');
            config.name = this.groupName;
            config.checked = this.value.indexOf(entry.get('value')) > -1;
            if (attr.boxWidth) {
                config.width = attr.boxWidth;
            }
            var item;
            if (this.multiSelect) {
                item = new Ext.form.Checkbox(config);
            } else {
                item = new Ext.form.Radio(config);
            }
            attr.items.push(item);
            item.on('check', function(box, checked) {
                if (checked) {
                    this.addValue(box.value);
                } else {
                    this.removeValue(box.value);
                }
                this.changed();
            }.bind(this));
        }.bind(this));
        Ext.ux.form.RadioGroup.superclass.constructor.call(this, attr);
    };

    Ext.extend(Ext.ux.form.RadioGroup, Ext.Panel, {

        initComponent   : function() {
            Ext.ux.form.RadioGroup.superclass.initComponent.apply(this, arguments);
            this.addEvents('change');
        },

        /**
         * Private
         * Fires a change event if the value has changed.
         */
        changed : function() {
            // check if there is a difference between the old and the new value
            // by creating an intersection and comparing the sizes
            var intersection = this.value.intersect(this.oldValue);
            if (intersection.length !== this.value.length ||
                intersection.length !== this.oldValue.length) {
                // there is a difference, store the new old value 
                var old = this.oldValue;
                this.oldValue = [].concat(this.value);
                if (!this._loading) {
                    this.fireEvent('change', this, this.value, old);
                }
            }
        },

        /**
         * Returns the array of selected values.
         */
        getValue    : function() {
            return this.value;
        },

        /**
         * Private
         * Adds the given value.
         */
        addValue    : function(value) {
            if (this.value.indexOf(value) === -1) {
                if (!this.multiSelect) {
                    this.value.clear();
                }
                this.value.push(value);
            }
        },

        /**
         * Private
         * Removes the given value.
         */
        removeValue : function(value) {
            if (this.value.indexOf(value) > -1) {
                this.value.remove(value);
            }
        },


        /**
         * Resets the complete selection.
         */
        reset       : function() {
            this.items.items.each(function(field) {
                field.setValue(false);
            });
            this.value.clear();
            this.oldValue.clear();
        },

        /**
         * Resets the selection to the given value(s).
         */
        setValue    : function(values) {
            // the loading flag prevents change events
            this._loading = true;
            this.reset();
            if (typeof values !== 'undefined') {
                if (values instanceof Array) {
                    var that = this;
                    values.each(function(val) {
                        that.check(val);
                    });
                } else if (typeof values === 'string') {
                    this.check(values);
                }
            }
            delete this._loading;
        },

        /**
         * Checks the radio / checkbox representing the given value.
         */
        check       : function(value) {
            var field = this.items.items.find(function(field) { return field.value === value; });
            if (Ext.isDefined(field)) {
                //checks the field
                field.setValue(true);
            }
        },

        /**
         * Disables the radio / checkbox representing the given value.
         */
        disable     : function(value) {
            if (typeof value === 'undefined') {
                this.items.items.each(function(field) {
                    field.disable();
                });
            } else {
                var field = this.items.items.find(function(field) { return field.value === value; });
                if (Ext.isDefined(field)) {
                    field.disable();
                }
            }
        },

        /**
         * Enables the radio / checkbox representing the given value.
         */
        enable      : function(value) {
            if (typeof value === 'undefined') {
                this.items.items.each(function(field) {
                    field.enable();
                });
            } else {
                var field = this.items.items.find(function(field) { return field.value === value; });
                if (Ext.isDefined(field)) {
                    field.enable();
                }
            }
        }

    });

    /**
     * This is a simple store extension that can be used with the RadioGroup above.
     */
    Ext.ux.form.ChoiceStore = function(attr) {
        var choices = attr.choices ? attr.choices : [];
        attr.fields = ['title', 'value'];
        attr.data = [];
        choices.each(function(c) {
            if (typeof c === "object" && c.length > 1) {
                attr.data.push([c[0], c[1]]);
            } else {
                attr.data.push([c, c]);
            }
        });
        Ext.ux.form.ChoiceStore.superclass.constructor.call(this, attr);
    };

    Ext.extend(Ext.ux.form.ChoiceStore, Ext.data.SimpleStore, {});
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Philipp Giese, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */



//var getStartContainer = function(range){
//    return range.startContainer;
//}
//
//var getEndContainer = function(range){
//    return range.endContainer;
//}
//
//var removeContainer = function(container){
//    if (container && container.nodeType == 1){
//        var index = $A(container.parentNode.childNodes).indexOf(container);
//        var parent = container.parentNode;
//        parent.removeChild(container);
//        parent.insertBefore(document.createTextNode(container.textContent), parent.childNodes[index])
//    }
//}
//
//var getAllParents = function(node){
//    var parents = [];
//    while(node && (node.nodeType != 1 || node.tagName.toLowerCase() != "body")){
//        parents.push(node);
//        node = node.parentNode;
//    }
//    return parents.reverse();
//}
//
//var getMostCommonAncestor = function(range){
//    var parentsStart = getAllParents(range.startContainer), 
//        parentsEnd = getAllParents(range.endContainer),
//        startC;
//
//    while(startC = parentsStart.shift() && parentsEnd.include(startC)){}
//
//    return startC || window.frames[0].document.body;
//}
//
//var getCommonStartIndex = function(root, start){
//    var cn = $A(root.childNodes);
//    while(start && start !== root){
//        if (cn.include(start)){
//            return cn.indexOf(start);
//        }
//        start = start.parentNode;
//    }
//    return -1;
//}
//
//var selectCommonNodes = function(range, root){
//    var start = range.startContainer, end = range.endContainer;
//    if (true || start.nodeType == 3 && range.startOffset == 0){
//        while(start && start.parentNode && start !== root){
//            if (start.parentNode.childNodes[0] != start || start.parentNode.childNodes.length != 1){ break; }
//            start = start.parentNode;
//        }
//    }
//    if (true || end.nodeType == 3 && range.endOffset == end.textContent.length){
//        while(end && end.parentNode && end !== root){
//            if (end.parentNode.childNodes[end.parentNode.childNodes.length-1] != end){ break; }
//            end = end.parentNode;
//        }
//    }
//    console.log(start, end);
//    if (start.nodeType == 3) range.setStart(start, 0); 
//    else range.setStart(start.parentNode, $A(start.parentNode.childNodes).indexOf(start)); 
//
//
//    if (end.nodeType == 3) range.setEnd(end, 0); 
//    else range.setEnd(end.parentNode, $A(end.parentNode.childNodes).indexOf(end)+1); 
//    console.log(range, range.startContainer, range.startOffset, range.endContainer, range.endOffset);
//}
//
//var getChildTextNode = function(node){
//    while(node && node.nodeType != 3){
//        node = node.firstChild;
//    }
//    return node || null;
//}
//
//var getNextTextNode = function(node){
//    while(node){
//        var child = getChildTextNode(node.nextSibling);
//        if (child){ return child; }
//        node = node.parentNode;
//    }
//    return null;
//}
//
//var getText = function(range, root){
//    var text = "",
//        start = getChildTextNode(range.startContainer),
//        end = getChildTextNode(range.endContainer);
//
//    while(start){
//        text += start.textContent;
//        if (start == end){ break; }
//        start = getNextTextNode(start);
//    }
//    return text;
//}
//
//var selection = window.frames[0].getSelection(), range = selection.getRangeAt(0);
//
//var start = getStartContainer(range),end = getEndContainer(range);
//
//var root = getMostCommonAncestor(range);
//var index = getCommonStartIndex(root, start);
//
//selectCommonNodes(range, root);
//var text = getText(range, root);
//range.deleteContents();
//console.log(text, root.childNodes[index]);
//root.insertBefore(text, root.childNodes[index]);


if(!window.Ext) { window.Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.form) { Ext.ux.form = {}; }

new function() {
    
    /**
     * Base class for all richtext editors. Provides functions for text editing.
     * 
     * @param {Object} conf Configuration object
     */
    Ext.ux.form.RichtextEditor = function(conf) {
        
        // !REMOVE ATTRIBUTES WHICH OVERWRITES THE CLASS METHODS!
        delete conf.isList;
        
        Ext.ux.form.RichtextEditor.superclass.constructor.call(this, conf);
                
        if(conf.enableGlossaryLink !== undefined) this.enableGlossaryLink = conf.enableGlossaryLink;
        if(conf.enableParagraph !== undefined) this.enableParagraph = conf.enableParagraph;
        if(conf.enableHeadings !== undefined) this.enableHeadings = conf.enableHeadings;
        if(conf.enableProcessLinks !== undefined) this.enableProcessLinks = conf.enableProcessLinks;
        if(conf.enableFontSize !== undefined) this.enableFontSize = conf.enableFontSize;
        if(conf.enableRemoveFormat !== undefined) this.enableRemoveFormat = conf.enableRemoveFormat;
        if(conf.enableHorizontalRule !== undefined) this.enableHorizontalRule = conf.enableHorizontalRule;
        //if(conf.enableCodeBlock !== undefined) this.enableCodeBlock = conf.enableCodeBlock;
        if(conf.enableUndoRedo !== undefined) this.enableUndoRedo = conf.enableUndoRedo;
        if(conf.hideToolbar !== undefined) this.hideToolbar = conf.hideToolbar;
        if(conf.enableUnderline !== undefined) this.enableUnderline = conf.enableUnderline; 
        if(conf.tbar !== undefined) this.additionalToolbarButtons = conf.tbar;
        if(conf.facade !== undefined) this.facade = conf.facade;

        // In Dictionary, images cannot be inserted
        this.enableImageInsertion = ("undefined" !== typeof ORYX && ORYX.Editor && this.facade) ? true : false ;
    };    
    
    Ext.extend(Ext.ux.form.RichtextEditor, Ext.form.HtmlEditor, {
        
        hideToolbar: false,

        enableGlossaryLink: true,
        enableParagraph: true,
        enableHeadings: true,
        enableProcessLinks: true,
        enableFont: false,
        enableFontSize: true,
        enableRemoveFormat: true,
        enableHorizontalRule: true,
        enableImageInsertion: true,
        enableCodeBlock : false,
        enableUndoRedo: true,
        enableUnderline: true,
        
        undoStack: [],
        redoStack: [],
        timeout: undefined,
        oldHTML: undefined,
        oldBreadcrump: undefined,
        oldOffset: undefined,
        keyCount: 0,
        
        additionalToolbarButtons : [],
        
        // key, value pairs
        // key is used as attribute for the font-tag
        // value is shown to the user
        defaultFontSizes: [[1,6],[2,8],[3,10],[4,12],[5,14],[6,16],[7,18]],
        defaultFontSize: 2,
        fontSizeApprox: {"10px": 1,
                         "12px": 2,
                         "16px": 3,
                         "18px": 4,
                         "24px": 5,
                         "32px": 6,
                         "48px": 7
        },
        
        /**
         * Get the explorer path - wrapper for different config files
         * narf
         * @returns
         */
        explorerPath : '/explorer',
        
         /**
          * The following functions are convenience wrappers for the functionality of the
          * editor. If this component is used these functions serve as an API. All other functions
          * are considered to be private. 
          */
                         
        /**
         * Toggle font-weight of selected text
         */
        bold: function() {
            this.forceSelection();
            this.logCmd('bold');
        },
        
        /**
         * Toggle font-style of selected text
         */
        italic: function() {
            this.forceSelection();
            this.logCmd('italic');
        },
        
        /**
         * Toggle underlining of selected text
         */
        underline: function() {
            this.forceSelection();
            this.logCmd('underline');
        },
        
        /**
         * Toggle h1
         */
        h1: function() {
            this.logCmd(this.toggleHeading.bind(this, '1'));
        },
        
        /**
         * Toggle h2
         */
        h2: function() {
            this.logCmd(this.toggleHeading.bind(this, '2'));
        },
        
        /**
         * Toggle h3
         */
        h3: function() {
            this.logCmd(this.toggleHeading.bind(this, '3'));
        },
        
        /**
         * Change the background color of the selected text
         * @param {Hex} color
         */
        background: function(color) {
            this.forceSelection();
            if(Ext.isGecko){
                this.logCmd('styleWithCSS', false);
                this.logCmd('hilitecolor', color);
                this.logCmd('styleWithCSS', true);
                this.deferFocus();
            } else {
                this.logCmd(Ext.isOpera ? 'hilitecolor' : 'backcolor', Ext.isSafari || Ext.isIE ? '#'+color : color);
                this.deferFocus();
            }
        },
        
        /**
         * Change the color of the selected text
         * @param {Hex} color
         */
        color: function(color) {
            this.forceSelection();
            this.logCmd('forecolor', Ext.isSafari || Ext.isIE ? '#'+color : color);
        },
        
        /**
         * Change the font of the selected text
         * @param {String} font
         */
        font: function(font) {
            this.forceSelection();
            this.logCmd('fontname', font);
        },
        
        /**
         * Change the size of the selected text
         * @param {Integer} size
         */
        size: function(size) {
            this.forceSelection();
            this.logCmd('fontsize', this.fontSizeApprox(size + "px"));
        },
        
        /**
         * Insert an horizontal rule
         */
        hr: function() {
            // log what happens in this function to have correct undo/redo
            this.logCmd(this.insertHorizontalRule.bind(this));
        },

        insertHorizontalRule: function () {
            var range = this.getRange(), node = range.startContainer;

            this.relayCmd('inserthorizontalrule', ''); // set the id param of the hr to '', so it won't get one and won't be ignored in IE when saving

            // find, where the horizontal rule was added
            if (1 === node.nodeType && node.childNodes.length > 0){
                node = node.childNodes[range.startOffset];
            }
            
            // apply some fixes
            if (node && this.isSingleCursorSelection(range)){
                // Find the horizontal rule
                var hr = node.nextSibling && node.nextSibling.nodeType === 1 && node.nextSibling.tagName.toLowerCase() === "hr" ? node.nextSibling :
                         node.previousSibling && node.previousSibling.nodeType === 1 && node.previousSibling.tagName.toLowerCase() === "hr" ? node.previousSibling :
                         // IE where p nodes might contain only a hr node, no text node
                         // Chrome replaces single br nodes with the hr
                         node.nodeType === 1 && node.tagName.toLowerCase() === "hr" ? node : undefined ;

                if (hr){
                    // IE does not render a margin to horizontalrule, add one (similar to --webkit-margin-before)
                    if (Ext.isIE){
                        hr.style.setProperty("margin-top", "0.5em");
                        hr.style.setProperty("margin-bottom", "0.5em");
                    }

                    // ie can put hr into hr
                    if (hr.parentNode && hr.parentNode.nodeName.toLowerCase() === "hr" && hr.parentNode.parentNode) {
                        hr.parentNode.parentNode.insertBefore(hr, hr.parentNode);
                    }

                    // remove previous linebreak if required
                    if (hr.previousSibling && 1 === hr.previousSibling.nodeType && "br" === hr.previousSibling.tagName.toLowerCase()){
                        hr.parentNode.removeChild(hr.previousSibling);
                    }
                    // Remove next linebreak
                    if (hr.nextSibling && 1 === hr.nextSibling.nodeType && "br" === hr.nextSibling.tagName.toLowerCase()){
                        hr.parentNode.removeChild(hr.nextSibling);
                    }
                    
                    // Workaround for problems when placing the hr at the end of the body.
                    // find out if node is last child in documents
                    // TODO: node can be last child of container, too! (But this is kinda hard to find out..)
                    var isLastChild = !node.nextSibling;
                    while (isLastChild && node && (node.nodeType !== 1 || node.tagName.toLowerCase() !== "body")){
                        isLastChild = !node.nextSibling;
                        node = node.parentNode;
                    }
                    // Add line break, if hr is the last child
                    if (isLastChild){
                        var isSupported = this.insertAtCursor("<br />");
                        if (!(isSupported)){
                            node && node.appendChild(document.createElement("br"));
                        }
                    }
                }
            }
        },

        insertOrEditImage: function () {
            // If an image is selected, store the surrounding div as container
            var imgNode = this.selectedImageNode();
            // open image editor if image is selected, otherwise open image chooser
            if (imgNode) {
                this.openImageEditor(imgNode);
            } else {
                this.openImageChooser(this.onImageChooserSave.bind(this), true);
            }
        },

        insertCodeBlock : function() {
            this.toggleCodeBlock();
        },
        
        /**
         * Insert an unordered list
         */
        ul: function() {
            if (Ext.isSafari){
                if (this.isSelectionContainedInTag("ul", "ol")){
                    this.logCmd('outdent'); 
                    return;
                }
            }
            this.logCmd('insertunorderedlist');
        },
        
        /**
         * Insert an ordered list
         */
        ol: function() {
            if (Ext.isSafari){
                if (this.isSelectionContainedInTag("ol", "ul")){
                    this.logCmd('outdent'); 
                    return;
                }
            }
            this.logCmd('insertorderedlist');
        },
        
        /**
         * Create a link of the selected text
         */
        link: function() {
            this.forceSelection();
            this.logCmd(this.createLink.bind(this));
        },
        
        /**
         * Remove link from the selected text
         */
        unlink: function() {
            this.logCmd(this.removeLink.bind(this));
        },
        
        removeAllFormat: function(){
            var body = this.win.document.body;
            
            var content = Ext.ux.Richtext.decode(body);
            var plain = content.text;
            
            body.innerHTML = plain.replace(/\n/ig, "<br />");
            
//          var content = body.innerHTML;
//          content = content.replace(/<br.{0,1}>/ig, "\n")
//                           .replace(/(<\/(div|li|h1|h2|h3|p)>)/ig, "$1\n")
//                           .stripTags()
//                           .replace(/\n/g, "<br/>");
//          body.innerHTML = content;
        },
        
        removeFormat : function() {
            
            // If the whole text is selected, remove all tags
            if (String(this.win.document.body.textContent) == String(this.getRange())){
                this.removeAllFormat();
                return;
            }
            
            var selection = this.getSelection(), 
                range = this.getRange(selection).cloneRange();
            
            var root = this.getMostCommonAncestor(range);
            
            // Reset alignment
            //this.relayCmd('justifyleft');
            // Remove all formats
            this.logCmd('removeformat');
            
            if (String(range).length){
                selection.removeAllRanges();
                selection.addRange(range);
            }
            // Outdent
//          this.relayCmd("styleWithCSS", true);
//          this.relayCmd("outdent");
//          this.relayCmd("styleWithCSS", false);
            
            // ATTENTION: THIS MUST BE TESTED VERY CAREFULLY
            // Remove formated containers
            var selection = this.getSelection(), 
                range = this.getRange(selection);

            this.forceSelection();
            //this.selectCommonNodes(range, root);
            this.iterateOverTextElements(range, root);
        },
 
        /**
         * Returns all parents of 
         * the node (exclude the body tag)
         * @param node
         * @returns
         */
        getAllParents: function(node){
            var parents = [];
            while(node && (node.nodeType != 1 || node.tagName.toLowerCase() != "body")){
                parents.push(node);
                node = node.parentNode;
            }
            return parents.reverse();
        },

        /**
         * Returns the container where the start
         * and end container is contained.
         * @param range
         * @returns {HTMLElement}
         */
        getMostCommonAncestor: function(range){
            var parentsStart = this.getAllParents(range.startContainer), 
                parentsEnd = this.getAllParents(range.endContainer),
                startC = parentsStart.shift(), lastC;

            while(startC && parentsEnd.include(startC) && startC.nodeType == 1){
                lastC = startC;
                startC = parentsStart.shift();
            }
            
            if (lastC && !["ol", "ul"].include(lastC.tagName.toLowerCase())){
                lastC = lastC.parentNode;
            }

            return lastC || this.win.document.body;
        },
        
        /**
         * Returns the first child text node which is a child of the node
         * @param node
         * @returns {Boolean}
         */
        getChildTextNode: function(onode, offset){
            if (onode && onode.nodeType == 3){
                return onode;
            }
            
            if (onode && onode.nodeType != 3){
                onode = onode.childNodes[offset];
            }
            var node = onode;
            while(node && node.nodeType != 3){
                node = node.firstChild;
            }
            
            return node || onode || null;
        },

//        /**
//         * Returns the next sibling text node 
//         * of the given node, independent from the 
//         * level.
//         * @param node
//         * @returns
//         */
//        getNextTextNode: function(node, root){
//            while(node){
//                if (node.nextSibling){
//                    if (node.nextSibling.childNodes.length == 0){
//                        node = node.nextSibling;
//                        continue;
//                    } else if (node.nextSibling.nodeType == 3){
//                        return node.nextSibling;
//                    }
//                }
//                var child = this.getChildTextNode(node.nextSibling);
//                if (child){ return child; }
//                
//                if (node == root || node.tagName.toLowerCase() == "body"){
//                  break;
//                }
//                
//                node = node.parentNode;
//            }
//            return null;
//        },
//        
//
//        /**
//         * Returns the next sibling text node 
//         * of the given node, independent from the 
//         * level.
//         * @param node
//         * @returns
//         */
//        getPreviousTextNode: function(node, root){
//            while(node){
//                if (node.previousSibling){
//                    if (node.previousSibling.childNodes.length == 0){
//                        node = node.previousSibling;
//                        continue;
//                    } else if (node.previousSibling.nodeType == 3){
//                        return node.previousSibling;
//                    }
//                }
//                var child = this.getChildTextNode(node.previousSibling);
//                if (child){ return child; }
//                
//                if (node == root || node.tagName.toLowerCase() == "body"){
//                  break;
//                }
//                
//                node = node.parentNode;
//            }
//            return null;
//        },
//        
        isNodePartOfSelection: function(node){
            var range = this.getRange();
            if (!range){
                return false;
            } else if ("function" != range.isPointInRange){
                return true;
            }
            return range.isPointInRange(node, 0) || range.startContainer == node || range.endContainer == node || false;
        },
        

        selectCommonNodes : function(range, root) {
            var start = range.startContainer, end = range.endContainer;
            
            if (start && start.nodeType == 3){
                var nstart;
                while(nstart = this.getPreviousTextNode(start, start.parentNode)){
                    start = nstart;
                }
            }
            
            if (end && end.nodeType == 3){
                var nend;
                while(nend = this.getNextTextNode(end, end.parentNode)){
                    end = nend;
                }
            }
            
            if (start !== range.startContainer){
                range.setStart(start, 0);
            }
            
            if (end !== range.endContainer){
                range.setEnd(end, end.textContent.length);
            }
            
//          var start = range.startContainer, end = range.endContainer;
//          if (true || start.nodeType == 3 && range.startOffset == 0) {
//              while (start && start.parentNode && start.parentNode !== root) {
//                  if (start.parentNode.childNodes[0] != start || start.parentNode.childNodes.length != 1) {
//                      break;
//                  }
//                  start = start.parentNode;
//              }
//          }
//          if (true || end.nodeType == 3 && range.endOffset == end.textContent.length) {
//              while (end && end.parentNode && end.parentNode !== root) {
//                  if (end.parentNode.childNodes[end.parentNode.childNodes.length - 1] != end || end.parentNode.childNodes.length != 1) {
//                      break;
//                  }
//                  end = end.parentNode;
//              }
//          }
//          if (start.nodeType == 3) range.setStart(start, 0);
//          else range.setStart(start.parentNode, $A(start.parentNode.childNodes).indexOf(start));
//
//          if (end.nodeType == 3) range.setEnd(end, 0);
//          else range.setEnd(end.parentNode, $A(end.parentNode.childNodes).indexOf(end) + 1);
        },

        /**
         * Helper to remove the direct 
         * container of the given node.
         * Used to remove formations.
         * @param node
         */
        removeFormatedContainer: function(node, root){
            var pnode = node.parentNode;
            if (pnode.tagName.toLowerCase() == "body" || pnode == root){ return; }
            

            // Cache all preceeding newlines
            var brs = [];
            while(node.nextSibling && node.nextSibling.nodeType == 1 && node.nextSibling.tagName.toLowerCase() == "br"){
                brs.push(node.parentNode.removeChild(node.nextSibling));
            }
            
            pnode.removeChild(node);
            pnode.parentNode.insertBefore(node, pnode);
            
            // Add all cached newlines to the new parent (except it 
            // was only one newline at the end of a container)
            if (brs.length !== 1 || pnode.childNodes.length !== 0){
                brs.each(function(br){
                    pnode.parentNode.insertBefore(br, pnode);
                });
            }

            if (pnode.childNodes.length === 0){
                if (["li", "h1", "h2", "h3", "div", "ul", "ol"].include(pnode.tagName.toLowerCase()) && String(node.textContent).trim().length){
                    pnode.parentNode.insertBefore(document.createElement("br"), pnode);
                }
                pnode.parentNode.removeChild(pnode);
            }
            
            if (node.parentNode && this.isNodePartOfSelection(node.parentNode) && 
                    !(["ul", "ol"].include(node.parentNode.tagName.toLowerCase()) && $A(node.parentNode.childNodes).indexOf(node))){
                this.removeFormatedContainer(node, root);
            }
        },

        /**
         * Returns the start text node of the 
         * given dom range
         * @param range
         * @returns
         */
        getStartTextNode: function(range, root){
            var start = this.getChildTextNode(range.startContainer, range.startOffset);
             // If the offset is at the end of the given start text node, use next one
            if (start && (range.startContainer == start && range.startOffset && range.startOffset == start.textContent.length) ||
                        (start.nodeType != 3)){
                start = this.getNextTextNode(start, root);
            }
            
//            if (start && start.nodeType == 3){
//              var nstart;
//              while(nstart = this.getPreviousTextNode(start, start.parentNode)){
//                  start = nstart;
//              }
//          }
            return start;
        },

        /**
         * Returns the last/end text node of the 
         * given dom range
         * @param range
         * @returns
         */
        getEndTextNode: function(range, root){
            var end = this.getChildTextNode(range.endContainer, range.endOffset);
            // If the offset is at the beginning of the given end text node, use previous one
            if (end && (range.endContainer == end && range.endOffset === 0)||
                    (end.nodeType != 3)){
                end = this.getPreviousTextNode(end, root);
            }
            
//            if (end && end.nodeType == 3){
//              var nend;
//              while(nend = this.getNextTextNode(end, end.parentNode)){
//                  end = nend;
//              }
//          }
            return end;
        },
        
        /**
         * Iterates over all element starting from 
         * the start container to the end container and removes
         * @param range
         * @param root
         * @returns {String}
         */
        iterateOverTextElements: function(range, root){
            var text = "", start, cstart, end, cend, cparent, firstNodeIsIncluded;
            start = cstart = this.getStartTextNode(range, root);
            end = cend = this.getEndTextNode(range, root);
            
            while(start && end){
                if (cparent != start.parentNode){
                    cparent = start.parentNode;
                    firstNodeIsIncluded = $A(cparent.childNodes).indexOf(start) === 0;
                }
                
                if (firstNodeIsIncluded){
                    this.removeFormatedContainer(start, root);
                }
                if (start == end){ break; }
                start = this.getNextTextNode(start, root);
            }

            if (cstart && cend){
                range.setStart(cstart, 0);
                range.setEnd(cend, cend.textContent.length);
            }
        },
        
        /**
         * 
         * @param listType
         * @returns {Boolean}
         */
        isSelectionContainedInTag: function(tagName, stopAtTagNames){
            var selection = this.getSelection();
            if(selection && selection.rangeCount > 0 && "string" == typeof tagName){
                var range = this.getRange(selection);
                var node = range.commonAncestorContainer;
                tagName = tagName.toLowerCase();
                stopAtTagNames = [].concat(stopAtTagNames || undefined).compact().invoke("toLowerCase");
                while (node && (node.nodeType !== 1 || node.tagName.toLowerCase() !== "body")){
                    if (node.nodeType === 1){
                        var tag = node.tagName.toLowerCase();
                        if (tag === tagName){
                            return true;
                        } else if (stopAtTagNames.include(tag)){
                            return false;
                        }
                    }
                    node = node.parentNode;
                }
            }
            return false;
        },
        
        /**
         * Toggle alignment of text
         * @param {String} align left | center | right
         */
        align: function(align) {
            switch(align) {
                case 'left':
                    this.logCmd('justifyleft');
                    break;
                case 'center':
                    this.logCmd('justifycenter');
                    break;
                case 'right':
                    this.logCmd('justifyright');
                    break;
            }  
        },
        
        /**
         * Removes all formatting from the current selection or 
         * if singleCursorSelection is active removes all formatting
         * from the current paragraph. 
         */
        /*
        removeFormat: function() {      
            var selection = this.getSelection();            
			var range = this.getRange(selection);
            var singleCursorSelection = this.isSingleCursorSelection(range);
            var commonAncestor = this.getAncestor(selection , singleCursorSelection);
            var bounds = undefined;
            
            if(Ext.isSafari) {
                bounds = this.findHighestSiblings(range.startContainer, range.endContainer);
                
                if(this.isStyleElement(commonAncestor) && 
                    commonAncestor.firstChild === bounds.left &&
                    commonAncestor.lastChild === bounds.right) {
                    
                    // this fixes a bug where all the content of an style elment was selected
                    // but remove format would not recognize the element itself and thus
                    // would not remove any formatting
                    bounds.left = commonAncestor;
                    bounds.right = commonAncestor;
                }
                
                this.removeFormatAndPreserveLists(bounds.left, bounds.right);
            } else {
                // remove everything like bold, italic, etc.
                this.relayCmd('removeformat');
                this.relayCmd('justifyleft');
                
                // standard relayCmd does not work if nothing is selected
                // this will remove all formatting inside the commonAncestor
                if(singleCursorSelection) {
                    bounds = this.computeHighestBounds({
                            left: range.commonAncestorContainer,
                            right: range.commonAncestorContainer
                    });
                    
                    this.selectBetween(bounds.left, bounds.right);
                    this.relayCmd('removeformat');
                } 
            }           
            
            //if(this.isMultiLineSelection(selection)) {
            this.removeHeadings(range.startContainer, range.endContainer);
            //}
            
            // containers will only be removed if all of their children are selected
            // _OR_ if the cursor is placed inside the element and nothing is selected
            if(this.isContainer(commonAncestor) && 
               (this.allChildrenSelected(commonAncestor)    || 
                singleCursorSelection)) {
                
                this.removeContainer(commonAncestor, true);             
            }           
        },
        */
        
        doUndo: function() {
            var lastCommand = this.undoStack.pop();
            
            while(!lastCommand && this.undoStack.length > 0) {lastCommand = this.undoStack.pop();}
            
            if(lastCommand) {
                this.redoStack.push(lastCommand);
                lastCommand.rollback();
                
                // Fix for leading whitespace and blinking cursor over the height of the iframe
                if (this.body.innerHTML === '') {
                    this.body.innerHTML = '<br/>'; 
                }
            }
            
            this.updateToolbar();
            this.win.focus();
        },
        
        doRedo: function() {
            var nextCommand = this.redoStack.pop();
            
            while(!nextCommand && this.redoStack.length > 0) {nextCommand = this.redoStack.pop();} 
            
            if(nextCommand) {
                this.undoStack.push(nextCommand);
                nextCommand.execute();
                
                // Fix for leading whitespace and blinking cursor over the height of the iframe
                if (this.body.innerHTML === '') {
                    this.body.innerHTML = '<br/>'; 
                }
            }  
            
            this.updateToolbar();
            this.win.focus();
        },
        
        // END OF CONVENIENCE WRAPPERS

        /**
         * @Override
         */
        pushValue : function(){
          if(this.initialized){
              var v = this.el.dom.value;
              // removed the part where an empty value was set to '&nbsp;'
              // if(!this.activated && v.length < 1){
              //     v = '&nbsp;';
              // }
              if(this.fireEvent('beforepush', this, v) !== false){
                  this.getEditorBody().innerHTML = v;
                  this.fireEvent('push', this, v);
              }
          }
        },
           
        getDocMarkup : function(){
            var style = '@import url(/templates/signavio/font/Open_Sans/style_regular.css);\n\n';
            style += 'body{border:0;margin:0;padding:3px;height:98%;cursor:text;word-wrap:break-word;}\n';//padding: ((Ext.isIE9 || Ext.isIE10) ? '0' : '3')
            style += 'body{font-family: "Open Sans",tahoma,sans-serif;font-size:12px;}\n';
            style += 'a{color:#ad0f5b !important;}\n';
            style += 'a font, a span{color:#AD0F5B !important;}\n';
            style += 'i{padding-right:1px;}\n';
            style += 'p{margin:0px;}\n';
            style += 'blockquote{padding:0;margin:0;border:none;background:none !important;}';
            style += 'ul,ol{padding-left:0px;}\n';
            style += 'ul ul,ul ol,ol ul,ol ol{padding-left:30px;}\n';
            style += 'li{margin-left:40px;}\n';
            style += '.x-no-background{background:none !important;}\n';
            
            if (Ext.isIE){
                style += 'ul,ol{margin:'+((Ext.isIE9 || Ext.isIE10 || Ext.isIE11) ? '0' : '-8')+'px 0px 6px 0px;}';
                style += 'hr {margin:-8px 0px 6px 0px;}';
                style += 'html {overflow: auto !important;}';
                style += 'body {height: 100% !important;overflow: auto !important;}';
            }
            return '<html><head><style type="text/css">'+style+'</style></head><body></body></html>';
        },

        /**
         * @override
         */
        onRender: function() {
            Ext.ux.form.RichtextEditor.superclass.onRender.apply(this, arguments);
            
            this.win = this.iframe.contentWindow;
            this.body = this.doc.body; 
            this.undoStack = [];
            this.redoStack = [];
            
            Event.observe(this.doc, 'keyup', this.handleKeyUp.bind(this)); 
            Event.observe(this.doc, 'keydown', this.handleKeyDown.bind(this));
            Event.observe(this.doc, 'keypress', this.handleKeyPress.bind(this));
            Event.observe(this.doc, 'mouseup', this.handleMouseUp.bind(this));
            Event.observe(this.doc, 'mousedown', this.handleMouseDown.bind(this));
            Event.observe(this.doc, 'click', this.handleClick.bind(this));
            Event.observe(this.doc, 'dblclick', this.handleDoubleClick.bind(this));
            Event.observe(this.doc, 'paste', this.handlePaste.bind(this));

            Event.observe(this.win, 'blur', this.handleBlur.bind(this));
            
            this.on("push", this.updateTitleOnLinks.bind(this));
            
            if(this.hideToolbar) {
                $(this.tb).hide();
            }
        },
        
        /**
         * Override the default getValue method to make sure that unclosed
         * tags are never returned as value.
         * Replaces unclosed "hr" and "br" tags with their closed versions.
         * @override
         */
        getValue : function() {
            var value = Ext.ux.form.RichtextEditor.superclass.getValue.apply(this, arguments);
            
            // Replaces all lineFeeds and unclosed <br> tags with 
            // properly closed tags (<br/> <hr/> <img ... />) for HTML strict compatibility.
            return Ext.ux.Richtext.getValidHorizontalRules(
                        Ext.ux.Richtext.getValidLineFeeds(
                            Ext.ux.Richtext.getValidImages(value)));
        },
        
        /**
         * Handles the blur event of the iframe
         */
        handleBlur : function() {
            // Suppose the target has changed
            this.iframeChanged = true;
            
            // The iframe has regained the focus
            var fn = function() {
                this.iframeChanged = false; 
            }.bind(this);
            
            // If already a blur timeout exists, clear it
            if (this.blurTimeout) {
                window.clearTimeout(this.blurTimeout);
                if (document.removeEventListener instanceof Function) {
                    document.removeEventListener("focus", fn, true);                    
                } else {
                    document.detachEvent("onFocus", fn);
                }
                
            }
            
            // Wait for the iframe to being targeted again
            if (document.addEventListener instanceof Function) {
                document.addEventListener("focus", fn, true);
            } else {
                document.attachEvent("onFocus", fn);
            }
            
            // Set the timeout to wait for being targetted again
            this.blurTimeout = window.setTimeout(function(iframe) {
                if (document.removeEventListener instanceof Function) {
                    document.removeEventListener("focus", fn, true);
                } else {
                    document.detachEvent("onFocus", fn);
                }
                // If the iframe has changed, discard the timeouts of the previous iframe
                // TODO: save contents
                if (this.iframeChanged) {
                    window.clearTimeout(this.timeout);
                }
                
                this.fireEvent("blur", this);
            }.bind(this), 10, this);
        },

        handleDoubleClick: function (event) {
          this.handleImageDoubleClick(event);
        },

        handleClick: function(event) {
            this.handleLinkClick(event);
            this.handleImageClicks(event);
        },

        /**
         * When a link is clicked with pressed crtl-key, open the link in a new tab/window
         * @param event
         */
        handleLinkClick : function(event) {
            if (event.ctrlKey) {
                // Get the target and check if it's a link
                var target = (event.target||{});
                if ((target.nodeName||"").toLowerCase() === "a") {
                    window.open(target.href);
                    Event.stop(event);
                }   
            }
        },

        handleMouseUp: function (event) {
            this.initializeOldValues();
            this.detourCaptionSelection(event);
        },

        handleMouseDown: function (event) {
            if ((Ext.isFF || Ext.isIE) && !this.handlesDisabled)
                this.disableImageHandles();
            this.detourCaptionSelection(event);
        },

        disableImageHandles: function () {
        	if (Ext.isFF) {
                this.doc.execCommand('enableObjectResizing', null, false);
        	} else if (Ext.isIE) {
        		this.fixImages();
        	}
            this.handlesDisabled = true;
        },
        
        initializeOldValues: function() {
            if(!this.oldHTML) {
                var selection = this.getSelection();
                
                if(selection.rangeCount === 0) {
                	return;
                }
                
                var range = this.getRange(selection);
                
                this.oldHTML = this.originalValue;
                this.oldBreadcrump = this.getBreadcrump(range.endContainer);
                this.oldOffset = range.endOffset;
            }
        },

        handleKeyPress: function (event) {
            this.handleImageKey(event);
        },

        handleKeyDown: function (e) {
            this.initializeOldValues();
        },
                
        handleKeyUp: function(e) {            

            if(this.timeout) {
                window.clearTimeout(this.timeout);
            }

            var k = e.keyCode;

            
            if (k === Ext.EventObject.ENTER) {   
                this.logKeys();
            } else if(k === Ext.EventObject.BACKSPACE || k === Ext.EventObject.DELETE) {
                this.fixImages(); // Backspace and Delete remove div containers, also those containing images
                if(Math.abs(this.oldHTML.length - this.body.innerHTML.length) >= 2) {
                    this.logKeys();
                }
            } else if (!e.ctrlKey) {
                this.keyCount++;
                
                if (this.keyCount >= 60) {
                    // heavy typing going on. log every 60 characters
                    this.logKeys();
                } else if(this.keyCount > 5){
                    // If more than 5 letters are typed, log them (fast)
                    this.timeout = window.setTimeout(this.logKeys.bind(this), 500);
                } else if(this.keyCount <= 5){
                    // If less than 5 letters are typed, wait longer (2s)
                    this.timeout = window.setTimeout(this.logKeys.bind(this), 2000);
                }
            } 
        },
        
        // XXX
        handlePaste : function(event) {
            // if (this.timeout) {
            //     window.clearTimeout(this.timeout);
            // }
//          this.container.mask("Inhalt wird überprüft");
//          Ext.fly(this.body).hide();
            var wait = 50;
            var that = this;
            onPasteFunc = function() {
                var decoded = Ext.ux.Richtext.decode(that.body);
                var reencoded = Ext.ux.Richtext.encode(decoded.text, decoded.format);
                that.body.innerHTML = reencoded;
//              var decoded = Ext.ux.Richtext.decode(me.body);
//              console.log(decoded.text);
//              var reencoded = Ext.ux.Richtext.encode(decoded.text, decoded.format);
//              me.body.innerHTML = reencoded||decoded.text;
//              Ext.fly(me.body).show();
//              console.log(that.body);
//              that.container.unmask();
            };
            window.setTimeout(this.logCmd.bind(this, onPasteFunc), wait);
        },

        
        /**
         * Retrieves the position of a node in the dom according
         * to the its in index in its parentnode's childNodes array
         * 
         * @param {Object} node
         * @return {Array} An array containing all indices starting at the body element
         */
        getBreadcrump: function(node) {
            var parentIndicies = [];
            
            while(node.parentNode && !this.isNotEditable(node.parentNode)){
                parentIndicies.push($A(node.parentNode.childNodes).indexOf(node));
                node = node.parentNode;
            }

            return parentIndicies.reverse();  
        },
        
        /**
         * Logs changes that were made only by typing text
         */
        logKeys: function() {
            if (this.win) {
                // if shapes are edited and you are quick clicking outside the
                // editor it is possible that the component is being destroyed 
                // before the keys could be logged
                var innerHTML = this.oldHTML;
                
                // Get the selection
                var selection = this.getSelection();
                
                if (!selection) {
                    return;
                }
                
                var range = this.getRange(selection);
                var offset = range.endOffset;
                var breadcrump = this.getBreadcrump(range.endContainer);
                
                var conf = {
                    oldBreadcrump: this.oldBreadcrump,
                    oldOffset: this.oldOffset,
                    oldHTML: this.oldHTML,
                    newBreadcrump: breadcrump,
                    newOffset: offset,
                    newHTML: this.body.innerHTML
                };
                
                this.executeCommand(new Ext.ux.Command(this, conf));
                
                this.keyCount = 0;
                this.oldHTML = this.body.innerHTML;
                this.oldOffset = offset;
                this.oldBreadcrump = breadcrump;
            }       
        },
                                        
        /**
         * @override
         */
        
        applyCommand: function(e) {             
            var c = e.getCharCode();
            if (c > 0) {
                c = String.fromCharCode(c).toLowerCase();
            }
            
            if(e.getKey() === e.TAB && this.enableParagraph) {
                if ((!this.undoStack||!this.undoStack.length) &&
                    (!this.redoStack||!this.redoStack.length)){
                    return;
                }
                e.stopEvent();
                            
                // If the cursor is inside a code block, handle tab press differently
                if(this.enableCodeBlock && this.isInsideCodeBlock()) {
                    this.handleTabInsideCodeBlock(e);
                } else if(e.shiftKey) {
                    this.outdent();
                } else {
                    this.indent();
                }               
            } else if(e.ctrlKey && ['b', 'i', 'u', 'z', 'y'].include(c)) {                
                e.stopEvent();
                var cmd;
                switch (c) {
                    case 'b':
                        cmd = 'bold';
                        break;
                    case 'i':
                        cmd = 'italic';
                        break;
                    case 'u':
                        if (this.enableUnderline) {
                            cmd = 'underline';
                        }
                        break;
                    case 'z':
                        if (e.shiftKey) {
                            this.doRedo();
                            this.win.focus();
                        }
                        else {
                            this.doUndo();
                            this.win.focus();
                        }
                        break;
                    case 'y':
                        this.doRedo();
                        this.win.focus();
                        break;
                }
                
                if(cmd){
                    this.logCmd(cmd);
                }            
            }
        },
        
        /**
         * @override
         */
        fixKeys: function(e) {
            return function(e) {
                var c = e.getCharCode();
                if (c > 0) {
                    c = String.fromCharCode(c).toLowerCase();
                }
                
                // If a paragraph or a code block is selected, use tab and shift+tab to indent or outdent it
                if(e.getKey() === e.TAB && this.enableParagraph) {
                    e.stopEvent();
                    e.preventDefault();

                    // If the cursor is inside a code block, handle tab press differently
                    if(this.enableCodeBlock && this.isInsideCodeBlock()) {
                        this.handleTabInsideCodeBlock(e);
                    } else if(e.shiftKey) {
                        this.outdent();
                    } else {
                        this.indent();
                    }
                }
                
                // If ctrl is pressed, check if it a richtext command or a general command
                else if(e.ctrlKey && ['b', 'i', 'u', 'z', 'y'].include(c)) {
                    e.stopEvent();
                    var cmd;                    
                    switch (c) {
                        case 'b':
                            cmd = 'bold';
                            break;
                        case 'i':
                            cmd = 'italic';
                            break;
                        case 'u':
                            if (this.enableUnderline) {
                                cmd = 'underline';
                            }
                            break;
                        case 'z':
                            if (e.shiftKey) {
                                this.doRedo();
                                this.win.focus();
                            }
                            else {
                                this.doUndo();
                                this.win.focus();
                            }
                            
                            break;
                        case 'y':
                            this.doRedo();
                            this.win.focus();
                            break;
                    }
                    
                    if(cmd){
                        this.logCmd(cmd);
                    }                       
                }
            };
        }(),
        
        /**
         * Checks if the cursor is inside a code block
         * @returns
         */
        isInsideCodeBlock : function() {
            if (this.enableCodeBlock) {
                var selection = this.getSelection();
                
                if(selection.rangeCount !== 0) {
                    // Get the range
                	var range = this.getRange(selection);
                    var ancestor = this.getAncestor(selection, this.isSingleCursorSelection(range));
                    var codeBlock = this.searchCodeBlock(ancestor);
                    return !!codeBlock;
                }
            } else {
                return false;
            }
            
        },
        
        /**
         * Handles pressing the tab key while the cursor is inside a code block
         * @param e
         */
        handleTabInsideCodeBlock : function(e) {
            var selection = this.getSelection();
            if (e.shiftKey && this.enableCodeBlock) {
                if (selection.anchorOffset >= 4) {
                    var cc = range.cloneContents();
                    if (cc.childNodes.length === 0) {
                        range.setStart(selection.anchorNode, selection.anchorOffset - 4);
                        if (range.cloneContents().childNodes.length === 1 &&
                            range.cloneContents().textContent.trim().length === 0) {
                            this.logCmd("delete");
                        } else {
                            this.logCmd("outdent");
                        }
                    } else if (cc.lastChild.nodeName === "BR") {
                        this.logCmd("outdent");
                    }
                } else {
                    this.logCmd("outdent");
                }
            } else {
                this.indent();
            }
        },
        
        /**
         * @override
         */
        createToolbar: function(editor) {            
            
            /**
             * Creates a new Button for the toolbar.
             * @param {String} id
             * @param {Boolean} toggle
             * @param {Function} handler
             * @param {String} cls
             * @param {String} icon
             * @param {String} customId
             * @returns Ext.Button
             */
            function createButton(id, toggle, handler, cls, icon, customId) {
                return {
                    itemId          : customId || id,
                    cls             : "x-btn-icon y-horizontal-menu-button " + (cls ? cls : ''),
                    enableToggle    : toggle !== false,
                    scope           : editor,
                    icon            : icon || '',
                    handler         : handler || editor.relayBtnCmd,
                    tabIndex        : -1,
                    tooltip         : {
                        title: Ext.ux.getI18N("richtext.title." + (customId || id).toLowerCase()),
                        text: Ext.ux.getI18N("richtext.text." + (customId || id).toLowerCase())
                    }
                };
            }

            // build the toolbar
            var tb = new Ext.Toolbar({
                renderTo:this.wrap.dom.firstChild
            });

            // stop form submits
            tb.el.on('click', function(e){
                e.preventDefault();
            });
            
            if (this.additionalToolbarButtons) {
                this.additionalToolbarButtons.each(function(btn) {
                    tb.add(btn);
                }.bind(this));
            }
            
            // TODO implement!!!            
            if(this.enableUndoRedo) {
                tb.add(
                    createButton('undo', false, this.doUndo.bind(this), 'x-edit-undo', Ext.IMAGE_URL + "/famfamfam"+ (Ext.isIPad ? '/32x32' : '') + "/arrow_undo.png", 'undo'),
                    createButton('redo', false, this.doRedo.bind(this), 'x-edit-redo', Ext.IMAGE_URL + "/famfamfam"+ (Ext.isIPad ? '/32x32' : '') + "/arrow_redo.png", 'redo'),
                    '-'
                );
            }
                        
//          if(this.enableFont){
//              this.fontSelect = tb.el.createChild({
//                  tag:'select',
//                  cls:'x-font-select',
//                  html: this.createFontOptions()
//              });
//                
//                new Ext.ToolTip({
//                    target: this.fontSelect,
//                    title: Ext.ux.getI18N("richtext.title.fontselect"),
//                    html: Ext.ux.getI18N("richtext.text.fontselect")
//                });
//                
//              this.fontSelect.on('change', function(){
//                  var font = this.fontSelect.dom.value;
//                  this.logCmd('fontname', font);
//                  this.deferFocus();
//              }, this);
//                
//              tb.add(
//                  this.fontSelect.dom,
//                  '-'
//              );
//          }
            
            if(this.enableFontSize) {
                var me = this;
                this.fontSizeComboBox = new Ext.form.ComboBox({
                    displayField    : 'display',
                    valueField      : 'value',
                    itemId          : 'fontsize',
                    forceSelection  : true,
                    mode            : 'local',
                    triggerAction   : 'all',
                    width           : 40,
                    emptyText       : '12',
                    store           : new Ext.data.SimpleStore({
                        autoDestroy : true,
                        fields      : ['value', 'display'],
                        data        : [[1, 10], [2, 12], [3, 16], [4, 18], [5, 24], [6, 32], [7, 48]]
                    }),
                    
                    editable        : false,
                    selectOnFocus   : false,
                    disableKeyFilter: true,
                    
                    tabIndex        : -1,
                    height          : 18,
                    listWidth       : 25,
                    iconCls         : 'no-icon',
                    cls             : Ext.isChrome ? 'y-richtext-combobox-chrome' : 'y-richtext-combobox',
                    ctCls           : ((Ext.isIE9 || Ext.isIE10 || Ext.isIE11) ? 'y-richtext-combobox-ct-ie9' : 'y-richtext-combobox-ct') + ' y-richtext-toolbar-button',
                    listeners       : {
                                        "select" : function(combo, rec) {
                                            this.forceSelection();
                                            
                                            if (Ext.isIE9 || Ext.isIE10 || Ext.isIE11) {
                                                var selection = this.userSelection;
                                                var range = this.userRange;
                                                selection.removeAllRanges();
                                                selection.addRange(range);
                                                this.logCmd("fontsize", rec.get("value"));
                                            } else {
                                                /*
                                                var cont = this.getRange().commonAncestorContainer; 
                                                if (cont) {
                                                    var parentNode = cont.parentNode;
                                                    if (parentNode.nodeName === "SPAN") {
                                                        this.logCmd(this.setStyle.bind(this, parentNode, "font-size", rec.get("display")+"px;"));
                                                    } else {
                                                        this.logCmd('fontsize', rec.get("value"));  
                                                    } 
                                                } else {
                                                */
                                                    this.logCmd('fontsize', rec.get("value"));  
                                                //}
                                            }
                                            
                                            // If the size of text changes, update the highlightcolor if it's set
                                            if (Ext.isGecko) {
                                                // If no common ancestor container exists, there can be no background color set
                                                var cont = this.getRange().commonAncestorContainer;
                                                if (!cont || !cont.style || !cont.style.backgroundColor) {
                                                    return;
                                                } 
                                                var color = this.getRange().commonAncestorContainer.style.backgroundColor;
                                                // If a backgroundcolor exists, update it to fit the text
                                                if (color) {
                                                    this.relayCmd('useCSS', false);
                                                    this.relayCmd('hilitecolor', color);
                                                    this.relayCmd('useCSS', true);
                                                    this.deferFocus();  
                                                }
                                            } else {
                                                var range = (Ext.isIE9 || Ext.isIE10 || Ext.isIE11) ? (this.userRange || this.getRange()) : this.getSelection().getRangeAt(0);
                                                var color = this.getRange().commonAncestorContainer.style && this.getRange().commonAncestorContainer.style['backgroundColor'] || undefined;
                                                // If a color exists, refresh it
                                                if (typeof color !== 'undefined') {
                                                    this.relayCmd(Ext.isOpera || Ext.isChrome? 'hilitecolor' : 'backcolor', color);
                                                }
                                                this.deferFocus();
                                            }
                                            combo.reset();
                                        }.bind(this)
                    },
                    onFocus         : function() {
                        me.userSelection = me.getSelection();
                        
                        // For some reason, me.getRange() cannot be used here:
                        // It will break the font-sizing functionality!
                        // Do the range-checking manually.
                        if (me.userSelection.rangeCount !== 0) {
                            me.userRange = me.userSelection.getRangeAt(0);
                        }
                        
                        Ext.form.TriggerField.superclass.onFocus.call(this);
                        if(!this.mimicing){
                            this.wrap.addClass('x-trigger-wrap-focus');
                            this.mimicing = true;
                            Ext.get(Ext.isIE ? document.body : document).on("mousedown", this.mimicBlur, this, {delay: 10});
                            if(this.monitorTab){
                                this.el.on("keydown", this.checkTab, this);
                            }
                        }
                    }
                });
                
                tb.add(this.fontSizeComboBox, '-');
                
            }
            
            // BOLD/ITALIC/UNDERLINE
            if(this.enableFormat){
                tb.add(
                    createButton('bold', true, this.bold.bind(this), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-bold.png", 'bold'),
                    createButton('italic', true, this.italic.bind(this), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-italic.png", 'italic')
                );
                
                if(this.enableUnderline) {
                    // underline currently not supported for svg graphics in FF
                    tb.add(
                            createButton('underline', true, this.underline.bind(this), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-underline.png", 'underline')    
                    );
                }
            }
            
            // FONT-COLOR/BACKGROUND
            if(this.enableColors){
                
                tb.add(
                        '-', 
                        createButton('color', false, this.changeColor.bind(this, 'color'), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-color.png", 'color'),
                        createButton('markUpColor', false, this.changeColor.bind(this, 'markUpColor'), undefined, Ext.IMAGE_URL + "/fugue/icons" + (Ext.isIPad ? '/32x32' : '') + "/highlighter-text.png", 'markUpColor')
                );
                
                
                // Graft the color hint boxes
                this.fontColorHint = ("undefined" !== typeof ORYX&&ORYX.Editor||Signavio&&Signavio.Core).graft("http://www.w3.org/1999/xhtml", undefined, this.getColorHint());
                this.fontColorHint.style.background = 'none repeat scroll 0 0 #000000';
                
                // Correct the position of the hint
                if (Ext.isFF) {
                    this.fontColorHint.style.top -= 2;
                }

                tb.items.map.color.el.dom.appendChild(this.fontColorHint);
            }
            
            // HEADING
            if(this.enableHeadings) {
                tb.add(
                    '-',
                    createButton('heading', true, this.h1.bind(this), undefined, Ext.IMAGE_URL + "/famfamfam/text_heading_1.png", "h1"),
                    createButton('heading', true, this.h2.bind(this), undefined, Ext.IMAGE_URL + "/famfamfam/text_heading_2.png", "h2"),
                    createButton('heading', true, this.h3.bind(this), undefined, Ext.IMAGE_URL + "/famfamfam/text_heading_3.png", "h3")
                );
            }
            
     
            if(this.enableAlignments){
                tb.add(
                    '-',
                    createButton('justifyleft', true, this.align.bind(this, 'left'), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + "/edit-alignment.png", 'justifyleft'),
                    createButton('justifycenter', true, this.align.bind(this, 'center'), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + "/edit-alignment-center.png", 'justifycenter'),
                    createButton('justifyright', true, this.align.bind(this, 'right'), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + "/edit-alignment-right.png", 'justifyright')
                );
            }           
            
            if(this.enableLists){
                tb.add(
                    '-',
                    createButton('insertorderedlist', true, this.ol.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + '/edit-list-order.png', 'insertorderedlist'),
                    createButton('insertunorderedlist', true, this.ul.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + '/edit-list.png', 'insertunorderedlist')
                );
            }
            
            if(this.enableParagraph) {
                tb.add(
                    '-',
                    createButton('outdent', false, this.outdent.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons' + (Ext.isIPad ? '32x32' : '') + '/edit-outdent.png', 'outdent'),
                    createButton('indent', false, this.indent.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons' + (Ext.isIPad ? '32x32' : '') + '/edit-indent.png', 'indent')
                    
                );
            }
            
            if(this.enableLinks){
                tb.add(
                    '-',
                    createButton('createlink', false, this.link.bind(this), undefined, Ext.IMAGE_URL + '/famfamfam' + (Ext.isIPad ? '32x32' : '') + '/world_link.png', 'createlink'),
                    createButton('unlink', false, this.unlink.bind(this), undefined, Ext.IMAGE_URL + '/famfamfam' + (Ext.isIPad ? '32x32' : '') + '/link_break.png', 'unlink')
                );
            }
            
            
            if(this.enableHorizontalRule) {
                tb.add(
                    '-',
                    createButton('inserthorizontalrule', false, this.hr.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons/edit-rule.png', 'inserthorizontalrule')
                );
            }

            if(this.enableImageInsertion) {
                tb.add(
                    createButton('insertimage', false, this.insertOrEditImage.bind(this), 'y-btn-icon-richtext-image-toolbar', Ext.IMAGE_URL + '/fugue/icons/image-import.png', 'insertimages')
                );
            }
            
            if(this.enableCodeBlock) {
                tb.add(
                    createButton('insertcodeblock', false, this.insertCodeBlock.bind(this), undefined, Ext.IMAGE_URL + "/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-color.png", "insertcodeblock")
                );
            }
            
            
            if(this.enableRemoveFormat) {
                tb.add(
                    '->',
                    createButton('removeformat', false, this.removeFormat.bind(this), undefined, Ext.IMAGE_URL + '/fugue/icons'+ (Ext.isIPad ? '32x32' : '') + '/eraser.png', 'removeformat')
                );
            }
                    
            this.tb = tb;
        },


        /************** Begin images ***************/

        IMAGE_ENDINGS: ["png", "jpg", "bmp", "gif"],

        /**
         * Creates and shows the image editor dialog
         * @param {object} node: A div node tagged 'img' that contains an img node
         */ 
        openImageEditor: function (imgNode) {
            if (!this.enableImageInsertion) { return };
            var dialog = this.getImageEditorDialog(this.onImageEditorSave.bind(this));
            // first child is the IMG node containing all information neccessary
            dialog.setupWith(Ext.ux.Richtext.getImgTags(imgNode));
            // set the targetNode for later reference
            dialog.targetNode = imgNode;
            dialog.show(); 
        },

        onImageEditorSave: function (button) {
            var dialog = button.ownerCt,
                target = dialog.targetNode.parentNode ? dialog.targetNode : this.selectedImageNode();
            this.logCmd(Ext.ux.Richtext.updateImage.bind(Ext.ux.Richtext, target, {
                src: dialog.srcValue(), 
                width: dialog.widthValue(), 
                caption: dialog.captionValue()
            }));
            this.selectImageNode(target);
            dialog.close();
        },

        /**
         * Shortcut to open the image chooser dialog without the trigger button
         */
        openImageChooser: function (clb, allowsInsertEdit, value) {
            if (!this.enableImageInsertion) return;
            var chooser;
            var insertAndEditFunc = function () {
                var value;
                chooser.items.items.first().getValue(function (val) {
                    value = val;
                    chooser.close()
                    clb(value, true)
                })
            }
            var that = this,
                buttons = allowsInsertEdit ?
                            [{  text    : Ext.ux.getI18N('richtext.img.insertandedit'),
                                id      : 'insert',
                                handler : insertAndEditFunc.bind(this)}] :
                            [];
            // Create the TriggerField
            chooser = new Signavio.ux.dialog.FileUpload(this.facade, {
                //buttons: ...+ implement in upload.js so that this is concatenated
                buttons: buttons,
                filter: ["dir"].concat(this.IMAGE_ENDINGS),
                domainKey: "richtext",
                value: value,
                showInternalFolders: false,
                allowedTypes: ["image/png", "image/jpeg", "image/svg"],
                saveText: Ext.ux.getI18N('richtext.img.insert')
            });

            // workaround facade event registration
            if (typeof clb === "function") {
                chooser.on("file.selected", clb.bind(this));
            } 

            var that = this;
            chooser.on("close", function () {
                that.un("file.selected");
            })
            chooser.show()
        },

        onImageChooserSave: function (value, editAfterInsert) {
            var that = this;
            this.insertImage(value.get("href"), editAfterInsert ? function () {
                that.win.focus(); // otherwise we don't get a propert selection
                var range = that.getRange(),
                    target = that.getImageFrom(that.nodeAtOffset(range.startContainer, range.startOffset-1)); // use -1 since the image was added but is not yet recognized in dom
            	if (Ext.isIE) {
            		target = that.imgNode;
            		delete that.imgNode;
            	}
                if (target) { that.openImageEditor(target); };
            } : function () {
            	if (Ext.isIE) {
            		delete that.imgNode;
            	}
            });
        },

        /** find if cursor is within image or caption **/
        selectedImageNode: function () {
            this.win.focus(); // otherwise IE gets no range
            var range = this.getRange();
            return this.getImageFrom(this.nodeAtOffset(range.startContainer, range.startOffset));
        },

        getImageFrom: function (node) {
            if (node) {
                if (this.isImage(node)) {
                    return node;
                } else if (this.isCaption(node)) {
                    return node.nodeType === 1 ? node.previousSibling : node.parentNode.previousSibling;
                }
            }
        },

        /** Insert an image from the given id to current selection */
        insertImage: function (value, clb) {
            this.win.focus(); // otherwise, IE has no range
            var that = this;
            var src = Ext.ux.Richtext.getURIFor(Ext.ux.Richtext.parseImageId(value));

            if (Ext.isIE) { // IE does not understand inserthtml; use insertimage and build the container structure around instead.
            	this.logCmd('insertimage', src, function () {
                    that.afterInsertImage();
                    if (typeof(clb) === "function") {
                        clb();
                    }
                })
            } else {
                // Get the focused node
                var range = this.getRange(),
                    node = range.startContainer;
                // Handle insertion into a text line (nodeType TEXT)
                if (node.nodeType === 3) { this.logCmd('inserthtml', '<br/>'); }
                // focus node is the container, we want to insert at a specific position
                else if (node.nodeType === 1 && node.childNodes.length > 0) { node = node.childNodes[range.startOffset]; }
                if (!node) {
                    this.logCmd('inserthtml', '<br/>');
                    node = this.nodeAtOffset(range.startContainer, range.startOffset-1);
                }
                this.logCmd('inserthtml', this.initialImgTag(src), node.nodeType === 3 ? function () {
                    that.afterInsertImage.bind(that);
                    if (typeof(clb) === "function") {
                        clb();
                    }
                } : clb);
            }
        },

        /** Builds the div container structure around the first image without it and selects it */
        afterInsertImage: function () {
            // Find the image node without container
            var imgNode = $A(this.win.document.getElementsByTagName("img")).find(function (imgNode) {
                return typeof imgNode.getAttribute(Ext.ux.Richtext.IMAGE_CAPTION_ATTRIBUTE) !== 'string';
            });
            if (!imgNode) return;
            if (Ext.isIE) { // disable handlebars in IE
                this.imgNode = imgNode; //temporarily remember the node to access it in editafterinsert
                imgNode.parentNode.insertBefore(document.createElement("br"), imgNode);
                imgNode.oncontrolselect = function () { return false; };
            }
            // set the default imgNode properties
            imgNode.setAttribute(Ext.ux.Richtext.IMAGE_CAPTION_ATTRIBUTE, '');
            // Create the container structure
            Ext.ux.Richtext.fixImage(imgNode);
            // set the selection around the image
            var selection = this.getSelection(),
                range = document.createRange ? document.createRange() : selection.createRange(),
                target = selection.focusNode;
            range.setStartBefore(imgNode);
            range.setEndAfter(imgNode);
            selection.removeAllRanges();
            selection.addRange(range);
        },

        /** Creates an initial image structure string that can be inserted as HTML */
        initialImgTag: function (src) {
            var imgHTML = Ext.ux.Richtext.getImageHTML({src: src});
            if (Ext.isChrome && !this.win.document.textContent) imgHTML = '<div>'+imgHTML+'</div>';
            return imgHTML;
        },

        removeImageNode: function (imgNode) {
            if (!imgNode) return;
            if (this.isCaption(imgNode.nextSibling)) {
                imgNode.parentNode.removeChild(imgNode.nextSibling);
            }
            if (this.isImage(imgNode)) {
                imgNode.parentNode.removeChild(imgNode);
            }
        },

        /** Creates a dialog that allows editiing an images width, src and caption */
        getImageEditorDialog: function (onSaveClb) {
            var that = this,
                pathFieldRef = {pathField: undefined};
            // The upper half of image editor is used to configure src and caption
            var captionField = new Ext.form.TextField({width: "200px", hideLabel: true});
            var pathField = new Ext.form.TriggerField({
                width           : "200px",
                hideTrigger     : false,
                triggerClass    : "x-trigger-other",
                onTriggerClick  : function(){
                    that.openImageChooser(pathField.onNewSource.bind(pathField), false, pathField.data);
                }.bind(this)
            })
            // onNewSource will be called onClose of image editor and when image editor is created
            var onNewSource = function (value) {
                // on initial open, we get only a href, every other time, we get a response.
                var value = value.get ? value.get("href") : value;
                Ext.ux.Richtext.getImgResource(Ext.ux.Richtext.parseImageId(value), function (res) {
                    pathField.data = res.href;
                    pathField.linked[res.href] = res;
                    pathField.setValue(res.rep.name +"."+ res.rep.extension);
                });
            };
            var onDelete = function (button) {
                var dialog = button.ownerCt,
                    target = dialog.targetNode.parentNode ? dialog.targetNode : this.selectedImageNode();
                that.removeImageNode(target);
                dialog.close();
            };
            pathField.linked = [];
            pathField.onNewSource = onNewSource;
            pathField.removeClass('x-grey-background');
            var picFieldset = {
                xtype       : "fieldset",
                cls         : "at-richtext-image-edit-ct",
                title       : Ext.ux.getI18N('richtext.img.edit.imgtitle'),
                autoWidth   : true,
                autoHeight  : true,
                layout      : "form",
                bodyStyle   : "margin:10px 10px 0 10px;",
                defaults    : {
                    hideLabel       : true,
                    width           : 466
                },
                items       : [{
                        html        : Ext.ux.getI18N('richtext.img.edit.sourcedescription'),
                        xtype       : 'panel',
                        bodyStyle   : "margin-left:1px",
                        cls         : 'y-description-panel'
                    },pathField,{
                        html        : Ext.ux.getI18N('richtext.img.edit.captiondescription'),
                        xtype       : 'panel',
                        bodyStyle   : "margin-top:10px; margin-left:1px",
                        cls         : 'y-description-panel'
                    },captionField]
            };
            // The lower half is used to configure the width
            var absoluteWidthField = new Ext.form.RadioInputField({ value: false,   label: Ext.ux.getI18N('richtext.img.edit.absolutewidth'), name: "width", type: "number" });
            var relativeWidthField = new Ext.form.RadioInputField({ value: true,    label: Ext.ux.getI18N('richtext.img.edit.relativewidth'), name: "width", type: "number" });
            var displayFieldset = {
                xtype       : "fieldset",
                cls         : "at-richtext-image-edit-ct",
                title       : Ext.ux.getI18N('richtext.img.edit.widthtitle'),
                autoWidth   : true,
                autoHeight  : true,
                defaultType : "textfield",
                layout      : "form",
                bodyStyle   : "margin:10px 10px 10px 10px;",
                items       : [{
                        html        : Ext.ux.getI18N('richtext.img.edit.widthdescription'),
                        hideLabel   : true,
                        xtype       : 'panel',
                        cls         : 'y-description-panel'
                    },
                    relativeWidthField,
                    absoluteWidthField],
                getValue    : function () {
                    return relativeWidthField.getValue() ? relativeWidthField.getTextValue() : absoluteWidthField.getTextValue() ;
                },
                getType     : function () { return relativeWidthField.radioButton.checked ? "%" : "" ; },
                setWidth    : function (type, value) {
                    if (type === Ext.ux.Richtext.RELATIVE_UNIT) {
                        relativeWidthField.setValue(true, value);
                        absoluteWidthField.setValue(false, "");
                    } else {
                        absoluteWidthField.setValue(true, value);
                        relativeWidthField.setValue(false, "");
                    }
                }
            };
            // The containing window
            return new Ext.ux.Window({
                title       : Ext.ux.getI18N('richtext.img.edit.title'),
                width       : 500,
                resizable   : false,
                bodyStyle   : "padding:0px;",
                modal       : true,
                items       : [new Ext.form.FormPanel({
                    autoWidth   : true,
                    layout      : "form",
                    border      : false,
                    bodyStyle   : "padding:0;",
                    items: [picFieldset , displayFieldset]
                })],
                buttons : [{
                    text        : Ext.ux.getI18N('richtext.img.delete'),
                    handler     : onDelete.bind(this)
                }, {
                    text        : Ext.ux.getI18N('richtext.img.save'),
                    handler     : onSaveClb.bind(this)
                }],
                widthValue: function () { return displayFieldset.getValue() + displayFieldset.getType();},
                srcValue: function () { return pathField.data; },
                captionValue: function () { return captionField.getValue(); },
                setupWith: function (conf) {
                    if (conf.src !== undefined) pathField.onNewSource(conf.src);
                    if (conf.widthType !== undefined && conf.width !== undefined) displayFieldset.setWidth(conf.widthType, conf.width);
                    if (conf.caption !== undefined) captionField.setValue(conf.caption);
                }
            });
        },

        /** Select image and caption nodes when clicked or reached by typing and with that make captions immutable */
        handleImageClicks: function(event) {
            var target = event.target || {},
                image;

            if (this.isImage(target)) {
                image = target;
            } else if (this.isCaption(target)) {
                image = target.nodeType === 1 ? target.previousSibling : target.parentNode.previousSibling;
            }
            if (image) {
                // select the whole image container if an image part was clicked
                this.selectImageNode(image);
                Event.stop(event);
            }
        },

        selectImageNode: function (imgNode) {
            if (!imgNode) { return; }
            // get the selection
            var selection = this.getSelection(),
                range = document.createRange ? document.createRange() : selection.createRange();
            // find the boundings
            var startNode = imgNode,
                endNode = this.isCaption(imgNode.nextSibling) ? imgNode.nextSibling : imgNode;
            range.setStartBefore(startNode);
            // apply the selection
            range.setEndAfter(endNode);
            selection.removeAllRanges();
            selection.addRange(range);
        },

        /** Open the image editor on double click */
        handleImageDoubleClick: function (event) {
            var node = event.target;
            if (this.isImage(node)) {
                this.openImageEditor(node);
            } else if (this.isCaption(node)) {
                this.openImageEditor(node.nodeType === 1 ? node.previousSibling : node.parentNode.previousSibling);
            }
            Event.stop(event);
        },

        /**
         * Forbid typing and deleting if cursor is set (i.e. selection starts or ends) within an image+caption, so they cannot be modified
         *    special keys are allowes
         *    delete before and backspace after image/caption trigger selection of image+caption
         */

        handleImageKey: function (event) {
            var selection = this.getSelection(),
                range = this.getRange(selection),
                k = Ext.isIE ? event.keyCode : event.which;
            var ENTER = 13, DEL = 46, BCKSPC = 8;
            if (!range) return;

            var start = this.getCursorPosition(range.startContainer, range.startOffset) || {pos: undefined, img: undefined},
                end = this.getCursorPosition(range.endContainer, range.endOffset) || {pos: undefined, img: undefined};

            // if the cursor or selection is somewhere within the image, handle events with respect to the cursor position
            if (start.pos || end.pos) {
                // Before image, no selection
                if (start.pos === end.pos && start.pos === 'bfr') {
                    // allow (enter, backspace) if no ctrl is pressed
                    if (k === BCKSPC && !event.ctrlKey) {
                        return;
                    } else if (k === DEL) {
                        this.selectImageNode(start.img);
                    } else if (k === ENTER) {
                        this.logCmd('insertHTML', '<br/>');
                    }
                }
                // behind image (and caption), no selection
                else if (start.pos === end.pos && start.pos === 'bhnd') {
                    // allow (enter, delete) if no ctrl is pressed
                    if (k === DEL && !event.ctrlKey) {
                        Event.stop(event);
                    } else if (k === BCKSPC) {
                        this.selectImageNode(end.img);
                    } else if (k === ENTER) {
                        this.logCmd('insertHTML', '<br/>');
                        Event.stop(event);
                        return;
                    }
                }
                // a selection around the whole image or further
                else if ((start.pos === undefined || start.pos === 'bfr') && (end.pos === undefined || end.pos === 'bhnd')) {
                    return;
                }

                // allow special characters and branded keys exept for insert + delete
                if (this.isSpecialKey(k)) { return; }
                // allow everything but enter, delete and backspace if ctrl is pressed
                if (event.ctrlKey && (k !== ENTER && k !== DEL && k !== BCKSPC)) { return; }
                // handle arrow keys when in image
                if ((start.pos || end.pos) && 37 <= k && k <= 40 && start.pos && end.pos) {
                    // cursor before is okay with up and left
                    if (start.pos === 'bfr' && (k == 37 || k == 38)) { return; }
                    // cursor behind is oky with right and down
                    if (end.pos === 'bhnd' && (k == 39 || k == 40)) { return; }
                    // otherwise, handle
                    this.setCursorBeforeOrBehindImage(k, start.img || end.img, selection);
                }
                // forbid everything else
                Event.stop(event);
            }
        },

        getCursorPosition: function (container, offset) {
            // image without caption, cursor before image
            // image with caption, cursor before image
            var node;
            if ((node = this.nodeAtOffset(container, offset)) && this.isImage(node)) {
                return {pos: 'bfr', img: node}
            }
            // image without caption, cursor behind image
            if ((node = this.nodeAtOffset(container, offset-1)) && this.isImage(node) && !this.isCaption(this.nodeAtOffset(container, offset))) {
                return { pos: 'bhnd', img: node}
            }
            // image with caption, cursor between image and caption or behind caption
            if ((node = this.nodeAtOffset(container, offset)) && this.isCaption(node)) {
                return {pos:  offset === container.length ? 'bhnd' : 'btwn', 
                    img: node.nodeType === 1 ? node.previousSibling : node.parentNode.previousSibling}
            }
            // image with caption, cursor within or behind caption
            if (this.isCaption(container)) {
                return {    pos: offset === container.length ? 'bhnd' : 'btwn',
                            img: container.nodeType === 1 ? container.previousSibling : container.parentNode.previousSibling }
            }

        },

        setCursorBeforeOrBehindImage: function (keycode, imgNode, selection) {
            if (!imgNode || !selection || keycode > 40  || keycode < 37) { return; }
            var newRange = document.createRange ? document.createRange() : selection.createRange();
            // key up or left
            if (keycode === 37 || keycode === 38) {
                newRange.setStartBefore(imgNode);
                newRange.setEndBefore(imgNode);
            // key down or right
            } else {
                var targetNode = this.isCaption(imgNode.nextSibling) ? imgNode.nextSibling : imgNode;
                newRange.setStartAfter(targetNode);
                newRange.setEndAfter(targetNode);
            }
            selection.removeAllRanges();
            selection.addRange(newRange);
        },

        nodeAtOffset: function (parent, offset) {
            if (parent.nodeType === 1) {
                return parent.childNodes[offset]
            } else {
                return parent
            }
        },

        /** make sure all images have their image container */
        // deprecated
        fixImages: function (root) {
            var root = root || this.win.document.body;
            Ext.ux.Richtext.fixImages(root);
        },

        fixImage: function (node) {
            Ext.ux.Richtext.fixImage(node);
        },

        specialKeys: [36,35,33,34,224,91,92,93,0],

        isSpecialKey: function (nr) {
            return this.specialKeys.member(nr) || // special characters but insert and delete
                (112 <= nr && nr <= 123); // function keys
        },

        // deprecated
        isImage: function (node) {
            return Ext.ux.Richtext.isImage(node);
        },

        // deprecated
        isCaption: function (node) {
            return Ext.ux.Richtext.isCaption(node);
        },

        detourCaptionSelection: function (event) {
            var target = event.target || {};
            if (this.isCaption(target)) {
                var selection = this.getSelection(),
                    range = document.createRange ? document.createRange() : selection.createRange();
                var endNode = target.nodeType === 1 ? target : target.parentNode,
                    startNode = target.previousSibling;
                range.setStartBefore(startNode);
                range.setEndAfter(endNode);
                selection.removeAllRanges();
                selection.addRange(range);
                Event.stop(event);
            }
        },

        fixImagesAfterCommand: function(cmd) {
                this.fixImages();
        },

        /************** End images ***************/
        
        executeCommand: function(cmd) {
            this.undoStack.push(cmd);
            this.redoStack = [];
            
            this.updateToolbar();
        },
        
        /*
        setStyle : function(node, key, value) {
            if (node.hasAttribute("style")) {
                var styles = node.getAttribute("style");
                if (styles.include(key)) {
                    styles = styles.replace(new RegExp(""+key+":[^;]+;", "gi"), key+":"+(value.endsWith(";") ? value : value+";"));
                } else {
                    styles += (key+":"+(value.endsWith(";") ? value : value+";"));
                }
            } else {
                styles = (key+":"+(value.endsWith(";") ? value : value+";"));
            }
            node.setAttribute("style", styles);
        },
        */
        
        /**
         * Returns a range object for the current selection
         * @param {DOMSelection} selection (optional)
         * @returns {DOMRange}
         */
        getRange: function(selection){
            // Get the selection
            selection = selection || this.getSelection();
            
            // Get the range
            if (selection.rangeCount === 0) {
                return this.win.document.createRange ? this.win.document.createRange() : selection.createRange();
            
            } else if ("function" == typeof selection.getRangeAt) {
                return selection.getRangeAt(0);
                
            } else {
                var range = this.win.document.createRange ? this.win.document.createRange() : selection.createRange();
                // Create a range exactly like the user selection
                range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
                return range;
            }
        },

        /** 
         * Logs a command
         * 
         * @param {String | Function} cmd
         * @param {Object} value
         * @param {Function} clb
         */
        logCmd: function(cmd, value, clb) {
            
            var selection = this.getSelection(),
                range = this.getRange(selection);
            
            Ext.ux.Richtext.hideCaptions(this.body);
            if("function" == typeof cmd) {
                cmd();
            } else {
                this.relayCmd(cmd, value);
            }
            this.fixImagesAfterCommand(cmd);
            // Ie doesn't handle indentation pretty well...
            if (Ext.isIE) {
                if (cmd == "indent") {
                    this.fixIEIndent()
                }
                if (cmd == "outdent") {
                    this.fixIEOutdent();
                }
            }

            selection = this.getSelection();
            if (selection.rangeCount <= 0){
                return;
            }
            range = this.getRange(selection);
            
            var offset = range.endOffset;
            var breadcrump = this.getBreadcrump(range.endContainer);
            
            var conf = {
                oldHTML: this.oldHTML,
                oldOffset: this.oldOffset,
                oldBreadcrump: this.oldBreadcrump,
                newHTML: this.body.innerHTML,
                newOffset: offset,
                newBreadcrump: breadcrump
            };
            
            // only log if something has changed.
            if (this.oldHTML !== this.body.innerHTML) {
                this.executeCommand(new Ext.ux.Command(this, conf));
                this.win.focus();
                
                this.oldHTML = this.body.innerHTML;
                this.oldOffset = offset;
                this.oldBreadcrump = breadcrump;
            }  
            
            if (clb instanceof Function) {
                clb();
            }
        },   
        
        /**
         * @override
         */
        onFocus : function() {
            if (!this.activated) {
                this.onFirstFocus();
                return;
            }
        },
        
        /**
         * @override
         */
        updateToolbar: function() {
            if(!this.activated){
                this.onFirstFocus();
                return;
            }
            // The toolbar buttons
            var buttons = this.tb.items.map;
            // The document
            var doc = this.doc;
            
            
//          if (this.isInsideCodeBlock()) {
//              var buttonNames = "";
//              buttonNames += (this.enableLists ? "insertorderedlist insertunorderedlist " : "");
//              buttonNames += (this.enableFormat ? "bold italic " : "");
//              buttonNames += (this.enableUnderline ? "underline " : "");
//              buttonNames += (this.enableAlignments ? "justifyleft justifycenter justifyright " : "");
//              buttonNames += (this.enableHeadings ? "h1 h2 h3 " : "");
//              buttonNames += "createlink insertcodeblock inserthorizontalrule markUpColor removeformat unlink color";
//              
//              var btns = $w(buttonNames);
//              btns.each(function(name) {
//                  buttons[name].disable();
//              });
//              if (this.fontSizeComboBox) {
//                  this.fontSizeComboBox.disable();
//              }
//              Ext.menu.MenuMgr.hideAll();
//              this.syncValue();
//              return;
//          } else if (this.enableCodeBlock) {
//              var buttonNames = "";
//              buttonNames += (this.enableLists ? "insertorderedlist insertunorderedlist " : "");
//              buttonNames += (this.enableFormat ? "bold italic " : "");
//              buttonNames += (this.enableUnderline ? "underline " : "");
//              buttonNames += (this.enableAlignments ? "justifyleft justifycenter justifyright " : "");
//              buttonNames += (this.enableHeadings ? "h1 h2 h3 " : "");
//              buttonNames += "createlink insertcodeblock inserthorizontalrule markUpColor removeformat unlink color";
//              
//              var btns = $w(buttonNames);
//              btns.each(function(name) {
//                  buttons[name].enable();
//              });
//              if (this.fontSizeComboBox) {
//                  this.fontSizeComboBox.enable();
//              }
//
//          }
            
            if (this.enableColors) {
            	var selection = this.getSelection();
            	var range = this.getRange(selection);
            	
                if (selection.rangeCount !== 0 && range.commonAncestorContainer.parentNode) {
                    var textColor = range.commonAncestorContainer.parentNode.color;
                }
                // If the text has a color != black
                if (textColor) {
                    // If the font color hint exists, set the new color
                    if (this.fontColorHint && this.fontColorHint.style) {
                        this.fontColorHint.style.background = "none repeat scroll 0% 0% "+textColor;
                    }
                    // If the color hint is not rendered yet, append it to the color button
                    if (this.fontColorHint && !this.fontColorHint.parentNode) {
                        buttons.color.el.dom.appendChild(this.fontColorHint);
                    }
                // If no color is set, remove the color hint box
                } else if (this.fontColorHint && this.fontColorHint.parentNode) {
                    this.fontColorHint.parentNode.removeChild(this.fontColorHint);
                }
            }
            
            // Toggle list buttons
            if(this.enableLists) {
                buttons.insertorderedlist.toggle(doc.queryCommandState('insertorderedlist'));
                buttons.insertunorderedlist.toggle(doc.queryCommandState('insertunorderedlist'));
            }
            
            
            // Toggle font format buttons
            if(this.enableFormat){
                buttons.bold.toggle(doc.queryCommandState('bold'));
                buttons.italic.toggle(doc.queryCommandState('italic'));
                
                if (this.enableUnderline) {
                    buttons.underline.toggle(doc.queryCommandState('underline'));
                }
            }
            
            // Toggle the alignment button
            if(this.enableAlignments){
                var jc = doc.queryCommandState('justifycenter'), jr = doc.queryCommandState('justifyright');
                buttons.justifyleft.toggle(!jc && !jr);
                buttons.justifycenter.toggle(jc);
                buttons.justifyright.toggle(jr);
            }
            
            /*
            if(this.enableFont && !Ext.isSafari){
                var name = (this.doc.queryCommandValue('FontName')||this.defaultFont).toLowerCase();
                if(name != this.fontSelect.dom.value){
                    this.fontSelect.dom.value = name;
                }
            }
            */
            /*
            if((Ext.isSafari || Ext.isOpera) && this.enableFont) {
                var name = (doc.queryCommandValue('FontName') || this.defaultFont).toLowerCase()
                                                                                  .split(",")[0]
                                                                                  .replace(/"|'/g, "");
                var value = $(this.fontSelect.dom).getValue();
                
                if(name != value) {                 
                    if(Ext.isOpera) {
                        // Opera is just a bitch!
                        document.getElementById(this.fontSelect.dom.id).value = name;
                    } else {
                        this.fontSelect.dom.value = name;
                    }
                }
            }
            */
            
            // Set the font size combo box value
            if(this.enableFontSize) {
                var size = doc.queryCommandValue('FontSize');
                this.fontSizeComboBox.setValue(size);
            }
            
            // Enable/Disable Undo/Redo buttons
            if(this.enableUndoRedo) {
                this.undoStack.length === 0 ? buttons.undo.disable() : buttons.undo.enable();
                this.redoStack.length === 0 ? buttons.redo.disable() : buttons.redo.enable();
            }
            
            // Toggle Headline buttons
            if(this.enableHeadings) {
                var selection = this.getSelection();
                var type;
                
                if(selection.rangeCount !== 0) {
                    // Get the range
                    var range = this.getRange(selection);
                    var ancestor = this.getAncestor(selection, this.isSingleCursorSelection(range));
                    var heading = this.searchHeading(ancestor);
                    
                    if(heading) {
                        type = heading.nodeName.toLowerCase();  
                    } 
                }
                
                buttons.h1.toggle((type ? type === 'h1' : false));
                buttons.h2.toggle((type ? type === 'h2' : false));
                buttons.h3.toggle((type ? type === 'h3' : false));
            }

            // Toggle image insert / edit button
            if (this.enableImageInsertion) {
                var imgNode = this.selectedImageNode();
                if (imgNode) {
                    // Show edit image button
                    buttons.insertimages.setIconClass('y-btn-icon-richtext-image-toolbar-update');
                }
                else {
                    // Show insert image button
                    buttons.insertimages.setIconClass('');
                }
            }
            
            Ext.menu.MenuMgr.hideAll();
            
            this.syncValue();
        },
        
        /**
         * @override
         */
        createLink: function() {
            var selection = this.getSelection(); 
            var range = this.getRange(selection);
            var link = undefined;
            
            if(this.isSingleCursorSelection(range)) {
                link = this.findLink(range.commonAncestorContainer);
            } else {
                link = this.findLink(range.startContainer, range.endContainer);
            }
            
            /*
             * Show the input box for the link to set
             * If no link exists in the selected text, create a new one
             */
            var prompt = Ext.Msg.show({
                   title        : this.createLinkText,
                   msg          : Ext.ux.getI18N('richtext.link.address'),
                   buttons      : Ext.Msg.OKCANCEL,
                   icon         : Ext.MessageBox.QUESTION,
                   // Show the existing value
                   value        : link ? link.getAttribute("href") : 'http://',
                   prompt       : true,
                   fn           : function(btn, value) {
                       if (btn === 'ok' && value.length > 0) {
                           // Allow a set of protocols
                           if (!["http", "https", "ftp", "file", "mailto"].include((value.split(":").first()||"").toLowerCase())) {
                               value = Signavio.Utils.evaluateLocalURL(value);
                               
                               if (!value.startsWith("file")) {
                                   value = "http://" + value;
                               }
                           }
                           
                           if (link) {
                               // Update the link
                               link.setAttributeNS(null, 'href', value.stripTags());
                               link.setAttributeNS(null, "title", value.stripTags() + ", " + Ext.ux.getI18N('richtext.link.tooltip'));
//                             link.setAttributeNS(null, 'title', value.stripTags() + ", öffnen mit Strg+Klick.");   
//                             link.setAttributeNS(null, 'alt', value.stripTags() + ", öffnen mit Strg+Klick.");
                           } else {
                               // Create a new link
                               selection.removeAllRanges();
                               selection.addRange(range);
                               this.logCreateLinkCommand(value);
                           }
                           
                       }
                   }.bind(this)
            });
            
            prompt.getDialog().on("render", function() {
                this.el.dom.getElementsByTagName("input")[0].focus();
            });
//          if (prompt.getDialog().rendered) {
//              prompt.getDialog().el.dom.getElementsByTagName("input")[0].focus();
//          }
        },  
        
        logCreateLinkCommand: function(uriString) {
        	var uriString = uriString.stripTags();
        	
        	/*
        	 * Workaround for a Firefox bug (https://bugzilla.mozilla.org/show_bug.cgi?id=451142)
        	 * to prevent special characters (like Umlauts) from being encoded incorrectly.
        	 * 
        	 */
            if (Ext.isFF) {
            	uriString = encodeURIComponent(uriString);
            }
            
            this.logCmd("createlink", uriString, function() {
            	if (Ext.isFF) {
            		// Find the new link node and revert the href's URI-encoding.
            		
                    var links = Ext.DomQuery.select("a[href=" + uriString + "]", this.body);

            		links.each(function(linkNode) {
            			linkNode.setAttributeNS(null, "href", decodeURIComponent(uriString));
            		});
            	}
            	
                this.updateTitleOnLinks();
            }.bind(this));


        },
        
        removeLink: function() {
            var selection = this.getSelection();
            var range = this.getRange(selection);
            var link;
            
            if(this.isSingleCursorSelection(range)) {
                link = this.findLink(range.commonAncestorContainer);
                if (!link && // If the cursor is a the begining of an anchor
                        range.commonAncestorContainer.nodeType == 3 &&
                        range.commonAncestorContainer.textContent.length == range.endOffset &&
                        range.commonAncestorContainer.nextSibling){
                    link = this.findLink(range.commonAncestorContainer.nextSibling);
                }
            } 
            
            if(link) {
                this.selectBetween(link, link);             
            }
            
            this.logCmd('unlink');
        },
        
        findLink: function(l, r) {
            if(!r) {
                if(this.isLink(l)) {
                    return l;
                } else if(l.parentNode &&
                         !this.isBody(l.parentNode)) {
                    
                    return this.findLink(l.parentNode);
                }
                
                return null;
            }
            
            var leftLink = this.findLink(l);
            var rightLink = this.findLink(r);
            
            if(leftLink === rightLink) {
                return leftLink;
            }
            
            return null;
        },
        
        /**
         * Iterates over all links inside the body and adds a tooltip if none is set
         */
        updateTitleOnLinks : function() {
            var links = Ext.DomQuery.select("a:not([title])", this.body);
            links.each(function(link) {
                var title = link.href + ", " + Ext.ux.getI18N("richtext.link.tooltip");
                link.setAttribute("title", title);
            });
        },
        
        /**
         * Due to a misshapen implementation of the midas commands 'indent' and 'outdent' in Ext 2.0.2, a blockquote is generated
         * instead of a div with margin-left. Using the command styleWithCSS fixes the problem. Be careful to switch off the command
         * after using to prevent undefined behaviour of other commands. The command useCSS is deprecated.
         * [update] now it generates a <blockquote style="margin-left:40px"></blockquote> (or similar
         */
        indent : function() {
            !Ext.isIE && this.relayCmd("styleWithCSS", true);
            this.logCmd("indent");
            !Ext.isIE && this.relayCmd("styleWithCSS", false);
        },

        /*
         * IE hast not implemented a styleWithCSS, so they still insert blockquotes without any margin. 
         * Manually set the margin-left to any blockquote.
         */
        fixIEIndent : function () {
            $A(this.win.document.getElementsByTagName("blockquote")).each(function (block) {
                block.style.setProperty("margin-left", "40px");
                block.style.removeProperty("margin-right");
            })
        },
        
        /**
         * Due to a misshapen implementation of the midas commands 'indent' and 'outdent' in Ext 2.0.2, a blockquote is generated
         * instead of a div with margin-left. Using the command styleWithCSS fixes the problem. Be careful to switch off the command
         * after using to prevent undefined behaviour of other commands. The command useCSS is deprecated. 
         * [update] now it generates a <blockquote style="margin-left:40px"></blockquote> (or similar)
         */
        outdent : function() {
            // TODO: put the relay command stuff around this or adapt relayCommand
            !Ext.isIE && this.relayCmd("styleWithCSS", true);
            this.logCmd("outdent");
            !Ext.isIE && this.relayCmd("styleWithCSS", false);
        },

        /*
         * Outdenting blockquotes withing blockquotes woks well, but when outdenting a blockquote within a p element,
         * it will be removed and the margin-left will be applied to the p element. Remove it manually
         */
        fixIEOutdent : function () {
            $A(this.win.document.getElementsByTagName("p"))
                .each(function(p) {
                    if (p.style && p.style.getAttribute("margin-left")) {
                        p.style.removeAttribute("margin-left");
                    }
                })
        },
        
        /**
          * Displays a color picker menu to determine the color to set.
          * @param button
          */
         changeColor : function(colortype, button, event) {
             // delete any other previous opened color menu
             if (this.colorMenu) {
                 this.colorMenu.destroy();
                 delete this.colorMenu;
             }
             var defaultColor = (colortype === 'color' ? '#000000' : '#FFFFFF');
             
             // Get the div to display the automatic color picker
             var colorDiv = ("undefined" !== typeof ORYX&&ORYX.Editor||Signavio&&Signavio.Core).graft('http://www.w3.org/1999/xhtml', undefined, this.getColorBox(defaultColor));    
             
             // Define the color menu
             this.colorMenu = new Ext.menu.ColorMenu({
                 allowOtherMenus    : false,
                 focus              : Ext.emptyFn,
                 plain              : true,
                 allowReselect      : true,
                 scope              : this,
                 listeners          : {
                     'itemclick'    : function (item, event) {
                         var color = (item.component ? "#"+item.component.value : defaultColor);
                         this.forceSelection();
                         if (colortype === 'color') {
                             // Set the color of the hint box
                             if (this.fontColorHint) this.fontColorHint.style.background = 'none repeat scroll 0 0 ' + color;
                             // Apply the font color
                             this.logCmd('forecolor', color);
                             this.deferFocus();
                         } else if (Ext.isGecko) {
                             // Set the highlight color
                             this.logCmd('useCSS', false);
                             this.logCmd('hilitecolor', color);
                             this.logCmd('useCSS', true);
                             this.deferFocus();
                         } else {
                             // Set the highlight color
                             this.logCmd(Ext.isOpera ? 'hilitecolor' : 'backcolor', color);
                             this.deferFocus();
                         }
                     }.bind(this)
                 },
                 items              : [{
                     text       : Ext.ux.getI18N("richtext.colormenu.defaultcolor"),
                     listeners  : {
                         'render'   : function(btn, event) {
                             if (colorDiv) {
                                 btn.el.dom.appendChild(colorDiv);
                             }
                         }.bind(this)
                     }
                 }, '-']
             });
                 
             this.colorMenu.show(button.el, 'tl-bl?');
         },
        
         /**
          * Returns a div representing the default color
          * @param {String} color
          * @returns {Array} the raw Array to graft a new div container
          */
         getColorBox : function(color) {
             return ['div', {
                 'class'    : 'y-richtext-color-box',
                 style      : 'background: none repeat scroll 0 0' + color + ';'
             }];
         },
         
         /**
          * Returns a div container for the color hint
          * @returns {Array} the raw Array to graft a new div container
          */
         getColorHint : function() {
             
             var cls = Ext.isIPad ? 'y-richtext2-color-hint y-richtext2-color-hint-ipad' :
                        Ext.isFF3 ? 'y-richtext2-color-hint y-richtext2-color-hint-ff3' :
                        Ext.isFF ? 'y-richtext2-color-hint y-richtext2-color-hint-ff' :
                        Ext.isOpera ? 'y-richtext2-color-hint y-richtext2-color-hint-opera' :
                        Ext.isChrome ? 'y-richtext2-color-hint y-richtext2-color-hint-chrome' :
                        Ext.isIE ? 'y-richtext2-color-hint y-richtext2-color-hint-ie' :
                            'y-richtext2-color-hint';
             
             return ['div', {
                'class' : cls
             }];
         },
        
        getTextNodeAtPosition: function(node, offset){
            if (node && node.nodeType === 3){
                return node;
            }
            if (node && node.nodeType === 1){
                if (node.childNodes.length === 0){
                    return this.getTextNodeAtPosition(offset == -1 ? node.previousSibling : node.nextSibling, offset == -1 ? -1 : 0);
                } else {
                    return this.getTextNodeAtPosition(offset == -1 ? $A(node.childNodes).last() : node.childNodes[offset], offset == -1 ? -1 : 0);
                }
            }
            return null;
        },
        
        /**
         * Returns the next text node of the given node
         * 
         */
        getNextTextNode: function(node, root){
            var pnode = node, tnode;
            while(pnode && (pnode.nodeType != 1 || (pnode.tagName.toLowerCase() != "body" && (!root || pnode != root)))){
                if (tnode = this.getTextNodeAtPosition(pnode.nextSibling, 0)){
                    return tnode;
                }
                pnode = pnode.parentNode;
            }
            return null;
        },

        /**
         * Returns the previous text node of the given node
         * 
         */
        getPreviousTextNode: function(node, root){
            var pnode = node, tnode;
            while(pnode && (pnode.nodeType != 1 || (pnode.tagName.toLowerCase() != "body" && (!root || pnode != root)))){
                if (tnode = this.getTextNodeAtPosition(pnode.previousSibling, -1)){
                    return tnode;
                }
                pnode = pnode.parentNode;
            }
            return null;
        },
        
        forceSelection: function(){
            var selection = this.getSelection(),
                range = this.getRange(selection);
            
            
            if (selection && range && this.isSingleCursorSelection(range)){
                
                var set = function(node, offset){
                    var startOffset = offset, 
                        list = node.textContent.match(/([^a-zäöüß0-9]+|[a-zäöüß0-9]+)/ig);
                    
                    var word = list.find(function(text){
                        offset -= text.length;
                        return (offset < 0) || (offset === 0 && text.trim());
                    });
                    
                    if (word && word.replace(/[^a-zäöüß0-9]+/gi, "")){
                        
                        // Get the index of the word
                        var from = startOffset - word.length - offset,
                            to = startOffset - word.length - offset + word.length;
                        
                        // Set the selection to the word
                        range.setStart(node, from);
                        range.setEnd(node, to);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        return true;
                    }
                    return false;
                };

                var offset = range.endOffset,
                    node = this.getTextNodeAtPosition(range.endContainer, offset);
                
                if (!node || !set(node, offset)){
                    if (!node){
                        if (offset > 0){
                            node = this.getTextNodeAtPosition(range.endContainer.childNodes[offset-1], -1);
                        }
                    } else {
                        if (offset == 0){
                            node = this.getPreviousTextNode(node);
                        } else {
                            node = this.getNextTextNode(node);
                        }
                    }
                    if (node){
                        set(node, node.textContent.length);
                    }
                }               
            }

            
            
        },
         
        /**
         * Due to the fact that chrome will remove lists as it recognizes them
         * as style elements we block this behaviour and parse the range 
         * between l and r ourselves and remove all formatting while still
         * keeping the lists and paragraphs.
         * 
         * @param {DOMNode} l
         * @param {DOMNode} r
         */
        removeFormatAndPreserveLists: function(l, r) {
            if(!l || (l === r && !l.childNodes) ||
               r.nextSibling === l) {
                return;
            }
            
            var sibling = l.nextSibling;
            var firstChild = l.firstChild;  
            var lastChild = l.lastChild;
            
            if(this.isStyleElement(l)) {                
                this.removeContainer(l);
            }
            
            if(firstChild) {
                this.removeFormatAndPreserveLists(firstChild, lastChild);
                return this.removeFormatAndPreserveLists(sibling, r);
            }
                        
            return this.removeFormatAndPreserveLists(sibling, r);
        },
        
        /**
         * Removes a container node and moves all of 
         * its contents one level up in the dom. 
         * 
         * @param   container   The containing node
         * @param   appendBR    True to append a BR Element after all childNodes
         * 
         * @returns Object      Object containing the parent of the container
         *                      and all children in an Array
         */
        removeContainer: function(container, appendBR) {        
            var parent = container.parentNode;
            var br = this.doc.createElement('br');
            
            if(Ext.isGecko) {
                var selection = this.getSelection();
                var range = this.getRange(selection);
            
                var fragment = range.createContextualFragment(container.innerHTML);
                
                if(appendBR &&
                    !this.isBreak(fragment.lastChild) &&
                    !this.isBreak(container.nextSibling)) {
                    
                    fragment.appendChild(br);
                }
                
                parent.replaceChild(fragment, container);
                return {
                    parent: parent,
                    children: null
                };
            } else if(Ext.isSafari || Ext.isOpera || Ext.isIE9 || Ext.isIE10 || Ext.isIE11) {
                // the createContextualFragment command is only supported by Firefox
                // PLUS Opera will not fire an erorr because they implemented the method
                // but it only return nonsense              
                
                var children = $A(container.childNodes);                
                var newNodes = [];
                
                if(Ext.isOpera) {
                    var sel = this.getSelection();
                    sel.removeAllRanges();
                }
                
                if(appendBR &&
                    !this.isBreak(container.nextSibling) &&
                    !this.isBreak(container.lastChild) &&
                    !this.isBlockquote(container.lastChild)) {
                    
                    children.push(br);
                }
                
                children.reverse().each(function(child) {                   
                    newNodes.push(parent.insertBefore(child, container.nextSibling));
                }.bind(this));
                                                
                newNodes = $A(newNodes).reverse();
                                                
                parent.removeChild(container);  
                return {
                    parent: parent,
                    children: newNodes
                };
            }
        },  
        
        /**
         * Creates a selection around all children of a node
         * 
         * @param {DOMNode} node
         * @return {Selection}
         */
        selectAllChildren: function(node) {
            var selection = this.getSelection();
            
            if(Ext.isGecko || Ext.isSafari || Ext.isIE9 || Ext.isIE10 || Ext.isIE11) {
                selection.selectAllChildren(node);
            } else if(Ext.isOpera) {
                // Since Opera does not implement the Selection object correctly
                // we utilize some mashup between IE syntax and Opera stuff
                // to get a Selection
                
                if (document.selection && document.selection.createRange) {
                    var textRange = this.win.document.selection.createRange();
                    
                    textRange.moveToElementText(node);
                    textRange.select();
                } else if (window.getSelection) {
	                var range = this.getRange(selection);
                
                    range.setStartBefore(node.firstChild);
                    range.setEndAfter(node.lastChild);
                    
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            
            return selection;
        },
        
        getAncestor: function(selection, singleCursorSelection) {
            if(Ext.isGecko || Ext.isSafari || Ext.isOpera || Ext.isIE9 || Ext.isIE10 || Ext.isIE11) {
                
                var range = this.getRange(selection);
                
                if(singleCursorSelection) {
                    return this.findContainer(range.commonAncestorContainer);
                }               
                
                // if text is not formatted then the text node itself is the common
                // ancestor. to get the real parent, we have to look up the parent node
                // of the text node
                if(range.startContainer === range.endContainer && 
                   range.commonAncestorContainer === range.startContainer) {
                    
                    return range.commonAncestorContainer.parentNode;
                } else {
                    return range.commonAncestorContainer;
                }
            }
            
            return null;
        },
       
        findContainer: function(node) {
            if(this.isContainer(node) ||
               this.isBody(node)) {
                return node;
            }
            
            if(node.parentNode) {
                return this.findContainer(node.parentNode);
            }
            
            return null;
        },      
        
        allChildrenSelected: function(parent) {
            var selection = this.getSelection();
            
            if(selection.rangeCount === 0) {
                // nothing selected
                return false;
            }
            
            // if the selection range is longer than one
            // line headings must be removed even if they are not completely 
            // selected -> therefore we stop here and return true
            if(this.isMultiLineSelection(selection)) {
                return true;
            }
            
            if(Ext.isGecko || Ext.isSafari || Ext.isOpera || Ext.isIE9 || Ext.isIE10 || Ext.isIE11) {
                $A(parent.childNodes).each(function(child) {
                    if(!selection.containsNode(child, false)) {
                        return false;
                    }                   
                });
                
                
                var range = this.getRange(selection);
            
                var textLength = range.commonAncestorContainer.textContent.length;
                var rangeLength = range.cloneContents().textContent.length;
                                                
                // |-------RANGE-------|
                // |___|  |_____|  |___|
                // all snippets are not the complete text range
                // thus the container will not be removed                   
                if(!(range.startOffset === 0 && textLength === rangeLength)) {
                    return false;
                }
            }
            
            return true;
        },
        
        getContainers: function() {
            
            // Collect all possible container tags
            var h1 = $A(this.win.document.getElementsByTagName("h1"));
            var h2 = $A(this.win.document.getElementsByTagName("h2"));
            var h3 = $A(this.win.document.getElementsByTagName("h3"));          
            
            var font = $A(this.win.document.getElementsByTagName("font"));
            
            var blockQuotes = $A(this.win.document.getElementsByTagName("blockquote"));
            
            var containers = h1.concat(h2, h3, font, blockQuotes);
            
            return containers;
        },   
                
        selectBetween: function(l,r, excludeLeft, excludeRight) {
            if(Ext.isOpera) {
                return this.selectBetweenOpera(l, r, excludeLeft, excludeRight);
            }
            
            if(Ext.isSafari){
                return this.selectBetweenSafari(l, r, excludeLeft, excludeRight);
            }
            
            var selection = this.getSelection();
            var range = this.getRange(selection);
                        
            if(l === r) {
                range.selectNodeContents(l);
            } else {            
                if(excludeLeft) {                   
                    range.setStart(l,0);
                } else {
                    range.setStart(l,0);
                }
                
                var length = 0;
                
                if(this.isTextNode(r)) {
                    length = r.textContent.length;
                } else {
                    length = $A(r.childNodes).length;
                }
                
                if(excludeRight) {
                    range.setEnd(r,0);
                } else {
                    range.setEnd(r,length);                 
                }
            }
            
            selection.removeAllRanges();
            selection.addRange(range);
            
            return {
                selection: selection,
                range: this.getRange(selection)
            };
        },
        
        selectBetweenSafari: function(l, r, excludeLeft, excludeRight){

            var selection = this.getSelection();
            var range = this.getRange(selection);
            
            if(l === r) {
                range.selectNodeContents(l);
            } else {            
                if (excludeLeft){
                    range.setStartAfter(l);
                } else {
                    range.setStartBefore(l);
                }
                if (excludeRight){
                    range.setEndBefore(r);
                } else {
                    range.setEndAfter(r);
                }
            }
            
            selection.removeAllRanges();
            selection.addRange(range);
            
            return {
                selection: selection,
                range: this.getRange(selection)
            };
            
        },
        
        selectBetweenOpera: function(l, r, excludeLeft, excludeRight) {
            var selection = this.getSelection();
            var range = this.getRange(selection);
                    
            if(!l.parentNode || !r.parentNode) {
                // opera sometimes does not update references to nodes
                // in this case it replaces them with textNodes without
                // parent or siblings
                // --> we need to stop here in order to avoid errors
                return {
                    selection: selection,
                    range: range
                };
            }           
                        
            if(excludeLeft || !l.previousSibling || 
                (l.previousSibling && this.isBlockingElement(l.previousSibling))) {
                
                range.setStart(l,0);
            } else {
                range.setStartBefore(l);
            }
            
            var length = 0;
            
            if(this.isTextNode(r)) {
                length = r.textContent.length;
            } else {
                length = $A(r.childNodes).length;
            }
                        
            if(excludeRight) {
                range.setEnd(r,length);
            } else {
                if(!r.nextSibling || 
                   this.isBlockingElement(r.nextSibling) ||
                        (r.nextSibling && r.nextSibling.textContent.blank())) {
                    
                    // otherwise Opera would create a _NEW_ empty
                    // Text object that messes up everything            
                    range.setEnd(r, length);
                } else {
                    range.setEndAfter(r);
                }
            }           
            
            selection.removeAllRanges();
            selection.addRange(range);
            
            return {
                selection: selection,
                range: this.getRange(selection)
            };
        },
        
        /**
         * Handle clicks on the heading buttons.
         * @param {Integer} size The desired size of the heading
         */
        toggleHeading: function(size) {
            var selection = this.getSelection();
            var range = this.getRange(selection);
            
            var ancestor = this.getAncestor(selection, this.isSingleCursorSelection(range));
            
            // searches the DOM upwards
            var heading = this.searchHeading(ancestor);
            
            if(heading) { 
                var node = this.removeContainer(heading, true);             
                
                if(node.children) {
                    // this is kind of a browser switch
                    // the nodes array will only be filled if the client
                    // browses with chrome or opera
                    //
                    // in these browser we need to restore the selection 
                    // after we deleted the old container
                    selection = this.selectBetween(node.children.first(), node.children.last());
                }
                
                // switched to another size for the heading with the 
                // current heading selected
                if(heading.nodeName.toLowerCase() !== 'h' + size) {
                    this.relayCmd('removeformat');
                    this.createHeading(size, selection);
                }
            } else {
                this.relayCmd('removeformat');
                this.createHeading(size, selection);
            }            
        },
        
        toggleCodeBlock: function(size) {
            var selection = this.getSelection();
            var range = this.getRange(selection);
            
            var ancestor = this.getAncestor(selection, this.isSingleCursorSelection(range));
            
            // searches the DOM upwards
            var codeBlock = this.searchCodeBlock(ancestor);
            
            if(codeBlock) { 
                var node = this.removeContainer(codeBlock, true);               
                
                if(node.children) {
                    // this is kind of a browser switch
                    // the nodes array will only be filled if the client
                    // browses with chrome or opera
                    //
                    // in these browser we need to restore the selection 
                    // after we deleted the old container
                    selection = this.selectBetween(node.children.first(), node.children.last());
                }
            } else {
                this.createCodeBlock(selection);
            }            
        },
        
        createCodeBlock : function(selection) {
            if (selection && selection.selection && selection.range) {
                var range = selection.range;
                selection = selection.selection;
            } else {
                var range;
            }
            
            this.logCmd("formatblock", "BLOCKQUOTE");
            this.updateToolbar();
        },
        
        /**
         * Creates a new Heading from a selected text fragment
         * @param {Number} size The desired size of the heading
         * @param {Object} selection The selection
         * @param {Boolean} modifying
         * @param bounds
         */
        createHeading: function(size, selection, modifying, bounds) {
            if (selection && selection.selection && selection.range) {
                var range = selection.range;
                selection = selection.selection;
            } else {
                var range;
            }
            
            if (!size) { return;}
            
            // If browser is firefox
            if(Ext.isGecko) {
                this.logCmd('heading', '<h' + size + '>');
            } else {
                if (!selection) {
                    /*
                     * To get the right selection, we have to ensure
                     * that the window has focus
                     */
                    this.win.focus();
                    selection = this.getSelection(); 
                }
                
                // Get the range
                range = this.getRange(selection);

                var commonAncestor = range.commonAncestorContainer;

                if(!bounds) {
                    if(!this.isSingleCursorSelection(range)) {
                        var start = range.startContainer, end = range.endContainer;
                        if (start.nodeType == 1 && start.childNodes[Math.max(range.startOffset-1, 0)]){
                            start = start.childNodes[Math.max(range.startOffset-1, 0)];
                        }
                        var bounds = this.findHighestSiblings(start, start);                        
                    } else {
                        if (commonAncestor.nodeType == 1 && commonAncestor.childNodes[Math.max(range.startOffset-1, 0)]){
                            commonAncestor = commonAncestor.childNodes[Math.max(range.startOffset-1, 0)];
                        }
                        var bounds = {
                            left    : commonAncestor,
                            right   : commonAncestor
                        };
                    }
                    
                    // the current bounds only referr to the selected elements
                    // the paragraph itself might have its bounds in a higher
                    // node of the dom tree
                    bounds = this.computeHighestBounds(bounds);                 
                }                   
                                    
                var container = bounds.left.parentNode;
                
                // remove all headings that currently exist inside the selection
                this.removeHeadings(bounds.left, bounds.right, bounds);
                
                // search for headings in higher nodes
                // if the contents are already surrounded with a h-tag
                // the existing h-tag will be replaced with the one
                // chosen now
                var heading = this.searchHeading(container);
                // The new heading
                var h = this.doc.createElement('h' + size);                 
                
                if(heading) {                       
                    if(!modifying) {
                        // this is a standard call from the ui
                        this.selectAllChildren(heading);                            
                        
                        // Replace the old heading with the new one
                        heading.parentNode.replaceChild(h, heading);
                        // Append the old contents
                        h.appendChild(range.extractContents());
                    } else {
                        // some routine is calling
                        this.removeContainer(heading);                          
                        this.appendHeading(h, size, bounds);
                    }                       
                } else if(!this.isNotEditable(container)){
                    if(this.isList(container)) {
                        this.transformListElements(container.childNodes, size, false, bounds.left, bounds.right);
                    } else {      
                        this.appendHeading(h, size, bounds);
                    }
                }
            
                if(!bounds.right.namespaceURI || !bounds.left.namespaceURI) {
                    // wrong reference outside the document
                    // -> get some selection to collapse
                    // TODO: this can be done better
                    selection.selection = this.getSelection();
                } else {
                    selection = this.selectBetween(bounds.left, bounds.right);
                }
                
                // to get the same look and feel and due to a bug in
                // opera where the new selection would contain a false
                // text node after the heading the selection is collapsed
                // to the end.
                //
                // now switching between headings is also enabled due
                // to the possibility of singleCursorSelection.
                selection.selection.collapseToEnd();
                
                this.win.focus();
            }
            this.updateToolbar();
        },
        
        /**
         * This method will create a new heading around a selection
         * of the size bounds.left -> bounds.right. All elements
         * that are falsely turned into heading elements will be
         * restored.
         * 
         * @param {DOMNode} h The new heading element
         * @param {Integer} size The size of the new heading
         * @param {Object} bounds The bounds of the selection
         */
        appendHeading: function(h, size, bounds) {
            this.selectBetween(bounds.left, bounds.right);                  
            
            this.surroundContents(h, Object.clone(bounds));                                                     
            this.removeFalseBR(h);
            this.removeEmptyLists(h);

            // sometimes text is placed in div-tags to emulate br
            // but divs in h-tags tell the editor to continue in h
            // even after the user has pushed enter
            // --> we remove the div-tags and replace them with br
            // this preserves the layout and does not influence the
            // editing
            this.selectAllChildren(h);
            this.removeDirt(h, true);           
            
            // we might have surrounded list items with the h tag
            this.restoreBlockElements(h, size, h.firstChild, h.lastChild);
            //this.restoreLists(h, size, h.firstChild, h.lastChild);
            //this.restoreParagraphs(h, size, h.firstChild, h.lastChild);
        },
        
        /**
         * Surround all elements that live between bounds.left and
         * bounds.right with a new container.
         * 
         * @param   {DOMNode}    container  The container to surround the elements
         * @param   {Object}     bounds     Left and right border
         */
        surroundContents: function(container, bounds) {
            var nextSibling = bounds.right.nextSibling;
            var parent = bounds.left.parentNode;
            
            var left = bounds.left, right;
            
            while(left && left !== nextSibling) {
                if(left) {                                      
                    var sibling = left.nextSibling;
                    
                    container.appendChild(left);                
                    
                    left = sibling;                 
                }
            }
                        
            if(nextSibling) {
                parent.insertBefore(container, nextSibling);
            } else {
                parent.appendChild(container);
                
                // fixing bounds object
                if(left === bounds.right) {
                    bounds.left = bounds.right = container;
                }
            }           
        },
        
        /**
        * when contents are extracted from a 
        * list it might occur that an empty list object
        * remains after the h tag. this object is
        * now being removed.
        * 
        * @param    {DOMNode}    node   The H Element
        **/
        removeEmptyLists: function(node) {
            if(node.nextSibling && this.isList(node.nextSibling)) {
                if(this.isEmpty(node.nextSibling)) {
                    node.parentNode.removeChild(node.nextSibling);
                }
            }
        },
        
        /**
         * Restores block elements e.g. text nodes.
         * @param container The parent container
         * @param size The size of a heading to create
         * @param leftBounds the left boundaries
         * @param rightBounds the right boundaries
         */
        restoreBlockElements: function(container, size, leftBounds, rightBounds) {
            var foundBlock = false;
            var children = $A(container.childNodes);
            var parent = container.parentNode;
            
            children.each(function(child) {
                if(!foundBlock && (this.isBlockquote(child) || this.isList(child) || this.isHorizontalRule(child))) {
                    foundBlock = true;
                    var selection;
                    
                    // change h tag to close before block
                    if(children.indexOf(leftBounds) < children.indexOf(child)) {
                        var modLeft = true;
                        
                        selection = this.selectBetween(leftBounds, child.previousSibling, false, true);
                        
                        if(!this.isSingleCursorSelection(selection.range)) {
                            // maybe an empty text node has been selected. this would result
                            // in singleCursorSelection and thus the createheading method
                            // would seaech for new boundaries. These new boundaries would
                            // then include nodes that are not intended to be turned into 
                            // headings
                            this.createHeading(size, selection, true, {
                                left: leftBounds,
                                right: child.previousSibling
                            });
                        }
                    }
                    
                    // change h tag to start after list
                    if(children.indexOf(rightBounds) > children.indexOf(child)) {
                        var modRight = true;
                        
                        selection = this.selectBetween(child.nextSibling, rightBounds, true, false);
                        
                        if(!this.isSingleCursorSelection(selection.range)) {
                            // for explanation see above
                            this.createHeading(size, selection, true, {
                                left: child.nextSibling,
                                right: rightBounds
                            });
                        }
                    }
                    
                    if(modRight || modLeft) {
                        if(this.isList(child)) {
                            // now transform all list elements
                            this.transformListElements(child.childNodes, size, true);
                        } else if(this.isBlockquote(child)) {
                            // blockquotes can also contain regular text PLUS
                            // other blockquotes, though we parse them
                            selection = this.selectBetween(child, child);
                            
                            if(!this.isSingleCursorSelection(selection.range)) {
                                this.transformBlockElements(child.childNodes, size, true);
                            }
                        } 
                    }
                }
            }.bind(this));
        },
        
        /**
         * This searches for the highest dimensions of a heading.
         * It stops when the body is reached or if there a tags that
         * block a heading such as br, div or other headings.
         * 
         * @param   {Object}    bounds      Object containing the current left
         *                                  and right boundaries.
         * 
         * @return  {Object}                And object with the highest dimenstions
         */
        computeHighestBounds: function(bounds) {
            var leftBoundary = this.findBoundary(bounds.left, 'left');
            var rightBoundary = this.findBoundary(bounds.right, 'right');
            
            if(!leftBoundary.previousSibling && 
               !rightBoundary.nextSibling && 
               !(this.isNotEditable(leftBoundary) || this.isNotEditable(rightBoundary)) &&
               !this.isBlockingElement(leftBoundary.parentNode) && 
               !this.isBlockingElement(leftBoundary) &&
               !this.isBlockingElement(rightBoundary) &&
               !this.isBody(leftBoundary.parentNode) &&
               !this.isBody(leftBoundary) &&
               !this.isBody(rightBoundary)) {
                
                return this.computeHighestBounds({
                    left: leftBoundary.parentNode,
                    right: leftBoundary.parentNode
                });
            }           
            
            return {
                left: leftBoundary,
                right: rightBoundary
            };
        },
        
        /**
         * Removes div and p elements inside an Element.
         * This is useful to prevent breaklines in an
         * h element for example.
         * 
         * @param   {DOMNode}    el         The element the will be looked through
         * @param   {Boolean}    forceBR    whether a br tag shall be included after
         *                                  the end of the old node
         */
        removeDirt: function(el, forceBR) {
            $A(el.childNodes).each(function(node) {
                if(node.childNodes) {                       
                    this.removeDirt(node);                  
                }
                
                if(this.isDirt(node)) {                 
                    this.removeContainer(node, forceBR);
                }
            }.bind(this));
        },
        
        /**
         * Looks up blockquote elements and turns their contents into 
         * headings of the specified size
         * 
         * @param   {NodeList}   nodes          NodeList of nodes to look up
         * @param   {Integer}    size           Size of the heading that will be created
         * @param   {Boolean}    force          I have no idea
         * @param   {DOMNode}    leftBoundary   OPTIONAL: possible starting point in NodeList
         * @param   {DOMNode}    rightBoundary  OPTIONAL: possible end point in NodeList
         */
        transformBlockElements: function(nodes, size, force, leftBoundary, rightBoundary) {
            var nodes = $A(nodes);
            
            nodes.each(function(node) {
                if((nodes.indexOf(node) < nodes.indexOf(leftBoundary) || 
                   nodes.indexOf(node) > nodes.indexOf(rightBoundary)) && 
                   !force){
                    
                    return;
                }
                
                if(this.isBlockquote(node)) {
                    this.transformBlockElements(node.childNodes || [], size, true);
                } else {                    
                    var h = this.doc.createElement('h' + size);
                    
                    this.appendHeading(h, size, {
                        left: node,
                        right: node
                    });             
                }
            }.bind(this));
        },
        
        /**
         * Transforms the content of list-items into heading elements
         * of the specified size.
         * 
         * @param   {NodeList}   nodes          NodeList of nodes to look up
         * @param   {Integer}    size           Size of the heading that will be created
         * @param   {Boolean}    force          No idea...
         * @param   {DOMNode}    leftBoundary   OPTIONAL: possible starting point in NodeList
         * @param   {DOMNode}    rightBoundary  OPTIONAL: possible end point in NodeList
         */
        transformListElements: function(nodes, size, force, leftBoundary, rightBoundary) {
            var nodes = $A(nodes);
            
            nodes.each(function(node) {
                if((nodes.indexOf(node) < nodes.indexOf(leftBoundary) || 
                   nodes.indexOf(node) > nodes.indexOf(rightBoundary)) && 
                   !force){
                    
                    return;
                }
                
                if(this.isList(node)) {
                    this.transformListElements(node.childNodes || [], elementName, true);
                } else {                    
                    var h = this.doc.createElement('h' + size)
                    
                    this.surroundContents(h, {
                        left: node.firstChild,
                        right: node.lastChild
                    });             
                                
                }
            }.bind(this));
        },    
        
        /**
         * When creating headings existing br elements that follow
         * the h element have to be removed because a h tag itself 
         * forces a linebreak. 
         * 
         * The other use case is that empty Elements that are created
         * by opera will be removed because they would destroy the
         * layout
         * 
         * @param   {DOMNode}    el     The Element to look though
         */
        removeFalseBR: function(el) {
            if(Ext.isOpera) {
                // opera adds some empty non-standard text
                // objects after the newly created h element
                // these force line-breaks that change the layout
                // thus we remove them
                if(el.nextSibling && el.nextSibling.textContent.blank()) {                  
                    el.parentNode.removeChild(el.nextSibling);
                }
            } 
            
            // A H Element forces a newline and thus an existing BR
            // has to be removed            
            if(this.isHeading(el)) {
                if(this.isBreak(el.nextSibling)) {
                    el.parentNode.removeChild(el.nextSibling);
                } else if(this.isBreak(el.lastChild)) {
                    el.removeChild(el.lastChild);
                }
                
                // move all other BRs to the outside of the H
                // Element
                this.moveBR(el);
            }           
        },
        
        /**
         * Moves all br elements at the end and at the end of an element
         * outside the element.
         * 
         * @param   {DOMNode}    el     The element to look through
         */
        moveBR: function(el) {
            while(this.isBreak(el.firstChild)) {
                el.parentNode.insertBefore(el.firstChild, el);
            }
            
            while(this.isBreak(el.lastChild)) {             
                if(el.nextSibling) {
                    el.parentNode.insertBefore(el.lastChild, el.nextSibling);
                } else {
                    el.parentNode.appendChild(el.lastChild);
                }
            }
        },
        
        searchCodeBlock : function(node) {
            if (this.isCodeBlock(node)) {
                return node;
            }
            
            if (!node) return null;
            
            if (node.parentNode && !this.isBody(node)) {
                return this.searchCodeBlock(node.parentNode);
            }
            
            return null;
        },
        
        /**
         * Searches for headings in all higher dom nodes of node.
         * 
         * @param   {DOMNode}    node   Starting point of the search
         * 
         * @return  {DOMNode}           A h element if one was found, null otherwise
         */
        searchHeading: function(node) {     
            if(this.isHeading(node)) {
                return node;
            }
            
            if (!node) {
                return null;
            }
            
            
            if(node.parentNode && !this.isBody(node)) {
                return this.searchHeading(node.parentNode);
            }       
            
            return null;
        },
        
        /**
         * Looks for the outermost non-blocking element on the same
         * dom level as start. 
         * 
         * @param   {DOMNode}   start       The node to start the search
         * @param   {String}    direction   Direction of the search
         */
        findBoundary: function(start, direction) {
            if(direction === 'left') {
                var sibling = start.previousSibling;                
            } else {
                var sibling = start.nextSibling;
            }
            
            if(sibling) {               
                if(this.isBlockingElement(start) || this.isBlockingElement(sibling)) {
                    return start;
                } else {
                    return this.findBoundary(sibling, direction);
                }
            }

            return start;
        },
           
        /**
         * Removes all h elements between the borders l and r.
         * 
         * @param   {DOMNode}   l       Left border
         * @param   {DOMNode}   r       Right border
         * @param   {Object}    bounds  OPTIONAL: bounds object that will be updated
         * @param   {Boolean}   jump    PRIVATE: Is used to indicate that the next node
         *                              of the higher level shall be looked up. You should not 
         *                              set this by yourself.
         * 
         * @return  {Boolean}           true if r has been reached, false otherwise
         */
        removeHeadings: function(l, r, bounds, jump) {
            if(!l || (l === r && !l.firstChild) ||
                r.nextSibling === l) {
                // while parsing containers it is possible
                // that l runs over r. the last condition
                // checks for that and prevents further removal
                // of headings
                return true;
            }
            
            var sibling = l.nextSibling;
            var parent = l.parentNode;
            var contained = this.contains(l, r);
            var isBody = this.isBody(parent);
            var stop = false;
            
            if(this.isHeading(l)) {
                if(bounds) {
                    // if the bounds start or end in a heading
                    // and we then remove these headings we render
                    // the bounds object useless, thus we have to 
                    // update the references to the first/last child 
                    // of the heading because these are the new 
                    // outermost elements after the heading is removed
                    // from the dom
                    if(l !== r && bounds.left === l) {
                        bounds.left = l.firstChild;
                    } else if(l === r && bounds.right === r) {
                        bounds.right = r.lastChild;
                    }
                }
                
                this.removeContainer(l, !this.isListItem(parent));
            } else if(l.firstChild && !jump) {
                stop = this.removeHeadings(l.firstChild, r, bounds, false);
                
                if(stop || contained) {
                    return true;
                }
                
                return this.removeHeadings(sibling, r, bounds, false);
            } 
            
            if(contained) {
                return true;
            }
            
            if(!sibling && !isBody) {
                return this.removeHeadings(parent, r, bounds, true);
            }

            return this.removeHeadings(sibling, r, bounds, false);

        },
        
        /**
         * Checks if one Element is contained in another one.
         * 
         * @param   {DOMNode}    container  The element that might contain the other
         * @param   {DOMNode}    el         The possibly contained element
         * 
         * @return  {Boolean}               true if the element is contained,
         *                                  false otherwise
         */
        contains: function(container, el) {
            if(container === el) {
                return true;
            }
            
            var children = $A(container.childNodes);            
            
            if(children.indexOf(el) !== -1) {
                return true;
            }
            
            var isChild = false;
            
            children.each(function(child) {
                if(isChild) {
                    return;
                }
                
                isChild = this.contains(child, el);             
            }.bind(this));
            
            return isChild;
        },
            
        /**
         * Calculates the depth of an element inside the dom tree.
         * 
         * @param   {DOMNode}    node   The node inside the tree
         * @param   {Integer}    count  PRIVATE: This stores the depth
         * 
         * @return  {Integer}           The depth as an integer
         */
        getDepth: function(node, count) {
            if(node.parentNode) {
                return this.getDepth(node.parentNode, (count || 0) + 1);
            }
            
            return count || 0;
        },
        
        /**
         * Finds the highest parents of two nodes in the dom tree that
         * are siblings.
         * 
         * @param   {DOMNode}    start  
         * @param   {DOMNode}    end
         * @param   {Integer}    depthStart PRIVATE: used inside the method, do not set
         * @param   {Integer}    depthEnd   PRIVATE: used inside the method, do not set
         * 
         * @return  {Object}                An object containing the ancestors of the nodes
         *                                  that are also divided into left and right.
         */
        findHighestSiblings: function(start, end, depthStart, depthEnd) {           
            
            // first we need to check which node is deeper in the tree              
            if(!depthStart) {
                depthStart = this.getDepth(start);
            }
            
            if(!depthEnd) {
                depthEnd = this.getDepth(end);
            }
            
            if(depthStart > depthEnd && start.parentNode) {
                // start is deeper in the tree
                // -> we check whether the parent of start has the same depth as end
                return this.findHighestSiblings(start.parentNode, end, undefined, depthEnd);
            } else if (depthStart < depthEnd && end.parentNode) {
                // end is deeper in the tree
                // -> we check whether the parent of end has the same depth as start
                return this.findHighestSiblings(start, end.parentNode, depthStart);
            } else {        
                // both nodes have the same depth but are wrapped in containers
                if(start.parentNode && end.parentNode && 
                   start.parentNode !== end.parentNode) {               
                    
                    var gpStart = start.parentNode.parentNode;
                    var children = $A(gpStart.childNodes);
                    
                    if(gpStart) {
                        if(children.indexOf(end.parentNode) === -1) {
                            // the wrapping can be multilevel
                            return this.findHighestSiblings(start.parentNode, end.parentNode, depthStart, depthEnd);
                        }                   
                        
                        // now we have the same parent and determine which of the elements 
                        // is the left and which is the right one
                        // we need this for the previousSibling-/ nextSibling-search
                        if(children.indexOf(start.parentNode) < children.indexOf(end.parentNode)) {                     
                            return {
                                left: start.parentNode,
                                right: end.parentNode
                            };
                        } else {
                            return {
                                left: end.parentNode,
                                right: start.parentNode
                            };
                        }
                    }                   
                }
                
                var sParent = start.parentNode;     
                var children = $A(sParent.childNodes);
                
                if(children.indexOf(start) < children.indexOf(end)) {
                    return {
                        left: start,
                        right: end
                    };
                } else {
                    return {
                        left: end,
                        right: start
                    };
                }
            }
        },      
        
        createFontSizeOptions: function() {
            var buf = [];
            
             this.defaultFontSizes.each(function(fs) {
                 buf.push(
                    '<option value="' + fs[0] + 'pt" ',
                        (this.defaultFontSize === fs[0] ? 'selected="true">' : '>'),
                        fs[1],
                    '</option>');
             }.bind(this));
             
             return buf.join('');
        },
        
        getSelection: function() {
            // Mozilla
            if (this.win.getSelection) {
                return this.win.getSelection();
            }
            
            // Safari + Chrome
            if (this.win && this.win.document && this.win.document.getSelection) {
                return this.win.document.getSelection();
            } 
            
            // IE
            if (this.win && this.win.document && this.win.document.selection) {
                return this.win.document.selection;//.createRange().text;
            }
        },
        
        isHeading: function(node) {
            return node ? ['h1', 'h2', 'h3'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
        },
        
        isCodeBlock: function(node) {
            return node ? ['blockquote'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
        },
        
        isList: function(node) {
            return node ? ['ul', 'ol'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
        },
        
        isLink: function(node) {
            return node ? node.nodeName.toLowerCase() === 'a' : false;
        },
        
        isBody: function(node) {
            return node ? node.nodeName.toLowerCase() ===  'body' : false;
        },
        
        isBreak: function(node) {
            return node ? node.nodeName.toLowerCase() === 'br' : false;
        },
        
        isBlockingElement: function(node) {
            return node ? ['ul', 'ol', 'li', 'h1', 'h2', 'h3', 'div', 'br', 'p', 'blockquote'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
        },
        
        isListItem: function(node) {
            return node ? node.nodeName.toLowerCase() === 'li' : false;
        },
        
        isTextNode: function(node) {
            return node ? node.nodeType === 3 : false;
        },
        
        isStyleElement: function(node) {
            return node ? ['b', 'i', 'u', 'font', 'span'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
        },
        
        isNotEditable: function(node) {
            return node ? ['head', 'html'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
        },
        
        isDirt: function(node) {
            return node ? ['div', 'p'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
        },
        
        isBlockquote: function(node) {
            return node ? ['blockquote'].indexOf(node.nodeName.toLowerCase()) !== -1 : false;
        },
        
        isHorizontalRule: function(node) {
            return node ? node.nodeName.toLowerCase() === 'hr' : false;  
        },
        
        isContainer: function(node) {
            var containers = this.getContainers()
            
            if(containers.indexOf(node) === -1) {
                return false;
            }
            
            return true;
        },
        
        /**
         * Checks whether a selection is collapsed or
         * not. Normally this is also possible via the
         * _collapsed_ attribute of the Selection object. 
         * But this seems to be not implemented corretly 
         * in all browsers.
         * 
         * @param   {Range}    range    The Range object of a selection
         * @returns {Boolean}           True if the selection is collapsed,
         *                              false otherwise
         */
        isSingleCursorSelection: function(range) {
            var selection = this.getSelection();
            
            return range && selection 
                    && selection.rangeCount == 1
                    && selection.toString().length == 0
                    && range.startContainer === range.endContainer
                    && range.startOffset === range.endOffset;
            
        },
        
        isMultiLineSelection: function(selection) {
            var ancestor = this.getAncestor(selection);
            var blockingCount = 0;          
            
            $A(ancestor.childNodes).each(function(node) {
                if(this.isBlockingElement(node)) {
                    blockingCount++;                    
                }
            }.bind(this));
            
            if(blockingCount > 1) {
                return true;
            }
            
            return false;
        },
        
        /**
         * Checks whether a given list contains no content. 
         * This is useful because sometimes empty lists remain
         * after an heading has been created. 
         * 
         * @param   {DOMNode}    list   List-Element (OL/ UL)
         * @return  {Boolean}           True if the list is empty, false otherwise  
         */
        isEmpty: function(list) {
            var isEmpty = true;
            
            $A(list.childNodes).each(function(li) {
                if(this.isList(li)) {
                    isEmpty = this.isEmpty(li);
                }
                
                // only continue if the list is still empty
                if (isEmtpy) {
                    if (li.childNodes) {
                        $A(li.childNodes).each(function(child) {
                            if (this.isHeading(child) ||
                            !child.textContent.blank()) {
                            
                                isEmpty = false;
                            }
                        }.bind(this));
                    }
                }
            }.bind(this));
            
            return isEmpty;
        },
        
        /**
         * 
         * @overwrite
         * @param text
         * @returns {boolean} : functionality supported
         */
        insertAtCursor : function(text){
            if(!this.activated){
                return true;
            }
            if(Ext.isIE8){
                this.win.focus();
                var r = this.getRange();
                if(r){
                    r.collapse(true);
                    r.pasteHTML(text);
                    this.syncValue();
                    this.deferFocus();
                }
            }else if (Ext.isIE) {
                return false;
            }else if(Ext.isGecko || Ext.isOpera){
                this.win.focus();
                this.execCmd('InsertHTML', text);
                this.deferFocus();
            }else if(Ext.isSafari){
                this.execCmd('InsertHTML', text);
                this.deferFocus();
            }
            return true;
        }
    });  
    
    // Create an Richtext Textarea
    Ext.ux.form.RichTextArea = function() {
        Ext.ux.form.RichTextArea.superclass.constructor.apply(this, arguments);
    };
    
    Ext.extend(Ext.ux.form.RichTextArea, Ext.form.TextArea);
    Ext.extend(Ext.ux.form.RichTextArea, Ext.ux.form.RichtextEditor, {
        onRender: function() {
            Ext.ux.form.RichTextArea.superclass.onRender.apply(this, arguments);
            
            this.wrap.setStyle({
                marginLeft: this.x + "px",
                marginTop: this.y + "px"
            });
        }
    });  
    
    // Create and Richtext Glossary Field
    Ext.ux.form.RichtextGlossary = function() {
        Ext.ux.form.RichtextGlossary.superclass.constructor.apply(this, arguments);
    };    
    
    Ext.extend(Ext.ux.form.RichtextGlossary, Ext.ux.form.GlossaryField);
    Ext.extend(Ext.ux.form.RichtextGlossary, Ext.ux.form.RichtextEditor);
  
        
    /**
     * Command object for the RichtextEditor
     * @class
     * 
     * @param {Object} context
     * @param {Object} conf
     */
    Ext.ux.Command = function(context, conf) {
        this.context = context;
        this.body = this.context.body;
        this.oldHTML = conf.oldHTML;
        this.oldBreadcrump = conf.oldBreadcrump;
        this.oldOffset = conf.oldOffset;
        this.newHTML = conf.newHTML;
        this.newBreadcrump = conf.newBreadcrump;
        this.newOffset = conf.newOffset;
                
        var moveCursor = function(breadcrump, offset) {
            var start = this.body;
            
            breadcrump.each(function(index) {
                start = start.childNodes[index] || start;
            });
            
            // Get the selection
            var selection = this.context.getSelection();
            var range = this.context.getRange(selection);

            if (!range) {return;}
            
            selection.removeAllRanges();
            selection.addRange(range);   
            // If the current 'start' node is not a text node, collapse to 0
            selection.collapse(start, Math.min(start.length || 0, offset));
        };
        
        this.execute = function() {
            if (this.body.innerHTML === this.newHTML) return;
            
            this.body.innerHTML = this.newHTML;
            
            // TODO
            // Vom Command aus die Umgebung beeinflussen ist irgendwie
            // nich wirklich schön gelöst. Vllt kann man das noch gut 
            // refactoren. 
            this.context.oldHTML = this.newHTML;
            this.context.oldOffset = this.newOffset;
            this.context.oldBreadcrump = this.newBreadcrump;
            
            moveCursor.call(this, this.newBreadcrump, this.newOffset);                  
        };
        
        this.rollback = function() {
            if (this.body.innerHTML === this.oldHTML) return;
            
            this.body.innerHTML = this.oldHTML;
            
            this.context.oldHTML = this.oldHTML;
            this.context.oldOffset = this.oldOffset;
            this.context.oldBreadcrump = this.oldBreadcrump;
                        
            moveCursor.call(this, this.oldBreadcrump, this.oldOffset);
        };                
    };

    // TODO: into Extensions with you
    Ext.form.RadioInputField = function (conf) {
        if (conf.label !== undefined) {
            this.label = conf.label;
        }

        this.radioButton = new Ext.form.Radio({
            cls             : "at-radio-input-field-radio",
            hideLabel       : true,
            name            : conf.name,
            checked         : conf.value || false,
            listeners: {
                check: this.onCheckChanged.bind(this)
            }
        });
        var inputFieldConfig = {
            cls: "at-radio-input-field-input" + (Ext.isIE ? ' x-ie' : ''),
            hideLabel: true,
            value: conf.text || ""
        }
        switch (conf.type) {
            case "number":
                this.inputField = new Ext.form.NumberField(inputFieldConfig);
                break;
            default:
                this.inputField = new Ext.form.TextField(inputFieldConfig);
        }
        this.labelField = new Ext.form.Label ({
            cls         : "at-radio-input-field-label",
            text        : conf.label || "",
            xtype       : "label"
        });
        conf.items = [
            this.radioButton, this.inputField, this.labelField
        ];
        conf.cls = "at-radio-input-field";
        // TODO: this no
        conf.frame = false;
        conf.bodyStyle = 'border:0;';

        Ext.form.RadioInputField.superclass.constructor.call(this, conf);

    };

    Ext.extend(Ext.form.RadioInputField, Ext.Panel, {
        setValue: function (bool, optText) {
            this.radioButton.setValue(bool);
            if (optText !== undefined) {
                this.setTextValue(optText);
            }
        },
        getValue: function () {
            return this.radioButton.checked;
        },
        getTextValue: function () {
            return this.inputField.getValue();
        },
        setTextValue: function (str) {
            this.inputField.setValue(str);
        },
        onCheckChanged: function (radioBtn, value) {
            if (value) {
                this.labelField.removeClass('disabled');
                this.inputField.enable();
            } else {
                this.labelField.addClass('disabled');
                this.inputField.disable();
            }
        }

    })
}();
ns("ux.form");

(function() {

	Signavio.ux.form.Spacer = function(attrs) {
		attrs = attrs || {};

		attrs.cls = "x-form-spacer";

		Signavio.ux.form.Spacer.superclass.constructor.call(this, attrs);
	};

	Ext.extend(Signavio.ux.form.Spacer, Ext.form.Label);

}());
/** 
 *  (c) 2013 Signavio GmbH
 *   
 *  @author Thomas Zimmermann
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.form){ Ext.ux.form = {} }

new function(){
	
	Ext.ux.form.TextAreaGrowing = function(attr) {
		
		/* Default attributes present in  Ext.form.TextArea */
		attr.growPad = Signavio.Config.GROWING_TEXT_AREA.VERTICAL_PADDING;
    	attr.growPadHorizontal = Signavio.Config.GROWING_TEXT_AREA.HORIZONTAL_PADDING;
    	attr.growMax = Signavio.Config.GROWING_TEXT_AREA.GROW_MAX;
    	attr.growMin = Math.max(attr.growMin || 0);
    	attr.growMinHorizontal = Math.max(attr.growMinHorizontal || 0);

    	/* Custom attributes */
    	this.growAppend = Signavio.Config.GROWING_TEXT_AREA.GROW_APPEND;
    	
    	/* TextArea's property to set overflow to hidden */
    	attr.preventScrollbars = true;
    	
		
		Ext.ux.form.TextAreaGrowing.superclass.constructor.call(this, attr);
	};

	Ext.extend(Ext.ux.form.TextAreaGrowing, Ext.form.TextArea, {
		
        /**
         * Automatically grows the field to accomodate the height of the text up to the maximum field height allowed.
         * This only takes effect if grow = true, and fires the autosize event if the height changes.
         */
        autoSize : function(){
            if(!this.grow || !this.textSizeEl){
                return;
            }
            var el = this.el;
            var v = el.dom.value;
            var ts = this.textSizeEl;
            if (!ts||!el){ return }
            ts.innerHTML = '';
            ts.appendChild(document.createTextNode(v));
            v = ts.innerHTML;

            if (!this.growHorizontally) {
	            try {
	            	Ext.fly(ts).setWidth(this.el.getWidth());
	            } catch(e) { }
            }
            
            if(v.length < 1){
                v = "&#160;&#160;";
            }else{
                if(Ext.isIE){
                    //v = v.replace(/\n/g, '<p>&#160;</p>');
                }
                v += this.growAppend;
            }
            ts.innerHTML = v;
            var h = Math.min(this.growMax, Math.max(ts.offsetHeight + this.growPad, this.growMin));
            if(h != this.lastHeight){
                this.lastHeight = h;
                this.el.setHeight(h);
                this.fireEvent("autosize", this, h);
                if (this.list) {
                	this.list.alignTo(this.el, this.listAlign);
                }
            }
            
            if (this.growHorizontally) {
                var w = Math.min(this.growMax, Math.max(ts.offsetWidth + this.growPadHorizontal, this.growMinHorizontal));
                if(w != this.lastWidth){
                    this.lastWidth = w;
                    this.el.setWidth(w);
                    if (this.list) {
                    	this.list.alignTo(this.el, this.listAlign);
                    }
                }
            }
        }
	});
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *
 *	This code is proprietary software within the 
 * 	company Signavio GmbH.
 *  
 */

new function(){

	/**
	 * BUGFIX for IE7:
	 * ExtJS 2.0.2 doesn't remove multilined emptytext on click, because ie7 recognizes a newline in
	 * the DOM as '\n\r'. Comparison of emptytext with the current content of the DOM node returns
	 * always false, because the predefined emptytext only contains '\n'. Firefox and Safari don't
	 * have this bug. 
	 */
	Ext.override(Ext.form.TextField, {
		preFocus: function(){
			var el = this.el;
			if (this.emptyText) {
				if (this.emptyText.sub("\n", "").sub("\r", "") == el.dom.value.sub("\n", "").sub("\r", "")) {
					this.setRawValue('');
				}
				el.removeClass(this.emptyClass);
			}
			if (this.selectOnFocus) {
				el.dom.select();
			}
		}
	})
};
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.form){ Ext.ux.form = {} }

(function(){
	
	Ext.ux.form.TextFieldList = function(attr){
		
		attr.listeners = Ext.apply({}, {
			specialkey: function(t, e){
				if (e.getKey() === e.ENTER) {
					t.onTriggerClick();
				} else if (e.getKey() === e.ESC) {
					t.stopEdit();
				}
			}
		}, attr.listeners||{})
		
		Ext.ux.form.TextFieldList.superclass.constructor.apply(this, [attr])
	}
	
	Ext.extend(Ext.ux.form.TextFieldList, Ext.form.TriggerField, {
		triggerClass: "x-form-add-trigger",
		ctCls : "x-form-textfield-list",
		listStyle : '',
		emptyListText: '',
		viewEntry: "{[Signavio.Utils.escapeHTML(values)]}",
		enableEmptyAdd: true,
		data: [],
		showSequenceLinks: true,
		onTriggerClick: function(){
			var index = this.editing !== undefined ? this.editing : this.data.length;
			
			var value = this.getRawValue();
			if (!this.enableEmptyAdd&&!value){
				return;
			}
			
			if (this.editing !== undefined) {
				var oldValue = this.data[this.editing];
				this.data[this.editing] = value;
				this.stopEdit();
				if (this.onEdit instanceof Function){
					this.onEdit(index,oldValue,value);
				}
			}
			else {
				var oldData = (this.data instanceof Array) ? this.data.clone() : [];
				this.data.push(value);
				if (this.onAdd instanceof Function){
					this.onAdd(value,oldData);
				}			
				if (Ext.fly(this.container)){Ext.fly(this.container).removeClass("x-empty-textfield-list");}
			}
			this.setRawValue("");
			this.updateView();
			
			var ni = (this.itemField.query('li') || [])[index];
			if (ni && this.ownerCt) 
				Ext.fly(ni).scrollIntoView(this.ownerCt.body);
			
			
			
			window.setTimeout(this.focus.bind(this), 10);
		},
		initValue: function(){
			if (typeof this.value == "string") {
				this.value = this.value ? [this.value] : [];
			}
			if (this.value instanceof Array) {
				this.data = this.value;
				var value = this.value;
				this.value = "";
			}
			Ext.ux.form.TextFieldList.superclass.initValue.apply(this, arguments);
			
			if(value) {
				this.data = value;
				this.updateView();
			}
		},
		setValue: function(value){
			this.value = value;
			this.setRawValue(value);
			if (!value){
				this.data = [];
				this.updateView();
			}
		},
		onStartEdit : Ext.emptyFn,
		onStopEdit : Ext.emptyFn,
		onRemove : Ext.emptyFn,
		onSwap:Ext.emptyFn,
		onAdd: Ext.emptyFn,
		onEdit: Ext.emptyFn,
		startEdit: function(index){
			// Abort previous editing
			if(this.editing !== undefined) {
				this.stopEdit();
			}
			
			this.editing = index;
			var el = this.itemField.query("li")[index];
			Ext.fly(el).addClass("x-editing");
			this.setRawValue(this.data[index]);
			window.setTimeout(this.focus.bind(this), 10);
			this.onStartEdit();
		},
		stopEdit: function(){
			if (this.editing === undefined) {
				return;
			}
			var el = this.itemField.query("li")[this.editing];
			Ext.fly(el).removeClass("x-editing");
			delete this.editing;
			this.setRawValue("");
			this.onStopEdit();
		},
		onRender: function(){
			Ext.ux.form.TextFieldList.superclass.onRender.apply(this, arguments);
			
			if (!this.itemField){
				this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {
					tag: "div",
					style: "margin:1px 0px 4px 0px;" + (!this.emptyListText ? 'display:none;' : '') + '' + this.listStyle
				}));
			}
			
			if (!this.itemFieldTpl){
				if (this.showSequenceLinks === false){
					this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty">'+this.emptyListText+'</span></tpl>',
							'<ol><tpl for="."><li>'+this.viewEntry+' ', '<span class="x-smaller">', '(', '<a href="#{[xindex-1]}" class="x-edit" tabindex="-1">{[(Ext.ux.getI18N("btnEdit"))]}</a>, ', '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>)</span>', '</li></tpl></ol>');
				}else{
					this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty">'+this.emptyListText+'</span></tpl>',
							'<ol><tpl for="."><li>'+this.viewEntry+' ', '<span class="x-smaller">', '(', '<tpl if="xindex != 1">', '<a href="#{[xindex-1]}" class="x-move-up" tabindex="-1">{[(Ext.ux.getI18N("moveUp"))]}</a>, ', '</tpl>', '<tpl if="xindex != xcount">', '<a href="#{[xindex-1]}" class="x-move-down" tabindex="-1">{[(Ext.ux.getI18N("moveDown"))]}</a>, ', '</tpl>', '<a href="#{[xindex-1]}" class="x-edit" tabindex="-1">{[(Ext.ux.getI18N("btnEdit"))]}</a>, ', '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>)</span>', '</li></tpl></ol>');
				}
			}
			
			if ((this.data || []).length > 0){
				if (Ext.fly(this.container)){Ext.fly(this.container).removeClass("x-empty-textfield-list");}
			}else{
				if (Ext.fly(this.container)){Ext.fly(this.container).addClass("x-empty-textfield-list");}
			}
			
			this.updateView();
		},
		onShow: function(){
			Ext.ux.form.TextFieldList.superclass.onShow.apply(this, arguments);
			// Update width
			if (this.width){
				delete this.lastSize;
				this.setWidth(this.width)
			}
		},
		onUpdateView : Ext.emptyFn,
		updateView: function(){		
			
			if (!this.itemFieldTpl||!this.itemField){ return }
			this.itemFieldTpl.overwrite(this.itemField, this.data || []);
			if (!this.emptyListText)
				this.itemField.setDisplayed((this.data || []).length > 0);
			
			this.updateEvents()
			if (this.ownerCt && this.ownerCt.updateSize) {
				this.ownerCt.updateSize();
			}	
			
			this.onUpdateView();
		},
		moveData: function(index, off){
			var a, b;
			a = this.data[index];
			this.data[index] = b = this.data[index + off];
			this.data[index + off] = a;
		},
		
		updateEvents: function(){
			
			this.itemField.select("a.x-move-up").on("click", function(e, t){
				Event.stop(e);
				var index = parseInt(t.getAttribute("href").split("#").last());
				this.onSwap(index,index-1);
				this.moveData(index, -1);
				this.updateView();			
			}.bind(this));
			
			this.itemField.select("a.x-move-down").on("click", function(e, t){
				Event.stop(e);
				var index = parseInt(t.getAttribute("href").split("#").last());
				this.onSwap(index,index+1);
				this.moveData(index, 1);
				this.updateView();			
			}.bind(this));
			
			this.itemField.select("a.x-remove").on("click", function(e, t){
				Event.stop(e);
				var index = parseInt(t.getAttribute("href").split("#").last());
				var oldValue = this.data[index];
				var oldData = this.data.clone();
				delete this.data[index];
				this.data = this.data.compact();
				this.updateView();
				this.onRemove(index,oldValue,oldData);
				// remove css class			
				if (!((this.data || []).length > 0)){
					if (Ext.fly(this.container)){Ext.fly(this.container).addClass("x-empty-textfield-list");}
				}
			}.bind(this));
			
			this.itemField.select("a.x-edit").on("click", function(e, t){
				Event.stop(e);
				var index = parseInt(t.getAttribute("href").split("#").last());
				this.startEdit(index);
			}.bind(this));
			
			var lis = this.itemField.select("li");
			lis.addClassOnOver("x-hover")
			lis.on("mouseover", function(r, t){ Ext.fly(t).addClass("x-hover"); });	
			lis.on("mouseout", function(r, t){  Ext.fly(t).removeClass("x-hover"); });		
					
		},
		getValue: function(){
			if (this.editing !== undefined) {
				var value = this.getRawValue();
				if (value){
					var data = [].concat(this.data||[]);
					data[this.editing] = value;
					return data.compact();
				}
			}
			return [].concat(this.data || [], this.getRawValue().trim() || undefined).compact();
		}
		
	})
	
}());
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.form){ Ext.ux.form = {}; }

(function() {
    Ext.ux.form.TimeSpanField = function(attr) {
                
        this.fromEditor = attr.from;
        this.tillEditor = attr.till || attr.from;
        
        this.timespan = !!attr.till;
        this.lockcounter = 0;
        
        attr.items = [attr.from, attr.till].compact();    
        
        Ext.ux.form.TimeSpanField.superclass.constructor.call(this, attr);
        
        this.fromEditor.on("specialkey", this.onSpecialKey.bind(this));
        this.fromEditor.on("blur", this.handleBlur.bind(this));
        this.fromEditor.on("focus", this.handleFocus.bind(this));
        
        if(attr.till) {
            this.tillEditor.on("specialkey", this.onSpecialKey.bind(this));
            this.tillEditor.on("blur", this.handleBlur.bind(this));
            this.tillEditor.on("focus", this.handleFocus.bind(this));
        }
        
        this.on("resize", this.handleResize.bind(this));
        this.on("show", this.handleShow.bind(this));
    };
    
    Ext.extend(Ext.ux.form.TimeSpanField, Ext.Panel, {
                
        timespan: false,
        
        handleShow: function() {
            this.fromEditor.focus();  
        },
        
        hideEditor: function() {
            if(this.lockcounter === 0) {
                this.fireEvent("blur");
            }
        },
        
        handleBlur: function() {
            this.lockcounter += -1;
            
            window.setTimeout(this.hideEditor.bind(this), 100);
        },
        
        handleFocus: function() {
            this.lockcounter += 1;
        },

        handleResize: function(self, aw, ah, w, h) {
            if(this.initialConfig.till) {
                w = w/2 - 5; // 5px padding
            }
            
            this.fromEditor.setSize(w, h);
            this.tillEditor.setSize(w, h);
        },
    
        onSpecialKey: function(field, e) {
            if(e.getKey() === e.ENTER) {
                if(this.fromEditor.isValid() 
                    && !this.tillEditor.isValid()) {
                                            
                    this.tillEditor.focus();
                } else if(!this.fromEditor.isValid()
                    && this.tillEditor.isValid()) {
                                            
                    this.fromEditor.focus();        
                } else {
                    this.hideEditor(true);
                }
            }
        },
    
        setValue: function(value) {
            if(value instanceof Array) {
                value = (value || []).flatten().map(function(el) {
                    return this.parseDate(el);
                }.bind(this));
                
                var from = value.first();
                var till = value.last();
                
                this.fromEditor.setValue(from);
                this.tillEditor.setValue(till);
            } else if(value instanceof Date) {
                this.fromEditor.setValue(value);
            }
        },
        
        dateFromString: function(value) {
            if(!value) {
                return;
            }
            
            var dateArray = value.split("-");
            dateArray = dateArray[0].split(".");
            
            var day = dateArray[0];
            var month = dateArray[1];
            var year = "20" + dateArray[2];
            
            var date = new Date(month + "/" + day + "/" + year);
            
            if(isNaN(date.getTime())) {
                return;
            }
            
            return date;
        },
        
        parseDate: function(value) {
            if(value instanceof Date) {
                return value;
            }
            
            if(typeof value === "string") {
                return this.dateFromString(value);
            }
            
            if(value instanceof Array) {
                return value.map(function(el) {
                    return this.parseDate(el);
                }.bind(this));
            }
        },
        
        getValue: function() {
            return [this.fromEditor.getValue(), this.tillEditor.getValue()].uniq();
        },
        
        isValid: function() {
            var from = this.fromEditor.getValue();
            var till = this.tillEditor.getValue();
            
            if(!this.timespan) {
                return !!from;
            }
            
            return from && till && from < till;
        }
     
    });
})();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */



new function(){
	
	/**
	 * BUGFIXING:
	 * The width of the wrap and the field for a triggerfield
	 * was calculated also with the border and padding, 
	 * which is wrong for chrome and safari. So the calculation
	 * is adjusted for it.
	 *  
	 * @param {Object} w
	 * @param {Object} h
	 */
//	Ext.form.TriggerField.prototype.onResize = function(w, h){
//        Ext.form.TriggerField.superclass.onResize.call(this, w, h);
//        if(typeof w == 'number'){
//			var nw = w - this.trigger.getWidth();
//			if (this.el.dom.offsetWidth !== undefined && this.el.dom.scrollWidth !== undefined && 
//				this.el.dom.offsetWidth !== this.el.dom.scrollWidth && (this.anchor || "").startsWith("100%")) {
//				 //nw -= this.el.getPadding("lr") + this.el.getBorderWidth("lr");
//			}
//            this.el.setWidth(this.adjustWidth('input', nw));
//        }
//        this.wrap.setWidth(this.el.getWidth()+this.trigger.getWidth());
//    }
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.form){ Ext.ux.form = {}; }

(function(){
	
	
	Ext.ux.form.UrlLinkFieldList = function(attr){
		
		attr.listeners = Ext.apply({}, {
			specialkey: function(t, e){
				if (e.getKey() === e.ENTER) {
					t.onTriggerClick();
				}
				else 
					if (e.getKey() === e.ESC) {
						t.stopEdit();
					}
			}
		}, attr.listeners||{})
		
		Ext.ux.form.UrlLinkFieldList.superclass.constructor.apply(this, [attr])
	}
	
	Ext.extend(Ext.ux.form.UrlLinkFieldList, Ext.ux.form.TextFieldList, new Object({
		emptyText :Ext.ux.getI18N("url"),
		emptyLabelText : Ext.ux.getI18N("label"),
		prefix: "",
		prefixHTTP: "http://",
		prefixFileLocal: "file:///",
		prefixFileNetwork: "file://///",
		enableEmptyAdd : false,
		showSequenceLinks: true,
		ctCls : 'x-url-link-field-list',
		viewEntry : "<a href='{[Signavio.Utils.escapeHTML(values.url)]}' target='_blank' tabindex='-1'>{[Signavio.Utils.escapeHTML(values.label||values.url)]}</a>",
		evaluateLokalURL : function(){
			// Add prefix for lokal urls
			var val = (Ext.ux.form.TextFieldList.prototype.getRawValue.call(this)||"").strip();
			
			// Replace '/' to '\'
			val = val.replace(/\\/g, "/");
			
			// FIND: C:...
			if (val.match(/^[A-Z]:[\/\\]/i)){
				val = val.replace(/^[A-Z]:/i, function(r){ return r.toUpperCase(); });
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this,this.prefixFileLocal+""+val);

			// FIND: //...
			} else if (val.match(/^\/\/[^\/]/)){
				val = val.slice(2);
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this,this.prefixFileNetwork+""+val);
			}
	    },		
		isURL: function(url){
			url = url.trim();
			return 	!!url.match(/^[^:\/\\#?;]*?\.[a-zA-Z]{2,4}$/) ||  // Find just url without parameter like: 	www.google.de
					!!url.match(/^[^:\/\\#?;]*?\.[a-zA-Z]{2,4}[\/]/);// Find the url with parameters like: 		www.google.de/com
		},
		initEvents : function(){
	        Ext.ux.form.UrlLinkFieldList.superclass.initEvents.apply(this, arguments);
        	this.el.on("keyup", this.evaluateLokalURL,  this);
		},
		onResize : function(w, h){
	        Ext.ux.form.UrlLinkFieldList.superclass.onResize.call(this, w, h);
	        if(typeof w == 'number'){
				var fw = (w/2) - ((this.trigger.getWidth() || 17)/2);
				if (this.el.dom.offsetWidth !== undefined && this.el.dom.scrollWidth !== undefined && 
					this.el.dom.offsetWidth !== this.el.dom.scrollWidth && (this.anchor || "").startsWith("100%")) {
					fw += 0;
				}
				
				// Set the label field to 70% of the half of the width
				var fwf = Math.max(70, Math.round(fw*0.7)),
					fwe = fw+(fw-fwf);
				this.fel.setWidth(this.adjustWidth('input', fwf));
	            this.el.setWidth(this.adjustWidth('input', fwe + (!this.trigger.getWidth()?17:0)));
	        }
	        this.wrap.setWidth(w); //this.el.getWidth()+(this.trigger.getWidth()||17)+this.fel.el.getWidth());
	    },

		onRender: function(){
			Ext.ux.form.UrlLinkFieldList.superclass.onRender.apply(this, arguments);
			
			this.fel = new Ext.form.TextField({
				style: "border-right:none;",
				emptyText: this.emptyLabelText,
				applyEmptyText: function(){
					if (this.el.dom.value === '')
						Ext.form.TextField.prototype.applyEmptyText.call(this);
				},
				listeners: {
					focus : this.mimicBlur.bind(this, {}),
					specialkey: function(t, e){
						// Set changes if in edit mode
						if (this.editing === undefined){ return; }
						if (e.getKey() === e.ENTER) {
							this.onTriggerClick();
						} else if (e.getKey() === e.ESC) {
							this.stopEdit();
						}
					}.bind(this)
				}
			});
			this.fel.render(this.wrap);
			this.fel.el.insertBefore(this.el);
			this.updateView();
		},
		onFocus 	: function(){
			Ext.ux.form.UrlLinkFieldList.superclass.onFocus.apply(this, arguments);
			if (this.getRawValueFrom(this)==='' && this.prefix){
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, this.prefix);
				window.setTimeout(this.el.focus.bind(this.el), 10);
			}
		},
		onBlur	: function(){
			if (this.prefix&&this.getRawValueFrom(this)==this.prefix){
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, "");
			}
			Ext.ux.form.UrlLinkFieldList.superclass.onBlur.apply(this, arguments);
		},		
		startEdit: function(index){
			// Abort previous editing
			if(this.editing !== undefined) {
				this.stopEdit();
			}
			
			this.editing = index;
			var el = this.itemField.query("li")[index];
			Ext.fly(el).addClass("x-editing");
			this.setRawValue(this.data[index]);
			this.preFocus();
			window.setTimeout(this.fel.focus.bind(this.fel), 10);
			this.onStartEdit();
		},
		stopEdit: function(){
			Ext.ux.form.UrlLinkFieldList.superclass.stopEdit.apply(this, arguments);
			this.el.focus();
			this.fel.focus(false, true);
		},
		setRawValue : function(value){
			Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, (value||{}).url || "");
			this.fel.setValue((value||{}).label || "");
		},
		preFocus : function(){
	        if(this.emptyText){
	            if(this.el.dom.value == this.emptyText){
					Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, "");
	            }
	            this.el.removeClass(this.emptyClass);
	        }
	        if(this.selectOnFocus){
	            this.el.dom.select();
	        }
	    },
		getRawValue: function(){
			var url = (this.getRawValueFrom(this) || "").trim();
			
			if(!this.fel) {
				return "";
			}
			
			var label = this.getRawValueFrom(this.fel);

			if (this.isURL(url)){
				url = this.prefixHTTP + url;
			}

			var obj = Ext.apply({}, {
				url: unescape(decodeURI(url)), 
				label: label
			}, this.editing !== undefined ? this.data[this.editing] : {});

			return url && url !== this.prefix ? obj : "";
		},
		getRawValueFrom: function(field){
			var v = field.rendered ? field.el.getValue() : Ext.value(field.value, '');
	        if(v === field.emptyText){
	            v = '';
	        }
	        return v;
		},
		applyEmptyText : function(){
	        if(this.rendered && this.emptyText && this.getRawValue().length < 1){            
				Ext.ux.form.TextFieldList.prototype.setRawValue.call(this, this.emptyText);
	            this.el.addClass(this.emptyClass);
	        }
	    },
		focus: function(){
			this.fel.focus();
		},
		getValue: function(){
			if (this.editing !== undefined) {
				var value = this.getRawValue();
				if (value){
					var data = [].concat(this.data||[]);
					data[this.editing] = value;
					return data.compact();
				}
			}
			return [].concat(this.data || [], this.getRawValue() || []).compact();
		},
		setValue: function(){
			
		}
	}));

}());

/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.form){ Ext.ux.form = {}; }

new function(){
	
	Ext.ux.form.SuggestBoxList = Ext.extend(Ext.ux.form.TextFieldList, {
		displayField: "value",
		dataIndex: undefined,
		/**
		 * @cfg {Function} callback receiving every data selection change.
		 */
		valueChangedCB: Ext.emptyFn,
		/**
	     * @cfg {Boolean/String} shadow True or "sides" for the default effect, "frame" for 4-way shadow, and "drop" for bottom-right
	     */
	    shadow:'sides',
	    /**
	     * @cfg {String} listAlign A valid anchor position value. See {@link Ext.Element#alignTo} for details on supported
	     * anchor positions (defaults to 'tl-bl')
	     */
	    listAlign: 'tl-bl?',
	    /**
	     * @cfg {String} selectedClass CSS class to apply to the selected item in the dropdown list (defaults to 'x-combo-selected')
	     */
	    selectedClass: 'x-combo-selected',
	    /**
	     * @cfg {Number} maxHeight The maximum height in pixels of the dropdown list before scrollbars are shown (defaults to 300)
	     */
	    maxHeight: 300,
	    /**
	     * @cfg {Number} minHeight The minimum height in pixels of the dropdown list when the list is constrained by its
	     * distance to the viewport edges (defaults to 90)
	     */
	    minHeight: 90,
		/**
	     * @cfg {String} triggerAction The action to execute when the trigger field is activated.  Use 'all' to run the
	     * query specified by the allQuery config option (defaults to 'query')
	     */
	    triggerAction: 'query',
	    /**
	     * @cfg {Number} minChars The minimum number of characters the user must type before autocomplete and typeahead activate
	     * (defaults to 4 if remote or 0 if local, does not apply if editable = false)
	     */
	    minChars : 4,
	    /**
	     * @cfg {Boolean} typeAhead True to populate and autoselect the remainder of the text being typed after a configurable
	     * delay (typeAheadDelay) if it matches a known value (defaults to true)
	     */
	    typeAhead: true,
	    /**
	     * @cfg {Number} queryDelay The length of time in milliseconds to delay between the start of typing and sending the
	     * query to filter the dropdown list (defaults to 500 if mode = 'remote' or 10 if mode = 'local')
	     */
	    queryDelay: 500,
	    queryClickDelay: 100,
	    /**
	     * @cfg {Number} pageSize If greater than 0, a paging toolbar is displayed in the footer of the dropdown list and the
	     * filter queries will execute with page start and limit parameters.  Only applies when mode = 'remote' (defaults to 0)
	     */
	    pageSize: 0,
	    /**
	     * @cfg {Boolean} selectOnFocus True to select any existing text in the field immediately on focus.  Only applies
	     * when editable = true (defaults to false)
	     */
	    selectOnFocus:false,
	    /**
	     * @cfg {String} queryParam Name of the query as it will be passed on the querystring (defaults to 'query')
	     */
	    queryParam: 'query',
	    /**
	     * @cfg {String} queryParam Name of the query defining the page size limit as it will be passed on the querystring (defaults to 'limit')
	     */
	    limitParam: 'limit',
	    limit: 0,
	    /**
	     * @cfg {String} queryParam Name of the query defining the current 
	     * position in the result list as it will be passed on the 
	     * querystring (defaults to 'offset')
	     */	
	    offsetParam: 'offset',
	    offset: 0,
	    /**
	     * @cfg {object} key value map of other parameter passed along with the
	     * querystring (defaults to '{}')
	     */	
	    otherParams: {},
	    /**
	     * Function to filter the paging information.
	     */
	    pagesRecFn: undefined,
	    /**
	     * @cfg {String} loadingText The text to display in the dropdown list while data is loading.  Only applies
	     * when mode = 'remote' (defaults to 'Loading...')
	     */
	    loadingText: 'Loading...',
	    /**
	     * @cfg {Boolean} resizable True to add a resize handle to the bottom of the dropdown list (defaults to false)
	     */
	    resizable: false,
	    /**
	     * @cfg {Number} handleHeight The height in pixels of the dropdown list resize handle if resizable = true (defaults to 8)
	     */
	    handleHeight : 8,
	    /**
	     * @cfg {Boolean} editable False to prevent the user from typing text directly into the field, just like a
	     * traditional select (defaults to true)
	     */
	    editable: true,
	    /**
	     * @cfg {String} allQuery The text query to send to the server to return all records for the list with no filtering (defaults to '')
	     */
	    allQuery: '',
	    /**
	     * @cfg {String} mode Set to 'local' if the ComboBox loads local data (defaults to 'remote' which loads from the server)
	     */
	    mode: 'remote',
	    /**
	     * @cfg {Number} minListWidth The minimum width of the dropdown list in pixels (defaults to 70, will be ignored if
	     * listWidth has a higher value)
	     */
	    minListWidth : 70,
	    /**
	     * @cfg {Boolean} forceSelection True to restrict the selected value to one of the values in the list, false to
	     * allow the user to set arbitrary text into the field (defaults to false)
	     */
	    forceSelection:false,
	    /**
	     * @cfg {Number} typeAheadDelay The length of time in milliseconds to wait until the typeahead text is displayed
	     * if typeAhead = true (defaults to 250)
	     */
	    typeAheadDelay : 250,
	    /**
	     * @cfg {String} valueNotFoundText When using a name/value combo, if the value passed to setValue is not found in
	     * the store, valueNotFoundText will be displayed as the field text if defined (defaults to undefined)
	     */

	    /**
	     * @cfg {Boolean} lazyInit True to not initialize the list for this combo until the field is focused. (defaults to true)
	     */
	    lazyInit : true,
	    
	    

	    initComponent : function(){
	    	Ext.ux.form.SuggestBoxList.superclass.initComponent.call(this);
	        this.addEvents(
	            /**
	             * @event expand
	             * Fires when the dropdown list is expanded
	             * @param {Ext.form.ComboBox} combo This combo box
	             */
	            'expand',
	            /**
	             * @event collapse
	             * Fires when the dropdown list is collapsed
	             * @param {Ext.form.ComboBox} combo This combo box
	             */
	            'collapse',
	            /**
	             * @event beforeselect
	             * Fires before a list item is selected. Return false to cancel the selection.
	             * @param {Ext.form.ComboBox} combo This combo box
	             * @param {Ext.data.Record} record The data record returned from the underlying store
	             * @param {Number} index The index of the selected item in the dropdown list
	             */
	            'beforeselect',
	            /**
	             * @event select
	             * Fires when a list item is selected
	             * @param {Ext.form.ComboBox} combo This combo box
	             * @param {Ext.data.Record} record The data record returned from the underlying store
	             * @param {Number} index The index of the selected item in the dropdown list
	             */
	            'select',
	            /**
	             * @event beforequery
	             * Fires before all queries are processed. Return false to cancel the query or set the queryEvent's
	             * cancel property to true.
	             * @param {Object} queryEvent An object that has these properties:<ul>
	             * <li><code>combo</code> : Ext.form.ComboBox <div class="sub-desc">This combo box</div></li>
	             * <li><code>query</code> : String <div class="sub-desc">The query</div></li>
	             * <li><code>forceAll</code> : Boolean <div class="sub-desc">True to force "all" query</div></li>
	             * <li><code>cancel</code> : Boolean <div class="sub-desc">Set to true to cancel the query</div></li>
	             * </ul>
	             */
	            'beforequery'
	        );
	        if(this.transform){
	            this.allowDomMove = false;
	            var s = Ext.getDom(this.transform);
	            if(!this.hiddenName){
	                this.hiddenName = s.name;
	            }
	            if(!this.store){
	                this.mode = 'local';
	                var d = [], opts = s.options;
	                for(var i = 0, len = opts.length;i < len; i++){
	                    var o = opts[i];
	                    var value = (Ext.isIE ? o.getAttributeNode('value').specified : o.hasAttribute('value')) ? o.value : o.text;
	                    if(o.selected) {
	                        this.value = value;
	                    }
	                    d.push([value, o.text]);
	                }
	                this.store = new Ext.data.SimpleStore({
	                    'id': 0,
	                    fields: ['value', 'text'],
	                    data : d
	                });
	                this.valueField = 'value';
	                this.displayField = 'text';
	            }
	            s.name = Ext.id(); // wipe out the name in case somewhere else they have a reference
	            if(!this.lazyRender){
	                this.target = true;
	                this.el = Ext.DomHelper.insertBefore(s, this.autoCreate || this.defaultAutoCreate);
	                Ext.removeNode(s); // remove it
	                this.render(this.el.parentNode);
	            }else{
	                Ext.removeNode(s); // remove it
	            }

	        }
	        this.selectedIndex = -1;
	        if(this.mode == 'local'){
	            if(this.initialConfig.queryDelay === undefined){
	                this.queryDelay = 10;
	            }
	            if(this.initialConfig.minChars === undefined){
	                this.minChars = 0;
	            }
	        }
	    },
	    
	    // private
	    initEvents : function(){
	    	Ext.ux.form.SuggestBoxList.superclass.initEvents.call(this);

	        this.keyNav = new Ext.KeyNav(this.el, {
//	            "up" : function(e){
//	                this.inKeyMode = true;
//	                this.selectPrev();
//	            },
//
//	            "down" : function(e){
//	                if(!this.isExpanded()){
//	                    this.onTriggerClick();
//	                }else{
//	                    this.inKeyMode = true;
//	                    this.selectNext();
//	                }
//	            },

//	            "enter" : function(e){
//	                this.onViewClick();
//	                this.delayedCheck = true;
//					this.unsetDelayCheck.defer(10, this);
//	            },

	            "esc" : function(e){
	                this.collapse();
	            },

//	            "tab" : function(e){
//	                this.onViewClick(false);
//	                return true;
//	            },

	            scope : this,

	            doRelay : function(foo, bar, hname){
	                if(hname == 'down' || this.scope.isExpanded()){
	                   return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
	                }
	                return true;
	            },

	            forceKeyDown : true
	        });
	        this.queryDelay = Math.max(this.queryDelay || 10,
	                this.mode == 'local' ? 10 : 250);
	        this.dqTask = new Ext.util.DelayedTask(this.initQuery, this);
	        if(this.typeAhead){
	            this.taTask = new Ext.util.DelayedTask(this.onTypeAhead, this);
	        }
	        if(this.editable !== false){
	            this.el.on("keyup", this.onKeyUp, this);
	            this.el.on("mousedown", this.onMouseDown, this);
	        }
	        if(this.forceSelection){
	            this.on('blur', this.doForce, this);
	        }
	    },
	    
		onLoad : function(store, records, options){
	        if(!this.hasFocus){
	            return;
	        }
	        if(this.store.getCount() == 0 && records && records.size() > 0) {
	        	this.store.data.addAll(records);
	        }
	        
	        if(this.store.getCount() > 0){
	            this.expand();
	            this.restrictHeight();
	            if(this.lastQuery == this.allQuery){
	                if(this.editable){
	                    this.el.dom.select();
	                }
	                if(!this.selectByValue(this.value, true)){
	                    this.select(0, true);
	                }
	            } else {
					if (this.selectedIndex !== -1 || this.forceSelection){
						this.selectNext();
					}
	                if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
	                    this.taTask.delay(this.typeAheadDelay);
	                }
	            }
	        }else{
	            this.onEmptyResults();
	        }
	        //this.el.focus();
	    },
	    
	    // private
	    onEmptyResults : function(){
	        this.collapse();
	    },
	    
	    /**
	     * @override
	     * Removes duplicates from the view data list and triggers the 
	     * superclass method
	     */
	    updateView: function() {
	    	if(this.data instanceof Array) {
	    		this.data = this.data.uniq();
	    	}
	    	
	    	Ext.ux.form.SuggestBoxList.superclass.updateView.call(this,arguments);
	    },
	    
	    onViewClick : function(doFocus){
	        var index = this.view.getSelectedIndexes()[0];
	        var r = this.store.getAt(index);
	        if(r && r.data.rep.isSelectable) {
	        	this.data.push(r.data.rep.value);
	        	this.updateView();
	        }
//	        if(r){
//	            this.onSelect(r, index);
//	        } else if (!this.forceSelection) {
//				this.setValue(Ext.form.ComboBox.superclass.getValue.call(this));
//				this.collapse();
//			}
//	        if(doFocus !== false){
//	            this.el.focus();
//	        }
	    },
	    
	    // private
	    onTypeAhead : function(){
	        if(this.store.getCount() > 0){
	            var r = this.store.getAt(0);
	            var newValue = r.data[this.dataIndex][this.displayField];
	            var len = newValue.length;
	            var selStart = this.getRawValue().length;
	            if(newValue && selStart != len){
	                this.setRawValue(newValue);
	                this.selectText(selStart, newValue.length);
	            }
	        }
	    },
	    
	    /**
	     * Execute a query to filter the dropdown list.  Fires the beforequery event prior to performing the
	     * query allowing the query action to be canceled if needed.
	     * @param {String} query The SQL query to execute
	     * @param {Boolean} forceAll True to force the query to execute even if there are currently fewer characters
	     * in the field than the minimum specified by the minChars config option.  It also clears any filter previously
	     * saved in the current store (defaults to false)
	     */
	    doQuery : function(q, forceAll){
	        if(q === undefined || q === null){
	            q = '';
	        }
	        var qe = {
	            query: q,
	            forceAll: forceAll,
	            combo: this,
	            cancel:false
	        };
	        if(this.fireEvent('beforequery', qe)===false || qe.cancel){
	            return false;
	        }
	        q = qe.query;
	        forceAll = qe.forceAll;
	        if(forceAll === true || (q.length >= this.minChars)){
	            if(this.lastQuery !== q){
	                this.lastQuery = q;
	                if(this.mode == 'local'){
	                    this.selectedIndex = -1;
	                    if(forceAll){
	                        this.store.clearFilter();
	                    }else{
	                        this.store.filter(this.displayField, q);
	                    }
	                    this.onLoad();
	                }else{
	                	// Set query parameters
//	                    this.store.baseParams[this.queryParam] = this.getParams(q);
//	                    this.store.baseParams[this.limitParam] = this.limit;
//	                    this.store.baseParams[this.offsetParam] = this.offset;
	                	
	                	// Load initial values depending on query string
	                	if(q === '' && this.initialValues instanceof Array) {
	                		this.store.loadData(this.initialValues.pluck("data"));
	                	} else {
	                		this.store.load({
	                			force: true, // forced to use not the cache
	                			params: this.getParams(q)
//	                        filter: this.filter
	                		});	                		
	                	}
	                	 
	                    this.expand();
	                }
	            }else{
	                this.selectedIndex = -1;
	                this.onLoad();
	            }
	        }
	    },
	    
	    // private
	    onKeyUp : function(e){
	        if(this.editable !== false && !e.isSpecialKey()){
	            this.lastKey = e.getKey();
	            this.dqTask.delay(this.queryDelay);
	        }
	    },
	    
	    /**
	     * Same usage as key up, but for empty input. Triggers display of initial 
	     * suggestible values.
	     */
	    onMouseDown : function(e) {
	    	if(this.editable !== false && this.getRawValue() === "") {
	    		this.dqTask.delay(this.queryClickDelay);
	    	}
	    },
	    
	    // private
	    initQuery : function(){
	        this.doQuery(this.getRawValue());
	    },
	    
	    // private
	    getParams : function(q, start){
	        var p = {};
	        
	        if(this.pageSize){
	            p.offset = start||0;
	            p.limit = this.pageSize;
	        }
	        p[this.currentValueParam] = q;
	        
	        if(typeof(this.otherParams) !== "undefined") {
	        	Ext.apply(p,this.otherParams);
	        }
	        
	        return p;
	    },
	    
	 // private
	    bindStore : function(store, initial){
	        if(this.store && !initial){
	            this.store.un('beforeload', this.onBeforeLoad, this);
	            this.store.un('load', this.onLoad, this);
	            this.store.un('loadexception', this.collapse, this);
	            if(!store){
	                this.store = null;
	                if(this.view){
	                    this.view.setStore(null);
	                }
	            }
	        }
	        if(store){
	            //this.store = Ext.StoreMgr.lookup(store);
	        	this.store = store;

	            this.store.on('beforeload', this.onBeforeLoad, this);
	            this.store.on('load', this.onLoad, this);
	            this.store.on('loadexception', this.collapse, this);

	            if(this.view){
	                this.view.setStore(store);
	            }
	        }
	    },
	    
	    // private
	    onRender : function(ct, position){
	    	Ext.ux.form.SuggestBoxList.superclass.onRender.call(this, ct, position);
//	        if(this.hiddenName){
//	            this.hiddenField = this.el.insertSibling({tag:'input', type:'hidden', name: this.hiddenName, id: (this.hiddenId||this.hiddenName)},
//	                    'before', true);
//	            this.hiddenField.value =
//	                this.hiddenValue !== undefined ? this.hiddenValue :
//	                this.value !== undefined ? this.value : '';
//
//	            // prevent input submission
//	            this.el.dom.removeAttribute('name');
//	        }
//	        if(Ext.isGecko){
//	            this.el.dom.setAttribute('autocomplete', 'off');
//	        }

	        if(!this.lazyInit){
	            this.initList();
	        }else{
	            this.on('focus', this.initList, this, {single: true});
	        }

	        if(!this.editable){
	            this.editable = true;
	            this.setEditable(false);
	        }
	    },
	    
	    /**
	     * Allow or prevent the user from directly editing the field text.  If false is passed,
	     * the user will only be able to select from the items defined in the dropdown list.  This method
	     * is the runtime equivalent of setting the 'editable' config option at config time.
	     * @param {Boolean} value True to allow the user to directly edit the field text
	     */
	    //TODO: guess refactoring is required
	    setEditable : function(value){
	        if(value == this.editable){
	            return;
	        }
//	        this.editable = value;
//	        if(!value){
//	            this.el.dom.setAttribute('readOnly', true);
//	            this.el.on('mousedown', this.onTriggerClick,  this);
//	            this.el.addClass('x-combo-noedit');
//	        }else{
//	            this.el.dom.setAttribute('readOnly', false);
//	            this.el.un('mousedown', this.onTriggerClick,  this);
//	            this.el.removeClass('x-combo-noedit');
//	        }
	    },
	    
	    /**
	     * Expands the dropdown list if it is currently hidden. Fires the 'expand' event on completion.
	     */
	    expand: function(){
	        if(this.isExpanded() || !this.hasFocus){
	            return;
	        }
	        this.list.alignTo(this.wrap, this.listAlign);
	        this.list.show();
	        this.innerList.setOverflow('auto'); // necessary for FF 2.0/Mac
	        Ext.getDoc().on('mousewheel', this.collapseIf, this);
	        Ext.getDoc().on('mousedown', this.collapseIf, this);
	        this.fireEvent('expand', this);
	    },
	    
	    /**
	     * Returns true if the dropdown list is expanded, else false.
	     */
	    isExpanded: function(){
	        return this.list && this.list.isVisible();
	    },
	    
	    initList: function(){
	    	// VARs
	    	var doLoadFN;
	    	
	        if(!this.list){
	            var cls = 'x-combo-list';

	            this.list = new Ext.Layer({
	                shadow: this.shadow, cls: [cls, this.listClass].join(' '), constrain:false
	            });

	            var lw = this.listWidth || Math.max(this.wrap.getWidth(), this.minListWidth);
	            this.list.setWidth(lw);
	            this.list.swallowEvent('mousewheel');
	            this.assetHeight = 0;

	            if(this.title){
	                this.header = this.list.createChild({cls:cls+'-hd', html: this.title});
	                this.assetHeight += this.header.getHeight();
	            }

	            this.innerList = this.list.createChild({cls:cls+'-inner'});
	            this.innerList.on('mouseover', this.onViewOver, this);
	            this.innerList.on('mousemove', this.onViewMove, this);
	            this.innerList.setWidth(lw - this.list.getFrameWidth('lr'));

	            if(this.pageSize){
	            	doLoadFN = function(start) {
	            		var currentVal = this.getRawValue(),
	            			opt;
	            		
	            		if(!currentVal) {
	            			currentVal = '';
	            		}
	            		
	            		opt = this.getParams(currentVal, start);
            	        this.store.load({params:opt});
	            	}.bind(this);
	                this.footer = this.list.createChild({cls:cls+'-ft'});
	                this.pageTb = new Ext.ux.PagingToolbar({
	                    store:this.store,
	                    pageSize: this.pageSize,
	                    renderTo:this.footer,
	                    doLoad: doLoadFN,
	                    style: 'z-index:1000002',
	                    afterPageText: "/{0}",
	                    beforePageText: "{0}",
	                    ctCls: "x-paginglist-container",
	                    cls: "x-paginglist"
	                });
	                this.assetHeight += this.footer.getHeight();
	            }

	            if(!this.tpl){
				    /**
				    * @cfg {String/Ext.XTemplate} tpl The template string, or {@link Ext.XTemplate}
				    * instance to use to display each item in the dropdown list. Use
				    * this to create custom UI layouts for items in the list.
				    * <p>
				    * If you wish to preserve the default visual look of list items, add the CSS
				    * class name <pre>x-combo-list-item</pre> to the template's container element.
				    * <p>
				    * <b>The template must contain one or more substitution parameters using field
				    * names from the Combo's</b> {@link #store Store}. An example of a custom template
				    * would be adding an <pre>ext:qtip</pre> attribute which might display other fields
				    * from the Store.
				    * <p>
				    * The dropdown list is displayed in a DataView. See {@link Ext.DataView} for details.
				    */
//	                this.tpl = '<tpl for="."><div class="'+cls+'-item"><a href="#{[xindex-1]}" class="x-form-add-trigger" tabindex="-1"><tpl for="rep">{value}</tpl></a></div></tpl>';
	            	var fn = function(rep) {
	            		if(rep.isSelectable) {
	            			return "x-row-unselectable";
	            		}
	            	};
	            	
	            	this.tpl = new Ext.XTemplate('<tpl for=".">',
	            			'<tpl for="rep"><div class="'+cls+'-item {[this.getRowClass(values)]}">',
	            			'{value}</div></tpl></tpl>',
	            			{
	            				getRowClass: function(val) {
	            					if(!val.isSelectable) {
	            						return "x-row-unselectable";
	            					}
	            				}
	            			});
	            }

			    /**
			    * The {@link Ext.DataView DataView} used to display the ComboBox's options.
			    * @type Ext.DataView
			    */
	            this.view = new Ext.DataView({
	                applyTo: this.innerList,
//	                disabledClass: "x-row-unselectable",
	                tpl: this.tpl,
	                singleSelect: true,
	                overClass:'x-view-over',
	                selectedClass: this.selectedClass,
	                itemSelector: this.itemSelector || 'div.' + cls + '-item'
	            });

	            this.view.on('click', this.onViewClick, this);

	            this.bindStore(this.store, true);

	            if(this.resizable){
	                this.resizer = new Ext.Resizable(this.list,  {
	                   pinned:true, handles:'se'
	                });
	                this.resizer.on('resize', function(r, w, h){
	                    this.maxHeight = h-this.handleHeight-this.list.getFrameWidth('tb')-this.assetHeight;
	                    this.listWidth = w;
	                    this.innerList.setWidth(w - this.list.getFrameWidth('lr'));
	                    this.restrictHeight();
	                }, this);
	                this[this.pageSize?'footer':'innerList'].setStyle('margin-bottom', this.handleHeight+'px');
	            }
	        }
	    },
	    
	 // private
	    onViewMove : function(e, t){
	        this.inKeyMode = false;
	    },

	    // private
	    onViewOver : function(e, t){
	    	if(this.inKeyMode){ // prevent key nav and mouse over conflicts
	            return;
	        }
	        var item = this.view.findItemFromChild(t);
	        if(item){
	            var index = this.view.indexOf(item);
	            this.select(index, false);
	        }
	    },
	    
	    // private
	    //TODO: refactoring
	    onBeforeLoad : function(){
	        if(!this.hasFocus){
	            return;
	        }
	        this.innerList.update(this.loadingText ?
	               '<div class="loading-indicator">'+this.loadingText+'</div>' : '');
	        this.restrictHeight();
	        this.selectedIndex = -1;
	    },
	    
	    /**
	     * Hides the dropdown list if it is currently expanded. Fires the 'collapse' event on completion.
	     */
	    collapse : function(){
	        if(!this.isExpanded()){
	            return;
	        }
	        this.list.hide();
	        Ext.getDoc().un('mousewheel', this.collapseIf, this);
	        Ext.getDoc().un('mousedown', this.collapseIf, this);
	        this.fireEvent('collapse', this);
	    },

	    // private
	    collapseIf : function(e){
	        if(!e.within(this.wrap) && !e.within(this.list)){
	            this.collapse();
	        }
	    },
	    
	    // private
		restrictHeight : function(){
	        this.innerList.dom.style.height = '';
	        var inner = this.innerList.dom;
	        var pad = this.list.getFrameWidth('tb')+(this.resizable?this.handleHeight:0)+this.assetHeight;
	        var h = Math.max(inner.clientHeight, inner.offsetHeight, inner.scrollHeight);
	        var ha = this.getPosition()[1]-Ext.getBody().getScroll().top;
	        var hb = Ext.lib.Dom.getViewHeight()-ha-this.getSize().height;
	        var space = Math.max(ha, hb, this.minHeight || 0)-this.list.shadowOffset-pad-2;
	        h = Math.min(h, space, this.maxHeight);
	        
	        this.innerList.setHeight(h);
	        this.list.beginUpdate();
	        this.list.setHeight(h+pad);
	        this.list.alignTo(this.el, this.listAlign);
	        this.list.endUpdate();
	    },
	    
	    /**
	     * Select an item in the dropdown list by its data value. This function does NOT cause the select event to fire.
	     * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
	     * @param {String} value The data value of the item to select
	     * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
	     * selected item if it is not currently in view (defaults to true)
	     * @return {Boolean} True if the value matched an item in the list, else false
	     */
	    selectByValue : function(v, scrollIntoView){
//	        if(v !== undefined && v !== null){
//	            var r = this.findRecord(this.valueField || this.displayField, v);
//	            if(r){
//	                this.select(this.store.indexOf(r), scrollIntoView);
//	                return true;
//	            }
//	        }
	        return false;
	    },

	    /**
	     * Select an item in the dropdown list by its numeric index in the list. This function does NOT cause the select event to fire.
	     * The store must be loaded and the list expanded for this function to work, otherwise use setValue.
	     * @param {Number} index The zero-based index of the list item to select
	     * @param {Boolean} scrollIntoView False to prevent the dropdown list from autoscrolling to display the
	     * selected item if it is not currently in view (defaults to true)
	     */
	    select : function(index, scrollIntoView){
	        this.selectedIndex = index;
	        this.view.select(index);
	        if(scrollIntoView !== false){
	            var el = this.view.getNode(index);
	            if(el){
	                this.innerList.scrollChildIntoView(el, false);
	            }
	        }
	    },

	    // private
	    selectNext : function(){
	        var ct = this.store.getCount();
	        if(ct > 0){
	            if(this.selectedIndex == -1){
	                this.select(0);
	            }else if(this.selectedIndex < ct-1){
	                this.select(this.selectedIndex+1);
	            }
	        }
	    },

	    // private
	    selectPrev : function(){
	        var ct = this.store.getCount();
	        if(ct > 0){
	            if(this.selectedIndex == -1){
	                this.select(0);
	            }else if(this.selectedIndex != 0){
	                this.select(this.selectedIndex-1);
	            }
	        }
	    },
	    
	    /**
	     * @override
	     * Propagates a value change at the displayed data list.
	     */
	    onUpdateView: function() {
	    	var option = {};
	    	
	    	if(this.data instanceof Array) {
	    		Ext.apply(option, this.otherParams);
	    		
	    		option.value = this.data;
	    		
	    		if(this.lastValue && this.lastValue != option) {
	    			this.valueChangedCB(option);	    			
	    		}
	    		
	    		this.lastValue = option;
	    	}
	    }
	});
}();

/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

ns("glossary");

(function() {

	var STORE_ID = "/glossarycategory";
	var PREFIX = STORE_ID + "/";

	var DUMMY_RECORD = [PREFIX, "", "", false];

	var TPL =
		'<tpl for=".">' +
			'<div class="x-combo-list-item">' +
				// Inden +
				'<tpl if="child">' +
					'<span style="margin-left:10px;">' +
				'</tpl>' +
				// Or not inden +
				'<tpl if="!child">' +
					'<span>' +
				'</tpl>' +
					'<div class="x-glossary-color" style="background-color:{color};"></div>' +
					'{name}' +
				'</span>' +
			'</div>' +
		'</tpl>';

	Signavio.glossary.CategorySelector = function(attrs) {
		attrs = attrs || {};

		this.blacklist = attrs.without || [];

		this.configure(attrs);
		this.extendStore(attrs.categoryStore);

		this.showAll = attrs.showAll;
		this.originID = attrs.originID;
		this.writableOnly = !!attrs.writableOnly;
		
		if (this.writableOnly) {
			this.requestWritableCategories();
		}

		attrs.store = this.createStore(attrs.categoryStore, attrs.showDummy, attrs.hideChildren);

		if(attrs.value && !this.categoryAvailable(attrs.categoryStore, attrs.value)) {
			delete attrs.value;
		}

		Signavio.glossary.CategorySelector.superclass.constructor.apply(this, arguments);

		var that = this;

		this.on("blur", function() {
			that.restoreDomValue();

			return false;
		});
	};

	Ext.extend(Signavio.glossary.CategorySelector, Ext.form.ComboBox, {

		boolDefault: function(value, defaultValue) {
			return Ext.isDefined(value) ? value : defaultValue;
		},

		categoryAvailable: function(store, ref) {
			var index = store.findBy(function(record) {
				return record.get("href") === ref;
			});

			return index !== -1;
		},

		configure: function(attrs) {
			Ext.applyIf(attrs, {
				dataField: "category",
				fieldLabel: Ext.ux.getI18N("glossary.category.label"),
				displayField: "name",
				valueField: "id",
				forceSelection: true,
				mode: 'local',
				readOnly: true,
				allowBlank: this.boolDefault(attrs.showDummy, false),
				triggerAction: 'all',
				lazyRender: this.boolDefault(attrs.lazyRender, true),
				lazyInit: this.boolDefault(attrs.lazyInit, false),
				hideChildren: this.boolDefault(attrs.hideChildren, false),
				tpl: TPL,
				showDummy: this.boolDefault(attrs.showDummy, false)
			});
		},
		
		requestWritableCategories: function() {
			/*
			 * Callback after the writable categories have been loaded
			 * to only keep these categories in the dropdown box.
			 */ 
			var categoryLoadCallback = function(records) {
				var writableCategories = records.collect(function(record) {
					return record.get("href");
				});
				this.removeNonWritableCategories(writableCategories);
			}.bind(this);
			
			/*
			 * Necessary switch because this component is used from editor
			 * and glossary/explorer, the former does not have the StoreManager.
			 */ 
			if (typeof (Signavio.Core.StoreManager) === "undefined") {
				var store = new Ext.data.Store({
		            proxy: new Ext.data.HttpProxy({
		            	useAjax	: true,
		            	method	: "GET", 
		            	headers	: {accept:"application/json"},
		                url		: '/p/glossarycategory?originId=' + this.originID + '&allCategories=true&withWritePrivOnly=true' 
		            }),
		            reader: new Signavio.Helper.RecordReader({rels:["cat"]})
		        });
				store.load({callback: categoryLoadCallback});
			} else {
				var categoryURL = '/glossarycategory?allCategories=true&withWritePrivOnly=true';
				Signavio.Core.StoreManager.getRelatedStore(categoryURL, categoryURL, null, {callback : categoryLoadCallback});
			}
		},

		extendStore: function(store) {
			if(store.getRecords) {
				return;
			}

			// This code was copied from the explorer. The getRecords method
			// should be present on ALL stores in the system. This code here
			// needs to be removed once the Editor and Explorer share the
			// same store structure.
			store.getRecords = function(rel) {
				var recs = [];
				rel = rel instanceof Array ? rel : (rel ? [rel] : null);

				(this.snapshot || this.data).each(function(r){
					if( !rel || rel.include(r.get("rel")) ){
						recs.push(r);
					}
				});

				return recs;
			};
		},

		parseRecords: function(records) {
			var categories = {
				root: []
			};

			var that = this;

			records.sortBy(function(record) {
				var rep = record.get("rep");

				return rep.order;
			}).each(function(record) {
				var rep = record.get("rep");
				var parent = rep.parentCategory || "root";

				if(!categories[parent]) {
					categories[parent] = [];
				}

				if(rep.hidden && !that.showAll) {
					return;					
				}

				categories[parent].push(rep);
			});

			return categories;
		},

		createData: function(categories, hideChildren) {
			var data = [];
			var that = this;

			var addRecord = function(record) {
				if(that.blacklist.include(record.id)) {
					return;
				}

				data.push([
					record.id || "",
					record.name || "",
					record.color,
					Ext.isDefined(record.parentCategory)
				]);
			};

			categories.root.each(function(record) {
				addRecord(record);

				if(categories[record.id] && !hideChildren) {
					categories[record.id].each(addRecord);
				}
			});

			return data;
		},

		createStore: function(categoryStore, prependNone, hideChildren) {
			
			// The category store should be removed once all 
			// components share the same store architecture!
			// It should be replaced by something like:
			// Signavio.Core.StoreManager.getCategoryStore();
			var records = categoryStore.getRecords("cat");

			var categories = this.parseRecords(records);
			var data = this.createData(categories, hideChildren);

			if(prependNone) {
				data = [DUMMY_RECORD].concat(data);
			}

			return new Ext.data.SimpleStore({
				fields: ["id", "name", "color", "child"],
				data: data
			});
		},
		
		removeNonWritableCategories: function(writableCategories) {
			var that = this;
			var toRemove = [];
			
			this.store.each(function(record) {
				if (!writableCategories.include(record.get("id"))) {
					toRemove.push(record);
				}
			});
			
			toRemove.each(function(toRemoveRecord) {
				that.store.remove(toRemoveRecord);
			});
		},

		getValue: function() {
			var value = Ext.form.ComboBox.prototype.getValue.apply(this);

			if(value.replace(PREFIX, "") === "") {
				return null;
			}

			return value;
		},

		restoreDomValue: function() {
			this.el.dom.value = (this.el.dom.value || "").unescapeHTML();
		},

		setValue: function() {
			Ext.form.ComboBox.prototype.setValue.apply(this, arguments);

			this.restoreDomValue();
		}
	});

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
ns("glossary.config");

(function() {

	Signavio.glossary.config.REL = {
		GLOSSARY_ITEM: "gitem",
		ATTACHMENT: "att",
		LINK: "link",
		INFO: "info",
		LINKED: "glossarylink",
		CATEGORY: "cat"
	};

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
ns("glossary");

(function() {

	var STORE_ID = "/glossarycategory";
	var PREFIX = STORE_ID + "/";

	Signavio.glossary.Editor = function(attrs) {
		attrs = attrs || {};

		this.prepareDefaults(attrs);

		Signavio.glossary.Editor.superclass.constructor.call(this, attrs);

		var that = this;

		this.on("resize", function() {
			that.updateSize();
		});

		this.fields = [];
		this.currentCategory = attrs.category;
		this.withoutCategories = attrs.withoutCategories;
		this.originID = attrs.originID;

		var data = this.extractInfo(this.store);
		this.changeCategory(this.getCategory(data), data);
	};

	Ext.extend(Signavio.glossary.Editor, Ext.ux.Window, {

		prepareDefaults: function(attrs) {
			attrs.minHeight = 450;
			attrs.minWidth = 900;

			attrs.width = Math.max(attrs.width || 0, document.viewport.getWidth() * 0.7, attrs.minWidth);
			attrs.height = Math.max(attrs.height || 0, document.viewport.getHeight() * 0.7, attrs.minHeight);

			attrs.title = attrs.store ? Ext.ux.getI18N("glossary.edit.title") : Ext.ux.getI18N("glossary.new.title");

			attrs.cls = "x-glossary-new";
			attrs.modal = true;
			attrs.autoScroll = true;
			attrs.layout = "form";
			attrs.labelWidth = 150;
			attrs.onEsc = Ext.emptyFn;

			attrs.onSave = attrs.onSave || Ext.emptyFn;

			var that = this;

			attrs.buttons = attrs.buttons || [
				{
					text: attrs.store ? Ext.ux.getI18N("glossary.edit.save") : Ext.ux.getI18N("glossary.new.save"),
					handler: function() {
						var win = this.ownerCt;

						attrs.onSave(win, that.extractParams(that.getFields()));
					}
				}
			];
		},

		getStore: function() {
			return this.store;
		},

		getFields: function() {
			return this.fields;
		},

		clearFields: function() {
			var that = this;

			(this.items || []).each(function(item) {
				that.remove(item);
			});

			this.fields.clear();
		},

		addField: function(field) {
			this.fields.push(field);
		},

		getLabels: function() {
			var iterate = function(children, labels){
				labels = labels || [];

				children.each(function(child){
					if (!child instanceof Ext.Panel){
						return;
					}

					if (child instanceof Ext.ux.form.TranslationField) {
						return;
					}

					if(child.items && child.items.getCount()){
						return iterate(child.items, labels);
					}

					labels.push(child);
				});

				return labels;
			};

			return iterate(this.items || []);
		},

		extractInfo: function(store) {
			if (!store) {
				return {
					category: "",
					title: "",
					description: "",
					glossaryLinks: [],
					attachments: [],
					formats: {},
					metaDataValues: {}
				};
			}

			var data = {};

			// Info
			var info = store.getRecords(Signavio.glossary.config.REL.INFO)[0];
			var rep = info.get("rep");

			if(!rep.category.startsWith(PREFIX)) {
				rep.category = PREFIX + rep.category;
			}

			// Category
			data.category = rep.category;
			// Title
			Ext.apply(data, Signavio.glossary.utils.getValuesFor(info.get("rep"), "title", function(title){
				return Signavio.Utils.unescapeHTML(title||"");
			}));
			// Description
			Ext.apply(data, Signavio.glossary.utils.getValuesFor(info.get("rep"), "description", function(desc){
				return Signavio.Utils.unescapeHTML(desc||"");
			}));
			//  Linked Attachments
			Ext.apply(data, Signavio.glossary.utils.getValuesFor(info.get("rep"), "attachments", function(v) {
				return v.clone();
			}));
			
			// Linked Models
			var glossaryLinks = store.getRecords(Signavio.glossary.config.REL.LINKED)[0];
			data.glossaryLinks = glossaryLinks.get("rep").map(function(link) {
				return Signavio.Core.RecordCreator.create(link.rel, link.href, link.rep);
			});
			
			// Formats
			data.formats = Object.clone(info.get("rep").formats || {});
			
			// Meta Data
			data.metaDataValues = Object.clone(info.get("rep").metaDataValues || {});
			
			return data;
		},

		onCategoryChange: function(value) {
			if (this.currentCategory === value){
				return;
			}

			this.currentCategory = value;

			var that = this;

			this.body.fadeOut({
				duration : 0.3,
				callback: function(){
					// Get the data
					var data = that.extractParams(that.getFields());

					var correctData = function(parent, data) {
						if(!parent.items) {
							return;
						}

						parent.items.each(function(item) {
							if(item.dataField && item.records){
								data[item.dataField] = item.records;
							}

							correctData(item, data);
						});
					};

					// Get the missing records
					correctData(that, data);

					that.changeCategory(value, data);
				}
			});
		},

		changeCategory: function(value, data) {
			this.clearFields();
			
			delete this.items;
			
			if(this.rendered) {
				this.body.update();
				this.body.show();
				this.body.setOpacity(0.01);
			}
			
			this.addItems(data);
			
			if(this.rendered) {
				// Update size
				this.doLayout();
				this.updateSize();
				this.doLayout();
				
				// Show the content
				this.body.fadeIn({
					duration: 0.3
				});
				
				this.syncSize();
			} else {
				Signavio.Utils.defer(function() {
					if(!this.rendered) {
						return;
					}

					this.updateSize();
				}, this);
			}
		},

		updateSize: function() {
			var width = this.getInnerWidth() - this.body.getPadding("lr") - this.labelWidth - 25;
			
			this.getFields().each(function(item) {
				if (item instanceof Ext.ux.form.TranslationField || item.translation) {
					return;
				}
				
				item.setWidth(width);
			});

			// Update translation box
			if(this.translation) {
				this.translation.updateSize();
			}
			
			// Set height of textareas
			// var height = this.getInnerHeight() - this.body.getPadding("tb") - 60;
			var height = this.getInnerHeight();
			
			// Seperate all items into Textareas and others
			var partitions = [].concat(this.getFields(), this.getLabels()).partition(function(item) {
				return (item instanceof Ext.form.TextArea) || (item instanceof Ext.ux.form.RichtextEditor);
			});

			var textareas = partitions[0];
			var remainder = partitions[1];
			
			if (textareas.length === 0) {
				return;
			}
			
			// Subtract height from others
			remainder.each(function(r) {
				if (!r.rendered || !r.el) {
					return;
				}
				
				var el = r instanceof Ext.form.TriggerField ? r.container : r.el;
				height -= el.getHeight() + el.getPadding("tb") + el.getMargins("tb");
				// height = height - (r.getInnerHeight ? r.getInnerHeight() : el.getHeight());
			});
			
			var textHeight = Math.max(height / textareas.length, 160);
			
			// Set height to Textareas or richtext editors
			textareas.each(function(text){
				if (text.translation){
					text.setHeight(textHeight);
					
					if(text.translation.origin) {
						text.translation.origin.setHeight(textHeight+3);
					}
				} else {
					text.setSize(width, textHeight);
				}
			});
		},

		createTranslationForm: function(items, data) {
			if(!items || items.length === 0) {
				return;
			}

			this.translation = new Ext.ux.form.TranslationForm({
				items: items,
				languages: this.languages,
				language: this.languages.first(),
				editing: this.editing,
				originData: data
			});

			this.add(this.translation);
		},

		addItems: function(data) {
			var languages = this.languages;
			
			var standard = this.createStandardFields(data);
			var additional = this.createAdditionalFields(data);
			var all = standard.concat(additional);
			
			var that = this;

			var partition = all.partition(function(field) {
				// doing this here in order to not 
				// reiterate the list
				that.addField(field);
				
				return languages.length > 1 && (field.multilanguage || field.dataField === "glossaryLinks");
			});
			
			var multilanguage  = partition[0];
			var singlelanguage = partition[1];
						
			// Add the standard fields
			[].without.apply(standard, multilanguage).each(function(field) {
				that.add(field);
			});
						
			// Add translation panel
			this.createTranslationForm(multilanguage, data);
			
			// Add the rest fields
			[].without.apply(singlelanguage, standard).each(function(field, i) {
				if (i === 0 && multilanguage.length > 0){
					that.add(new Ext.Panel({
						html: Ext.ux.getI18N("glossary.multilanguage.non_attributes"),
						border: false,
						cls: "y-translation-hint",
						style: "width: auto",
						autoWidth: true
					}));
				}

				that.add(field);
			});
		},

		createStandardFields: function(data) {
			var fields = [];
			
			// Label
			var label = this.getLabel();
			fields.push(label);
			
			// Category
			var category = this.getCategory(data);
			var categoryField = this.getCategorySelector(category);
			fields.push(categoryField);
			
			// Title
			var title = this.generateTitleField(data.title);
			title.values = this.getValuesForMultilanguage(data, "title");
			this.getTitleField = function() {
				return title;
			};
			fields.push(title);
			
			// Glossary Links
			var links = this.getLinkListField(data.glossaryLinks);
			this.getGlossaryLinksField = function() {
				return links;
			};
			fields.push(links);
			
			// Description
			var descriptionField = this.getDescriptionField(data);
			fields.push(descriptionField);
			
			// Attachments
			var attachmentsField = this.getAttachmentsField(data.attachments);
			attachmentsField.values = this.getValuesForMultilanguage(data, "attachments", function(v) {
				return v.clone();
			});
			fields.push(attachmentsField);
			
			return fields;
		},

		getLabel: function() {
			var text = Ext.ux.getI18N("glossary.new.create");
			
			if(this.store) {
				text = Ext.ux.getI18N("glossary.edit.description");
			}
			
			return new Ext.Panel({
				html	: text,
				border	: false,
				cls: "y-translation-hint"
			});
		},

		getCategorySelector: function(category) {
			var that = this;

			return new Signavio.glossary.CategorySelector({
				value			: category,
				categoryStore	: that.categoryStore,
				without			: that.withoutCategories,
				writableOnly	: true,
				originID		: that.originID,
				listeners		: {
					change: function(t,value){
						that.onCategoryChange(value);
					},
					select: function(t,value){
						that.onCategoryChange(value.get("id"));
					}
				}
			});
		},

		/**
		 * Parse to the new format no matter what
		 */
		getCategory: function(data) {
			// Include fallback to parse the old format, just in case, y'know...?
			var category = (data.category || this.currentCategory).split("=").last();
			
			return category.startsWith(PREFIX) ? category : PREFIX + category;
		},

		generateTitleField: function(title) {
			var that = this;

			return Ext.ux.form.FieldFactory.generate("MetaDataGlossaryLink", {
				dataField: "title",
				fieldLabel: Ext.ux.getI18N("glossary.view.title"),
				value: title,
				multilanguage: true,
				showEmptyItems: false,
				forceSelection: false,
				hiddenItems: this.store && this.store.id ? [this.store.id] : [],
				languages: this.languages,
				language: this.languages.first(),
				getSearchQuery: function(){
					var me = this;
					var value = this.getRawValue().slice(0, this.getCursorPosition()).toLowerCase().replace(/\s+/g, " ");
					value = " " + value + " ";

					var records = that.getGlossaryLinksField().records || [];
					var lastWords = records.map(function(r) {
						var title = me.translate(r.get("rep"), "title") || "";
						
						return " " + title.trim().split(/\s+/g).last().toLowerCase() + " ";
					}).uniq();
					var lastIndex = 0;
					
					lastWords.each(function(word){
						lastIndex = value.include(word) ? Math.max(value.indexOf(word)+word.length, lastIndex) : lastIndex;
					});
					
					return value.slice(lastIndex).trim();
				},
				getValue: function(){
					return this.getRawValue();
				},
				onNewRecord: function(record){
					that.getGlossaryLinksField().onSelect(record);
					delete this.records;
				},
				listeners: {
    				/* There is a nasty focus-bug in IE (See: http://bugs.jquery.com/ticket/12319): 
    				 * The richtext editor's iframe will block
    				 * any focus (by clicking) on any input inside the editingWindow.
    				 * Workaround: manually set focus on the title text input.
    				 */
					render: function(titleField) {
						titleField.focus(false, 1000);
					}
				}
			});
		},

		getAttachmentsField: function(attachments) {
			var attachmentTemplate = new Ext.XTemplate(
				'<ol>' +
					'<tpl for=".">' +
						'<li>' +
							'<a href="{url}" target="_blank" tabindex="-1">' +
								'{[Signavio.Utils.escapeHTML(values.label || values.url)]}' +
							'</a> ' +
							'<span class="x-smaller">' +
								'(<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">' +
									'{[Ext.ux.getI18N("btnRemove")]}' +
								'</a>)' +
							'</span>' +
						'</li>' +
					'</tpl>' +
				'</ol>'
			);
			
			return Ext.ux.form.FieldFactory.generate("MetaDataUrlList", {
				dataField		: "attachments",
				fieldLabel		: Ext.ux.getI18N("glossary.view.attachments"),
				lineWrap		: true,
				multilanguage	: true,
				data			: attachments||[],
				itemFieldTpl	: attachmentTemplate
				
			});
		},

		getDescriptionField: function(data) {
			var description = data.description;
			var formats = data.formats;
			var that = this;
			
			if(this.richtextEnabled	&& formats && formats.description instanceof Array) {
				description = Ext.ux.Richtext.encode(description, formats.description);
			}
						
			// Encode all descriptions in all languages
			var descriptions = this.getValuesForMultilanguage(data, "description");
			if (this.richtextEnabled){
				$H(descriptions).each(function(pair){
					var key = "description";

					if(that.languages.first() && pair.key !== that.languages.first()) {
						key = key + "_" + pair.key;
					}

					if (formats[key] instanceof Array){
						descriptions[pair.key] = Ext.ux.Richtext.encode(descriptions[pair.key], formats[key]);
					}
				});
			}
			
			return Ext.ux.form.FieldFactory.generate("MetaDataStringInfo", {
				dataField		: "description",
				fieldLabel		: Ext.ux.getI18N("glossary.view.description"),
				lineWrap		: true,
				multilanguage	: true,
				richtextEnabled	: this.richtextEnabled,
				value			: description,
				values			: descriptions,
				editingWindow	: this // the richtext created can be replaces by normal text
			});
		},

		getLinkListField: function(links) {
			var that = this;

			return Ext.ux.form.FieldFactory.generate("MetaDataGlossaryLinkList", {
				dataField	: "glossaryLinks",
				hideInput	: true,
				fieldLabel	: "", //Signavio.I18N.Glossary.View.linkedGlossaryItems,
				labelSeparator: "",
				records		: links || [],
				languages	: this.languages,
				language	: this.languages.first(),
				updateView	: function(){
					var empty = this.records.length === 0;

					this.container.parent().first().setDisplayed(true);
					this.container.parent(".x-form-item").setDisplayed(!empty);
					
					// shouldn't be necessary anymore as title field counts to multilanguage section
					that.getTitleField().container.parent()[empty ? "removeClass" : "addClass"]("x-no-margin");
				},
				getValue: function(){
					var value = (this.records || []).map(function(rec) {
						return rec.get("href") || rec.get("rep");
					});
					
					var exclude = (that.getTitleField().getValue() || "").strip();
				
					return value.findAll(function(v){
						// TODO: Use multilanguage
						return typeof v === "string" || (!exclude || !v.title !== exclude);
					});
				}
			});
		},

		createAdditionalFields: function(data) {
			var category = this.getCategory(data),
				metaData = data.metaDataValues || {},
				formats = data.formats || {},
				me = this;
			
			var fields = [];
			
			this.getMetaData(category).each(function(meta){
				var metaInfo = meta.get("rep");
				var className = metaInfo.type + (!!metaInfo.isList ? "List" : "");
				var value = metaData[metaInfo.id] || metaInfo.defaultValue || "";
				
				if (value instanceof Array){
					value = value.clone();
				} else if (value instanceof Object){
					value = Object.clone(value);
				}
				
				/* Richtext */
				if (this.richtextEnabled &&
					formats[metaInfo.id] instanceof Array &&
					metaData[metaInfo.id]) {
					
					value = Ext.ux.Richtext.encode(metaData[metaInfo.id], formats[metaInfo.id]);
				}
				
				var defaultValue = "";
				
				if(metaInfo.defaultValue !== metaData[metaInfo.id]) {
					defaultValue = metaInfo.defaultValue || defaultValue;
				}
				
				
				// Encode all values in all languages
				var values = this.getValuesForMultilanguage(metaData, metaInfo.id);
				if (this.richtextEnabled){
					$H(values).each(function(pair){
						var key = metaInfo.id+(!me.languages.first() || pair.key === me.languages.first() ? "" : "_"+pair.key);
						if (formats[key] instanceof Array){
							values[pair.key] = Ext.ux.Richtext.encode(values[pair.key], formats[key]);
						}
					});
				}
				
				var field = Ext.ux.form.FieldFactory.generate(className, Ext.apply({
					dataField	: "metaDataValues." + metaInfo.id,
					fieldLabel	: metaInfo.name,
					richtextEnabled	: this.richtextEnabled,
					//emptyText	: "",
					defaultValue: defaultValue,
					values		: values,
					languages	: this.languages,
					linkableType: metaInfo.category? (metaInfo.category.startsWith(PREFIX)? metaInfo.category : (PREFIX + metaInfo.category)) : "",
					language	: this.languages.first(),
					editingWindow: this // if richtext, it can later be replaced
				}, metaInfo, ["MetaDataStringInfoList"].include(className) ? {data: value || []} : {value: value}));
				
				fields.push(field);
			}.bind(this));
			
			return fields;
		},

		getValuesFor: function(data, key, fn){
			var obj = {};
			
			fn = fn ? fn : Prototype.K;

			$H(data).each(function(pair){
				// Attention: Key must not have an _ as character
				if (pair.key === key || pair.key.startsWith(key + "_")) {
					obj[pair.key] = fn(pair.value);
				}
			});

			return obj;
		},

		getValuesForMultilanguage: function(data, key, fn){
			var obj = {};
			var defaultLanguage = this.languages.first();
			
			$H(Signavio.glossary.utils.getValuesFor(data, key, fn)).each(function(pair){
				obj[pair.key === key ? defaultLanguage||key : pair.key.replace(key+"_", "")] = pair.value;
			});

			return obj;
		},
		
		getBaseParams: function(){
			return {
				language:"en", 
				title:"", 
				description:""
			};
		},

		validateValue: function(value){
			if (typeof value !== "string"){
				return value;
			}
			
			// Replace invalid characters (see https://github.com/douglascrockford/JSON-js/blob/master/json2.js for more information)
			return value.replace(/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, '');
		},

		extractParams: function(items){
			
			var params = this.getBaseParams();
			var me = this;
			var defaultLanguage = this.languages.first();

			params.formats = params.formats || {};
			
			items.each(function(item){
				if (!item.dataField) {
					return;
				}
				
				// WHAT THE FUCK!?
				// Get the language for the item
				var lang = item.multilanguage &&
					item.translation &&
					item.ownerCt.ownerCt.ownerCt instanceof Ext.ux.form.TranslationForm &&
					item.translation.language;

				if (lang && lang === defaultLanguage) {
					lang = false;
				}
				
				// Define the default language
				var values = {};
				values[lang || defaultLanguage] = me.validateValue(item.getValue());
				
				if (item.translation instanceof Ext.ux.form.TranslationField && item.translation.values){
					values = Ext.apply({}, values, item.translation.values);
				}
				
				$H(values).each(function(pair){
					var language = pair.key !== "undefined" ? pair.key : undefined;
					var value = pair.value;
						
					// Get the key and property
					var key = item.dataField + (language && language !== defaultLanguage ? "_" + language : ""),
						property = params;
					
					// For complex properties, try to find the right one
					if (item.dataField.include(".")){
						var keys = item.dataField.split(".");
						// If the property and the structure defined by the
						// different keys, does not exist in the current
						// params, create it.
						keys.slice(0, keys.length - 1).each(function(key) {
							if (!property[key]) {
								property[key] = {};
							}
							property = property[key];
						});

						key = keys.last() + (language && language !== defaultLanguage ? "_" + language : "");
					}
					
					if (!(item instanceof Ext.ux.form.RichtextEditor)) {
						property[key] = me.validateValue(value);
					} else {
						var doc = document.createElement("body");
						// strict mode cant handle &nbsp; correctly, replace them with hex code
						value = value.replace(/&nbsp;/g, "&#160;");
						doc.innerHTML = value;
						var decoded = Ext.ux.Richtext.decode(doc);
						
						if (decoded.text.trim()){
							property[key] = decoded.text;
							// Save the formats for each data field
							params.formats[key] = decoded.format;
						}else{
							params.formats[key] = [];
							// set empty description
							property[key] = "";
						}
					}
				});
			});
			
			// adding defaults
			params.metaDataValues = params.metaDataValues || {};
			params.attachments = params.attachments || [];
			params.glossaryLinks = params.glossaryLinks || [];
			
			return params;
		}

	});

}());
/**
 * Copyright (c) 2013
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
ns("glossary.utils");

(function() {

	Signavio.glossary.utils.getValuesFor = function(data, key, fn){
		var obj = {};

		fn = fn ? fn : Prototype.K;

		$H(data).each(function(pair){
			// Attention: Key must not have an _ as character
			if (pair.key === key || pair.key.startsWith(key + "_")) {
				obj[pair.key] = fn(pair.value);
			}
		});

		return obj;
	};

}());
/**
 * Copyright (c) 2012
 * Lukas Brand
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

/**
 * Define namespaces
 */
if ("undefined" == typeof window.Ext){ window.Ext = {}; }
if ("undefined" == typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" == typeof Ext.ux.grid){ Ext.ux.grid = {}; }

(function() {    
	Ext.ux.grid.IKSEditorGridPanel = function(config) {
		Ext.apply(this, config);
		Ext.ux.grid.IKSEditorGridPanel.superclass.constructor.call(this, config);
	};
	
	Ext.ux.grid.IKSEditorGridPanel = Ext.extend(Ext.grid.EditorGridPanel, {
		
		startEditing : function(row, col, typeValue, trueOldValue) {
			this.stopEditing();
			if (this.colModel.isCellEditable(col, row)) {
				this.view.ensureVisible(row, col, true);
				var r = this.store.getAt(row);
				var field = this.colModel.getDataIndex(col);
				
				var columnConfig = this.colModel.getColumnById(col)||this.colModel.config[col];
				
				var value = r.data[field];
				
				var e = {
					grid : this,
					record : r,
					field : field.field || field,
					value : value,
					row : row,
					column : col,
					cancel : false
				};
				if (this.fireEvent("beforeedit", e) !== false && !e.cancel) {
					this.editing = true;
					var ed = this.colModel.getCellEditor(col, row);
					if ("undefined" === typeof (ed)) {
						return;
					}
					if (!ed.rendered) {
						ed.initialOpen = true;
						
						ed.render(this.view.getEditorParent(ed));
					}
					(function() {
						// complex but required for focus issues in safari, ie and opera
						if (!this.editing) {
							return;
						}
						ed.row = row;
						ed.col = col;
						ed.record = r;
						ed.trueOldValue = trueOldValue || r.data[field];
						ed.selectionModel = this.selModel;
						if (ed.trueOldValue instanceof Array) {
							ed.trueOldValue = ed.trueOldValue.clone();
						}
						ed.on("complete", this.onEditComplete, this, {
							single : true
						});
						ed.on("specialkey", this.selModel.onEditorKey, this.selModel);
						
						this.activeEditor = ed;
						var v;
						if (ed.field.requiresComplexData) {
							v = {
								existing : this.preEditValue(r, field),
								typed : typeValue ? typeValue : ""
							};
						}
						
						else {
							if (typeValue === undefined) {
								v = this.preEditValue(r, field);
							}
							else {
								v = typeValue;
							}
						}
						
						// If cell is empty and a default value exists
						if (v === "" && columnConfig.defaultValue) {
							v = columnConfig.defaultValue;
						}
						
						ed.startEdit(this.view.getCell(row, col), v);
					}).defer(50, this);
					
					// Fix for cursor position on initial editor open via typing
					if (ed.initialOpen) {
						window.setTimeout(function() {
							var rv = ed.field.el.dom.value;
							var field = ed.field.field||ed.field;
							field.reset();
							field.setRawValue(rv);
							delete ed.initialOpen;
						}, 50);
					}
					
				}
			}
		},
		
		onEditComplete : function(ed, value, startValue) {
			Ext.grid.EditorGridPanel.prototype.onEditComplete.call(this, ed, value, ed.trueOldValue);
		}
	});
}());
/**
 * Copyright (c) 2013
 * Lukas Brand, Christian Wiggert
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

/**
 * Define namespaces
 */
if ("undefined" == typeof window.Ext){ window.Ext = {}; }
if ("undefined" == typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" == typeof Ext.ux.grid){ Ext.ux.grid = {}; }

(function() {

    /**
     * This field class works in combination with the NestableEditorGridPanel and allows
     * to embed another NestableEditorGridPanel within an existing one. 
     * @param config configuration for the NestedGridField
     * Possible configuration options:
     * - {String} fieldId : an identifier for this field
     * - {String} emptyText : a text that will be shown when there is no content to render or the field is expanded
     * - {Boolean} noText : indicates that no content shall be rendered
     * - {Ext.XTemplate}||{Ext.Template}||{String} renderTpl : a template that defines the content that will be rendered
     * @param store the store that contains the contents for the nested grid, it will be used for the nested grid
     * To work properly, the store should contain a field 'parentId' which references the 'id' of the parent row in the parent grid.
     * Furthermore, a field 'id' should be defined which identifies every row in the store.
     * @param colModel the ColumnModel for the nested grid
     * @param gridConfig the configuration for the nested grid
     **/
    Ext.ux.form.NestedGridField = function(config, store, colModel, gridConfig) {
        var defaultValues = {
            id          : Ext.id(),
            fieldId     : 'source',
            emptyText   : Ext.ux.getI18N('NEGP.nestedField.emptyText')
        };
        Ext.apply(this, config, defaultValues);
        this.store = store;
        this.colModel = colModel;
        this.initialColConfig = this.colModel.config;
        this.nestedGridFields = colModel.config.findAll(function(entry) {
            return entry instanceof Ext.ux.form.NestedGridField;
        });
        this.gridConfig = gridConfig || {};
        if (!this.gridConfig.emptyText) {
            this.gridConfig.emptyText = config.emptyText;
        }
        this.renderer = this.renderer.createDelegate(this);
        Ext.ux.form.NestedGridField.superclass.constructor.call(this, config);
    };

    Ext.extend(Ext.ux.form.NestedGridField, Ext.form.Field, {
        init : function(grid) {
            this.grid = grid;
            this.grid.on("render", function() {
                var view = this.grid.getView();
                view.mainBody.on("click", this.onClick, this);
            }, this);
        },

        onClick : function(e, t) {
            if (!Ext.get(t).hasClass("x-grid3-" + this.fieldId + "-" + this.id)) {
                // in some browser the pointer-events does not work, so check if the click happened on a child element
                var parent = Ext.fly(t).findParent(".x-grid3-" + this.fieldId + "-" + this.id, 3, true);
                if (parent) {
                    t = parent;
                }
            }
            if (Ext.get(t).hasClass("x-grid3-" + this.fieldId + "-" + this.id)) {
                e.stopEvent();

                // Remove any existing confirm hints
//              this.plugin.clearActiveConfirmHints();

                var inner = Ext.get(t).parent(".x-grid3-cell-inner");
                var cell = inner.parent(".x-grid3-cell");
                var row = cell.parent(".x-grid3-row-table");

                var index = this.grid.getView().findRowIndex(row.dom);
                // Get the active record
                var record = this.grid.store.getAt(index);
                var level = (this.grid.level || 0);

                // Find expanded nodes in the control column and close them
                Ext.DomQuery.select(".y-nestedgrid-parent .expanded").without(cell.dom).each(function(node) {
                    var $node = Ext.fly(node);
                    var m = $node.dom.className.match(/hierarchy-level-(\d+)/);
                    if (m && m[1] > level) {
                        $node.removeClass("expanded");
                        $node.removeClass(m[0]);
                    }
                });

                cell.toggleClass("expanded");

                if (cell.hasClass("expanded")) {

                    var mask = this.grid.getView().el.mask();
                    var ms = mask.dom.style;
                    ms["backgroundColor"] = "#FFFFFF";
                    ms["zIndex"] = 2 * (this.grid.level || 0) + 1; // instead of static 1
                    ms["opacity"] = "0.6";

                    // Close the control grid when the mask over the risk grid was clicked
                    mask.on("click", function() {
                        cell.removeClass("expanded");
                        this.hideNestedGrid(row);
                    }.bind(this));
                    this.grid.mask = mask;

                    cell.originalHeight = cell.getHeight();

                    // we limit the content of the store to the values belonging to the parent row
                    this.filterStore(record.get('id'));

                    this.nestedGrid = this.grid.getNestedGrid(this.fieldId, Ext.apply(this.gridConfig, {
                        store       : this.store,
                        cm          : this.colModel,
                        sourceCell  : inner,
                        cell        : cell,
                        row         : row,
                        parentId    : record.get("id"),
                        value       : this.value,
                        nestedField : this,
                        doResize    : function(parentGrid) {
                            var pBox = parentGrid.el.getBox();
                            var oldBox = this.getBox();

                            // Align the grid nicely inside the parentGrid
                            this.updateBox(Ext.apply(oldBox, {
                                width   : Math.round(pBox.width - 50),
                                x       : Math.round(pBox.x + 40)
                            }));
                        }
                    }));

                    this.nestedGrid.doResize(this.grid);

                    var s = this.nestedGrid.el.dom.style;

                    s["zIndex"] = 2 * (this.nestedGrid.level || 1); // instead of static 1
                    s["border"] = "1px solid #888888";
                    s["borderRadius"] = "1px";
                    s["boxShadow"] = "0px 6px 8px -6px silver";
                    s["position"] = "absolute";

                    // adjust the z-indices of the source field and its grid so the styling will be correct
                    inner.dom.style["zIndex"] = 2 * (this.nestedGrid.level || 1) + 1;
                    this.grid.el.dom.style["zIndex"] = "";
                    cell.addClass("hierarchy-level-" + (this.nestedGrid.level || 1));

                    this.nestedGrid.updateSourceCell();

                    // Show the control grid
                    this.nestedGrid.show();

                    this.nestedGrid.adjustCellHeight();

                    // Reposition the grid
                    this.nestedGrid.el.alignTo(inner, "tl-bl", [0, -1]);
                    this.nestedGrid.doResize(this.grid);
                    this.grid.syncShadow();

                } else if (this.nestedGrid && this.nestedGrid.isVisible()) {

                    this.hideNestedGrid(row);
                }
            }
        },

        initColConfig : function() {
            var config = [];
            this.initialColConfig.each(function(col) {
                config.push(Object.clone(col));
            });
            this.colModel.setConfig(config);
        },

        removeRowsWithParentId : function(parentId) {
            if (this.store && parentId) {
                this.unfilterStore();
                this.filterStore(parentId);
                var ids = [];
                var that = this;
                this.store.each(function(r) {
                    ids.push(r.get('id'));
                    that.store.remove(r);
                });
                // recursively remove the rows in the nested stores
                this.nestedGridFields.each(function(field) {
                    ids.each(function(id) {
                        field.removeRowsWithParentId(id);
                    });
                });
                this.unfilterStore();
                this.store.commitChanges();
            }
        },

        filterStore : function(parentId) {
            if (this.store && parentId) {
                this.store.filter('parentId', parentId);
                this.store.currentParentId = parentId;
            }
        },

        unfilterStore : function() {
            this.store.clearFilter();
            delete this.store.currentParentId;
        },

        hideNestedGrid : function(row) {
            // Hide all child grids
            this.nestedGrid.hideNestedGrids();
            // Hide the grid
            this.nestedGrid.hide();
            // Update the control count in the cell
            this.nestedGrid.updateSourceCell();
            var parentId = this.nestedGrid.parentId;

            // Remove the mask
            this.grid.getView().el.unmask();
            delete this.grid.mask;

            this.grid.detachNestedGrid(this.fieldId);
            delete this.nestedGrid;

            this.unfilterStore();

            this.refreshRow(parentId);
            // reset the z-index of the parent grid
            this.grid.el.dom.style['zIndex'] = 2 * (this.grid.level || 0);

            // Reset the size of the current row
            row.dom.style["height"] = "";
            this.grid.syncShadow();
        },

        refreshRow : function(parentId) {
            if (Ext.isDefined(this.grid.store)) {
                var r = this.grid.store.get('id', parentId);
                if(Ext.isDefined(r)) {
                    this.grid.getView().refreshRow(r);
                }
            }
        },

        getEmptyValue : function() {
            return ["<span class='y-empty-text'>",
                Signavio.Utils.escapeHTML(this.emptyText),
                " <img src='/images/glyphicons/small/more.png'/>",
                "</span>"].join("");
        },

        renderer : function(v, p, record) {
            p.css += 'x-grid3-nested';
            if (this.noText) {
                v = "&nbsp;<span class='y-empty-text'><img src='/images/glyphicons/small/more.png'/></span>";
            } else {
                if (this.store) {
                    v = this.store.getRange().findAll(function(row) {return row.get('parentId') === record.get('id');}).length;
                } else {
                    v = 0;
                }

                if (v === 0) {
                    v = this.getEmptyValue();
                } else {
                    if (Ext.isDefined(this.renderTpl)) {
                        var values = this.store.getRange().findAll(function(row) {return row.get('parentId') === record.get('id');});
                        if (this.renderTpl instanceof Ext.Template) {
                            v = this.renderTpl.apply({'records': values});
                        } else {
                            v = new Ext.XTemplate(this.renderTpl).apply({'records': values});
                        }
                    }

                    // If a value exists, render an edit icon
                    v += " <span class='y-empty-text'><img src='/images/glyphicons/small/more.png'/></span>";

                }
            }

            return ['<div class="x-grid3-nested-col x-grid3-',
                    this.fieldId,
                    '-',
                    this.id,
                    '"><div class="y-cell-value',
                    (this.noText ? ' y-no-text' : ''),
                    '">',
                        // The cell value
                        v,
                    '</div></div>'].join("");
        }
    });


    /**
     * This is the NestableEditorGridPanel, an EditorGridPanel which can contain
     * more nested instances of NestableEditorGridPanels. Another grid can be embedded
     * by defining a NestedGridField in the ColumnModel. 
     * @param config the configuration for this grid
     * The options are inherited from Ext.grid.EditorGridPanel and extended by the following options:
     * - {String} addNewRowText     : the text that shall be shown in the add new row line
     * - {JSONObject} defaultValues : an object where you can define a default value for every field in the store
     * - {JSONArray} additionalIds  : an array with ids of fields that shall be assigned a generated id if a new row is added
     **/
    Ext.ux.grid.NestableEditorGridPanel = function(config) {
        this.view = this.getStripeView(),
        this.nestedGrids = {};
        var cm = config.cm || config.colModel;
        // add the NestedGridFields to the list of plugins,
        // because it is required for their full functionality
        this.nestedGridFields = cm.config.findAll(function(entry) {
            return entry instanceof Ext.ux.form.NestedGridField;
        });
        config.plugins = (config.plugins || []).concat(this.nestedGridFields);
        if (!config.cls && !config.parentGrid) {
            config.cls = 'y-nestedgrid-main';
        }
        if (!Ext.isDefined(config.level) || !config.parentGrid) {
            this.level = 0;
        }
        Ext.apply(this, config);
        Ext.ux.grid.NestableEditorGridPanel.superclass.constructor.call(this, config);
        if (Ext.isDefined(this.selModel)) {
            // seems to be necessary to catch special keys in the editor
            this.selModel.grid = this;
        }
    };

    Ext.extend(Ext.ux.grid.NestableEditorGridPanel, Ext.grid.EditorGridPanel, {

        /* taken from IKSEditorGridPanel */
        startEditing : function(row, col, typeValue, trueOldValue) {
            this.stopEditing();
            if (this.colModel.isCellEditable(col, row)) {
                this.view.ensureVisible(row, col, true);
                var r = this.store.getAt(row);
                var field = this.colModel.getDataIndex(col);

                var columnConfig = this.colModel.getColumnById(col)||this.colModel.config[col];

                var value = r.data[field];

                var e = {
                    grid : this,
                    record : r,
                    field : field.field || field,
                    value : value,
                    row : row,
                    column : col,
                    cancel : false
                };
                if (this.fireEvent("beforeedit", e) !== false && !e.cancel) {
                    this.editing = true;
                    var ed = this.colModel.getCellEditor(col, row);
                    if ("undefined" === typeof (ed)) {
                        return;
                    }
                    if (!ed.rendered) {
                        ed.initialOpen = true;

                        ed.render(this.view.getEditorParent(ed));
                    }
                    (function() {
                        // complex but required for focus issues in safari, ie and opera
                        if (!this.editing) {
                            return;
                        }
                        ed.row = row;
                        ed.col = col;
                        ed.record = r;
                        ed.trueOldValue = trueOldValue || r.data[field];
                        ed.selectionModel = this.selModel;
                        if (ed.trueOldValue instanceof Array) {
                            ed.trueOldValue = ed.trueOldValue.clone();
                        }
                        ed.on("complete", this.onEditComplete, this, {
                            single : true
                        });
                        ed.on("specialkey", this.selModel.onEditorKey, this.selModel);

                        this.activeEditor = ed;
                        var v;
                        if (ed.field.requiresComplexData) {
                            v = {
                                existing : this.preEditValue(r, field),
                                typed : typeValue ? typeValue : ""
                            };
                        } else {
                            if (typeValue === undefined) {
                                v = this.preEditValue(r, field);
                            } else {
                                v = typeValue;
                            }
                        }

                        // If cell is empty and a default value exists
                        if (v === "" && columnConfig.defaultValue) {
                            v = columnConfig.defaultValue;
                        }

                        ed.startEdit(this.view.getCell(row, col), v);
                    }).defer(50, this);

                }
            }
        },

        onRender : function(parent) {
            Ext.ux.grid.NestableEditorGridPanel.superclass.onRender.apply(this, arguments);
            if (!this.parentGrid) {
                parent.addClass('y-nestedgrid-parent');
            }
        },

        onEditComplete : function(ed, value, startValue) {
            // Overwritten version of Ext.grid.EditorGridPanel.prototype.onEditComplete.
            // Support for complex field values was added.
            startValue = ed.trueOldValue;

            this.editing = false;
            this.activeEditor = null;
            ed.un("specialkey", this.selModel.onEditorKey, this.selModel);
            var r = ed.record;
            var field = this.colModel.getDataIndex(ed.col);
            value = this.postEditValue(value, startValue, r, field);
            // startValue might be a complex object
            // assume then it has an ID and run a check against the ID
            if(String(value) !== (typeof startValue === 'object' ? String(startValue.id) : String(startValue) )) {
                var e = {
                    grid: this,
                    record: r,
                    field: field,
                    originalValue: startValue,
                    value: value,
                    row: ed.row,
                    column: ed.col,
                    cancel:false
                };
                if(this.fireEvent("validateedit", e) !== false && !e.cancel){
                    r.set(field, e.value);
                    delete e.cancel;
                    this.fireEvent("afteredit", e);
                }
            }
            this.view.focusCell(ed.row, ed.col);
        },

        /* --- */

        /**
         * Creates a new nested grid and applies the given config. The grid is rendered to the container of this grid.
         * @param {JSONObject} config grid configuration object
         */
        createNestedGrid : function(config) {
            var grid = new Ext.ux.grid.NestableEditorGridPanel(Ext.apply({
                    cls             : 'y-nestedgrid',
                    renderTo        : this.container,
                    border          : false,
                    enableHdMenu    : false,
                    enableColumnMove: false,
                    minColumnWidth  : 100,
                    clicksToEdit    : 1,
                    autoHeight      : true,
                    sm              : this.getSelectionModel(),
                    parentGrid      : this,
                    level           : this.level + 1
                }, config));

            if (Ext.isIE) {
                grid.on("show", function() {
                    this.el.repaint();
                });
            }

            grid.on("afteredit", function() {
                this.store.commitChanges();
            });

            return grid;
        },

        /**
         * Returns a nested grid for the given fieldId. If no respective grid exists yet, a new one will 
         * be created. The given config will be used to initialize the new grid. If there is already a grid
         * it will be initialized with the given config and shown in the parent grids container.
         * @param fieldId ID of the field, the nested grid is connected to
         * @param config the configuration for the nested grid
         **/
        getNestedGrid : function(fieldId, config) {
            var grid = this.nestedGrids[fieldId];
            if (!Ext.isDefined(grid) || grid.el.dom.childNodes.length === 0) {
                // in case of IE the grid might have no child nodes after detaching, so create a new one
                grid = this.createNestedGrid(config);
                this.nestedGrids[fieldId] = grid;
                return grid;
            }
            // update the grid with the new config 
            Ext.apply(grid, config);
            if (grid.detached) {
                this.container.appendChild(grid.el);
                delete grid.detached;
            }
            return grid;
        },

        /**
         * Removes the nested grid for the given field ID from the DOM.
         * 
         * @param fieldId
         */
        detachNestedGrid : function(fieldId) {
            if (this.nestedGrids[fieldId]) {
                var grid = this.nestedGrids[fieldId];
                grid.detached = true;
                grid.el.remove();
            }
        },

        /**
         * Recursively hides all nested grids which are still expanded.
         **/
        hideNestedGrids : function() {
            var that = this;
            Object.keys(this.nestedGrids).each(function(gridId) {
                var grid = that.nestedGrids[gridId];
                if (!grid.detached) {
                    grid.nestedField.hideNestedGrid(grid.row);
                }
            });
        },

        /**
         * Returns a new Ext.grid.GridView with vertical stripes and fitted columns
         */
        getStripeView : function() {
            var me = this;
            return new Ext.grid.GridView({

                forceFit        : true,
                autoFill        : true,
                scrollOffset    : 0,

                findCell : function(el) {
                    if (!el) {
                        return false;
                    }
                    // increased the max depth from 3 to 5 because of the nested content
                    return this.fly(el).findParent(this.cellSelector, 5);
                },

                updateColumnCss: function(){
                    [].concat(this.innerHd, $A(this.getRows())).each(function(row){
                        var i = 0;
                        Ext.get(row).select("td{display!=none}").each(function(cell){
                            cell[(i++%2) === 0 ? "addClass" : "removeClass"]("x-colum-odd");
                        });
                    });
                },

                // @overwrite Update css classes for the row
                updateColumnHidden: function(){
                    var res = Ext.grid.GridView.prototype.updateColumnHidden.apply(this, arguments);
                    this.updateColumnCss();
                    return res;
                },
                // @overwrite Update css classes for the row
                processRows: function(){
                    var res = Ext.grid.GridView.prototype.processRows.apply(this, arguments);
                    this.updateColumnCss();
                    return res;
                },
                // @overwrite Update css classes for the row
                refreshRow: function(){
                    var nestedOpened = Object.keys(me.nestedGrids).any(function(key) {
                        return !!!me.nestedGrids[key].detached;
                    });
                    if (!nestedOpened) {
                        // TODO: change this, by calling the correct adjust height method
                        var res = Ext.grid.GridView.prototype.refreshRow.apply(this, arguments);
                        this.updateColumnCss();
                        return res;
                    }
                },

                /**
                 * Extend the renderUI method to add an addRow-button after the real grid
                 */
                renderUI : function() {
                    Ext.grid.GridView.prototype.renderUI.apply(this, arguments);

                    var addNode = document.createElement("div");
                    Ext.get(addNode).addClass("y-add-row");
                    addNode.innerHTML = ["<div unselectable='on'></div><span class='y-add-row-desc'>",
                                         me.addNewRowText ? Signavio.Utils.escapeHTML(me.addNewRowText) : "Add new row",
                                         "</span>"].join("");

                    this.mainBody.dom.parentNode.insertBefore(addNode, this.mainBody.dom.nextSibling);

                    // Add a new row on click
                    Ext.fly(addNode).on("click", this.grid.addNewRow.bind(this.grid));
                },

                getColumnTooltip : function(i){
                    var tt = this.cm.getColumnTooltip(i);
                    if(tt){
                        return 'title="'+tt+'"';
                    }
                    return "";
                }
            });
        },

        getSelectionModel : function() {
            var selModel = new Ext.grid.CellSelectionModel({
                listeners : {
                    // Handle clicks of the row remover
                    beforecellselect : function(s, r, c) {
                        if (c === 0) {
                            var conf = this.colModel.config[0];
                            // the first element might not be removeable (but only if there is just one element)
                            if (r === 0 && Ext.isDefined(conf) && !!conf.firstHidden && this.store.getCount() === 1) {
                                return false;
                            }
                            this.clearActiveConfirmHints();
                            this.confirmRowRemoval(r, this.view.getCell(r,c).firstChild);

                            return false;
                        }
                        return true;
                    }.bind(this)
                }
            });

            return selModel;
        },

        clearActiveConfirmHints : function() {
            if (this.confirmationDialog) {
                this.confirmationDialog.remove();
                delete this.confirmationDialog;
            }
        },

        /**
         * Displays a confirmation for removing a row, handles the actual removal of rows and attached controls when deleting a risk.
         */
        confirmRowRemoval : function(row, cell) {
            var record = this.store.getAt(row);

            // Check if the record is empty
            var isEmpty = !$H(record.data).any(function(p) {
                return p.key !== "id" && p.value;
            });

            // Create a new hint to ask for removal
            var confirmation = document.createElement("div");
            confirmation.innerHTML = "<span>"+ Ext.ux.getI18N('NEGP.delete') + "</span><a class='y-delete-confirm-yes' href='#'>" + Ext.ux.getI18N('NEGP.yes') + "</a><a class='y-delete-confirm-no' href='#'>" + Ext.ux.getI18N('NEGP.no') + "</a>";

            // Wrap the confirmation into an ext element
            var $confirmation = Ext.get(confirmation);
            // confirmation.setAttributeNS(null,"class", "y-delete-confirm");
            $confirmation.addClass("y-delete-confirm");

            // remove the confirmation dialog
            // in case of IE it seems that the same event, that creates this dialog is propagated further on,
            // therefore ignore the first click
            var clickCounter = Ext.isIE  || Ext.isChrome ? 1 : 0;
            var removeConfirmationDialog = function(e) {
                if (e.target === confirmation) {return;}
                if (clickCounter > 0) {
                    clickCounter--;
                    return;
                }
                $confirmation.remove();
                Ext.fly(document).un("click", removeConfirmationDialog);
            };

            // Add a click listener on the whole document to remove the confirmation dialog
            Ext.fly(document).on("click", removeConfirmationDialog);

            // Remove the row when the yes button is clicked
            $confirmation.child(".y-delete-confirm-yes").on("click", function(e) {
                Event.stop(e);
                $confirmation.remove();
                // TODO Show confirmation dialog to remove the record
                this.store.remove(record);

                this.nestedGridFields.each(function(field) {
                    field.removeRowsWithParentId(record.get('id'));
                });

                // Update the source cell with the new count
                this.updateSourceCell();

                this.view.refresh();

                this.syncShadow();
            }.bind(this));

            // Remove the confirmation when 'no' is clicked
            $confirmation.child(".y-delete-confirm-no").on("click", function(e) {
                Event.stop(e);
                $confirmation.remove();
            });

            // Align the confirmation dialog to the delete button inside the row
            this.el.parent().appendChild($confirmation);
            $confirmation.alignTo(cell, "l-l", this.getConfirmationAlignment());
            $confirmation.dom.style['zIndex'] = 2 * (this.level || 0) + 1;
            this.confirmationDialog = $confirmation;
        },

        /**
         * Sadly, yet again different browsers let ext align elements differently to each other,
         * so depending on the used browser, some small adjustments have to be made
         * @returns {Array} alignment
         */
        getConfirmationAlignment : function() {
            if (Ext.isFF) {
                return [-3, 0];
            }
        },

        /**
         * Adds a new row to the given grid
         */
        addNewRow : function() {
            var Row = Ext.data.Record.create(this.store.fields.items);
            var newRow = Object.clone(this.defaultValues);

            // initialize
            this.store.fields.items.each(function(field) {
                if (!Ext.isDefined(newRow[field.name])) {
                    newRow[field.name] = "";
                }
            });

            var isNested = Ext.isDefined(this.store.currentParentId);

            var addition = isNested ? {
                // add the id of the parent entry to the new entry of the nested grid
                parentId    : this.store.currentParentId,
                id          : Signavio.Utils.generateUUID(false, true)
            } : {
                // it is a new entry in the main grid
                id          : Signavio.Utils.generateUUID(false, true)
            };
            // generate ids for user defined fields
            (this.additionalIds || []).each(function(id) {
                addition[id] = Signavio.Utils.generateUUID(false, true);
            });

            // create a new record for the currently selected risk
            this.store.add(new Row(Ext.apply(newRow, addition)));

            this.updateSourceCell();

//          this.store.commitChanges();
            this.view.refresh();

            this.syncShadow();
        },

        adjustCellHeight : function() {
            // Update the height of the active row so the nested grid can be inside
            this.row.dom.style["height"] = (this.el.getHeight() + this.cell.originalHeight || (this.cell.originalHeight = this.cell.getHeight())) + "px";
            if (this.parentGrid && this.parentGrid.row) {
                // parentGrid is also a nested grid
                this.parentGrid.adjustCellHeight();
            }
            if (this.parentGrid && (Ext.isIE8 || Ext.isIE7)) {
                // this fix ensures that mask will adjust is size properly
                // because in IE 8 is doesn't happen automatically
                this.parentGrid.adjustMaskHeight();
            }
        },

        adjustMaskHeight : function() {
            if (this.mask && this.el) {
                this.mask.setSize(this.mask.getSize().width, this.el.getHeight() - 2);
            }
        },

        updateSourceCell : function() {
            if (!this.sourceCell) {
                return;
            }
            var child = this.sourceCell.child(".y-cell-value");
            // the following content is visible if the nested grid is expanded
            if (!child.hasClass('y-no-text')) {
                var text = this.emptyText ? Signavio.Utils.unescapeHTML(this.emptyText) : 'Add content';
                child.dom.innerHTML = text;
            } else {
                child.dom.innerHTML = "&nbsp;";
            }
            this.adjustCellHeight();
        },

        syncShadow : function() {
            if (!this.parentGrid && this.ownerCt) {
                this.ownerCt.syncShadow();
            } else if (this.parentGrid) {
                this.parentGrid.syncShadow();
            }
        }
    });
}());
if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.grid) {Ext.ux.grid = {}; }

(function() {

    var ICONS = {
            'ICON1' 	: Signavio.Config.IMAGE_PATH + '/glyphicons/small/cmc-usdollar.png',
            'ICON2' 	: Signavio.Config.IMAGE_PATH + '/glyphicons/small/cmc-user.png',
            'ICON3' 	: Signavio.Config.IMAGE_PATH + '/glyphicons/small/cmc-cogwheel.png',
            'ICON4' 	: Signavio.Config.IMAGE_PATH + '/glyphicons/small/cmc-flash.png',
            'PROPERTY' 	: Signavio.Config.IMAGE_PATH + '/glyphicons/small/cmc-text.png'
    };

    Ext.ux.grid.LayersSelectionGrid = function(attrs) {
        attrs = attrs || {};

        // Selection model
        var sm = new Ext.grid.CheckboxSelectionModel();
        // Store
        attrs.store = attrs.store || new Ext.data.JsonStore({
				root: 'rep',
				fields: ['id', 'name', 'ruleSets', 'showAttributeValues', 'visualization'],
			});
        
		// If the GET method is not set manually via this proxy,
		// Ext automagically does a POST whenever there are URL params
		// (as in the portal comment mode for instance).
        // ATTENTION: The proxy may not be passed to the JsonStore constructor
        // because the JsonStore will create a new HTTPProxy itself (without the right parameters!)
        attrs.store.proxy = new Ext.data.HttpProxy({
            method: 'GET',
            url: Signavio.Config.BACKEND_PATH + '/clinfo'
		});
        
        // Column model
        attrs.cm = attrs.cm || new Ext.grid.ColumnModel([sm, {
                header: 'Icon',
                dataIndex: 'visualization',
                width: 16,
                renderer: function(val, opt, record){
                    if (!val || !ICONS[val]){ return ""; }

                    var icon = ICONS[val];

                    return '<div class="attr-layers-icon"><img src="'+icon+'"/></div>';
                }
            },{
        		header: 'Layer',
        		dataIndex: 'name'
        	}]);
        // Overwrite attributes
        Ext.applyIf(attrs, {
            sm: sm,
            viewConfig: {
                forceFit: true,
                emptyText: Ext.ux.getI18N('layersselectiongrid.emptytext')
            },
            hideHeaders: true,
            stripeRows: true
        });

        Ext.ux.grid.LayersSelectionGrid.superclass.constructor.call(this, attrs);

        attrs.store.load();
    };

    Ext.extend(Ext.ux.grid.LayersSelectionGrid, Ext.grid.EditorGridPanel, {
        cls: "layers-selection-grid"
    	
    });

}());

if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.grid) { Ext.ux.grid = {}; }

(function() {

    Ext.ux.grid.LockingColumnModel = Ext.extend(Ext.grid.ColumnModel, {

        isLocked: function(columnIndex) {
            return this.config[columnIndex].locked === true;
        },

        setLocked: function(columnIndex, value, suppressEvent) {
            if(this.isLocked(columnIndex) === value) {
                return;
            }

            this.config[columnIndex].locked = value;

            if(!suppressEvent) {
                this.fireEvent("columnlockchange", this, columnIndex, value);
            }
        },

        getTotalLockedWidth: function() {
            var totalWidth = 0;

            for(var i = 0, len = this.config.length; i < len; i = i + 1) {
                if(this.isLocked(i) && !this.isHidden(i)) {
                    totalWidth += this.getColumnWidth(i);
                }
            }

            return totalWidth;
        },

        getLockedCount: function() {
            var len = this.config.length;

            for(var i = 0; i < len; i = i + 1) {
                if(!this.isLocked(i)) {
                    return i;
                }
            }

            return len;
        },

        moveColumn: function(oldIndex, newIndex) {
            var oldLocked = this.isLocked(oldIndex),
                newLocked = this.isLocked(newIndex),
                state = oldIndex < newIndex && oldLocked && newLocked;

            this.setLocked(oldIndex, state, true);

            Ext.ux.grid.LockingColumnModel.superclass.moveColumn.apply(this, arguments);
        },

        getRendererScope : function(col){
            return this.config[col].scope;
        }

    });

}());
if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.grid) {Ext.ux.grid = {}; }

(function() {

    Ext.ux.grid.LockingEditorGridPanel = function(attrs) {
        attrs = attrs || {};

        attrs.view = attrs.view || new Ext.ux.grid.LockingGridView();
        attrs.cm = attrs.cm || new Ext.ux.grid.LockingColumnModel(attrs.columns);

        Ext.ux.grid.LockingEditorGridPanel.superclass.constructor.call(this, attrs);
    };

    Ext.extend(Ext.ux.grid.LockingEditorGridPanel, Ext.grid.EditorGridPanel);

}());
if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.grid) { Ext.ux.grid = {}; }

(function() {

    Ext.ux.grid.LockingGridView = function(attrs) {
        Ext.ux.grid.LockingGridView.superclass.constructor.call(this, attrs);
    };

    Ext.extend(Ext.ux.grid.LockingGridView, Ext.grid.GridView, {

        lockText : 'Lock',
        unlockText : 'Unlock',
        rowBorderWidth : 1,
        lockedBorderWidth : 0,

        initTemplates: function() {
            var ts = this.templates || {};

            if(!ts.master) {
                ts.master = new Ext.Template(
                    '<div class="x-grid3" hidefocus="true">',
                        '<div class="x-grid3-locked">',
                            '<div class="x-grid3-header">',
                                '<div class="x-grid3-header-inner">',
                                    '<div class="x-grid3-header-offset" style="{lockedStyle}">',
                                        '{lockedHeader}',
                                    '</div>',
                                '</div>',
                                '<div class="x-clear"></div>',
                            '</div>',
                            '<div class="x-grid3-scroller">',
                                '<div class="x-grid3-body" style="{lockedStyle}">',
                                    '{lockedBody}',
                                '</div>',
                                '<div class="x-grid3-scroll-spacer"></div>',
                            '</div>',
                        '</div>',
                        '<div class="x-grid3-viewport x-grid3-unlocked">',
                            '<div class="x-grid3-header">',
                                '<div class="x-grid3-header-inner">',
                                    '<div class="x-grid3-header-offset" style="{ostyle}">',
                                        '{header}',
                                    '</div>',
                                '</div>',
                                '<div class="x-clear"></div>',
                            '</div>',
                            '<div class="x-grid3-scroller">',
                                '<div class="x-grid3-body" style="{bstyle}">',
                                    '{body}',
                                '</div>',
                                '<a href="#" class="x-grid3-focus" tabIndex="-1"></a>',
                            '</div>',
                        '</div>',
                        '<div class="x-grid3-resize-marker">&#160;</div>',
                        '<div class="x-grid3-resize-proxy">&#160;</div>',
                    '</div>'
                );
            }

            this.templates = ts;

            Ext.ux.grid.LockingGridView.superclass.initTemplates.call(this);
        },

        initElements: function() {
            var el = Ext.get(this.grid.getGridEl().dom.firstChild);

            var lockedWrap = el.child("div.x-grid3-locked");
            var lockedHd = lockedWrap.child("div.x-grid3-header");
            var lockedScroller = lockedWrap.child("div.x-grid3-scroller");

            var mainWrap = el.child("div.x-grid3-viewport");
            var mainHd = mainWrap.child("div.x-grid3-header");
            var mainScroller = mainWrap.child("div.x-grid3-scroller");

            if(this.grid.hideHeaders) {
                lockedHd.setDisplayed(false);
                mainHd.setDisplayed(false);
            }

            if(this.forceFit) {
                mainScroller.setStyle("overflow-x", "hidden");
            }

            Ext.apply(this, {
                el: el,
                mainWrap: mainWrap,
                mainHd: mainHd,
                mainBody: mainScroller.child("div.x-grid3-body"),
                focusEl: mainScroller.child("a.x-grid3-focus"),
                innerHd: mainHd.child("div.x-grid3-header-inner").dom,
                scroller: mainScroller,
                resizeMarker: el.child("div.x-grid3-resize-marker"),
                resizeProxy: el.child("div.x-grid3-resize-proxy"),
                lockedWrap: lockedWrap,
                lockedHd: lockedHd,
                lockedScroller: lockedScroller,
                lockedBody: lockedScroller.child("div.x-grid3-body"),
                lockedInnerHd: lockedHd.child("div.x-grid3-header-inner").dom
            });

            this.focusEl.swallowEvent("click", true);
        },

        getLockedRows: function() {
            if(this.hasRows()) {
                return this.lockedBody.dom.childNodes;
            }

            return [];
        },

        getLockedRow: function(row) {
            return this.getLockedRows()[row];
        },

        getCell: function(row, col) {
            var lockedLength = this.cm.getLockedCount();

            if(col < lockedLength) {
                return this.getLockedRow(row).getElementsByTagName("td")[col];
            }

            return Ext.ux.grid.LockingGridView.superclass.getCell.call(this, row, col - lockedLength);
        },

        getHeaderCell: function(index) {
            var lockedLength = this.cm.getLockedCount();

            if(index < lockedLength) {
                return this.lockedHd.dom.getElementsByTagName("td")[index];
            }

            return Ext.ux.grid.LockingGridView.superclass.getHeaderCell.call(this, index - lockedLength);
        },

        syncScroll: function() {
            this.lockedScroller.dom.scrollTop = this.scroller.dom.scrollTop;

            Ext.ux.grid.LockingGridView.superclass.syncScroll.call(this);
        },

        addRowClass: function(row, cls) {
            var lockedRow = this.getLockedRow(row);

            if(lockedRow) {
                this.fly(lockedRow).addClass(cls);
            }

            Ext.ux.grid.LockingGridView.superclass.addRowClass.call(this, row, cls);
        },

        removeRowClass: function(row, cls) {
            var lockedRow = this.getLockedRow(row);

            if(lockedRow) {
                this.fly(lockedRow).removeClass(cls);
            }

            Ext.ux.grid.LockingGridView.superclass.removeRowClass.call(this, row, cls);
        },

        removeRow: function(row) {
            Ext.removeNode(this.getLockedRow(row));
            Ext.ux.grid.LockingGridView.superclass.removeRow.call(this, row);
        },

        removeRows: function(first, last) {
            var lockedBody = this.lockedBody.dom,
                rowIndex = first;

            for(; rowIndex <= last; rowIndex = rowIndex + 1) {
                Ext.removeNode(lockedBody.childNodes[first]);
            }

            Ext.ux.grid.LockingGridView.superclass.removeRows.call(this, first, last);
        },

        updateAllColumnWidths : function(){
            var totalWidth = this.getTotalWidth(),
                columnCount = this.cm.getColumnCount(),
                lockedWidth = this.getLockedWidth(),
                lockedLength = this.cm.getLockedCount(),
                widths = [],
                len,
                i;

            this.updateLockedWidth();

            for(i = 0; i < columnCount; i = i + 1){
                widths[i] = this.getColumnWidth(i);
                var hd = this.getHeaderCell(i);
                hd.style.width = widths[i];
            }

            var lockedRows = this.getLockedRows(),
                rows = this.getRows(),
                row,
                titleRow,
                j;

            for(i = 0, len = rows.length; i < len; i = i + 1){
                row = lockedRows[i];
                row.style.width = lockedWidth;

                if(row.firstChild){
                    row.firstChild.style.width = lockedWidth;
                    titleRow = row.firstChild.rows[0];

                    for (j = 0; j < lockedLength; j = j + 1) {
                       titleRow.childNodes[j].style.width = widths[j];
                    }
                }

                row = rows[i];
                row.style.width = totalWidth;

                if(row.firstChild){
                    row.firstChild.style.width = totalWidth;
                    titleRow = row.firstChild.rows[0];

                    for (j = lockedLength; j < columnCount; j = j + 1) {
                       titleRow.childNodes[j - lockedLength].style.width = widths[j];
                    }
                }
            }

            this.onAllColumnWidthsUpdated(widths, totalWidth);
            this.syncHeaderHeight();
        },

        updateColumnWidth : function(col){
            var width = this.getColumnWidth(col),
                lockedLength = this.cm.getLockedCount(),
                ns, rowWidth, c, row;

            this.updateLockedWidth();

            if(col < lockedLength){
                ns = this.getLockedRows();
                rowWidth = this.getLockedWidth();
                c = col;
            } else {
                ns = this.getRows();
                rowWidth = this.getTotalWidth();
                c = col - lockedLength;
            }

            var hd = this.getHeaderCell(col);
            hd.style.width = width;

            for(var i = 0, len = ns.length; i < len; i = i + 1) {
                row = ns[i];
                row.style.width = rowWidth;

                if(row.firstChild){
                    row.firstChild.style.width = rowWidth;
                    row.firstChild.rows[0].childNodes[c].style.width = width;
                }
            }

            this.onColumnWidthUpdated(col, width, this.getTotalWidth());
            this.syncHeaderHeight();
        },

        updateColumnHidden : function(col, hidden){
            var lockedLength = this.cm.getLockedCount(),
                ns, rowWidth, c, row,
                display = hidden ? 'none' : '';

            this.updateLockedWidth();

            if(col < lockedLength){
                ns = this.getLockedRows();
                rowWidth = this.getLockedWidth();
                c = col;
            }else{
                ns = this.getRows();
                rowWidth = this.getTotalWidth();
                c = col - lockedLength;
            }

            var hd = this.getHeaderCell(col);
            hd.style.display = display;

            for(var i = 0, len = ns.length; i < len; i = i + 1) {
                row = ns[i];
                row.style.width = rowWidth;

                if(row.firstChild){
                    row.firstChild.style.width = rowWidth;
                    row.firstChild.rows[0].childNodes[c].style.display = display;
                }
            }

            this.onColumnHiddenUpdated(col, hidden, this.getTotalWidth());
            delete this.lastViewWidth;
            this.layout();
        },

        doRender : function(cs, rs, ds, startRow, colCount, stripe){
            var templates = this.templates,
                cellTemplate = templates.cell,
                rowTemplate = templates.row,
                last = colCount - 1,
                totalStyle = 'width:' + this.getTotalWidth() + ';',
                lockedStyle = 'width:' + this.getLockedWidth() + ';',
                buf = [], lbuf = [], cb, lcb, c, p = {}, rp = {}, r;

            for(var j = 0, len = rs.length; j < len; j = j + 1) {
                r = rs[j]; cb = []; lcb = [];
                var rowIndex = (j+startRow);

                for(var i = 0; i < colCount; i = i + 1){
                    c = cs[i];
                    p.id = c.id;
                    p.css = (i === 0 ? 'x-grid3-cell-first ' : (i === last ? 'x-grid3-cell-last ' : '')) +
                        (this.cm.config[i].cellCls ? ' ' + this.cm.config[i].cellCls : '');

                    p.attr = p.cellAttr = '';
                    p.value = c.renderer(r.data[c.name], p, r, rowIndex, i, ds);
                    p.style = c.style;

                    if(Ext.isEmpty(p.value)){
                        p.value = '&#160;';
                    }

                    if(this.markDirty && r.dirty && Ext.isDefined(r.modified[c.name])){
                        p.css += ' x-grid3-dirty-cell';
                    }

                    if(c.locked){
                        lcb[lcb.length] = cellTemplate.apply(p);
                    } else {
                        cb[cb.length] = cellTemplate.apply(p);
                    }
                }
                var alt = [];

                if(stripe && ((rowIndex+1) % 2 === 0)){
                    alt[0] = 'x-grid3-row-alt';
                }

                if(r.dirty){
                    alt[1] = ' x-grid3-dirty-row';
                }

                rp.cols = colCount;

                if(this.getRowClass){
                    alt[2] = this.getRowClass(r, rowIndex, rp, ds);
                }

                rp.alt = alt.join(' ');
                rp.cells = cb.join('');
                rp.totalStyle = totalStyle;
                buf[buf.length] = rowTemplate.apply(rp);
                rp.cells = lcb.join('');

                // is this assignment correct!?
                rp.totalStyle = lockedStyle;
                lbuf[lbuf.length] = rowTemplate.apply(rp);
            }

            return [buf.join(''), lbuf.join('')];
        },

        /*
        afterRender : function(){
            if(!this.ds || !this.cm){
                return;
            }

            var bd = this.renderRows() || ['&#160;', '&#160;'];
            this.mainBody.dom.innerHTML = bd[0];
            this.lockedBody.dom.innerHTML = bd[1];
            this.processRows(0, true);

            if(this.deferEmptyText !== true){
                this.applyEmptyText();
            }

            this.grid.fireEvent('viewready', this.grid);
        },
        */
        renderUI : function(){
            var templates = this.templates,
                header = this.renderHeaders(),
                body = templates.body.apply({rows:'&#160;'});

            var html = templates.master.apply({
                body: body,
                header: header[0],
                lockedHeader: header[1],
                ostyle: 'width:' + this.getOffsetWidth() + ';',
                bstyle: 'width:' + this.getTotalWidth()  + ';',
                lockedBody: body,
                lockedStyle: 'width:'+this.getLockedWidth()+';'
            });

            var g = this.grid;

            g.getGridEl().dom.innerHTML = html;

            this.initElements();

            this.mainBody.dom.innerHTML = this.renderRows();
            this.processRows(0, true);

            // get mousedowns early
            Ext.fly(this.innerHd).on("click", this.handleHdDown, this);
            this.mainHd.on("mouseover", this.handleHdOver, this);
            this.mainHd.on("mouseout", this.handleHdOut, this);
            this.mainHd.on("mousemove", this.handleHdMove, this);

            this.scroller.on('scroll', this.syncScroll,  this);
            if(g.enableColumnResize !== false){
                this.splitone = new Ext.grid.GridView.SplitDragZone(g, this.mainHd.dom);
            }

            if(g.enableColumnMove){
                this.columnDrag = new Ext.grid.GridView.ColumnDragZone(g, this.innerHd);
                this.columnDrop = new Ext.grid.HeaderDropZone(g, this.mainHd.dom);
            }

            if(g.enableHdMenu !== false){
                if(g.enableColumnHide !== false){
                    this.colMenu = new Ext.menu.Menu({id:g.id + "-hcols-menu"});
                    this.colMenu.on("beforeshow", this.beforeColMenuShow, this);
                    this.colMenu.on("itemclick", this.handleHdMenuClick, this);
                }
                this.hmenu = new Ext.menu.Menu({id: g.id + "-hctx"});
                this.hmenu.add(
                    {id:"asc", text: this.sortAscText, cls: "xg-hmenu-sort-asc"},
                    {id:"desc", text: this.sortDescText, cls: "xg-hmenu-sort-desc"}
                );
                if(g.enableColumnHide !== false){
                    this.hmenu.add('-',
                        {id:"columns", text: this.columnsText, menu: this.colMenu, iconCls: 'x-cols-icon'}
                    );
                }
                this.hmenu.on("itemclick", this.handleHdMenuClick, this);

                //g.on("headercontextmenu", this.handleHdCtx, this);
            }

            if(g.enableDragDrop || g.enableDrag){
                var dd = new Ext.grid.GridDragZone(g, {
                    ddGroup : g.ddGroup || 'GridDD'
                });
            }

            this.updateHeaderSortState();
        },
        /*
        afterRenderUI: function(){
            var g = this.grid;
            this.initElements();
            Ext.fly(this.innerHd).on('click', this.handleHdDown, this);
            Ext.fly(this.lockedInnerHd).on('click', this.handleHdDown, this);
            this.mainHd.on({
                scope: this,
                mouseover: this.handleHdOver,
                mouseout: this.handleHdOut,
                mousemove: this.handleHdMove
            });
            this.lockedHd.on({
                scope: this,
                mouseover: this.handleHdOver,
                mouseout: this.handleHdOut,
                mousemove: this.handleHdMove
            });
            this.scroller.on('scroll', this.syncScroll,  this);
            if(g.enableColumnResize !== false){
                this.splitZone = new Ext.grid.GridView.SplitDragZone(g, this.mainHd.dom);
                this.splitZone.setOuterHandleElId(Ext.id(this.lockedHd.dom));
                this.splitZone.setOuterHandleElId(Ext.id(this.mainHd.dom));
            }
            if(g.enableColumnMove){
                this.columnDrag = new Ext.grid.GridView.ColumnDragZone(g, this.innerHd);
                this.columnDrag.setOuterHandleElId(Ext.id(this.lockedInnerHd));
                this.columnDrag.setOuterHandleElId(Ext.id(this.innerHd));
                this.columnDrop = new Ext.grid.HeaderDropZone(g, this.mainHd.dom);
            }
            if(g.enableHdMenu !== false){
                this.hmenu = new Ext.menu.Menu({id: g.id + '-hctx'});
                this.hmenu.add(
                    {itemId: 'asc', text: this.sortAscText, cls: 'xg-hmenu-sort-asc'},
                    {itemId: 'desc', text: this.sortDescText, cls: 'xg-hmenu-sort-desc'}
                );
                if(this.grid.enableColLock !== false){
                    this.hmenu.add('-',
                        {itemId: 'lock', text: this.lockText, cls: 'xg-hmenu-lock'},
                        {itemId: 'unlock', text: this.unlockText, cls: 'xg-hmenu-unlock'}
                    );
                }
                if(g.enableColumnHide !== false){
                    this.colMenu = new Ext.menu.Menu({id:g.id + '-hcols-menu'});
                    this.colMenu.on({
                        scope: this,
                        beforeshow: this.beforeColMenuShow,
                        itemclick: this.handleHdMenuClick
                    });
                    this.hmenu.add('-', {
                        itemId:'columns',
                        hideOnClick: false,
                        text: this.columnsText,
                        menu: this.colMenu,
                        iconCls: 'x-cols-icon'
                    });
                }
                this.hmenu.on('itemclick', this.handleHdMenuClick, this);
            }
            if(g.trackMouseOver){
                this.mainBody.on({
                    scope: this,
                    mouseover: this.onRowOver,
                    mouseout: this.onRowOut
                });
                this.lockedBody.on({
                    scope: this,
                    mouseover: this.onRowOver,
                    mouseout: this.onRowOut
                });
            }

            if(g.enableDragDrop || g.enableDrag){
                this.dragZone = new Ext.grid.GridDragZone(g, {
                    ddGroup : g.ddGroup || 'GridDD'
                });
            }

            this.updateHeaderSortState();
        },
        */
        getOffsetWidth : function() {
            return (this.cm.getTotalWidth() - this.cm.getTotalLockedWidth() + this.getScrollOffset()) + 'px';
        },

        getScrollOffset: function() {
            return this.scrollOffset;
        },

        getLockedWidth : function() {
            return this.cm.getTotalLockedWidth() + 'px';
        },

        getTotalWidth : function() {
            return (this.cm.getTotalWidth() - this.cm.getTotalLockedWidth()) + 'px';
        },

        layout : function(){
            if(!this.mainBody){
                return;
            }

            var g = this.grid;
            var c = g.getGridEl();
            var csize = c.getSize(true);
            var vw = csize.width;
            var vh;

            if(!g.hideHeaders && (vw < 20 || csize.height < 20)){
                return;
            }

            this.syncHeaderHeight();

            if(g.autoHeight){
                this.scroller.dom.style.overflow = 'visible';
                this.lockedScroller.dom.style.overflow = 'visible';

                if(Ext.isWebKit){
                    this.scroller.dom.style.position = 'static';
                    this.lockedScroller.dom.style.position = 'static';
                }
            } else {
                this.el.setSize(csize.width, csize.height);
                var hdHeight = this.mainHd.getHeight();
                vh = csize.height - (hdHeight);
            }

            this.updateLockedWidth();

            if(this.forceFit){
                if(this.lastViewWidth !== vw){
                    this.fitColumns(false, false);
                    this.lastViewWidth = vw;
                }
            } else {
                this.autoExpand();
                this.syncHeaderScroll();
            }

            this.onLayout(vw, vh);
        },

        renderHeaders : function(){
            var cm = this.cm,
                ts = this.templates,
                ct = ts.hcell,
                cb = [], lcb = [],
                p = {},
                len = cm.getColumnCount(),
                last = len - 1;

            for(var i = 0; i < len; i = i + 1){
                p.id = cm.getColumnId(i);
                p.value = cm.getColumnHeader(i) || '';
                p.style = this.getColumnStyle(i, true);
                p.tooltip = this.getColumnTooltip(i);
                p.css = (i === 0 ? 'x-grid3-cell-first ' : (i === last ? 'x-grid3-cell-last ' : '')) +
                    (cm.config[i].headerCls ? ' ' + cm.config[i].headerCls : '');

                if(cm.config[i].align === 'right'){
                    p.istyle = 'padding-right:16px';
                } else {
                    delete p.istyle;
                }

                if(cm.isLocked(i)){
                    lcb[lcb.length] = ct.apply(p);
                }else{
                    cb[cb.length] = ct.apply(p);
                }
            }

            return [ts.header.apply({cells: cb.join(''), tstyle:'width:'+this.getTotalWidth()+';'}),
                    ts.header.apply({cells: lcb.join(''), tstyle:'width:'+this.getLockedWidth()+';'})];
        },

        updateHeaders : function(){
            var hd = this.renderHeaders();
            this.innerHd.firstChild.innerHTML = hd[0];
            this.innerHd.firstChild.style.width = this.getOffsetWidth();
            this.innerHd.firstChild.firstChild.style.width = this.getTotalWidth();
            this.lockedInnerHd.firstChild.innerHTML = hd[1];

            var lw = this.getLockedWidth();
            this.lockedInnerHd.firstChild.style.width = lw;
            this.lockedInnerHd.firstChild.firstChild.style.width = lw;
        },

        getResolvedXY : function(resolved){
            if(!resolved){
                return null;
            }
            var c = resolved.cell, r = resolved.row;
            return c ? Ext.fly(c).getXY() : [this.scroller.getX(), Ext.fly(r).getY()];
        },

        syncFocusEl : function(row, col, hscroll){
            hscroll = col < this.cm.getLockedCount() ? false : hscroll;
            var xy = row;
            if(!Ext.isArray(xy)){
                row = Math.min(row, Math.max(0, this.getRows().length-1));
                if (isNaN(row)) {
                    return;
                }
                xy = this.getResolvedXY(this.resolveCell(row, col, hscroll));
            }
            this.focusEl.setXY(xy||this.scroller.getXY());
        },

        resolveCell : function(row, col, hscroll){
            if(!Ext.isNumber(row)){
                row = row.rowIndex;
            }
            if(!this.ds){
                return null;
            }
            if(row < 0 || row >= this.ds.getCount()){
                return null;
            }
            col = (col !== undefined ? col : 0);

            var rowEl = this.getRow(row),
                cm = this.cm,
                colCount = cm.getColumnCount(),
                cellEl;
            if(!(hscroll === false && col === 0)){
                while(col < colCount && cm.isHidden(col)){
                    col++;
                }
                cellEl = this.getCell(row, col);
            }

            return {row: rowEl, cell: cellEl};
        },

        ensureVisible : function(row, col, hscroll){
            return Ext.ux.grid.LockingGridView.superclass.ensureVisible.call(this, row, col, col < this.cm.getLockedCount() ? false : hscroll);
        },

        insertRows : function(dm, firstRow, lastRow, isUpdate){
            var last = dm.getCount() - 1;

            if(!isUpdate && firstRow === 0 && lastRow >= last){
                this.refresh();
            } else {
                if(!isUpdate){
                    this.fireEvent('beforerowsinserted', this, firstRow, lastRow);
                }

                var html = this.renderRows(firstRow, lastRow),
                    before = this.getRow(firstRow);

                if(before){
                    if(firstRow === 0){
                        this.removeRowClass(0, this.firstRowCls);
                    }

                    Ext.DomHelper.insertHtml('beforeBegin', before, html[0]);
                    before = this.getLockedRow(firstRow);
                    Ext.DomHelper.insertHtml('beforeBegin', before, html[1]);
                } else {
                    this.removeRowClass(last - 1, this.lastRowCls);
                    Ext.DomHelper.insertHtml('beforeEnd', this.mainBody.dom, html[0]);
                    Ext.DomHelper.insertHtml('beforeEnd', this.lockedBody.dom, html[1]);
                }

                if(!isUpdate){
                    this.fireEvent('rowsinserted', this, firstRow, lastRow);
                    this.processRows(firstRow);
                } else if(firstRow === 0 || firstRow >= last){
                    this.addRowClass(firstRow, firstRow === 0 ? this.firstRowCls : this.lastRowCls);
                }
            }

            this.syncFocusEl(firstRow);
        },

        getColumnStyle : function(col, isHeader){
            var style = !isHeader ? this.cm.config[col].cellStyle || this.cm.config[col].css || '' : this.cm.config[col].headerStyle || '';
            style += 'width:'+this.getColumnWidth(col)+';';

            if(this.cm.isHidden(col)){
                style += 'display:none;';
            }

            var align = this.cm.config[col].align;

            if(align){
                style += 'text-align:'+align+';';
            }

            return style;
        },

        getColumnData : function(){
            var cs = [], cm = this.cm, colCount = cm.getColumnCount();

            for(var i = 0; i < colCount; i = i + 1) {
                var name = cm.getDataIndex(i);
                cs[i] = {
                    name : (!Ext.isDefined(name) ? this.ds.fields.get(i).name : name),
                    renderer : cm.getRenderer(i),
                    scope : cm.getRendererScope(i),
                    id : cm.getColumnId(i),
                    style : this.getColumnStyle(i),
                    locked : cm.isLocked(i)
                };
            }

            return cs;
        },

        renderBody : function(){
            var markup = this.renderRows() || ['&#160;', '&#160;'];
            return [this.templates.body.apply({rows: markup[0]}), this.templates.body.apply({rows: markup[1]})];
        },

        refreshRow: function(record){
            var store = this.ds,
                colCount = this.cm.getColumnCount(),
                columns = this.getColumnData(),
                last = colCount - 1,
                cls = ['x-grid3-row'],
                rowParams = {
                    tstyle: String.format("width: {0};", this.getTotalWidth())
                },
                lockedRowParams = {
                    tstyle: String.format("width: {0};", this.getLockedWidth())
                },
                colBuffer = [],
                lockedColBuffer = [],
                cellTpl = this.templates.cell,
                rowIndex,
                row,
                lockedRow,
                column,
                meta,
                css,
                i;

            if (Ext.isNumber(record)) {
                rowIndex = record;
                record = store.getAt(rowIndex);
            } else {
                rowIndex = store.indexOf(record);
            }

            if (!record || rowIndex < 0) {
                return;
            }

            for (i = 0; i < colCount; i = i + 1) {
                column = columns[i];

                if (i === 0) {
                    css = 'x-grid3-cell-first';
                } else {
                    css = (i === last) ? 'x-grid3-cell-last ' : '';
                }

                meta = {
                    id: column.id,
                    style: column.style,
                    css: css,
                    attr: "",
                    cellAttr: ""
                };

                meta.value = column.renderer.call(column.scope, record.data[column.name], meta, record, rowIndex, i, store);

                if (Ext.isEmpty(meta.value)) {
                    meta.value = ' ';
                }

                if (this.markDirty && record.dirty && typeof record.modified[column.name] !== 'undefined') {
                    meta.css += ' x-grid3-dirty-cell';
                }

                if (column.locked) {
                    lockedColBuffer[i] = cellTpl.apply(meta);
                } else {
                    colBuffer[i] = cellTpl.apply(meta);
                }
            }

            row = this.getRow(rowIndex);
            row.className = '';
            lockedRow = this.getLockedRow(rowIndex);
            lockedRow.className = '';

            if (this.grid.stripeRows && ((rowIndex + 1) % 2 === 0)) {
                cls.push('x-grid3-row-alt');
            }

            if (this.getRowClass) {
                rowParams.cols = colCount;
                cls.push(this.getRowClass(record, rowIndex, rowParams, store));
            }

            // Unlocked rows
            this.fly(row).addClass(cls).setStyle(rowParams.tstyle);
            // rowParams.cells = colBuffer.join("");
            // row.innerHTML = this.templates.row.apply(rowParams);
            this.insertRows(this.ds, rowIndex, rowIndex, true);
            this.getRow(rowIndex).rowIndex = rowIndex;
            this.getLockedRow(rowIndex).rowIndex = rowIndex;

            this.onRemove(this.ds, record, rowIndex + 1, true);

            // Locked rows
            this.fly(lockedRow).addClass(cls).setStyle(lockedRowParams.tstyle);
            // lockedRowParams.cells = lockedColBuffer.join("");
            // lockedRow.innerHTML = this.templates.rowInner.apply(lockedRowParams);
            // lockedRow.innerHTML = this.templates.row.apply(lockedRowParams);
            // lockedRow.rowIndex = rowIndex;
            this.syncRowHeights(row, lockedRow);
            this.fireEvent('rowupdated', this, rowIndex, record);
        },

        refresh : function(headersToo){
            this.fireEvent('beforerefresh', this);
            this.grid.stopEditing(true);
            var result = this.renderBody();

            this.mainBody.update(result[0]);
            this.mainBody.setWidth(this.getTotalWidth());
            this.lockedBody.update(result[1]);
            this.lockedBody.setWidth(this.getLockedWidth());
            
            if(headersToo === true){
                this.updateHeaders();
                this.updateHeaderSortState();
            }

            this.processRows(0, true);
            this.layout();
            this.applyEmptyText();
            this.fireEvent('refresh', this);
        },

        onDenyColumnLock : function(){

        },

        processRows : function(startRow, skipStripe){
            if(!this.ds || this.ds.getCount() < 1){
                return;
            }
            var rows = this.getRows(),
                lrows = this.getLockedRows(),
                row, lrow;
            skipStripe = skipStripe || !this.grid.stripeRows;
            startRow = startRow || 0;
            for(var i = 0, len = rows.length; i < len; ++i){
                row = rows[i];
                lrow = lrows[i];
                row.rowIndex = i;
                lrow.rowIndex = i;
                if(!skipStripe){
                    row.className = row.className.replace(this.rowClsRe, ' ');
                    lrow.className = lrow.className.replace(this.rowClsRe, ' ');
                    if ((i + 1) % 2 === 0){
                        row.className += ' x-grid3-row-alt';
                        lrow.className += ' x-grid3-row-alt';
                    }
                }
                this.syncRowHeights(row, lrow);
            }
            if(startRow === 0){
                Ext.fly(rows[0]).addClass(this.firstRowCls);
                Ext.fly(lrows[0]).addClass(this.firstRowCls);
            }
            Ext.fly(rows[rows.length - 1]).addClass(this.lastRowCls);
            Ext.fly(lrows[lrows.length - 1]).addClass(this.lastRowCls);
        },

        syncRowHeights: function(row1, row2){
            if(this.syncHeights){
                var el1 = Ext.get(row1),
                    el2 = Ext.get(row2),
                    h1 = el1.getHeight(),
                    h2 = el2.getHeight();

                if(h1 > h2){
                    el2.setHeight(h1);
                }else if(h2 > h1){
                    el1.setHeight(h2);
                }
            }
        },

        initData : function(ds, cm){
            if(this.cm){
                this.cm.un('columnlockchange', this.onColumnLock, this);
            }

            Ext.ux.grid.LockingGridView.superclass.initData.call(this, ds, cm);

            if(this.cm){
                this.cm.on('columnlockchange', this.onColumnLock, this);
            }
        },

        onColumnLock : function(){
            this.refresh(true);
        },

        handleHdMenuClick : function(item){
            var index = this.hdCtxIndex,
                cm = this.cm,
                id = item.getItemId(),
                llen = cm.getLockedCount();

            switch(id){
                case 'lock':
                    if(cm.getColumnCount(true) <= llen + 1){
                        this.onDenyColumnLock();

                        return;
                    }

                    cm.setLocked(index, true, llen !== index);

                    if(llen !== index){
                        cm.moveColumn(index, llen);
                        this.grid.fireEvent('columnmove', index, llen);
                    }
                break;
                case 'unlock':
                    if(llen - 1 !== index){
                        cm.setLocked(index, false, true);
                        cm.moveColumn(index, llen - 1);
                        this.grid.fireEvent('columnmove', index, llen - 1);
                    } else {
                        cm.setLocked(index, false);
                    }
                break;
                default:
                    return Ext.ux.grid.LockingGridView.superclass.handleHdMenuClick.call(this, item);
            }
            return true;
        },

        handleHdDown : function(e, t){
            Ext.ux.grid.LockingGridView.superclass.handleHdDown.call(this, e, t);

            if(this.grid.enableColLock !== false){
                if(Ext.fly(t).hasClass('x-grid3-hd-btn')){
                    var hd = this.findHeaderCell(t),
                        index = this.getCellIndex(hd),
                        ms = this.hmenu.items, cm = this.cm;
                    ms.get('lock').setDisabled(cm.isLocked(index));
                    ms.get('unlock').setDisabled(!cm.isLocked(index));
                }
            }
        },

        syncHeaderHeight: function(){
            var hrow = Ext.fly(this.innerHd).child('tr', true),
                lhrow = Ext.fly(this.lockedInnerHd).child('tr', true);

            hrow.style.height = 'auto';
            lhrow.style.height = 'auto';
            
            var hd = hrow.offsetHeight,
                lhd = lhrow.offsetHeight,
                height = Math.max(lhd, hd) + 'px';

            hrow.style.height = height;
            lhrow.style.height = height;
        },

        updateLockedWidth: function(){
            var lw = this.cm.getTotalLockedWidth(),
                tw = this.cm.getTotalWidth() - lw,
                csize = this.grid.getGridEl().getSize(true),
                lp = Ext.isBorderBox ? 0 : this.lockedBorderWidth,
                rp = Ext.isBorderBox ? 0 : this.rowBorderWidth,
                vw = Math.max(csize.width - lw - lp - rp, 0) + 'px',
                so = this.getScrollOffset();

            if(!this.grid.autoHeight){
                var vh = Math.max(csize.height - this.mainHd.getHeight(), 0) + 'px';
                this.lockedScroller.dom.style.height = vh;
                this.scroller.dom.style.height = vh;
            }

            this.lockedWrap.dom.style.width = (lw + rp) + 'px';
            this.scroller.dom.style.width = vw;
            this.mainWrap.dom.style.left = (lw + lp + rp - 1) + 'px';

            if(this.innerHd){
                this.lockedInnerHd.firstChild.style.width = lw + 'px';
                this.lockedInnerHd.firstChild.firstChild.style.width = lw + 'px';
                this.innerHd.style.width = vw;
                this.innerHd.firstChild.style.width = (tw + rp + so) + 'px';
                this.innerHd.firstChild.firstChild.style.width = tw + 'px';
            }

            if(this.mainBody){
                this.lockedBody.dom.style.width = (lw + rp) + 'px';
                this.mainBody.dom.style.width = (tw + rp) + 'px';
            }
        },

        updateSortIcon : function(col, dir){
            var sortClasses = this.sortClasses,
                lockedHeaders = this.lockedHd.select('td').removeClass(sortClasses),
                headers = this.mainHd.select('td').removeClass(sortClasses),
                lockedLen = this.cm.getLockedCount(),
                cls = sortClasses[dir === 'DESC' ? 1 : 0];

            if(col < lockedLen){
                lockedHeaders.item(col).addClass(cls);
            } else {
                headers.item(col - lockedLen).addClass(cls);
            }
        }
    });

}());

if ("undefined" == typeof window.Ext){ window.Ext = {} }
if ("undefined" == typeof Ext.ux){ Ext.ux = {} }
if ("undefined" == typeof Ext.ux.grid){ Ext.ux.grid = {} }

new function() {
	/**
	 * @class Ext.grid.RowNumberer
	 * This is a utility class that can be passed into a {@link Ext.grid.ColumnModel} as a column config that provides
	 * an automatic row numbering column.
	 * <br>Usage:<br>
	 <pre><code>
	 // This is a typical column config with the first column providing row numbers
	 var colModel = new Ext.grid.ColumnModel([
	    new Ext.grid.RowNumberer(),
	    {header: "Name", width: 80, sortable: true},
	    {header: "Code", width: 50, sortable: true},
	    {header: "Description", width: 200, sortable: true}
	 ]);
	 </code></pre>
	 * @constructor
	 * @param {Object} config The configuration options
	*/
	Ext.ux.grid.RowLabeler = function(config){
	    Ext.apply(this, config);
	    if(this.rowspan){
	        this.renderer = this.renderer.createDelegate(this);
	    }
	};

	Ext.ux.grid.RowLabeler.prototype = {
	    /**
	     * @cfg {String} header Any valid text or HTML fragment to display in the header cell for the row
	     * number column (defaults to '').
	     */
	    header: "",
	    /**
	     * @cfg {Number} width The default width in pixels of the row number column (defaults to 23).
	     */
	    width: 23,
	    /**
	     * @cfg {Boolean} sortable True if the row number column is sortable (defaults to false).
	     */
	    sortable: false,

	    // private
	    fixed		: false,
	    menuDisabled: true,
	    dataIndex	: '',
	    id			: 'labeler',
	    rowspan		: undefined,
	    selectable	: false,

	    // private
	    renderer : function(v, p, record, rowIndex){
	        if(this.rowspan){
	            p.cellAttr = 'rowspan="'+this.rowspan+'"';
	        }
	        return record.get("label");
	    }
	};
}();

if ("undefined" == typeof window.Ext){ window.Ext = {} }
if ("undefined" == typeof Ext.ux){ Ext.ux = {} }
if ("undefined" == typeof Ext.ux.grid){ Ext.ux.grid = {} }


(function() {
	/**
	 @class Ext.ux.grid.SimpleRowSelectionModel
	 * @extends Ext.grid.RowSelectionModel
	 * Extends the default {@link Ext.grid.RowSelectionModel} by a 
	 * simpleSelect option.
	 * @constructor
	 * @param {Object} config
	 */
	Ext.ux.grid.SimpleRowSelectionModel = function(config) {
		Ext.apply(this, config);
		
		Ext.ux.grid.SimpleRowSelectionModel.superclass.constructor.call(this);
	};
	
	Ext.extend(Ext.ux.grid.SimpleRowSelectionModel, Ext.grid.RowSelectionModel,  {
		/**
	     * @cfg {Boolean} simpleSelect
	     * True to allow toggling the selection of one row without hold shift or
	     * ctrl. (defaults to true)
	     */
		simpleSelect: true,
		
		// private
		// overrides #handleMouseDown of the RowSelectionModel to enable 
		// simpleSelect
	    handleMouseDown : function(g, rowIndex, e){
	        if(e.button !== 0 || this.isLocked()){
	            return;
	        };
	        var view = this.grid.getView();
	        if(e.shiftKey && this.last !== false){
	            var last = this.last;
	            this.selectRange(last, rowIndex, e.ctrlKey);
	            this.last = last; // reset the last
	            view.focusRow(rowIndex);
	        }else{
	            var isSelected = this.isSelected(rowIndex);
	            if((e.ctrlKey||this.simpleSelect) && isSelected){
	                this.deselectRow(rowIndex);
	            }else if(!isSelected || this.getCount() > 1){
	                this.selectRow(rowIndex, e.ctrlKey || e.shiftKey || this.simpleSelect);
	                view.focusRow(rowIndex);
	            }
	        }
	    }
	});
}())
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

new function(){
	
	
	var isIPad = !!String(window.navigator.userAgent).match(/ipad/i);
	var isIPhone = !!String(window.navigator.userAgent).match(/iphone/i);
	
	var defaults = {touchCount: 1};

	Ext.isIPad = isIPad || isIPhone;
	Ext.isTouch = Ext.isIPad;
	
	
	if ((isIPad || isIPhone) && "undefined" != typeof iScroll){
		

		/*******************************
		 *** iPAD - EVENT - HANDLING ***
		 *******************************/
		(function(){ // @scope Event-Handling
			
			var initialScale = 1.0;
			try {
				initialScale = Number(Ext.getDoc().child("meta[name=viewport]").dom.content.replace(/(.*initial-scale=)([0-9\.]*)(.*)/, "$2"));
			} catch(e){}
			
			//window.addEventListener('onorientationchange' in window ? 'orientationchange' : 'resize', setHeight, false);
			document.addEventListener('touchmove', function(e){ e.preventDefault(); }, false);
			
			/**
			 * PRIVATE METHODS
			 * 
			 */
			
			// Raise event
			var raiseEvent = function(type, node, event, obj){
//				console.log(type)
				var ev = document.createEvent('MouseEvents');
				ev.initMouseEvent(type, true, true, window, 'dblclick' === type ? 2 : 1,
					event.screenX, event.screenY, event.clientX, event.clientY,
					false, false, false, false,
					0, null);
				ev._fake = true;
				Ext.apply(ev, obj || {});
				node.dispatchEvent(ev);
			};
			
			// Return the target element
			var getTarget = function(node){
				node = (node.ownerSVGElement ? (Ext.fly(node).parent("g")||{dom:node}).dom : node);
				return node.nodeType !== 1 ? node.parentNode : node;
			};
			
			var clickTarget = undefined, clickTimer, startPos;
			
			/**
			 * CLICK
			 */
 			document.addEventListener('touchstart', function(e){ 
 				if (e.target && ["textarea", "input"].include(String(e.target.tagName).toLowerCase())){
 					return;
 				}
 				clickTarget = undefined;
 				window.clearTimeout(clickTimer);
 				if (e.touches.length == 1){
 					clickTarget = getTarget(e.touches[0].target);
 					startPos = {x: e.touches[0].pageX, y: e.touches[0].pageY};
 					clickTimer = window.setTimeout(function(){ clickTarget = undefined; }, 1000);
 					raiseEvent("mousedown", e.touches[0].target, e.touches[0]);
 					
 					// Prevent default so that the mouse down is not raises twice. 
 					// Mainly that a menu won't close if clicking it --> Toolbar.
 					//if ((getComputedStyle(clickTarget, null)["-webkit-tap-highlight-color"] === "rgba(0, 0, 0, 0)" || String(clickTarget.className).include("x-menu")) && !clickTarget.ownerSVGElement){
 						e.preventDefault();
 					//}
 				}
 			}, true);

 			document.addEventListener('touchmove', function(e){
 				if (e.touches.length == 1 && clickTarget && startPos){
 					if ((Math.abs(startPos.x - e.touches[0].pageX) + Math.abs(startPos.y - e.touches[0].pageY)) >= 5){
 						clickTarget = startPos = undefined;
 					}
 				}
 			}, true);
 			
 			document.addEventListener('touchend', function(e){ 
 				if (e.changedTouches.length == 1 && clickTarget && clickTarget === getTarget(e.target)){
 					raiseEvent("mouseup", clickTarget, e.changedTouches[0]);
					raiseEvent("click", clickTarget, e.changedTouches[0]);
					raiseEvent("mouseout", clickTarget, e.changedTouches[0]);
 					clickTarget = false;
 				}
 			}, true);
 			
			var target, timer, dblClickEnabled = false;
			
			/**
			 * DBL-CLICK
			 */
 			document.addEventListener('click', function(e){ 
 				if (!e._fake){
 					if (window.navigator.product === "Gecko"){
 						return;
 					}
 					e.preventDefault();
 	 				e.stopPropagation();
 	 				return;
 				}

 				window.clearTimeout(timer);
 				if (dblClickEnabled && target === e.target){
 					raiseEvent("dblclick", e.target, e);
 					dblClickEnabled = target = false;
 				} else {
 					dblClickEnabled = true; target = e.target;
	 				timer = window.setTimeout(function(){
	 					dblClickEnabled = target = false;
	 				}, 1000);
 				}
 			}, true);
 			
 			
 			
			/**
			 * DBL-CLICK with TWO-FINGERS
			 */
			(function(){
				var clickcount = 0, timer, startDBLPos, 
					onDBLClick = function(e){
						raiseEvent("dblclick", e.target, e, {touchCount: 2});
					}.bind(this);
					
				document.addEventListener("gesturestart", function(ev){
					clickcount = clickcount > 1 ? 0 : ++clickcount;
					startDBLPos = 0;
					target = dblClickEnabled = clickTarget = startPos = false;
				}, false);
				
	 			document.addEventListener("touchmove", function(e){
	 				if (e.touches.length == 2 && clickcount > 0){
	 					if (!startDBLPos){
	 						startDBLPos = {x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY};
	 					}
	 					if ((Math.abs(startDBLPos.x - e.changedTouches[0].pageX) + Math.abs(startDBLPos.y - e.changedTouches[0].pageY)) >= 10){
	 						clickcount = startDBLPos = 0;
	 					}
	 				}
	 			}, true);
	 			
				document.addEventListener("gestureend", function(ev){
					window.setTimeout(function(){
						clickcount = 0;
					}, 2000);
					if (clickcount === 2){
						onDBLClick(ev);
						clickcount = 0;
						startDBLPos = undefined;
	 					dblClickEnabled = target = false;
 						clickTarget = startPos = undefined;
					}
				}, false);
			}.bind(this)());
			
 			/** **********************
 			 * MOUSE-EVENTS - EDITOR
 			 * 
 			 */
 			if ("undefined" != typeof ORYX){

 	 			/**
 	 			 * MOUSE-DOWN
 	 			 */
 	 			document.addEventListener('touchstart', function(e){ 
 	 				// @deprecated See above
 	 				//if (e.touches.length == 1)
 	 				//	raiseEvent("mousedown", e.touches[0].target, e.touches[0]);
 	 			}, true);
 	 			
 	 			/**
 	 			 * MOUSE-MOVE
 	 			 */
 	 			(function(){
 	 				var timer;
 	 	 			document.addEventListener('touchmove', function(e){ 
 	 	 				if (e.touches.length == 1){
// 	 	 					window.clearTimeout(timer);
// 	 	 					timer = window.setTimeout(function(event){
 	 	 						raiseEvent("mousemove", event.touches[0].target, event.touches[0]);
// 	 	 					}.bind(this, e), 100);
 	 	 				}
 	 	 			}, true);
 	 	 			
 	 	 			/**
 	 	 			 * MOUSE-UP
 	 	 			 */
 	 	 			document.addEventListener('touchend', function(e){ 
 	 	 				if (e.changedTouches.length == 1){
// 	 	 					window.clearTimeout(timer);
 	 	 					raiseEvent("mouseup", e.changedTouches[0].target, e.changedTouches[0]);
 	 	 				}
 	 	 			}, true);
 	 	 			document.addEventListener('gestureend', function(e){
// 	 					window.clearTimeout(timer);
 	 	 				raiseEvent("mouseup", e.target, e);
 					}, true);
 	 			}());

 	 			
 	 			/**
 	 			 * For ToolTips create a text representation.
 	 			 * Only supported for SVG dom elements
 	 			 */
 	 			Ext.ToolTip.prototype.initTarget = function(){
 	 				if (this.html && this.target){
 	 				    this.target = Ext.get(this.target);
 	 				    if (this.target.dom.ownerSVGElement){
	 	 				    var path = this.target.dom, parent = path.parentNode;
	 	 				    var node = ORYX.Editor.graft("http://www.w3.org/2000/svg", parent, ['text', {
	 	 				            stroke: "none",
	 	 				            x: path.transform.animVal.getItem(0).matrix.e + path.getBBox().width + 10,
	 	 				            y: path.transform.animVal.getItem(0).matrix.f - (path.getBBox().height / 2)
	 	 				        }, this.html]);

	 	 				 	path.addEventListener("DOMNodeRemoved", function(){
	 	 				 		node.parentNode.removeChild(node);
	 	 				 	}, false);
 	 				    }
 	 				}
 	 			};
 	 			
 	 		/** ********************
 			 * MOUSE-EVENTS - EXPLORER
 			 * 
 	 		 */
 			} else {
 				
 	 			var touch, moved = false, touchedEndRecently = false, touchCount = 0;
 	 			
 	 			/**
 	 			 * MOUSE-DOWN
 	 			 */
 	 			document.addEventListener('touchstart', function(e){ 
 					touchCount = e.touches.length;	
 	 				if (touchCount >= 1 && !touchedEndRecently && !moved) {
 	 					touch = touch || (e.touches.length == 2 ? e.changedTouches[0] : e.touches[0]);
 	 					moved = false;
 	 				}
 	 				
 	 				if (touchCount == 2 && touch && !moved) {
 	 					raiseEvent("mousedown", touch.target, touch);
 	 				}
 	 			}, true);
 	 			
 	 			/**
 	 			 * MOUSE-MOVE
 	 			 */
 	 			document.addEventListener('touchmove', function(e){ 
 	 				if (e.touches.length === 2){
 	 					raiseEvent("mousemove", e.touches[e.touches[0]==touch?1:0].target, e.touches[e.touches[0]==touch?1:0]);
 	 					moved = true;
 						target = dblClickEnabled = clickTarget = startPos = false;
 	 				}
 	 			}, true);
 	 			
 	 			/**
 	 			 * MOUSE-UP
 	 			 */
 	 			document.addEventListener('touchend', function(e){ 
 	 				if (e.changedTouches.length >= 1 && --touchCount === 1){
 	 					raiseEvent("mouseup", e.changedTouches[0].target, e.changedTouches[0]);
 	 					touchedEndRecently = true;
 	 					window.setTimeout(function(){touchedEndRecently = false; }, 1000);
 	 				}
 	 				if (moved){
 	 					moved = false;
 	 					e.preventDefault();
 	 					e.stopPropagation();
 	 				}
 	 				touch = undefined;
 	 			}, true);
 	 			
 			}

		}());
			
		
		/*****************************
		 *** EXT - UX - COMPONENTS ***
		 *****************************/
		
		
		/**
		 * Add SCROLLING for GRIP PANEL
		 */ 
		(function(){
			var rui = Ext.grid.GridView.prototype.renderUI;
			Ext.grid.GridView.prototype.renderUI = function(){
				var res = rui.apply(this, arguments);
				this.iscroll = new iScroll(this.mainBody.dom, Object.clone(defaults));
				
				//if (this instanceof Ext.grid.GroupingView){
					//this.mainBody.on('click', this.interceptMouse, this);
				//}
				
				return res;
			};

			var tog = Ext.grid.GroupingView.prototype.toggleGroup;
			Ext.grid.GroupingView.prototype.toggleGroup = function(){
				var res = tog.apply(this, arguments), initialScroll;
				if (this.iscroll){
					this.iscroll.destroy();
					initialScroll = this.mainBody.dom.style.webkitTransform;
				}
				this.iscroll = new iScroll(this.mainBody.dom, Object.clone(defaults));
				if (initialScroll){
					this.mainBody.dom.style.webkitTransform = initialScroll;
				}
				return res;
			};
			
		}());

		
		
		/**
		 * Add SCROLLING for TREE PANEL
		 */ 
		(function(){
			var onr = Ext.tree.TreePanel.prototype.onRender;
			Ext.tree.TreePanel.prototype.onRender = function(){
				var res = onr.apply(this, arguments);
				var sn = this.innerCt.findParent("div{overflow=auto}");
				sn = sn ? sn.firstChild : this.innerCt.dom;
				this.iscroll = new iScroll(sn, Object.clone(defaults));
				this.on("expandnode", function(){
					
					var sn = this.innerCt.findParent("div{overflow=auto}"), initialScroll;
					sn = sn ? sn.firstChild : this.innerCt.dom;
					
					if (this.iscroll){
						this.iscroll.destroy();
						initialScroll = sn.style.webkitTransform;
					}
					this.iscroll = new iScroll(sn, Object.clone(defaults));
					if (initialScroll){
						sn.style.webkitTransform = initialScroll;
					}
				});
				return res;
			};		
		}());

		
		
		/**
		 * Add SCROLLING for DATAVIEW
		 */
		(function(){
			Ext.DataView.prototype.onRender = function(){
				var created = true;
		        if(!this.el){
		        	created = false;
		            this.el = document.createElement('div');
		        }
		        Ext.DataView.superclass.onRender.apply(this, arguments);
		        
		        // @todo: Enable scrolling if dataview is created through applyTo like in the combobox-innerlist
		        if (!created){
			        if (this.cls){
			        	this.el.addClass(this.cls);
			        }
			        
			        if (this.style){
			        	this.el.applyStyles(this.style);
			        }
			        
			        if (!this.scroll){
			        	this.scroll = this.el.getStyle("overflow") === "auto" ? this.el.createChild({tag:"div"}) : this.el;
			        }
			        
			        if (this.scroll.parent().getStyle("overflow") === "auto"){
				        if (!this.iscroll){
							this.iscroll = new iScroll(this.scroll.dom, Object.clone(defaults));
				        } else {
					        this.iscroll.refresh();
				        }
			        }
		        }
			};
			
			Ext.DataView.prototype.refresh = function(){
		        this.clearSelections(false, true);
		        (this.scroll||this.el).update("");
		        var html = [];
		        var records = this.store.getRange();
		        if(records.length < 1){
		            (this.scroll||this.el).update(this.emptyText);
		            this.all.clear();
		            return;
		        }
		        this.tpl.overwrite((this.scroll||this.el), this.collectData(records, 0));
		        this.all.fill(Ext.query(this.itemSelector, (this.scroll||this.el).dom));
		        this.updateIndexes(0);
		        
		        if (this.iscroll){
		        	this.iscroll.refresh();
		        }
		    };
		    
		    Ext.DataView.prototype.onBeforeLoad = function(){
		        if(this.loadingText){
		            this.clearSelections(false, true);
		            (this.scroll||this.el).update('<div class="loading-indicator">'+this.loadingText+'</div>');
		            this.all.clear();
			        if (this.iscroll){
			        	this.iscroll.refresh();
			        }
		        }
		    };
		    
		    Ext.DataView.prototype.show = function(){
		    	Ext.BoxComponent.prototype.show.apply(this, arguments);
		        if (this.iscroll){
		        	this.iscroll.refresh();
		        }
		    };
		}());
		
		
		/**
		 * Stop Scrolling if drag and drop
		 */
	    
	    (function(){
	    	
	    	// Cache last move position
	    	var lastMouseMoveEvent;
	    	Ext.EventManager.on(document, "mousemove", function(e){ lastMouseMoveEvent = e; }, this, true);
	    	
	    	var stopScrolling = function(panel){
	    		if (panel && panel.iscroll){
	    			panel.iscroll.scrolling = false;
	    			panel.iscroll.resetPosition();
	    		}
	    	};
	    	
	    	
	    	Ext.dd.DragDropMgr.handleMouseDown = function(e, oDD) {
	            if(Ext.QuickTips){
	                Ext.QuickTips.disable();
	            }
	            this.currentTarget = e.getTarget();
	            this.dragCurrent = oDD;

	            var el = oDD.getEl();

	            // track start position
	            this.startX = e.getPageX();
	            this.startY = e.getPageY();

	            this.deltaX = this.startX - el.offsetLeft;
	            this.deltaY = this.startY - el.offsetTop;

	            this.dragThreshMet = false;
	        };
	        
	        
	        Ext.dd.DragDropMgr.startDrag = function(x, y) {
	        	//this.useCache = false;
	        	for (var i in this.ids["default"]) {
	                var oDD = this.ids["default"][i];
	                if (!this.isTypeOfDD(oDD)) { continue; }
	                if (this.isOverTarget(lastMouseMoveEvent ? lastMouseMoveEvent.getPoint() : new Ext.lib.Point(x, y), oDD, this.mode)){
	                	 // @TODO: This is a hacky way to get the parent panel of the dragProxy
	                	try {
	                		if (this.dragCurrent)          		
	                			stopScrolling(Ext.getCmp(this.dragCurrent.el.parent(".x-panel").dom.id));
	                		lastMouseMoveEvent = undefined;
	                	} catch(e){}
	                	break;
	                } else {
	                	return
	                }
	        	}
	            clearTimeout(this.clickTimeout);
	            if (this.dragCurrent) {   
	                this.dragCurrent.b4StartDrag(x, y);
	                this.dragCurrent.startDrag(x, y);
	            }
	            this.dragThreshMet = true;
	        };
	    }());
	    
	    
		// Return the scrolling of the given element
		var parseWebkitTransform = function(el){
			try {
				var obj = (el.style.webkitTransform || "").replace(/(.*translate.+?)([-0-9\.]+)(.*?)([-0-9\.]+)(.*)/i, "{left:$2, top:$4}");
				obj = obj.startsWith("{") ? obj.evalJSON() : {};
				if (obj && "undefined" != typeof obj.left && "undefined" != typeof obj.top){
					return [-obj.left, -obj.top];
				}
			} catch(e){}
			return [0, 0];
		};
		
	    
	    /**
	     * HTMLAnchorElement - Fix focus
	     */
	    (function(){
	    	var focus = HTMLAnchorElement.prototype.focus;
	    	HTMLAnchorElement.prototype.focus = function(){
	    	    var scroll =  Ext.fly(this).parent("div{overflow=auto}", true);
	    	    if (!scroll){
		    	    focus.call(this);
	    	    	return;
	    	    }

	    	    // Set origin scroll pos
	    	    var fc = scroll.children[0];
	    	    var sp = parseWebkitTransform(fc);
    	    	if (sp[0] || sp[1]){
    	    		scroll.scrollLeft = sp[0];
    	    		scroll.scrollTop = sp[1];
    	    	}
    	    	
	    	    // Focus
    	    	focus.call(this);
    	    	
	    	    // Set new scroll pos
	    	    fc.style.webkitTransform = "translate("+(-scroll.scrollLeft)+"px, "+(-scroll.scrollTop)+"px)";
	    	    scroll.scrollLeft = scroll.scrollTop = 0;
	    	};
	    }());
	    
	    
	    (function(){
		    /**
		     * EXT - FIX Scroll Animation
		     */
		    if (window.Ext && Ext.lib){
		    	// Get scroll attribute
		    	Ext.lib.Scroll.prototype.getAttribute = function(attr){
		            var val = null;
		            var el = this.getEl();
		            if (attr == 'scroll') {
		                val = parseWebkitTransform(el.firstChild);
		            } else {
		                val = Ext.lib.Scroll.superclass.getAttribute.call(this, attr);
		            }
		            return val;
		    	};
		    	
		    	// Set scroll attribute
		    	Ext.lib.Scroll.prototype.setAttribute = function(attr, val, unit) {
		            var el = this.getEl();
		            if (attr == 'scroll') {
			        	el.firstChild.style.webkitTransform = "translate("+(-val[0])+"px, "+(-val[1])+"px)";
	//		        	if (mainscroll && mainscroll.element === el){
	//		        		mainscroll.x = -val[0];
	//		        		mainscroll.y = -val[1];
	//		        	}
		            } else {
		            	Ext.lib.Scroll.superclass.setAttribute.call(this, attr, val, unit);
		            }
		        };
		        
		        // Get the scroll values
		        var gScroll = Ext.Element.prototype.getScroll;
		        Ext.Element.prototype.getScroll = function(){
			        var d = this.dom, doc = document; 
			        if (d !== doc && d !== doc.body) { 
			        	var scroll = new Ext.lib.Scroll(d).getAttribute("scroll");
			        	return {left: scroll[0], top: scroll[1]}; 
			        } else {
			        	return gScroll.apply(this, arguments);
			        } 
	
		        }
		    }
        
        
 			
 			/**
 			 * FIX YUI Scroll Animation
 			 *
 			 */
			if (window.YAHOO && YAHOO.util){
	 			YAHOO.util.Scroll.prototype.getAttribute = function(attr, val, unit) {
	 			    var val = null;
	 		        var el = this.getEl().firstChild;
	 		        if (attr == 'scroll') {
						val = parseWebkitTransform(el);
	 		        } else {
	 		            val = superclass.getAttribute.call(this, attr);
	 		        }
	 		        return val || [0, 0];
	 			}
	 			
	 			YAHOO.util.Scroll.prototype.setAttribute = function(attr, val, unit) {
			        var el = this.getEl().firstChild;
			        if (attr == 'scroll') {
//			        	console.log("scroll to "+val[0]+" and "+val[1])
			        	//var scrollTop = Math.min(Math.max(0, el.scrollHeight-el.parentNode.offsetHeight), Math.max(0, fx.now));
	 				
			        	el.style.webkitTransform = "translate("+(-val[0])+"px, "+(-val[1])+"px)";
			        	if (mainscroll && mainscroll.element === el){
			        		mainscroll.x = -val[0];
			        		mainscroll.y = -val[1];
			        	}
			        } else {
			        	YAHOO.util.Scroll.superclass.setAttribute.call(this, attr, val, unit);
			        }
	 			};

				
	 			/**
	 			 * FIX YUI get("scrollTop")/get("scrollLeft")
	 			 */
	 			var gap = YAHOO.util.AttributeProvider.prototype.get;
	 			YAHOO.util.AttributeProvider.prototype.get = function(key){
	 				if (key == "scrollTop" || key == "scrollLeft"){
	 					return parseWebkitTransform(this.get("element").firstChild)[key == "scrollTop" ? 1 : 0];
	 				}
	 	            return gap.call(this, key);
	 			};
	 			
			}
 			
 			
 			/**
 			 * FIX jQuery Scrolling animation
 			 */
 			if (window.jQuery && jQuery.fx){
	 			jQuery.fx.step.scrollTop = function(fx){
	 				var el = fx.elem.children[0];
	 				var scrollTop = Math.min(Math.max(0, el.scrollHeight-el.parentNode.offsetHeight), Math.max(0, fx.now));
	 				el.style.webkitTransform = "translate(0px, "+(-(scrollTop))+"px)";
	 			};
	 			
	 			var cur = jQuery.fx.prototype.cur;
	 			jQuery.fx.prototype.cur = function(){
	 				if (this.prop === "scrollTop" || this.prop === "scrollLeft"){
	 					return parseWebkitTransform(this.elem.children[0])[this.prop == "scrollTop" ? 1 : 0];
	 				} else {
	 					return cur.apply(this, arguments);
	 				}
	 			};
 			}
	    }());
	}

}();

ns("ux");

(function() {

	Signavio.ux.Image = function(attrs) {
		attrs = attrs || {};

		var cls = ["x-signavio-image"].concat(attrs.cls).compact().join(" ");

		attrs.template = attrs.template || new Ext.Template(
			"<img class='" + cls + "' src='{0}' />"
		);

		delete attrs.cls;

		Signavio.ux.Image.superclass.constructor.apply(this, arguments);
	};

	Ext.extend(Signavio.ux.Image, Ext.BoxComponent, {

		onRender: function() {
			this.el = Ext.get(this.template.append(this.container.dom, [this.src]));

			this.el.setStyle({
				height: this.size(this.height),
				width: this.size(this.width),
				maxHeight: this.size(this.maxHeight),
				maxWidth: this.size(this.maxWidth)
			});
		},

		size: function(number) {
			if(!number) {
				return;
			}

			return number + "px";
		}

	});

}());
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" == typeof window.Ext){ window.Ext = {} }
if ("undefined" == typeof Ext.ux){ Ext.ux = {} }
if ("undefined" == typeof Ext.ux.layout){ Ext.ux.layout = {} }

/**
 * Implement a vertical box layout. Item are resized by their minHeight property.
 * Stretched by relatively by the flex weight factor. Or have a fixed height
 * value.
 */
new function(){
	Ext.ux.layout.VBoxLayout = Ext.extend(Ext.layout.ContainerLayout, {
		
		onLayout: function(ct, target) {
			Ext.ux.layout.VBoxLayout.superclass.onLayout.call(this, ct, target);
			
			var visibleItems = this.getVisibleItems(ct),
				containerSize = this.getContainerSize(),
			
				childBoxes = this.calculateChildBoxes(visibleItems, containerSize);
			
			this.layoutChildPanels(childBoxes);
		},
		
		/**
		 * Retrieves all items of the container being uncollapsed and rendered. 
		 * Additionally counts the collapsed ones.
		 */
		getVisibleItems: function(ct) {
			var container = ct||this.container,
				containerItems = container.items.items,
				
				// Static height of collapsed items
				coHeight = 0,
				// Items for height calculation
				visibleItems = [];
			
			containerItems.each(function(item) {
				if(item.rendered && item.hidden !== true) {
					if(item.collapsed === true) {
						coHeight += item.getSize().height||0;
					} else {
						visibleItems.push(item);
					}
				}
			});
			
			this.collapsedItemsHeight = coHeight;
			
			return visibleItems;
		},
		
		/**
		 * Calculates the size of the target layout container.
		 */
		getContainerSize: function() {
			var size = {width: 0 , height: 0},
				layoutTarget = this.container.getLayoutTarget();
			
			if(layoutTarget) {
				size = this.container.getLayoutTarget().getViewSize();
				
				// IE-Issues with invalid width and height values
				if(Ext.isIE && Ext.isStrict && size.width == 0) {
					size = layoutTarget.getStyleSize();
				}
				
				// TODO: perhaps consider padding?
				
				size.height -= layoutTarget.getPadding('tb');
				
			}
				
			return size;
		},
		
		isNumber: function(o) {
			return ! isNaN(o - 0);
		},
		
		/**
		 * Calculates the size of the child box elements and triggers the
		 * layout callback
		 */
		calculateChildBoxes: function(items, ctSize) {
			// Var declaration 
			var availableHeight = ctSize.height - this.collapsedItemsHeight,
				flexCount = 0,
				me = this,
				
				childHeight, hasLayoutCB, heightPerFlex,
				flex,
				boxes = [];			
                
			// Calculate flex values of all items
			items.each(function(child) {
				childHeight = child.height;
				hasLayoutCB = !child.hasLayout && (child.doLayout instanceof Function);
				
				// Only consider elements without a fixed height in the
				// calculation
				if(me.isNumber(childHeight)) {					
					if(hasLayoutCB) {
						child.doLayout();
						childHeight = child.getSize().height;
						availableHeight -= childHeight;
					}
				}
				
				// Flexible box
				else if(child.flex) {
					flexCount += child.flex;
				}
				
				// Default flex
				else {
					flexCount++;
				}
			});
			
			heightPerFlex = availableHeight / flexCount;
			
			// Calculate height values
			items.each(function(box) {
				// Ignore fixed height boxes
				if(!me.isNumber(box.height)) {
					flex = box.flex||1;
					boxes.push({panel: box, dirty: true, height: flex * heightPerFlex});
				}
			});
			
			return boxes;
		},
		
		/**
		 * Triggers layouting of child panels with adjusted sizes.
		 */
		layoutChildPanels: function(configs) {
			if(configs instanceof Array) {
				configs.each(function(info) {
					if(info.dirty) {
						// TODO: update other position setting here as well.
						info.panel.setSize(undefined, info.height);
						info.panel.doLayout();
					}
				});
			}
		},
		
		/**
		 * Recalculates size for each panel in the container and updates the
		 * layout.
		 */
		adjustSize : function(p) {
			var items = this.getVisibleItems(),
	            ctSize = this.getContainerSize(),
				
	            // Recalculate panel sizes         
	        	childBoxCache = this.calculateChildBoxes(items, ctSize);
	       
	        // Upadate layout
			this.layoutChildPanels(childBoxCache);
		},
		
		/**
		 * Additional removes the resize listener.
		 */
		onRemove: function(c){
	        Ext.ux.layout.VBoxLayout.superclass.onRemove.call(this, c);
	        
	        c.un('expand', this.adjustSize, this);
	        c.un('collapse', this.adjustSize, this);
	    },
	    
	    // private	
	    renderItem : function(c) {
	    	Ext.ux.layout.VBoxLayout.superclass.renderItem.apply(this, arguments);
			
			c.on('expand', this.adjustSize, this);
			c.on('collapse', this.adjustSize, this);
	    }
	    
	    
	});
	
	Ext.Container.LAYOUTS['ux.vbox'] = Ext.ux.layout.VBoxLayout;
}();

/**
 *  (c) 2010 Signavio GmbH
 *
 *  @author Willi Tscheschner
 *
 */

if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {} }

new function(){

	/**
	 * Returns the PropertyEditor for the given name.
	 *
	 * @param {String} name
	 * @return {AbstractPropertyEditor}
	 */
	Ext.ux.propertyeditor.getEditor = function(name){
		if (!name || "string" != typeof name){ return null; }
		name = name.toLowerCase();

		for (var i in Ext.ux.propertyeditor){
			if (String(i).toLowerCase() === name){
				return Ext.ux.propertyeditor[i];
			}
		}
		return null;
	}


	/**
	 * Abstract class to provide an editor which can be used in
	 * a stencilset and with this in the propertywindow
	 *
	 * @class
	 * @param {Object} property
	 * @param {Object} facade
	 */
	Ext.ux.propertyeditor.AbstractPropertyEditor = function(property, facade){
		this.property = property;
		this.properties = property ? property.stencil().properties() : undefined;
		this.facade = facade;
		Ext.ux.propertyeditor.AbstractPropertyEditor.superclass.constructor.apply(this, [{}]);
	}

	Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, Ext.form.TriggerField,  {

		readOnly: true,
		triggerClass:"x-trigger-other",

		windowCreate: {},

		/**
		 * This method can be used to define a value which
		 * will be shown in the property window.
		 * @param {Object} value
		 * @return {String}
		 */
		renderer: function(value){
			return String(value);
		},

		setValue: function(value){
			this.value = value;
			this.setRawValue(this.renderer(value));
		},

		getValue: function(){
			return this.value;
		},

		onTriggerClick: function(){

			var panel = this.getEditor(this.getValue())
				, me = this
				, buttons = (this.windowCreate||{}).buttons
				, noButtons = this.windowCreate.noButtons;

			delete (this.window||{}).noButtons;
			
			if (buttons){
				delete (this.windowCreate||{}).buttons;
			}

			var useApplyInsteadOfSaveButton = !!(this.windowCreate||{}).useApplyInsteadOfSaveButton;
			
			buttons = [].concat(buttons||[], [{
						text: Ext.ux.getI18N(useApplyInsteadOfSaveButton ? "btnapply" : "btnsave"),
						handler: function(){
							if (this.onBeforeSave(this.getValue(), panel.getValue())) {
								this.onSave(this.getValue(), panel.getValue());
								win.close();
							}
						}.bind(this)
					}]);
			
			// Destroy all buttons if specified by configuration
			if (noButtons) {
				buttons = [];
			}
			
			var win = new Ext.ux.Window(Ext.apply({
					autoCreate: true,
					title: (this.property?this.property.title():"")||this.title||"",
					cls: "x-property-editor",
					minWidth: 200,
					minHeight:200,
					height: 300,
					width: 340,
					modal: true,
					collapsible: false,
					fixedcenter: true,
					shadow: true,
					proxyDrag: true,
					layout: "anchor",
					bodyStyle: "padding:10px;background-color:#FFFFFF;",
					autoScroll: true,
					keys: [{
						key: 27, //Esc
						fn: function(){
							win.hide();
						}.bind(this)
					}],
					items: [panel],
					listeners: {
						show : this.onWindowShow.bind(this, win, panel),
						hide : this.onWindowHide.bind(this, win, panel)
					},
					render: function(){
						Ext.Window.prototype.render.apply(this, arguments);
						me.onWindowRendered(win);
					},
					buttons: buttons
				}, this.windowCreate));

			win.show();
			
			// store window reference
			this.win = win;
		},

		/**
		 * Callback before the new value is stored.
		 * Should be used for further checks.
		 * @param {Object} oldValue
		 * @param {Object} newValue
		 * @returns true if the Editor can save
		 */
		onBeforeSave: function(oldValue, newValue) {
			return true;
		},

		/**
		 * Callback to store the new value
		 * @param {Object} oldValue
		 * @param {Object} newValue
		 */
		onSave: function(oldValue, newValue){
			this.setValue(newValue);
			this.fireEvent('dialogClosed', this, newValue, oldValue);
		},

		/**
		 * Will be called if the window is shown
		 * @param {Object} win
		 * @param {Object} panel
		 */
		onWindowShow: function(win, panel){
			// Hide Editor
			this.fireEvent("blur");
			if (panel.focus instanceof Function) {
				// Set Focus to the field
				window.setTimeout(panel.focus.bind(panel), 100);
			}

			if(this.facade.disableEvent) {
				// this method is currently only available in the editor
				// -> Facade should also get part of libs and components should then only
				// extend it with specialized functionality
				this.facade.disableEvent(Signavio.Config.EVENT_KEYDOWN);
			}
		},

		/**
		 * Will be called if the window is hiding
		 * @param {Object} win
		 * @param {Object} panel
		 */
		onWindowHide: function(win, panel){
			if(this.facade.enableEvent) {
				// this method is currently only available in the editor
				// -> Facade should also get part of libs and components should then only
				// extend it with specialized functionality
				this.facade.enableEvent(Signavio.Config.EVENT_KEYDOWN);
			}
		},

		/**
		 * Will be called when the window has been rendered
		 * @param win
		 */
		onWindowRendered: function(win){},

		/**
		 * @abstract
		 */
		getEditor: function(value){
			throw Error("AbstractPropertyEditor.getEditor has to be implemented.");
		}

	});


}()
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Specific class to provide a panel to define a text area for the condition of an edge for ITSM
	 * 
	 */
	Ext.ux.propertyeditor.ITSMCondition = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {resizable: false, bodyStyle: "padding: 0px; background: white;", layout: "anchor", width: 400, height: 300},

		
		getVariableCombo: function(){
			
			
			var items = [];
			try {
				var val = this.facade.getCanvas().getProperty("variables");
				if ("string" == typeof val){
					val = val.evalJSON();
				}
				if ("object" == typeof val){
					items = val.items.pluck("name").compact();
				}
			} catch(e){}
			
			var variablesStore = new Ext.data.SimpleStore({
				data: items.map(function(r){ return [r, r]; }),
				fields: ["title", "id"]
			});
			
			var variables = new Ext.form.ComboBox({
				displayField	: "title",
				valueField		: "id",
				store			: variablesStore,
				mode			: "local",
				triggerAction	: "all",
				emptyText		: Ext.ux.getI18N("propertyeditor.itsm.condition.add"),
				onViewClick 	: function(){
					return Ext.form.ComboBox.prototype.onViewClick.call(this, false);
				},
				listeners		: {
					select: function(foo, rec){
						this.appendVariable(this.getVariableName(rec));
						variables.setValue();
					}.bind(this)
				}
			});
			
			return variables;
		},
		
		/**
		 * Returns the readable name of the variable record
		 * @param rec {Ext.data.Record} 
		 * @returns {String}
		 */
		getVariableName: function(rec){
			return "'"+rec.get("title")+"'";
		},
		
		/**
		 * 
		 * @param title
		 */
		appendVariable: function(title){
			var text = this.text.getValue() || "",
				cursor = "undefined" == typeof this.lastcursor ? {start: text.length, end: text.length} : this.lastcursor;
			this.text.setValue(text.slice(0, cursor.start) + "" + title + "" + text.slice(cursor.end));
			
			window.setTimeout(function(){
				this.text.focus();
			}.bind(this), 100);
		},
		
		
		/**
		 * Returns a panel where the condition area is included
		 * @param {Object} value
		 */
		getEditor: function(value){
			this.panel = new Ext.Panel({
				getValue: this.extractValue.bind(this),
				anchor: "100% 100%",
				layout: "anchor",
				border: false,
				tbar:  new Ext.Toolbar({style: "border:none;", items:[this.getVariableCombo()]}),
				items: [this.text = new Ext.form.TextArea({
						getCursor: function(){
							var dom = this.el.dom;
							if (dom && "undefined" != typeof dom.selectionStart){
								return {start: dom.selectionStart, end: dom.selectionEnd};
							} else if (window.getSelection && window.getSelection().getRangeAt){
								var range = window.getSelection().getRangeAt(0);
								return {start: range.startOffset, end: range.endOffset};
							}
							return undefined;
						},
						anchor: "100% 100%",
						value: value || "",
						listeners: {
							focus: function(){ delete this.lastcursor; }.bind(this),
							blur: function(){ this.lastcursor = this.text.getCursor(); }.bind(this)
						}
					})
				]});
			return this.panel;
		},
		
		/**
		 * Returns the value of the defined
		 * 
		 */
		extractValue: function(){
			return Ext.form.TextArea.prototype.getValue.call(this.panel.items.get(0)) || "";
		}
		
	});	
}();
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	

	/**
	 * Abstract class to provide a panel to define variable mappings for ITSM
	 * 
	 */
	Ext.ux.propertyeditor.ITSMFormEditor = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {resizable: false, bodyStyle: "padding: 10px; background: white;", layout: "fit", width: undefined, height: undefined},

		config: {
			proxy: undefined,
			fields: []
		},
		
		/**
		 * Parses the value and returns the obj
		 * @param (String) value
		 * @returns
		 */
		parseValue: function(value){
			if (value && "string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){}
			}
			return value;
		},
		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			value = this.parseValue(value);			
			var result = this.config.fields.map(function(field){
				return value[field.id+"Name"] || undefined;
			}).compact().join(" - ") || "";
			return result.unescapeHTML();
		},
		
		/**
		 * Update all used comboboxes.
		 * Disable/enable related comboboxes
		 * 
		 */
		updateComboBoxes: function(){
			var ff1 = this.formfield1.getValue(),
				ff2 = this.formfield2.getValue(),
				ff3 = this.formfield3.getValue();
			
			this.formfield2.enable();
			this.formfield3.enable();
			
			if (!ff1){
				this.formfield2.setValue("");
				this.formfield2.disable();
				this.formfield3.setValue("");
				this.formfield3.disable();
			} else if (!ff2) {
				this.formfield3.setValue("");
				this.formfield3.disable();
			}
			
			if (this.formfield4 && this.formfield5){
				var ff4 = this.formfield4.getValue(),
					ff5 = this.formfield5.getValue();
				this.formfield4.enable();
				this.formfield5.enable();
				if (!ff3){
					this.formfield4.setValue("");
					this.formfield4.disable();
					this.formfield5.setValue("");
					this.formfield5.disable();
				} else if (!ff4) {
					this.formfield5.setValue("");
					this.formfield5.disable();
				}
			}
				
		},

		/**
		 * 
		 * @returns {String}
		 */
		getAdditionalParameters: function(){
			var company = this.facade.getCanvas().getProperty("enterprise");
			if (!company) {
				company = this.facade.getCanvas().getStencil().property("oryx-enterprise").value();
			}
			if (company){
				return "company="+company;
			}
			return "";
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			if ("string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){ value = {};  }
			} else {
				value = value || {};
			}
			
			var onFF1Change = function(){					
        		this.formfield2.lastQuery = undefined;
        		this.formfield2.store.proxy.conn.url = this.formfield2.initialConfig.url+"&"+this.config.fields[0].id+"="+escape(this.formfield1.getValue());
				this.formfield2.setValue("");
				this.formfield3.setValue("");
        		this.updateComboBoxes();
        	}.bind(this);
        	
			var onFF2Change = function(){
        		this.formfield3.lastQuery = undefined;
        		this.formfield3.store.proxy.conn.url = this.formfield3.initialConfig.url+"&"+this.config.fields[0].id+"="+escape(this.formfield1.getValue())+"&"+this.config.fields[1].id+"="+escape(this.formfield2.getValue());
				this.formfield3.setValue("");
        		this.updateComboBoxes();
        	}.bind(this);
        	
        	
        	var additionalParameters = this.getAdditionalParameters();

			this.formfield1 = new Ext.ux.form.ComboBox({
				fieldLabel: this.config.fields[0].label,
				forceSelection: false,
		        typeAhead: false, 
				allowBlank: false,
				fieldId: this.config.fields[0].id,
		        url: Signavio.Config.BACKEND_PATH + "/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[0].id+(additionalParameters?"&"+additionalParameters:""),
		        changed: onFF1Change,
		        listeners: {
		        	select: onFF1Change,
		        	change: onFF1Change
		        },
		        setValue : function(s) {
		        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
		        	if (this.rendered)
		        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
		        	return res;
		        }
		    });
			
			this.formfield2 = new Ext.ux.form.ComboBox({
				fieldLabel: this.config.fields[1].label,
				forceSelection: false,
		        typeAhead: false, 
				allowBlank: false,
				fieldId: this.config.fields[1].id,
		        url: Signavio.Config.BACKEND_PATH + "/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[1].id+(additionalParameters?"&"+additionalParameters:""),
		        disabled: true,
		        changed: onFF2Change,
		        listeners: {
		        	select: onFF2Change,
		        	change: onFF2Change
		        },
		        setValue : function(s) {
		        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
		        	if (this.rendered)
		        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
		        	return res;
		        }
		    });
			
			this.formfield3 = new Ext.ux.form.ComboBox({
				fieldLabel: this.config.fields[2].label,
				forceSelection: false,
		        typeAhead: false, 
				allowBlank: false,
				fieldId: this.config.fields[2].id,
		        url: Signavio.Config.BACKEND_PATH + "/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[2].id+(additionalParameters?"&"+additionalParameters:""),
		        disabled: true,
		        setValue : function(s) {
		        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
		        	if (this.rendered)
		        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
		        	return res;
		        }
		    });
			
			if (this.config.fields.length == 5){
				
				
				var onFF3Change = function(){
	        		this.formfield4.lastQuery = undefined;
	        		this.formfield4.store.proxy.conn.url = this.formfield4.initialConfig.url+"&"+this.config.fields[0].id+"="+escape(this.formfield1.getValue())+"&"+this.config.fields[1].id+"="+escape(this.formfield2.getValue())+"&"+this.config.fields[2].id+"="+escape(this.formfield3.getValue());
					this.formfield4.setValue("");
	        		this.updateComboBoxes();
	        	}.bind(this);

	        	this.formfield3.on("change", onFF3Change);
	        	this.formfield3.on("select", onFF3Change);
	        	this.formfield3.changed = onFF3Change;
				
	        	
	        	var onFF4Change = function(){
	        		this.formfield5.lastQuery = undefined;
	        		this.formfield5.store.proxy.conn.url = this.formfield5.initialConfig.url+"&"+this.config.fields[3].id+"="+escape(this.formfield4.getValue());
					this.formfield5.setValue("");
	        		this.updateComboBoxes();
	        	}.bind(this);
	        	
				this.formfield4 = new Ext.ux.form.ComboBox({
					fieldLabel: this.config.fields[3].label,
					forceSelection: false,
			        typeAhead: false, 
					allowBlank: false,
					fieldId: this.config.fields[3].id,
			        url: Signavio.Config.BACKEND_PATH + "/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[3].id+(additionalParameters?"&"+additionalParameters:""),
			        disabled: true,
			        changed: onFF4Change,
			        listeners: {
			        	select: onFF4Change,
			        	change: onFF4Change
			        },
			        setValue : function(s) {
			        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
			        	if (this.rendered)
			        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
			        	return res;
			        }
			    });
				
				this.formfield5 = new Ext.ux.form.ComboBox({
					fieldLabel: this.config.fields[4].label,
					forceSelection: false,
			        typeAhead: false, 
					allowBlank: false,
					fieldId: this.config.fields[4].id,
			        url: Signavio.Config.BACKEND_PATH + "/itsm?proxy="+this.config.proxy+"&field="+this.config.fields[4].id+(additionalParameters?"&"+additionalParameters:""),
			        disabled: true,
			        setValue : function(s) {
			        	var res = Ext.ux.form.ComboBox.superclass.setValue.call(this, s);
			        	if (this.rendered)
			        		this.setRawValue(this.lastSelectionText = Signavio.Utils.unescapeHTML(s||""));
			        	return res;
			        }
			    });
			}
			
			this.setInitialValue(value);

			// Enable blank field (but don't use the standard 
			// behavior, otherwise an empty record will be added)
			this.formfield1.allowBlank = true;
			this.formfield2.allowBlank = true;
			this.formfield3.allowBlank = true;
			if (this.formfield4) this.formfield4.allowBlank = true;
			if (this.formfield5) this.formfield5.allowBlank = true;
			
			this.panel = new Ext.Panel({
				layout: "form",
				border: false,
				anchor: "100% 100%",
				items: [this.formfield1, this.formfield2, this.formfield3, this.formfield4, this.formfield5].compact(),
				getValue: this.extractValue.bind(this)
			});
			
			return this.panel;
		},
		
		/**
		 * Returns the value of the defined
		 * 
		 */
		extractValue: function(){
			var cm = this.formfield1.getValue(),
				or = this.formfield2.getValue(),
				gr = this.formfield3.getValue(),
				f1 = (this.formfield4 && this.formfield4.getValue()) || false,
				f2 = (this.formfield5 && this.formfield5.getValue()) || false,
				getTitle = function(pn, value){ 
					return pn.store.getRange().find(function(t){ return t.get("value")== value; }).get("title");
				};
			if (!this.config.all || (cm && or && gr && (!this.formfield4 || f1) && (!this.formfield5 || f2))){
				var obj = {};
				if (cm){
					obj[this.config.fields[0].id+"Id"] = cm;
					obj[this.config.fields[0].id+"Name"] = getTitle(this.formfield1, cm);
				}
				if (or){
					obj[this.config.fields[1].id+"Id"] = or;
					obj[this.config.fields[1].id+"Name"] = getTitle(this.formfield2, or);
				}
				if (gr){
					obj[this.config.fields[2].id+"Id"] = gr;
					obj[this.config.fields[2].id+"Name"] = getTitle(this.formfield3, gr);
				}
				if (f1){
					obj[this.config.fields[3].id+"Id"] = f1;
					obj[this.config.fields[3].id+"Name"] = getTitle(this.formfield4, f1);
				}
				if (f2){
					obj[this.config.fields[4].id+"Id"] = f2;
					obj[this.config.fields[4].id+"Name"] = getTitle(this.formfield5, f2);
				}
				return Object.toJSON(obj);
			}
			return "";
		},
		
		/**
		 * Sets the initial values
		 */
		setInitialValue: function(value){
			// Set initial values
			if (!this.config.all || this.config.fields.all(function(field){ return value[field.id+"Id"] || false; })){
				var id1 = this.config.fields[0].id,
					id2 = this.config.fields[1].id,
					id3 = this.config.fields[2].id;
				
				if (value[id1+"Id"]){
					this.formfield1.store.loadData([{title: value[id1+"Name"], value:value[id1+"Id"]}]);
					this.formfield1.setValue(value[id1+"Id"]);
					this.formfield1.changed();
				}
				
				if (value[id2+"Id"]){
					this.formfield2.store.loadData([{title: value[id2+"Name"], value:value[id2+"Id"]}]);
					this.formfield2.setValue(value[id2+"Id"]);
					this.formfield2.changed(); 
				}
				
				if (value[id3+"Id"]){
					this.formfield3.store.loadData([{title: value[id3+"Name"], value:value[id3+"Id"]}]);
					this.formfield3.setValue(value[id3+"Id"]);
				}
				
				if (this.formfield4 && this.formfield5) {
					var id4 = this.config.fields[3].id,
						id5 = this.config.fields[4].id;
					this.formfield3.changed(); 
					
					if (value[id4+"Id"]){
						this.formfield4.store.loadData([{title: value[id4+"Name"], value:value[id4+"Id"]}]);
						this.formfield4.setValue(value[id4+"Id"]);
						this.formfield4.changed(); 
					}
					
					if (value[id5+"Id"]){
						this.formfield5.store.loadData([{title: value[id5+"Name"], value:value[id5+"Id"]}]);
						this.formfield5.setValue(value[id5+"Id"]);
					}
				}
			}
		}
	});	
	
	
	
	/**
	 * Specific panel for ITSM Assignees
	 */
	Ext.ux.propertyeditor.ITSMAssignee = Ext.extend(Ext.ux.propertyeditor.ITSMFormEditor, {
		
		config: {
			proxy: "role",
			all: true,
			fields: [{
					id: "company",
					label: Ext.ux.getI18N("propertyeditor.itsm.assignee.company")
				},{
					id: "organization",
					label: Ext.ux.getI18N("propertyeditor.itsm.assignee.organization")
				},{
					id: "group",
					label: Ext.ux.getI18N("propertyeditor.itsm.assignee.group")
				}]
		},
		
		getAdditionalParameters: function(){
			return "";
		}
	
	});
	
	
	
	
	
	
	Ext.ux.propertyeditor.ITSMLocation = Ext.extend(Ext.ux.propertyeditor.ITSMFormEditor, {
		
		config: {
			proxy: "location",
			fields: [{
					id: "region",
					label: Ext.ux.getI18N("propertyeditor.itsm.location.region")
				},{
					id: "sitegroup",
					label: Ext.ux.getI18N("propertyeditor.itsm.location.sitegroup")
				},{
					id: "site",
					label: Ext.ux.getI18N("propertyeditor.itsm.location.site")
				}]
		}
	
	});
	
	
	
	
	Ext.ux.propertyeditor.ITSMServiceCat = Ext.extend(Ext.ux.propertyeditor.ITSMFormEditor, {
		
		config: (function() {
			var tId = new Ext.Template("tier{0}");
			var tLabel = new Ext.Template(Ext.ux.getI18N("propertyeditor.itsm.servicecat.tier"));
			return {
				proxy: "servicecat",
				fields: $A($R(1,3).map(function(i) {
							return {
								id: tId.apply([i]), 
								label: tLabel.apply([i])
								};
						}))
			};
		})()
	
	});
	
	
	
	
	Ext.ux.propertyeditor.ITSMProductCat = Ext.extend(Ext.ux.propertyeditor.ITSMFormEditor, {
		
		config: (function() {
			var tId = new Ext.Template("tier{0}");
			var tLabel = new Ext.Template(Ext.ux.getI18N("propertyeditor.itsm.servicecat.tier"));
			return {
				proxy: "productcat",
				fields: $A($R(1,3).map(function(i) {
							return {
								id: tId.apply([i]), 
								label: tLabel.apply([i])
								};
						})).concat(
						[{
							 id: "name",
							 label: Ext.ux.getI18N("propertyeditor.itsm.productcat.name")
						 },{
							 id: "model",
							 label: Ext.ux.getI18N("propertyeditor.itsm.productcat.model")
						 }])
			};
		})()
	
	});
}();
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
//	/**
//	 * Specific class to provide a panel to define variable mappings for ITSM
//	 * 
//	 */
//	Ext.ux.propertyeditor.ITSMTaskGroupTemplateInterface = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
//		
//		windowCreate: {height: 400, width: 400, resizable: false, bodyStyle: "padding:0px;"},
//		
//		/**
//		 * Returns a panel where the skript form is inside
//		 * @param {Object} value
//		 */
//		getEditor: function(value){
//			
//			var shape = this.facade.getSelection()[0];
//			var taskGroupTemplate = shape.getProperty("taskgrouptemplates") || "";
//			if (taskGroupTemplate.length > 0) {
//			
//				new Ajax.Request(Signavio.Config.BACKEND_PATH + "/itsm?proxy=interface&processname=" + escape(taskGroupTemplate), {
//					method		: 'get',
//					requestHeaders : {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
//					//asynchronous: async === true,
//					onSuccess: function(transport){
//						var json;
//						try {
//							json = transport.responseText.evalJSON();	
//						} catch(e){
//							json = transport.responseText;
//						}
//						
//						alert(transport.responseText);
//					}
//				});
//				
//			} else {
//				alert("Kein TaskGroupTemplate ausgewählt!");
//			}
//			
//
//			
//		}
//		
//	});	
}();
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Specific class to provide a panel to define variable mappings for ITSM
	 * 
	 */
	Ext.ux.propertyeditor.ITSMVariableMapping = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height: 400, width: 400, resizable: false, bodyStyle: "padding:0px;"},

		/**
		 * These magic numbers represent the specification for the maximum use of each variable type.
		 */
		maxNumbers: {
			"String"	: 6,
			"Integer"	: 3,
			"Real"		: 3,
			"Boolean"	: 2,
			"Date"		: 2
		},
		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if (value && "string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){}
			}
			if (value instanceof Array){
				return value.map(function(item){
					if (item && item.id){
						var usage = String(item.usage||"").toUpperCase();
						return [item.id, ((usage.include("IN")?"IN":"") + (usage.include("OUT")?"OUT":"")) || undefined].compact().join(" - ");
					}
				}).join("<br/>");
			}
			return "";
		},
		
		/**
		 * Retrieves variable values which happen to have an OUT usage
		 * from a precedent task, if any exists.
		 */
		retrieveOutValuesFromPredecessor: function() {
			if (this.facade.getSelection().length == 1) {
				var current = this.facade.getSelection()[0];
				if (current.incoming.length == 1 
					&& current.incoming[0].getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#SequenceFlow"
					&& current.incoming[0].incoming.length == 1
					&& current.incoming[0].incoming[0].getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#Task") {
					var mapping = current.incoming[0].incoming[0].getProperty("variablemapping");
					if (typeof mapping == "string" && mapping.length > 0) {
						mapping = mapping.evalJSON();
						if (mapping instanceof Array) {
							var items = mapping.findAll(function(item) {
								return item.usage.include("OUT");
							});
							items.each(function(item) {
								item.usage = "IN";
							})
							return items;
						}
					}
				}
				
			}	
			return {};
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			if ("string" == typeof value){
				try {
					value = value.evalJSON();
				} catch(e){ value = {};  }
			} else {
				value = value || {};
			}
			
			if (!(value instanceof Array))
				value = this.retrieveOutValuesFromPredecessor();
			
			this.store = new Ext.data.SimpleStore({
				data: value instanceof Array ? value.map(function(item){
					if (item && item.id){
						var usage = String(item.usage||"").toUpperCase();
						return [item.id, usage.include("IN"), usage.include("OUT")];
					}
				}).compact(): [],
				fields: ["variable", "input", "output"]
			});
			
			
			var items = [];
			try {
				var val = this.facade.getCanvas().getProperty("variables");
				if ("string" == typeof val){
					val = val.evalJSON();
				}
				if ("object" == typeof val){
					items = val.items.pluck("name").compact();
				}
			} catch(e){}
			
			var variablesStore = new Ext.data.SimpleStore({
				data: items.map(function(r){ return [r, r]; }),
				fields: ["title", "id"]
			});
			
			var variables = new Ext.form.ComboBox({
				displayField	: "title",
				valueField		: "id",
				store			: variablesStore,
				mode			: "local",
				triggerAction	: "all",
				listeners		: {
					focus: function(){
						// Show only variables which are not used yet
						var used = this.store.getRange().map(function(r){ return r.get("variable") || undefined; }).compact();
						variablesStore.loadData(items.findAll(function(item){
							return !used.include(item);
						}).map(function(r){ return [r, r]; }));
					}.bind(this)
				}
			});

			var checkboxInput = new Ext.form.Checkbox({});
			var checkboxOuput = new Ext.form.Checkbox({});
			
			this.panel = new Ext.grid.EditorGridPanel({
				border	: false,
				anchor	: "100% 100%",
				getValue: this.extractValue.bind(this),
				store	: this.store,
				clicksToEdit : 2,
				autoExpandColumn : "variable",
				enableHdMenu : false,
				enableColumnResize: false,
				listeners : {
					afteredit: function(o){ o.record.commit(); }
				},
				sm 		: new Ext.grid.RowSelectionModel({singleSelect: true, listeners: { selectionchange: this.onSelectionChange.bind(this) }}),
				columns	: [{dataIndex:'variable',	header: Ext.ux.getI18N("propertyeditor.itsm.variablemapping.header.variable"), editor: variables, renderer: this.renderVariable.bind(this, variablesStore), id: "variable"},
				           {dataIndex:'input',		header: Ext.ux.getI18N("propertyeditor.itsm.variablemapping.header.input"), 	editor: checkboxInput, renderer: this.renderBoolean.bind(this), width: 50},
				           {dataIndex:'output',		header: Ext.ux.getI18N("propertyeditor.itsm.variablemapping.header.output"), 	editor: checkboxOuput, renderer: this.renderBoolean.bind(this), width: 50}],
				tbar	: [{text: Ext.ux.getI18N("btnadd"), icon: ""+Ext.IMAGE_URL+"/famfamfam/add.png", handler: this.doAdd.bind(this), iconCls:"x-dummy"},
				    	   {text: Ext.ux.getI18N("btnremove"), icon: ""+Ext.IMAGE_URL+"/famfamfam/cross.png", handler: this.doDelete.bind(this), iconCls:"x-dummy", disabled: true},
				    	   "-",
				    	   {text: Ext.ux.getI18N("moveup"), icon: ""+Ext.IMAGE_URL+"/famfamfam/bullet_arrow_up.png", handler: this.doMove.bind(this, -1), iconCls:"x-dummy", disabled: true},
				    	   {text: Ext.ux.getI18N("movedown"), icon: ""+Ext.IMAGE_URL+"/famfamfam/bullet_arrow_down.png", handler: this.doMove.bind(this, 1), iconCls:"x-dummy", disabled: true}]
			});
			
			return this.panel;
		},
		
		/**
		 * Returns the title of the given value from the store
		 * @param store
		 * @param value
		 * @returns
		 */
		renderVariable: function(store, value){
			if (!value){ return ""; }
			
			var record = store.getRange().find(function(r){ return r.get("id") == value; });
			if (record){
				return record.get("title");
			}
			return value;			
		},
		
		/**
		 * Returns a string representation of a boolean value
		 * @param value
		 * @param meta
		 * @returns {String}
		 */
		renderBoolean: function(value, meta){
			if (!value || value === "false"){
				return "";
			}
			meta.attr = "style='overflow:visible;position:relative;'";
			return "<img src='"+Ext.IMAGE_URL+"/famfamfam/check.png' style='position:absolute;top:1px;'/>";
		},
		
		/**
		 * Specific handling of the selection change from the grid panel
		 * 
		 */
		onSelectionChange: function(){
			var sm = this.panel.getSelectionModel(),
				index = sm.getCount() == 1 ? this.store.indexOf(sm.getSelected()) : -1,
				isSelected = index >= 0,
				isFirst = index === 0,
				isLast = index === this.store.getCount()-1,
				tb = this.panel.getTopToolbar();
				
			if (isSelected){
				tb.items.get(1).enable();
				tb.items.get(3).setDisabled(isFirst);
				tb.items.get(4).setDisabled(isLast);
			} else {
				tb.items.get(1).disable();
				tb.items.get(3).disable();
				tb.items.get(4).disable();
			}
		},
		
		/**
		 * Checks whether no more than the maximum number of variables of each type are used.
		 * this.maxNumbers defines the upper limits.
		 */
		onBeforeSave: function(oldValue, newValue) {
			if (!Ext.ux.propertyeditor.ITSMVariableMapping.superclass.onBeforeSave.apply(this, arguments))
				return false;
			var val = this.facade.getCanvas().getProperty("variables");
			if (typeof val == "undefined")
				// there are no variables defined
				return true;
			// get the global variable definitions
			if ("string" == typeof val){
				val = val.evalJSON();
			}
			var types = {};
			if ("object" == typeof val){
				val.items.each(function(item) {
					if (typeof item.name == "string" && item.name.length > 0)
						types[item.name] = item.type; 
				});
			}
			// count the locally used variables
			var newVal = newValue;
			if (typeof newVal == "string") {
				newVal = newVal.evalJSON();
			}
			if (newVal instanceof Array) {
				var count = {};
				newVal.each(function(item) {
					count[types[item.id]] = (count[types[item.id]] || 0) + 1;
				});
				var type = Object.keys(count).find(function(key) {
					return count[key] > this.maxNumbers[key];
				}.bind(this));
				if (type) {
				    this.showErrorMessageForType(type);
				    return false;
				}
			}
			return true;
		},
		
		/**
		 * Shows a short notice that to many variables of one type are registered.
		 */
		showErrorMessageForType: function(type) {
			Ext.Msg.show({
				title: Ext.ux.getI18N('propertyeditor.itsm.variablemapping.error.title'),
				msg: (new Ext.Template(Ext.ux.getI18N('propertyeditor.itsm.variablemapping.error.message'))).apply([type, this.maxNumbers[type]]),
				buttons: Ext.Msg.OK,
				icon: Ext.Msg.ERROR
			}).getDialog().syncSize();
		},
		
		/**
		 * Moves the currently selected record regarding the given offset inside the store
		 * @param offset
		 */
		doMove: function(offset){
			var selected = this.panel.getSelectionModel().getSelected();
			if (!selected){ return; }
			
			var index = this.store.indexOf(selected)+offset;
			this.store.remove(selected);
			this.store.commitChanges();
			this.store.insert(index, selected);
			this.store.commitChanges();
			this.panel.getSelectionModel().selectRow(index);
		},
		
		/**
		 * Adds a dummy record to the store
		 * 
		 */
		doAdd: function(){
			// Add empty entry
			this.store.loadData([["", true, false]], true);
			// Start editing
			this.panel.getSelectionModel().selectLastRow();
			this.panel.startEditing(this.store.getCount()-1, 0);
		},
		
		/**
		 * Remove the currently selected record from the store
		 * 
		 */
		doDelete: function(){
			
			var records = [].concat(this.panel.getSelectionModel().getSelections()),
				store = this.store,
				index = records.length>0?store.indexOf(records[0]):-1;
			records.each(function(record){
				store.remove(record);
			});
			store.commitChanges();
			if (index >= 0 && store.getCount()){
				this.panel.getSelectionModel().selectRow(Math.min(index, store.getCount()-1));
			}
		},
		
		/**
		 * Returns the value of the defined
		 * [{id:"anId", usage:"IN | OUT | INOUT|<leer>"}*]
		 */
		extractValue: function(){
			return Object.toJSON(this.store.getRange().map(function(rec){
			    		if (rec.get("variable")){
			    			return {id: rec.get("variable"), usage: (rec.get("input")?"IN":"")+ (rec.get("output")?"OUT":"")}
			    	    }
			    		// Ignore variables where no title is defined
			    	}).compact());
		}
		
	});	
}();
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Lukas Brand
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function(){
	
	var ControlField = function(config, plugin) {
		Ext.apply(this, config);
		if (!this.id) {
			this.id = Ext.id();
		}
		this.plugin = plugin;
		this.renderer = this.renderer.createDelegate(this);
	};
	
	ControlField.prototype = {
			init	: function(grid) {
				this.grid = grid;
				this.grid.on("render", function() {
					var view = this.grid.getView();
					view.mainBody.on("click", this.onClick, this);
				}, this);
			},
			
			/**
			 * When the grid is clicked, evaluate the target. If it is a control field,
			 * update the control grid with the target record and expand it.
			 */
			onClick : function(e, t) {
								
				if (Ext.get(t).hasClass("x-grid3-control-"+this.id) || 
					(Ext.isIE && Ext.get(t).hasClass("y-control-field-cell-item"))) {
					e.stopEvent();
					
					// Fix IE-Bug
					if (Ext.isIE && Ext.get(t).hasClass("y-control-field-empty-text")){
						t =  Ext.get(t).parent(".x-grid3-control-col").dom;
					}
					
					// Remove any existing confirm hints
					this.plugin.clearActiveConfirmHints();
					
					var inner = Ext.get(t).parent(".x-grid3-cell-inner");
					var cell = inner.parent(".x-grid3-cell");
					var row = cell.parent(".x-grid3-row-table");
					
					var index = this.grid.getView().findRowIndex(row.dom);
					// Get the active record
					var record = this.grid.store.getAt(index);
					
					// Find expanded nodes in the control column and close them
					Ext.DomQuery.select(".y-risk-dialog .expanded").without(cell.dom).each(function(node) {
						Ext.fly(node).removeClass("expanded");
					});
					
					cell.toggleClass("expanded");
					
					if (cell.hasClass("expanded")) {
						
						var mask = this.grid.getView().el.mask();
						var ms = mask.dom.style;
						ms["backgroundColor"] = "#FFFFFF";
						ms["zIndex"] = 1;
						ms["opacity"] = "0.6";
						
						// Close the control grid when the mask over the risk grid was clicked
						mask.on("click", function() {
							cell.removeClass("expanded");
							this.hideControlGrid(row);
						}.bind(this));
						
						cell.originalHeight = cell.getHeight();
						
						this.plugin.controlGrid = this.plugin.getControlGrid({
							controlCell : inner,
							cell		: cell,
							row			: row,
							riskid		: record.get("id"),
							value		: this.value,
							doResize	: function(riskGrid) {
								var riskBox = riskGrid.el.getBox();
								var oldBox = this.getBox();
								
								// Align the grid nicely inside the riskGrid
								this.updateBox(Ext.apply(oldBox, {
									width	: Math.round(riskBox.width - 50),
									x		: Math.round(riskBox.x + 40)
								}));								
								
							}
						});
						
//						this.plugin.controlGrid.doResize();
						
						var s = this.plugin.controlGrid.el.dom.style;
						
						s["zIndex"] = 1;
						s["border"] = "1px solid #888888";
						s["borderRadius"] = "1px";
						s["boxShadow"] = "0px 6px 8px -6px silver";
						s["position"] = "absolute";
						
						this.plugin.updateControlCell(this.plugin.controlGrid);
						
						// Show the control grid
						this.plugin.controlGrid.show();
						
						this.plugin.adjustCellHeight(this.plugin.controlGrid, row, cell, inner);
						
						// Reposition the grid
						this.plugin.controlGrid.el.alignTo(inner, "tl-bl", [0, -1]);
						this.plugin.controlGrid.doResize(this.plugin.grid);
						this.grid.ownerCt.syncShadow();
						
					} else if (this.plugin.controlGrid && this.plugin.controlGrid.isVisible()) {

						this.hideControlGrid(row);
					}
				}
			},
			
			/**
			 * Hides the control grid, resets the height of the opened row and syncs the size of the window
			 */
			hideControlGrid : function(row) {
				// Hide the grid
				this.plugin.controlGrid.hide();
				// Update the control count in the cell
				this.plugin.updateControlCell(this.plugin.controlGrid);
				
				// Remove the mask
				this.grid.getView().el.unmask();
				
				this.plugin.controlGrid.destroy();
				
				// Reset the size of the current row
				row.dom.style["height"] = "";
				this.grid.ownerCt.syncShadow();
			},
			
			renderer : function(v, p, record) {
				p.css += 'x-grid3-control';
				
				if (this.plugin.controlStore){
					v = this.plugin.controlStore.getRange().findAll(function(row) {return row.get("riskid") === record.get("id");}).length;
				} else {
					v = this.plugin.controlData.findAll(function(row) {return row.riskid === record.get("id");}).length;
				}

				if (v === 0) {
					v = this.plugin.getControlCellEmptyValue();
				} else {
					// If a value exists, render an edit icon
					v += "<span class='y-control-field-cell-item'><div class='y-risk-edit-icon y-control-field-cell-item'/></span>";
				}
				
				//var arrow = "<img src='/images/signavio/s.gif' class='y-arrow'/>";
				
				return ['<div class="x-grid3-control-col x-grid3-control-',
				        this.id,
				        '"><span class="y-control-field-cell-item y-cell-value">',
				        	// The cell value
				        	v,
				        '</span></div>'].join("");
			}
	};
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.MetaDataIKS = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {
			title		: Ext.ux.getI18N('IKS.title'),
			description	: Ext.ux.getI18N('IKS.desc'),
			bodyStyle	: "",
			maxHeight	: 600,
			autoHeight	: true,
			cls			: "y-risk-dialog",
			height		: undefined,
//			closeAction	: "close",
			width		: Math.max(Math.min((document.width||window.innerWidth||0) * 0.98, 1500), 1000),
			minWidth	: Ext.isIE ? 800 : 200,
			useApplyInsteadOfSaveButton : true,
			modal		: true
		},
		
		updateIKSHint : function() {
			var selectedNodes = this.facade.getSelection();
			this.facade.raiseEvent(ORYX.CONFIG.EVENT_UPDATE_IKS_HINT, selectedNodes);
			
		},
		
		renderer : function(value) {

			var parsedValue = {totalCount:0};
			
			if ("string" === typeof value && value.trim()) {
				try {
					var value = JSON.parse(value);
					if ("object" === typeof value && !(value instanceof Array)) {
						parsedValue = value;
					}
				} catch(e) {
					
				}
			}
			
			var count = parsedValue.totalCount || 0;
			
			return count + " " + (count===1?Ext.ux.getI18N('IKS.risk'):Ext.ux.getI18N('IKS.risks'));
		},
		
		/**
		 * Store all risk nodes for easier access
		 */
		riskNodes : [],
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value) {
			var me = this;
			
			this.windowCreate.listeners	= {
				close	: function() {
					me.updateIKSHint();
					this.destroy();
				}
			};
			
			var parsedValue = {items: []};
			
			if ("string" === typeof value && value.trim()) {
				try {
					var value = JSON.parse(value);
					if ("object" === typeof value && !(value instanceof Array)) {
						parsedValue = value;
					}
				} catch(e) {
					
				}
			}
			
			this.riskData = this.getAllRisks(parsedValue);
			this.controlData = this.getAllControls(parsedValue);
			this.getControlStore() // Cache data

			
			this.grid = new Ext.ux.grid.IKSEditorGridPanel({
				anchor			: '100%',
				cls				: 'y-risk-grid',
				cm				: this.getColModel(this.getRiskColumnConfig()),
				store			: this.getRiskStore(),
				autoExpandColumn: 'name',
//				autoWidth		: true,
				//minColumnWidth	: Ext.isIE ? 90 : 100,
				border			: true,
				maxHeight		: 400,
				enableHdMenu	: false,
				enableColumnMove: false,
				clicksToEdit	: 1,
				autoHeight		: true,
				plugins			: this.getControlField(),
				sm				: this.getSelectionModel("risk"),
				view			: this.getStripeView("risk"),
				getValue		: function() {
					
					var value = {
						totalCount: 0,
						items: []
					};

					if (this.controlStore) { // Clear filter
						this.controlStore.clearFilter();
					}

					// Iterate over every Risk
					if (this.grid.store) {
						this.grid.store.getRange().each(function(record){
							var item = Object.clone(record.data);
							
							// Try to find every Control for the Risk
							if (this.controlStore) {
								item.controls = {items: []};
								this.controlStore.getRange().each(function(a) {
									if (a.get("riskid") == record.get("id")){
										var risk = Object.clone(a.data);
										delete risk.riskid;
										item.controls.items.push(risk);
									}
								});

								item.controls.totalCount = item.controls.items.length;
							}

							value.items.push(item);
						}.bind(this));
					}

					value.totalCount = value.items.length;
					
					
					/*
					 * If a default language for the model is defined, save it store the
					 * knowledge about the used language when editing risks/controls
					 */
					var lang = this.facade.getAllLanguages().first();
					if (lang) {
						value.language = lang;
					}
					
					return $H(value).toJSON();
				}.bind(this),
				listeners : {
					resize	: function(grid) {
						var minWidth = this.grid.getColumnModel().config
								.collect(function (col) {return col.minWidth})
								.sum();
						if (this.grid.getSize().width < minWidth) {
							var padding = this.grid.getSize().width > minWidth-10 ? minWidth - this.grid.getSize().width + "px" : "10px";
							this.grid.el.dom.style.setProperty("padding-right", padding, null);
							this.grid.setWidth(minWidth);
							this.grid.el.dom.style.setProperty("padding-right", "10px", null);
						} else if (this.grid.getSize().width > minWidth) {
							this.grid.el.dom.style.setProperty("padding-right", "0px", null);
						}
											
						if (this.controlGrid && this.controlGrid.isVisible()) {
							this.controlGrid.doResize(grid);
						}
						
					}.bind(this)
				}
			});
			
			// Save changes immediately into the underlying store, don't keep dirty fields
			this.grid.on("afteredit", function() {
				this.store.commitChanges();
			});
			
			return this.grid;
		},

		getAllRisks: function(data){

			var risks = [];

			(data.items||[]).each(function(d){
				d = Object.clone(d);
				d.controls = "";
				risks.push(d);
			});

			return risks;
		},

		getAllControls: function(data){

			var controls = [];

			(data.items||[]).each(function(d){
				((d.controls||{items:[]}).items||[]).each(function(c){
					c = Object.clone(c);
					c.riskid = d.id;
					controls.push(c);
				});
			});

			return controls;
		},
		
		getControlGrid : function(config) {
			var me = this;
			
			var controlGrid = new Ext.ux.grid.IKSEditorGridPanel(Ext.apply({
				cls				: 'y-control-grid',
				cm				: this.getColModel(this.getControlColumnConfig()),
				store			: this.getControlStore(config.riskid),
				renderTo		: this.grid.ownerCt.body,
				autoExpandColumn: 'name',
				border			: false,
				enableHdMenu	: false,
				enableColumnMove: false,
				//minColumnWidth	: 100,
				clicksToEdit	: 1,
				autoHeight		: true,
				sm				: this.getSelectionModel("control"),
				view			: this.getStripeView("control")
			}, config));

			if (Ext.isIE) {
				controlGrid.on("show", function() {
					this.el.repaint();
				});
			}
			
			controlGrid.on("afteredit", function() {
				this.store.commitChanges();
			});
			
			return controlGrid;
		},
		
		getRiskStore : function() {
			
			var fields = this.getRiskColumnConfig().pluck("dataIndex");	;
//				var data = shape.getProperty("iks");
//				var data = [[undefined, "Fehlerhafter Vorgabevorschlag", undefined, "Fehlende Info", "Verzögerung", "Hoch", 5, 3, 2],
//				            [undefined, "Bestellung entspricht VV nicht", undefined, "Kommunikation", "Verzögerung", "Mittel", 3, 0, 1],
//				            [undefined, "Ware entspricht Bestellung nicht", undefined, "Falsche Lieferung", "Mehraufwand", "Mittel", 5, 1, 3]];
			
			return new Ext.data.SimpleStore({
				fields	: fields,
				// Collect the data according to the defined fields
				data	: (this.riskData||[]).map(function(v) {
					return fields.map(function(f) {
						return v[f];
					});
				})
			});
		},
		
		getControlStore : function(riskid) {
			
			if (!this.controlStore) {
				
				var fields = this.getControlColumnConfig().pluck("dataIndex");
				
				this.controlStore = new Ext.data.SimpleStore({
					fields	: fields,
					data	: (this.controlData||[]).map(function(v) {
						return fields.map(function(f) {
							return v[f];
						});
					})
				});
			}
			
			if (riskid) {
				this.controlStore.filter("riskid", riskid);
				// Save the currently active risk id for filtering options
				this.controlStore.currentRiskID = riskid;
			}
			
			return this.controlStore;
		},
		
		/**
		 * Returns a new Ext.grid.ColumnModel for the given grid config
		 */
		getColModel : function(config) {
			return new Ext.grid.ColumnModel(config);
		},
		
		/**
		 * Returns a new column config
		 * @returns {Array}
		 */
		getRiskColumnConfig : function() {
			//TODO If a special config is defined in the admin panel, take it to override the default config
			var config = (this.property.complexItems()).clone().map(this.complexItemToColumn.bind(this));
			config = this.exaggerateConfig(config);
			
			// Id field
			var idField = {
				dataIndex	: 'id',
				hidden		: true
			};

			// Overwrite the conrol field with a custom one
			var control = config.find(function(c){ return c.id == "controls"; });
			if (control){
				config[config.indexOf(control)] = this.getControlField();
			}

			return [].concat(	this.getRowRemover("risk"),
								config,
								idField);
		},

		complexItemToColumn: function(complexItem){
			var me = this, json = Object.clone(complexItem.json());
			json.dataIndex 	= json.id;
			json.header 	= complexItem.title();
			json.renderer 	= json.renderer || function(val){
				if(json.type === "choice") {
					// Find the choice definition by value
					var valItem = (json.items||[]).find(function(i) {
						return i.value === val;
					});

					if(valItem) {
						var displayItem = me.getLocalizedProperty("title", valItem);
						if(displayItem) {
							return displayItem;
						}
					}
				}

				return "string" == typeof val ? val.escapeHTML() : val;
			}
			return json;
		},
		
		getControlColumnConfig : function() {
			//TODO If a special config is defined in the admin panel, take it to override the default config
			var config = (this.property.complexItems()||[]).clone();
			var control = config.find(function(c){ return c.id() == "controls"; });

			if (control){
				config = (control.complexItems()).clone().map(this.complexItemToColumn.bind(this));
			} else {
				return [];
			}

			config = this.exaggerateConfig(config);
			
			var riskIDField = {
				dataIndex	: 'riskid',
				hidden		: true
			};
			
			config = [].concat(	this.getRowRemover("control"),
								config,
								riskIDField);
			
			return config;
		},
		
		/**
		 * Add editors, default widths and types to the given config
		 * @param {Object} config
		 */
		exaggerateConfig : function(config) {
			if (!(config instanceof Array)) { return; }
			
			config = config.map(function(conf) {
				var newConf = Object.clone(conf);
				newConf.editor = this.getEditorForColumnConfig(conf);
				newConf.width = this.getWidthForColumnConfig(conf);
				newConf.minWidth = 100;
				//newConf.header = this.getLocalizedProperty("header", conf);
				newConf.tooltip = Signavio.Utils.escapeHTML(this.getLocalizedProperty("description", conf));
				
				return newConf;
			}.bind(this));
			
			return config;
		},
		
		/**
		 * Returns the width of the column based on its type
		 * @param {Object} columnConfig
		 */
		getWidthForColumnConfig : function(columnConfig) {
			if (typeof columnConfig.width === "number") {
				return columnConfig.width;
			}
			if (columnConfig.id === "name"){
				return 250;
			}
			switch((columnConfig.type||"").toLowerCase()) {
			case "number":
			case "choice":
//				 return 100;
			default:
				 return 200;
			}
		},
		
		/**
		 * Returns the matching editor for the given column config, based on the defined type
		 */
		getEditorForColumnConfig : function(columnConfig) {
			if (!columnConfig) { return; }
			switch ((columnConfig.type||"").toLowerCase()) {
			case "number":
				return new Ext.form.NumberField({
					allowBlank		: columnConfig.optional !== false,
					allowNegative	: false
				});
				break;
			case "choice":
				return new Ext.form.ComboBox({
					mode			: "local",
					displayField	: "displayText",
					valueField		: "value",
					readOnly		: true,
					editable		: false,
					triggerAction	: 'all',
					lazyRender		: true,
					listClass		: 'y-combo-list',
					store			: new Ext.data.SimpleStore({
						fields		: ["value", "displayText"],
						data		: this.getComboItemsForColumnConfig(columnConfig.items||[])
					})
				});
				break;
			case "text":
				var editor = new Ext.Editor(
					new Ext.form.TextArea({
						allowBlank		: columnConfig.optional !== false
					}), {
						shadow : false,
						alignment : Ext.isIE ? "tl-tl?" : "c-c?"
					});
				// This is hack to ensure that height = 60 px (50 px for IE), I am therefore overriding the 
				// doAutoSize() method
				editor.doAutoSize = function() {
					var sz = this.boundEl.getSize();
					this.setSize(sz.width,  Ext.isIE ? 50 : 60);
				}.bind(editor);
				return editor;
				break;
			default:
				return new Ext.form.TextField({
					allowBlank		: columnConfig.optional !== false
				});
			}
		},
		
		/**
		 * Returns the data needed to create the store for a ComboBox based on columnConfig items
		 * @param {Array} items Takes the items defined in the columnConfig
		 * @returns {Array}
		 */
		getComboItemsForColumnConfig : function(items) {
			if (!(items instanceof Array)) { return; }
			
			return items.map(function(item) {
				return [item.value, this.getLocalizedProperty("title", item)];
			}.bind(this));
		},
		
		getRowRemover : function(type) {
			return new Ext.grid.RowNumberer({
				dataIndex: 'numberer',
				
				renderer : function(v, p, record, r) {
					p.cellAttr = 'title="' + Ext.ux.getI18N(type === "risk" ? 'IKS.removerisk':'IKS.removecontrol') + '"';
					return "";
					//return rowIndex + 1;
				}
			});
		},
		
		/**
		 * Adds a special column for opening the control grid on a row
		 */
		getControlField : function(value) {
			if (!this.controlField) {
				this.controlField = new ControlField({
					header		: Ext.ux.getI18N('IKS.controls'),
					dataIndex	: 'controls',
					width		: 220,
					value		: value
				}, this);
			}
			
			return this.controlField;
		},
		
		getSelectionModel : function(gridType) {
			var selModel = new Ext.grid.CellSelectionModel({
				listeners : {
					// Handle clicks of the row remover
					beforecellselect : function(s, r, c) {
						if (c === 0) {
							
							this.clearActiveConfirmHints();
							this.confirmRowRemoval(r, s.grid, s.grid.view.getCell(r,c).firstChild, gridType);
							
							return false;
						}
						return true;
					}.bind(this)
				}
			});
			
			return selModel;
		},
		
		clearActiveConfirmHints : function() {
			if (this.confirmationDialog) {
				this.confirmationDialog.remove();
				delete this.confirmationDialog;
			}
		},
		
		/**
		 * Returns a new Ext.grid.GridView with vertical stripes and fitted columns
		 * @param {String} gridType Either "risk" or "control" to determine the "add new row" title
		 */
		getStripeView : function(gridType) {
			
			var me = this;
			
			return new Ext.grid.GridView({
				
				forceFit		: true,
				autoFill		: true,
				scrollOffset	: 0,
				
				updateColumnCss: function(){
					[].concat(this.innerHd, $A(this.getRows())).each(function(row){
						var i = 0;
						Ext.get(row).select("td{display!=none}").each(function(cell){
							cell[(i++%2) === 0 ? "addClass" : "removeClass"]("x-colum-odd");
						});
					});
				},
				
				// @overwrite Update css classes for the row
				updateColumnHidden: function(){
					var res = Ext.grid.GridView.prototype.updateColumnHidden.apply(this, arguments);
					this.updateColumnCss();
					return res;
				},
				// @overwrite Update css classes for the row
				processRows: function(){
					var res = Ext.grid.GridView.prototype.processRows.apply(this, arguments);
					this.updateColumnCss();
					return res;
				},
				// @overwrite Update css classes for the row
				refreshRow: function(){
					var res = Ext.grid.GridView.prototype.refreshRow.apply(this, arguments);
					this.updateColumnCss();
					return res;
				},
				
				/**
				 * Extend the renderUI method to add an addRow-button after the real grid
				 */
				renderUI : function() {
					Ext.grid.GridView.prototype.renderUI.apply(this, arguments);
					
					var addNode = document.createElement("div");
					addNode.setAttributeNS(null, "class", "y-add-row");
					addNode.innerHTML = ["<div unselectable='on'></div><span class='y-add-row-desc'>",
					                     Signavio.Utils.escapeHTML(new Ext.Template(Ext.ux.getI18N('IKS.newEntry')).apply([(gridType === "risk" ? Ext.ux.getI18N('IKS.newEntryRisk') : Ext.ux.getI18N('IKS.newEntryControl') )])),
					                     "</span>"].join("");
					
					this.mainBody.dom.parentNode.insertBefore(addNode, this.mainBody.dom.nextSibling);
					
					// Add a new row on click
					Ext.fly(addNode).on("click", me.addNewRow.bind(me, this.grid));
				},
				
				getColumnTooltip : function(i){
			        var tt = this.cm.getColumnTooltip(i);
			        if(tt){
//			            if(Ext.QuickTips.isEnabled()){
//			                return 'ext:qtip="'+tt+'"';
//			            }else{
		                return 'title="'+tt+'"';
//			            }
			        }
			        return "";
			    }
			});
		},
		
		/**
		 * Adds a new row to the given grid
		 */
		addNewRow : function(grid) {
			var store = grid.store;
			var Row = Ext.data.Record.create(store.fields.items);
			var newRow = {};
			
			// initialize empty
			store.fields.items.each(function(field) {
				// TODO If typed cells exist, initialize it here (typed)
				newRow[field.name] = "";
			});
			
			var isControl = ("undefined" !== typeof store.currentRiskID);
			
			var addition = isControl ? {
				// If a risk is active and the new row is a control, add the corresponding risk id to the control
				riskid		: store.currentRiskID
			} : {
				// If a new risk is added, create a new id for it
				id			: ORYX.Editor.provideId()
			};
			
			// create a new record for the currently selected risk
			store.add(new Row(Ext.apply(newRow, addition)));
			
			this.updateControlCell(grid);

			store.commitChanges();
			
			this.grid.ownerCt.syncShadow();
		},
		
		/**
		 * Returns the icon which should be displayed inside the grid when no controls for the risk exists
		 */
		getControlCellEmptyValue : function() {
			return ["<span class='y-control-field-cell-item y-empty-text'>",
			        Signavio.Utils.escapeHTML(Ext.ux.getI18N('IKS.addControls')),
			        "</span>"].join(""); // <img src='/images/glyphicons/small/help.png' title='",Signavio.Utils.escapeHTML("Fügen sie neue Kontrollen für das gewählte Risiko hinzu"),"'/>"
		},

		/**
		 * Update the expanded control cell with the new row count, display a warning icon if no row exists
		 */
		updateControlCell : function(grid) {
			if (!grid.controlCell) {
				return;
			}
			
			var text = this.getControlCellEmptyValue();
			var controlCount = grid.store.data.length;
			
			if (!grid.controlCell.parent(".x-grid3-cell").hasClass("expanded") && controlCount) {
				text = controlCount + " <span class='y-empty-text y-control-field-cell-item'><div class='y-risk-edit-icon y-control-field-cell-item'/></span>";
			}

			grid.controlCell.child(".y-cell-value", true).innerHTML = text;
			this.adjustCellHeight(grid, grid.row, grid.cell, grid.controlCell);
		},
		
		/**
		 * Displays a confirmation for removing a row, handles the actual removal of rows and attached controls when deleting a risk.
		 */
		confirmRowRemoval : function(row, grid, cell, gridType) {
			var riskRecord = grid.store.getAt(row);
			
			// Check if the record is empty
			var isEmpty = !$H(riskRecord.data).any(function(p) {
				return p.key !== "riskid" && p.value;
			});
			
			// Create a new hint to ask for removal
			var confirmation = document.createElement("div");
			confirmation.setAttributeNS(null,"class", "y-delete-confirm");
			confirmation.innerHTML = "<span>"+Ext.ux.getI18N('IKS.deleteThisTpl')+(gridType==="risk"?Ext.ux.getI18N('IKS.deleteThisRisk'):Ext.ux.getI18N('IKS.deleteThisControl'))+"</span><a class='y-delete-confirm-yes' href='#'>"+Ext.ux.getI18N('IKS.yes')+"</a><a class='y-delete-confirm-no' href='#'>"+Ext.ux.getI18N('IKS.no')+"</a>";

			// Wrap the confirmation into an ext element
			var $confirmation = Ext.get(confirmation);
			
			 // in case of IE it seems that the same event, that creates this dialog is propagated further on,
			// therefore ignore the first click
			var clickCounter = Ext.isIE || Ext.isChrome ? 1 : 0; 
			
			// remove the confirmation dialog
			var removeConfirmationDialog = function(e) {
				if (e.target === confirmation) {return;}
				if (clickCounter > 0) {
					clickCounter--;
					return;
				} 
				$confirmation.remove();
				Ext.fly(document).un("click", removeConfirmationDialog);
			};
			
			// Add a click listener on the whole document to remove the confirmation dialog
			Ext.fly(document).on("click", removeConfirmationDialog);
			
			// Remove the row when the yes button is clicked
			$confirmation.child(".y-delete-confirm-yes").on("click", function(e) {
				Event.stop(e);
				$confirmation.remove();
				// TODO Show confirmation dialog to remove the record
				grid.store.remove(riskRecord);
				
				var isRiskGrid = !grid.store.fields.keys.include("riskid");
				// If a risk row is deleted, remove all controls
				if (isRiskGrid) {
					var cStore = this.getControlStore();
					// Find all controls which are associated to the removed risk
					cStore.data.items.findAll(function(controlRecord) {
						return controlRecord.get("riskid") === riskRecord.get("id");
					})
					// And remove them
					.each(function(record) {
						cStore.remove(record);
					});
					
//					this.adjustCellHeight(grid, grid.row, grid.cell, grid.controlCell);
					
				} else {
					// Update the control cell with the new count
					this.updateControlCell(grid);
				}
				this.grid.ownerCt.syncShadow();
			}.bind(this));
			
			// Remove the confirmation when 'no' is clicked
			$confirmation.child(".y-delete-confirm-no").on("click", function(e) {
				Event.stop(e);
				$confirmation.remove();
			});
			
			// Align the confirmation dialog to the delete button inside the row
			grid.el.parent().appendChild($confirmation);
			$confirmation.alignTo(cell, "l-l", this.getConfirmationAlignment());
			
			this.confirmationDialog = $confirmation;
		},
		
		/**
		 * Sadly, yet again different browsers let ext align elements differently to each other,
		 * so depending on the used browser, some small adjustments have to be made
		 * @returns {Array} alignment
		 */
		getConfirmationAlignment : function() {
			if (Ext.isFF) {
				return [-3, 0];
			}
		},
		
		adjustCellHeight : function(grid, row, cell, inner) {

			var offsetLeft = -50;
			
			// Update the height of the active row so the control grid can be inside
			row.dom.style["height"] = (grid.el.getHeight() + cell.originalHeight || (cell.originalHeight = cell.getHeight())) + "px";
			// Let the control grid appear inside the row
			//grid.el.alignTo(inner, "tl-bl", [offsetLeft, 0]);
			
		},
		
		/**
		 * Returns the value of the given property name.
		 * @param {String} prop The name of the property
		 * @param {Object} obj The object to find the value in
		 */
		getLocalizedProperty : function(prop, obj) {
			return ORYX.Core.StencilSet.getTranslation(obj, prop);
			// if (!(obj||{})[prop]) {
			// 	var localizedProp = this.getLocalizedPropertyName(prop);
			// 	return obj[localizedProp] || "";
			// }
			// return obj[prop];
		},
		
		/**
		 * Returns the given property name annotated with the current language
		 * @param {String} prop The property name, e.g. title
		 * @returns {String} e.g. title_de
		 */
		getLocalizedPropertyName : function(prop) {
			// Store the current language lazily for easier reference
			if (!this.lang) {
				this.lang = this.facade.getAllLanguages().first() || ORYX.I18N.Language;
			}
			var lang = (this.lang||"").split("_").first();
			return prop + "_" + lang;
		}
	});
}());
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Christian Wiggert
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function(){
    /**
     * This is the data collection of the predefined NPB attributes and the respective values that are handled by the properpty editor.
     */
    var NPBData = {
        organisationLevel: {
            title           : "Ebene der Verwaltungsorganisation",
            type            : "Choice",
            items           : [["Bund", "BU"], ["Land", "LA"], ["kommunale Ebene", "KE"]]
        },
        topics: {
            title           : "Themenbereiche",
            type            : "Choice",
            multiSelect     : true,
            extendable      : true,
            items           : [["Arbeit", "0201"], ["Auswärtiges", "0202"], ["Bauen und Wohnen", "0203"], ["Bildung", "0204"], ["Familie", "0205"], ["Finanzen", "0206"], ["Forschung", "0207"], ["Frauen", "0208"], ["Gesundheit", "0209"], ["Inneres", "0210"], ["Innere Verwaltung", "0211"], ["Integration", "0212"], ["Justiz", "0213"], ["Kultur", "0214"], ["Natur- und Landschaftspflege", "0215"], ["Rechtliche Planung und Entwicklung", "0216"], ["Schule", "0217"], ["Sicherheit und Ordnung", "0218"], ["Soziales", "0219"], ["Sozial-, Kinder-,Jugend- und Familienhilfe", "0220"], ["Sport", "0221"], ["Stadtentwicklung", "0222"], ["Technologie", "0223"], ["Tourismus", "0224"], ["Umwelt", "0225"], ["Umweltschutz", "0226"], ["Verbraucherschutz", "0227"], ["Ver- und Entsorgung", "0228"], ["Verkehrsflächen und -anlagen (ÖPNV)", "0229"], ["Verkehr", "0230"], ["Verteidigung", "0231"], ["Wirtschaft", "0232"], ["Wissenschaft", "0233"]]
        },
        processStatus: {
            title           : "Status des Prozesses",
            type            : "Choice",
            items           : [["Lokaler Ist-Prozess", "0101"], ["Interorganisational abgestimmter Ist-Prozess", "0102"], ["Interorganisational abgestimmter Soll-Prozess", "0103"], ["Visionärer Prozess", "0104"]]
        },
        processType: {
            title           : "Prozessart",
            type            : "Choice",
            items           : [["Unterstützungsprozess", "UP"], ["Kern-/Geschäftsprozess", "KG"], ["Führungsprozess", "FP"]]
        },
        sizeOfRegionalAdministrationBody: {
            title           : "Größe der Gebietskörperschaft",
            type            : "Choice",
            items           : [["über 400.000", "0006"], ["200.000 - 400.000", "0005"], ["100.000 - 200.000", "0004"], ["50.000 - 100.000", "0003"], ["25.000 - 50.000", "0002"], ["10.000 - 25.000", "0001"]]
        },
        resultReceiver: {
            title           : "Ergebnisempfänger",
            type            : "Choice",
            multiSelect     : true,
            items           : [["Verwaltung (G2G)", "G2G"], ["Bürger(G2C)", "G2C"], ["Unternehmen (G2B)", "G2B"], ["Sonstige verwaltungsexterne, juristische Körperschaften", "SO"]]
        },
        description: {
            title           : "Beschreibung",
            type            : "String",
            multiLine       : true
        },
        responsibleOrganisationUnit: {
            title           : "Federführende Organisationseinheit",
            type            : "String"
        },
        administrativeService: {
            title           : "LeiKa-Schlüssel",
            type            : "String"
        },
        numberOfCases: {
            title           : "Fallzahl",
            type            : "Choice",
            optional        : true,
            items           : [["bis 100", "0301"], ["bis 500", "0302"], ["bis 1.000", "0303"], ["bis 5.000", "0304"], ["bis 10.000", "0305"], ["über 10.000", "0306"]]
        },
        eGovernment: {
            title           : "E-Government Komponente",
            type            : "Choice",
            multiSelect     : true,
            optional        : true,
            items           : [["Formularservice", "0401"], ["Digitalisierung Schriftgut", "0402"], ["E-Payment", "0403"], ["E-Signatur", "0404"], ["E-Archiv", "0405"], ["DMS", "0406"], ["GIS", "0407"], ["VBS", "0408"], ["Verzeichnisdienst", "0409"], ["Mobile Services", "0410"]]
        },
        electronicAssistance: {
            title           : "Grad der elektr. Unterstützung",
            type            : "Choice",
            optional        : true,
            items           : [["keine Unterstützung", "0501"], ["Information", "0502"], ["Formulardownload", "0503"], ["E-Formular kann gesendet werden, ggf. mit Signatur", "0504"], ["Vollelektronische Interaktion", "0505"]]
        },
        // is not available in the editor, because it will be set by the backend
        modelingMethod: {
            title           : "Modellierungsmethode",
            type            : "Choice",
            optional        : true,
            items           : [["BPMN", "BPMN"], ["EPK / eEPK", "EPK"], ["FAMOS", "FAM"], ["Picture", "PIC"], ["UML", "UML"]]
        },
        tags: {
            title           : "Schlagworte",
            type            : "List",
            optional        : true
        },
        cost: {
            title           : "Kosten",
            type            : "String",
            optional        : true
        },
        processingTime: {
            title           : "Durchlaufzeiten",
            type            : "String",
            optional        : true
        },
        linkProcess: {
            title           : "Link",
            type            : "String",
            optional        : true
        },
        additionalLegalNorm : {
            title           : "Weitere relevante Rechtsnormen",
            type            : "String",
            optional        : true
        },
        contactName: {
            title           : "Name der Kontaktperson",
            type            : "String",
            optional        : true
        },
        contactMail: {
            title           : "Mail",
            type            : "String",
            optional        : true
        },
        contactPhone: {
            title           : "Telefon",
            type            : "String",
            optional        : true
        }
    };

    /**
     * This field is used for the topics attribute. It uses an additional window
     * where the user can either pick values from a predefined list or define some
     * new values.
     */
    var CustomTrigger = function(config) {
        CustomTrigger.superclass.constructor.apply(this, arguments);
        // there are two types of values, the predefined topics
        this.officialValues = [];
        // and the free chosen topics (simply a free text)
        this.miscValue = null;
        var items = NPBData.topics.items.pluck(1);
        // so split them
        this.values.each(function(v) {
            if (items.include(v)) {
                this.officialValues.push(v);
            } else {
                this.miscValue = v;
            }
        }.bind(this));
        this.topicStore = new Ext.ux.form.ChoiceStore({choices: NPBData.topics.items});
        // create the concatenated display value for the field
        this.value = this.values.map(function(v) {
            var t = this.getTitle(v);
            return t ? t : v;
        }.bind(this)).join(', ');
    };

    Ext.extend(CustomTrigger, Ext.form.TriggerField, {
        triggerClass: "x-trigger-other",
        values: [],

        getValue: function() {
            var result = [].concat(this.officialValues);
            if (this.miscValue) {
                result.push(this.miscValue);
            }
            return result;
        },

        /**
         * Returns the title for given topic value.
         *
         * @param {String} v the value of the record
         */
        getTitle: function(v) {
            var found = this.topicStore.query('value', v);
            if (found.length === 1) {
                return found.get(0).get('title');
            }
            return null;
        },

        onTriggerClick: function() {
            // callback to update the trigger field when the additional window is closed
            var valueCb = function(values) {
                this.values = values ? values.pluck(1) : [];
                this.setValue(values.pluck(0).join(', '));
            }.bind(this);
            var combo = new Ext.ux.form.ComboFieldList({
                fieldLabel  : NPBData.topics.title,
                store       : this.topicStore,
                mode        : 'local',
                listClass   : 'npb-combo-list-wrap',
                onRender    : function() {
                    Ext.ux.form.ComboFieldList.superclass.onRender.apply(this, arguments);
                    this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {
                                    tag: 'div',
                                    style: 'margin: 5px; display:none;' + this.listStyle
                                }));
                    if(!this.itemFieldTpl) {
                        this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty"></span></tpl>',
                            '<ul class="x-combo-multi-list">',
                                '<tpl for=".">',
                                    '<li class="y-filter-combo-list">{[Signavio.Utils.escapeHTML(values[0])]} ',
                                        '<span class="x-smaller">',
                                            '(',
                                                '<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>',
                                            ')',
                                        '</span>',
                                    '</li>',
                                '</tpl>',
                            '</ul>');
                    }
                    this.updateView();

                },
                values      : this.officialValues.map(function(v) { 
                    var t = this.getTitle(v);
                    if (t) {
                        return [t, v];
                    }
                    return [v, v]; 
                }.bind(this))
            });
            var miscText = new Ext.form.TextField({
                value       : this.miscValue
            });
            var dialog = new Ext.ux.Window({
                autoHeight  : true,
                minHeight   : 300,
                width       : 234,
                modal       : true,
                title       : Ext.ux.getI18N('propertyeditor.npb.topics.title'),
                cls         : 'npb-topics-window',
                defaults    : {
                    width: 200
                },
                keys        : [{
                    key : 27,
                    fn  : function(){
                        dialog.destroy();
                        dialog.hide();
                    }
                }],
                closeAction : "close",
                buttons     : [{
                    text    : Ext.ux.getI18N('btnsave'),
                    handler : function() {
                        this.officialValues = combo.values.pluck(1);
                        this.miscValue = miscText.getValue();
                        var result = [].concat(combo.values);
                        if (this.miscValue) {
                            result.push([this.miscValue, this.miscValue]);
                        }
                        valueCb(result);

                        dialog.destroy();
                        dialog.close();
                    }.bind(this)
                }],
                items       : [
                    new Ext.form.Label({
                        text: Ext.ux.getI18N('propertyeditor.npb.topics.desc')
                    }),
                    new Ext.form.Label({
                        text    : Ext.ux.getI18N('propertyeditor.npb.topics.predefined') + ':'
                    }),
                    combo,
                    new Ext.form.Label({
                        text    : Ext.ux.getI18N('propertyeditor.npb.topics.other') + ':'
                    }),
                    miscText
                ]
            });

            dialog.show();
        }
    });

    var StringListTrigger = function(config) {
        StringListTrigger.superclass.constructor.apply(this, arguments);
        if (!(this.values instanceof Array)) {
            this.values = [];
        }
        this.value = this.values.join(', ');
    };

    Ext.extend(StringListTrigger, Ext.form.TriggerField, {
        triggerClass: "x-trigger-other",
        
        getValue: function() {
            return this.values;
        },
        
        onTriggerClick: function() {
            var field = new Ext.ux.form.TextFieldList({
                value           : this.values,
                listStyle       : 'margin: 5px;'
            });
            var info = new Ext.form.Label({
                text: Ext.ux.getI18N('propertyeditor.npb.tags.desc')
            });
            var dialog = new Ext.ux.Window({
                autoHeight  : true,
                minHeight   : 300,
                width       : 400,
                modal       : true,
                resizable   : true,
                title       : Ext.ux.getI18N('propertyeditor.npb.tags.title'),
                cls         : 'npb-topics-window',
                defaults    : {
                    width: 200
                },
                keys        : [{
                    key : 27,
                    fn  : function() {
                        dialog.destroy();
                        dialog.hide();
                    }
                }],
                closeAction : "close",
                buttons     : [{
                    text    : Ext.ux.getI18N('btnsave'),
                    handler : function() {
                        // this.value = dialog.items.items[0].getValue();
                        this.values = field.getValue();
                        this.setValue(this.values.join(', '));
                        dialog.destroy();
                        dialog.close();
                    }.bind(this)
                }],
                items       : [
                    info,
                    field
                ]
            });
            // somehow I have to set the width here in order to be accepted, the config didn't work
            field.setWidth(366);
            info.setWidth(366);
            dialog.show();

        }
    });

    /** 
     * This specific field wraps the validation and retrieval of correct values for
     * the administrative service key. Those keys are enlisted in the so called Leistungskatalog (LeiKa).
     */
    var LeiKaStore = new Ext.data.Store({
        baseParams  : {},
        proxy       : new Ext.data.HttpProxy({
            useAjax : true,
            method  : 'GET',
            headers : {'Accept': 'application/json'},
            url     : Signavio.Config.BACKEND_PATH + '/leika' // TODO: which config to use?
        }),
        reader      : new Ext.ux.data.RecordReader({rels: 'leika'})
    });

    var LeiKaBox = function() {
        Ext.PagingToolbar.prototype.paramNames.start = "offset";
        LeiKaBox.superclass.constructor.apply(this, arguments);
    };

    Ext.extend(LeiKaBox, Ext.form.ComboBox, {
        lazyInit            : false,
        typeAhead           : false,
        hideTrigger         : true,
        preventScrollbars   : true,
        forceSelection      : true,
        displayField        : 'rep.id',
        loadingText         : Ext.ux.getI18N('propertyeditor.npb.searching'),
        emptyTextList       : '<div class="x-no-entry">' + Ext.ux.getI18N('propertyeditor.npb.no_leika') + '</div>',
        queryDelay          : 100,
        minChars            : 2,
        pageSize            : 10,
        resizable           : false,
        showEmptyItems      : true,
        queryParam          : "q",
        itemSelector        : 'div.search-item',
        invalidText         : Ext.ux.getI18N('propertyeditor.npb.invalid_leika'),
        tpl                 : new Ext.XTemplate(
                '<tpl for="."><div class="search-item">',
                    '<span><span style="font-weight: bold;">{values.rep.id}</span> - {values.rep.performance}<tpl if="Ext.isDefined(values.rep.performanceDetail) &amp;&amp; values.rep.performanceDetail.length &gt; 0"> ({values.rep.performanceDetail})</tpl> - {values.rep.serviceName}</span>',
                '</div></tpl>'
        ),

        listeners           : {
            select      : function(field, record, index) {
                if (record && record.get("rep")) {
                    this.setValue(record.get("rep").id);
                }
            },
            focus       : function(field) {
                var v = this.getRawValue();
                if (typeof v === 'string' && v.length > this.minChars) {
                    this.doQuery(this.getRawValue());
                }
            }
        },

        validator           : function(value) {
            if (Ext.isDefined(value) && value !== null) {
                return value.match(/^[0-9]{14}$/) !== null;
            }
            return false;
        },

        // @override
        initEvents      : function() {
            LeiKaBox.superclass.initEvents.call(this);

            // Overwrite tab behavior
            this.keyNav.tab = function() {
                if (this.selectedIndex >= 0){
                    this.onViewClick(false);
                } else {
                    this.collapse();
                }
                return true;
            };
        },

        // @override
        initList        : function() {
            var ps = Ext.isNumber(this.pageSize) ? this.pageSize : 10;
            // if the pageSize is 0, no toolbar will be shown
            this.pageSize = 0;
            LeiKaBox.superclass.initList.apply(this, arguments);
            // reset the pageSize afterwards
            this.pageSize = ps;
        },

        // @override
        onEmptyResults  : function() {
            var v = this.getRawValue();
            if (typeof v === 'string' && v.length > 0 && this.showEmptyItems) {
                this.view.el.createChild(this.emptyTextList, this.view.el.first());
            } else {
                this.collapse();
            }
        }

    });

    /**
     * This is a special property editor for the specific attributes that are necessary to exchange a process
     * model with the Nationale Prozessbibliothek.
     */   
    Ext.ux.propertyeditor.NPBAttributes = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
        windowCreate: {
            cls         : 'y-npb-property-editor',
            width       : 440,
            autoHeight  : true,
            title       : Ext.ux.getI18N('propertyeditor.npb.title')
        },

        /**
         * Renders teh value that is shown in the property editor.
         *
         * @param {String} value the property value
         */
        renderer: function(value) {
            var i = 0;
            if (value || value.length > 0) {
                var obj = JSON.parse(value);
                var keys = Object.keys(NPBData);
                // count the mandatory attributes and display the count
                keys.each(function(key) {
                    if (!!!NPBData[key].optional) {
                        if (NPBData[key].multiSelect) {
                            var v = this.parseMultiSelect(obj[key]);
                            if (v.length > 0) {
                                i++;
                            }
                        } else if (obj[key] && obj[key].value && obj[key].value.length > 0) {
                            i++;
                        }
                    }
                }.bind(this));
            }

            return i + Ext.ux.getI18N('propertyeditor.npb.render_msg');
        },

        /**
         * Parses an array of strings.
         *
         * @param {Mixed} obj the raw value
         */
        parseMultiSelect: function(obj) {
            if (obj) {
                var v;
                if (typeof obj === "string") {
                    var temp = JSON.parse(obj);
                    if (typeof temp === "object") {
                        v = temp.value;
                    }
                } else if (typeof obj === "object") {
                    v = obj.value;
                }
                if (v) {
                    if (typeof v === "string") {
                        if (v.startsWith("[") && v.endsWith("]")) {
                            return JSON.parse(v);
                        } else {
                            return JSON.parse("[\"" + v + "\"]");
                        }
                    } else if (v instanceof Array) {
                        return v;
                    }
                    // else we assume there is some kind of invalid value
                    // and return the default value
                }
            }
            return [];
        },

        /**
         * Parses a single string value.
         *
         * @param {Mixed} obj the raw value
         */
        parseValue: function(obj) {
            var v;
            if (obj) {
                if (typeof obj === "string") {
                    var temp = JSON.parse(obj);
                    if (typeof temp === "object") {
                        v = temp.value;
                    }
                } else if (typeof obj === "object") {
                    v = obj.value;
                }
            }
            return v || "";
        },

        /**
         * Wraps a value before it is stored in the property again.
         */
        wrapValue: function(value, type) {
            return {
                'value': value,
                'type': type
            };
        },

        /**
         * This is a simple migration function which checks whether the stored property value still used the old schema.
         * If necessary it transforms the old schema into the new one.
         */
        migrateOldVersion: function(obj) {
            // this.parseValue(obj.organisationLevel),
            // so we have to figure out whether the stored value contains any old values that need to be migrated
            var keys = Object.keys(NPBData).findAll(function(key) {
                return NPBData[key].type === 'Choice';
            });
            // simply check if the stored value for any choice attribute contains the literal title as the value
            // replace the old value with the new appropriate code
            keys.each(function(key) {
                if (NPBData[key].multiSelect) {
                    var values = this.parseMultiSelect(obj[key]);
                    var newValue = [];
                    values.each(function(value) {
                        var entry = NPBData[key].items.find(function(item) {
                            return value === item[0];
                        });
                        if (typeof entry !== 'undefined') {
                            newValue.push(entry[1]);
                        } else {
                            newValue.push(value);
                        }
                    }.bind(this));
                    obj[key] = this.wrapValue(newValue, 'liste');
                } else  {
                    var value = this.parseValue(obj[key]);
                    var entry = NPBData[key].items.find(function(item) {
                        return value === item[0];
                    });
                    if (typeof entry !== 'undefined') {
                        obj[key] = this.wrapValue(entry[1], 'text');
                    }
                }
            }.bind(this));
        },

        onWindowRendered: function(win) {
            Ext.ux.propertyeditor.NPBAttributes.superclass.onWindowRendered.apply(this, arguments);
            // there is some hard coded padding that we want to be gone...
            if (win && win.body) {
                win.body.setStyle('padding', '0px');
            }

        },

        /**
         * Returns the appropriate field for a certain attribute based on the defined schema.
         */
        getField: function(key, obj) {
            var data = NPBData[key];
            if (data) {
                if (key === 'administrativeService') {
                    return new LeiKaBox({
                        store       : LeiKaStore,
                        fieldLabel  : data.title,
                        value       : this.parseValue(obj[key]),
                        listClass   : 'npb-leika-list-wrap'
                    });
                } else if (data.type === 'Choice') {
                    if (data.multiSelect) {
                        if (data.extendable) {
                            return new CustomTrigger({
                                fieldLabel  : data.title,
                                readOnly    : true,
                                values      : this.parseMultiSelect(obj[key])
                            });
                        } else {
                            return new Ext.ux.form.RadioGroup({
                                fieldLabel  : data.title,
                                store       : new Ext.ux.form.ChoiceStore({choices: data.items}),
                                multiSelect : true,
                                labelWidth  : 200,
                                autoWidth   : true,
                                values      : this.parseMultiSelect(obj[key])
                            });
                        }
                    } else {
                        return new Ext.ux.form.ComboBox({
                            fieldLabel  : data.title,
                            readOnly    : true,
                            store       : new Ext.ux.form.ChoiceStore({choices: data.items}),
                            value       : this.parseValue(obj[key]),
                            mode        : 'local',
                            listClass   : 'npb-combo-list-wrap'
                        });
                    }
                } else if (data.type === 'String') {
                    if (data.multiLine) {
                        return new Ext.form.TextArea({
                            fieldLabel  : data.title,
                            value       : this.parseValue(obj[key])
                        });
                    } else {
                        return new Ext.form.TextField({
                            fieldLabel  : data.title,
                            value       : this.parseValue(obj[key])
                        })
                    }
                } else if (data.type === 'List') {
                    return new StringListTrigger({
                        fieldLabel      : data.title,
                        values          : this.parseMultiSelect(obj[key])
                    });
                }
            } else {
                return null;
            }
        },

        getEditor: function(value) {
            // parse value to JSON or create initial JSON
            var obj;
            if (value !== null && value.length > 0) {
                obj = JSON.parse(value);
            } else {
                obj = {};
            }

            this.migrateOldVersion(obj);

            // so there are a lot of mandatory and optional attributes
            // therefore we split them up into two tabs
            // first the mandatory attributes
            var tabOneKeys = ['organisationLevel', 'topics', 'processStatus', 'processType', 
                    'sizeOfRegionalAdministrationBody', 'resultReceiver', 'description', 
                    'responsibleOrganisationUnit', 'administrativeService'];
            var tabOne = new Ext.Panel({
                title       : Ext.ux.getI18N('propertyeditor.npb.tab_mandatory'),
                anchor      : "100% 100%",
                layout      : "form",
                bodyStyle   : "padding: 10px;",
                labelWidth  : 200,
                defaults    : {
                    width: 200
                },
                items       : tabOneKeys.map(function(key) {
                    return this.getField(key, obj);
                }.bind(this))
            });
            // secondly the optional attributes
            var tabTwoKeys = ['additionalLegalNorm', 'electronicAssistance', 'eGovernment', 
                    'numberOfCases', 'tags', 'cost', 'processingTime', 'contactName', 'contactMail', 'contactPhone'];
            var tabTwo = new Ext.Panel({
                title       : Ext.ux.getI18N('propertyeditor.npb.tab_optional'),
                anchor      : "100% 100%",
                layout      : "form",
                bodyStyle   : "padding: 10px;",
                labelWidth  : 200,
                defaults    : {
                    width: 200
                },
                items       : tabTwoKeys.map(function(key) {
                    return this.getField(key, obj);
                }.bind(this))
            });

            return new Ext.TabPanel({
                initialValue: obj,
                activeTab   : 0,
                height      : Ext.isIE ? 520 : 500, // somehow IE needs more space
                border      : false,
                anchor: "100% 100%",
                layoutOnTabChange: true,
                items       : [
                    tabOne,
                    tabTwo
                ],
                getValue: function() {
                    // override the existing fields with the new values
                    // so not editable values don't get lost
                    this.wrapTabValues(tabOne, tabOneKeys, this.initialValue);
                    this.wrapTabValues(tabTwo, tabTwoKeys, this.initialValue);
                    return Object.toJSON(this.initialValue);
                },
                /**
                 * Wraps the values for a given tab before they serialized in the property.
                 */ 
                wrapTabValues: function(tab, keys, obj) {
                    keys.each(function(key, i) {
                        var data = NPBData[key];
                        if (data.multiSelect || data.type === 'List') {
                            obj[key] = this.wrapValue(tab.items.items[i].getValue(), 'liste');
                        } else {
                            obj[key] = this.wrapValue(tab.items.items[i].getValue(), 'text');
                        }
                    }.bind(this));
                },
                /**
                 * Wraps the value for a single attribute.
                 */
                wrapValue: function(value, type) {
                    return {
                        'value': value,
                        'type': type
                    };
                }
            });
        }
    });
})();
/** 
 *  (c) 2012 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

new function(){
	
	/**
	 * Property Editor for remote accessible property editors of a customer
	 * specific implementation.
	 * 
	 * The remote property editor is loaded into an iFrame. Submit value 
	 * exchange than is again realized by an iFrame, initiated by the remote
	 * property editor. A Signavio JS Snipped is provided for OEM customers.
	 */
	Ext.ux.propertyeditor.RemoteProperty = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width:undefined, noButtons: true, hideCancelButton: true},
		
		/**
		 * It is assumed that value is of format {rawValue:"..", renderedValue:".."}
		 * 
		 * @param value
		 */
		getEditor: function(value) {
			var remoteEditorFrame = document.createElement("iframe")
			 , form = document.createElement("form")
			 , inputVal = document.createElement("input")
			 , iFrameId = "signavio_remoteproperty_" + Ext.id()
			 , propData = value||{}
			 , me = this;
			
			remoteEditorFrame.setAttribute("name", iFrameId);
			remoteEditorFrame.setAttribute("id", iFrameId);
			remoteEditorFrame.setAttribute("frameborder", "0");
			remoteEditorFrame.setAttribute("frameBorder", "0");
			remoteEditorFrame.setAttribute("height", "100%");
			remoteEditorFrame.setAttribute("width", "100%");
			remoteEditorFrame.setAttribute("marginheight", "0");
			remoteEditorFrame.setAttribute("marginwidth", "0");
			remoteEditorFrame.setAttribute("scrolling", "no");
			
			remoteEditorFrame.doSubmit = function(propDataSubmit){
				// Transform to JSON String
				propData = Object.toJSON(propDataSubmit)||"";
				
				// Call save
				if (me.win) {
					if (me.onBeforeSave(me.getValue(), panel.getValue())) {
						me.onSave(me.getValue(), panel.getValue());	
						me.win.close();
					}
					
//					me.win.destroy();
				}
			};
			
			remoteEditorFrame.cancelPropEdit = function() {
				if (me.win) {
					me.win.close();
//					me.win.destroy();
				}
			};
			
			/**
			 * Takes the property value string and returns the respective JSON
			 * object.
			 */
			remoteEditorFrame.getPropertyData = function() {
				var defaultVal = {rawValue:"", renderedValue:""};
				if ("string" == typeof propData) {
					try {
						return propData.evalJSON();
					} catch (e) {
						return defaultVal;
					}
				}
				return defaultVal;
			};
			
			/**
			 * Collects property data on submit from the iframe creating
			 * form and stores it for further processing.
			 * @returns
			 */
			var collectPostData = function() {
				propData = inputVal.getAttribute('value');
				console.log("onsubmit", propData);
				return true;
			};
			
			//Set form attributes to open the property editor in an iFrame and
			//to post the value data
			form.setAttribute("action", this.property.url());
			form.setAttribute("method", "POST");
			form.setAttribute("target", iFrameId);
			
			//Set form input to pass value to remote
			inputVal.setAttribute("name", "signavio_remoteproperty_value");
			inputVal.setAttribute("value", propData);
			
			form.appendChild(inputVal);
			remoteEditorFrame.appendChild(form);
			
			
			// Create editor panel
			// Window options
			
			if (!this.windowCreate.height) {
				this.windowCreate.height = this.property.remoteWindowHeight();
			}
			if (!this.windowCreate.width) {
				this.windowCreate.width = this.property.remoteWindowWidth();
			}
			this.windowCreate.autoScroll = this.property.remoteWindowAutoScroll();
			
			var panel = new Ext.Panel({
				html: '',
				border: false,
				anchor: "100% 100%",
				layout: "form",
				cls: "x-remoteprop",
				autoScroll: this.property.remoteWindowAutoScroll()||false,
				getValue: function(){
					return propData;
				},
				listeners: {
					render: function() {
						this.body.appendChild(remoteEditorFrame);
						
						// Append property value
						var eForm = Ext.get(form);
						eForm.on('onsubmit', collectPostData);
						form.submit();
					}
				}
			});
			
			
			return panel;
		},
		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			// VARs
			var valueObj, renderedVal = "";
			
			var renderToStringFn = function(val) {
				if ("string" == typeof val) {
					return val;
				} else {
					return Object.toJSON(val);
				}
			};
			
			if (value && "string" == typeof value) {
				try {
					valueObj = value.evalJSON();
				} catch (e) {
				}
			} 
			
			// Get the rendered value
			if (valueObj) {
				if (valueObj.renderedValue) {
					renderedVal = renderToStringFn(valueObj.renderedValue);
				}
			}
			
			// Case still no readable value
			if (!renderedVal && value && value.renderedValue) {
				renderedVal = renderToStringFn(value.renderedValue);
			}
			
			if (!renderedVal && value) {
				renderedVal = renderToStringFn(value);
			}
			
			return renderedVal.truncate(20, '...');
		}
		
		
	});
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {} }

new function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.SaperionACL = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width:350},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			var conf = this.property.autocomplete();
			var skript = new Ext.ux.form.ComboBox({
							hideTrigger: conf.trigger === false,
							forceSelection: conf.optional === false,
					        typeAhead: conf.optional === false, 
					        url: conf.url,
							allowBlank: this.property.optional(),
							fieldLabel: this.property.title().split(":").last(),
							style:"margin-bottom: 5px;",
							value: ["+", "-"].include(String(value).slice(0, 1)) ? String(value).slice(1) : String(value)
					    });
			
						
			return new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "form",
				getValue: function(){
					var pre = this.items.last().checked ? "-" : "+",
						value = String(skript.getValue()).trim();
					return value ? pre+value : "";
				},
				defaults: {
					width: 200
				},
				items: [skript, 
						new Ext.form.Radio({
							fieldLabel: Ext.ux.getI18N("panel.operation"),
							boxLabel: Ext.ux.getI18N("panel.add"),
							style:"position: relative;top: 2px;",
							labelStyle:"padding: 1px 0;",
							checked: !String(value).startsWith("-"),
							name:"x-saperion-operation"
						}), 
						new Ext.form.Radio({
							fieldLabel: "",
							labelSeparator : "",
							style:"position: relative;top: 2px;",
							labelStyle:"padding: 1px 0;",
							boxLabel: Ext.ux.getI18N("panel.remove"),
							checked: String(value).startsWith("-"),
							name:"x-saperion-operation"
						})]
			});
		}
		
	});	
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion performer dialog.
	 * 
	 */
	Ext.ux.propertyeditor.SaperionPerformer = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		types: {
			"GRPORGUNIT": "group",
			"GRPROLE": "group",
			"GRPSIMPLE": "group",
			"GRPMEMBER": "user"
		},
		
		windowCreate: {height:undefined, width:630, resizable: false},
		
		url: Signavio.Config.BACKEND_PATH + "/saperion?proxy=members",
		
		/**
		 * Returns TRUE if the value is a json object
		 * @param {Object} value
		 */
		isStaticValue: function(value){
			return String(value).startsWith("{") && String(value).endsWith("}");
		},
		
				
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if (this.isStaticValue(value)){
				var obj = this.parsePerformers(value);
				return (obj.items||[]).pluck("fullname").join(", ")+""+(obj.selectuser ? " "+Ext.ux.getI18N("panel.label_free_userselection")+"":"");	
			} else {
				return value;
			}
		},
		
		/**
		 * Returns a panel where the performer form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			
			var enableStaticValue = !value || this.isStaticValue(value), performers = {totalCount:0, items:[]}, br = "";
			
			if (enableStaticValue){
				performers = this.parsePerformers(value);
			} else {
				br = value;
			}
			
			
			this.panel = new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "form",
				cls: "ext-el-mask-no-background x-performer-dialog",
				hideLabels: true,
				getValue: this.extractValue.bind(this),
				items: [
					// STATIC
					new Ext.form.Radio({
						boxLabel: Ext.ux.getI18N("panel.static"),
						name: "performertype",
						checked: enableStaticValue,
						listeners: {
							check: function(f, checked){
								var items = this.ownerCt.items.items;
								items.slice(1, items.length-2).invoke("setDisabled", !checked);
								items[3].setDisabled(!checked || !items[1].checked);
							}
						}
					}), 
					new Ext.form.Checkbox({
						boxLabel: Ext.ux.getI18N("panel.no_free_userselection"),
						style: "position:relative;top:2px;",
						checked: performers.selectuser || false,
						onRender: function(){
							Ext.form.Checkbox.prototype.onRender.apply(this, arguments);
							var width = this.ownerCt.items.get(0).wrap.child("label").getWidth();
							this.container.parent().setStyle({top: "0px", position: "absolute", left: (width+40)+"px"});
						},
						listeners: {
							check: function(cb, checked){
								cb.ownerCt.items.get(3).setDisabled(!checked);
							}
						}
					}), 
					new Ext.Panel({
						border: false,
						html:  Ext.ux.getI18N("panel.no_defined_role_label")+":",
						bodyStyle: "padding: 5px 0 2px 86px;"
					}),
					new Ext.Panel({
						border: false,
						layout: "column",
						bodyStyle: "padding-left: 86px;padding-bottom: 10px;", 
						listeners: { render: function(r){ if (!performers.selectuser) r.disable(); }},
						getValue: function(){
							return {
								selectsingleuser: this.items.get(0).items.get(0).checked,
								selectrolemember: this.items.get(1).items.get(0).checked,
								selectrole: this.items.get(2).items.get(0).checked
							};
						},
						items: [new Ext.Panel({
									border: false,
									columnWidth: 0.3,
									items: [new Ext.form.Checkbox({
										style: "position:relative;top:2px;",
										boxLabel: Ext.ux.getI18N("panel.no_defined_role_single_user"),
										checked: performers.selectsingleuser !== false
									})]
								}),new Ext.Panel({
									border: false,
									columnWidth: 0.3,
									items: [new Ext.form.Checkbox({
										style: "position:relative;top:2px;",
										boxLabel: Ext.ux.getI18N("panel.no_defined_role_role_member"),
										checked: performers.selectrolemember !== false
									})]
								}),new Ext.Panel({
									border: false,
									columnWidth: 0.3,
									items: [new Ext.form.Checkbox({
										style: "position:relative;top:2px;",
										boxLabel: Ext.ux.getI18N("panel.no_defined_role_group"),
										checked: performers.selectrole !== false
									})]
								})]
					}),
					this.getPerformerPanel(performers, !enableStaticValue),
					
					// DYNAMIC
					new Ext.form.Radio({
						boxLabel:Ext.ux.getI18N("panel.dynamic"),
						name:"performertype",
						checked: !enableStaticValue,
						listeners: {
							 check: function(f, checked){
								this.ownerCt.items.last().setDisabled(!checked);
							}
						}
					}),
//					new Ext.form.TextField({
//						width: 575,
//						emptyText: Ext.ux.getI18N("panel.businessrule"),
//						style: "margin-left:20px;",
//						disabled: enableStaticValue,
//						value: br
//					})
					new Ext.ux.form.ComboBox({
						emptyText: Ext.ux.getI18N("panel.businessrule"),
						exceptionText: "Der SAPERION Server ist nicht erreichbar.",
						hideTrigger: false,
						forceSelection: false,
				        typeAhead: true, 
				        url: "./saperion?proxy=script",
						allowBlank: true,
						width: 575,
						disabled: enableStaticValue,
						value: br,
						afterRender: function(){
							Ext.ux.form.ComboBox.prototype.afterRender.apply(this, arguments);
							this.wrap.setStyle("margin-left", "20px");
						}
				    })
				]
			});
			
			return this.panel;
		},
		
		/**
		 * Returns the Ext.Panel to define the performers.
		 * @param {Array} performers
		 * @param {Boolean} enabled
		 * @return {Ext.Panel}
		 */
		getPerformerPanel: function(performers, enabled){
			
			var height = 300, performerList, self = this, me = this;
			
			// Store which holds all performers
			var store = new Ext.data.SimpleStore({
				data: performers.items.map(function(per){
					return [per.fullname, per.type || "", per.description || "", per.uid || ""];
				}),
				fields: ["fullname", "type", "description", "uid"]
			});
			
			// List of all available performers
			var performerTree = new Ext.tree.TreePanel({
				rootVisible: false,
				root: new Ext.tree.AsyncTreeNode({}),
				loader: new Ext.tree.TreeLoader({
					url: this.url,
					requestMethod: "GET",
					listeners: {
						beforeload: function(foo, node){
							if (node.attributes.uid)
								this.baseParams.uid = node.attributes.uid;
						},
						load: function(){
							if (performerTree.root.spinner){
								Ext.get(performerTree.root.ui.wrap).first().remove();
								delete performerTree.root.spinner;
							}
						},
						loadexception: function(){
							var wrap = Ext.get(performerTree.root.ui.wrap);
							wrap.first().remove();
							wrap.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
										 	"<img src='"+Ext.IMAGE_URL+"/famfamfam/error.png' style='margin-right:5px;opacity:0.2;position:relative;top:4px;width:16px;height:16px;'/>" +
										 	"Der SAPERION Server ist nicht erreichbar." +
										 "</div>");
						}
					},
					// Specific mapping of response to node attribute
					createNode: function(attr){
						attr.text = attr.fullname;
						attr.leaf = (self.types[attr.type] || attr.type) === "user";
						attr.cls  = attr.type ? "x-" + (self.types[attr.type] || attr.type) : "";
						return Ext.tree.TreeLoader.prototype.createNode.call(this, attr);
					},
					//@overwrite
					requestData : function(node, callback){
				        if(this.fireEvent("beforeload", this, node, callback) !== false){
				            this.transId = Ext.Ajax.request({
				                method:this.requestMethod,
				                url: this.dataUrl||this.url,
				                success: this.handleResponse,
				                failure: this.handleFailure,
				                scope: this,
				                argument: {callback: callback, node: node},
				                params: this.getParams(node),
				                headers:{Accept: "application/json"}
				            });
				        }else{
				            // if the load is cancelled, make sure we notify
				            // the node that we are done
				            if(typeof callback == "function"){
				                callback();
				            }
				        }
				    }
				}),
				autoScroll: true,
				cls: "x-performer-tree",
				columnWidth: 0.5,
				height: height,
				afterRender	: function(){
					Ext.tree.TreePanel.prototype.afterRender.apply(this, arguments);
					
					// Waiting spinner
					this.root.spinner = this.root.ui.wrap.update("<div style='color:silver;font-style:italic;margin-left:5px;'>" +
											 	"<img src='/libs/ext-2.0.2/resources/images/default/grid/loading.gif' style='margin-right:5px;opacity:0.4;position:relative;top:4px;'/>" +
											 	"User werden geladen." +
											 "</div>");
				}
			});
			
			
			// Buttons in the middle to add/remove performer
			var selector = new Ext.Panel({
				border: false,
				width: 47,
				height: height,
				cls: "x-performer-selector",
				bodyStyle: "display:table-cell;padding:10px;text-align:center;vertical-align:middle;",
				items: [
					
					// Left -> Right
					new Ext.Button({
						icon: ""+Ext.IMAGE_URL+"/famfamfam/arrow_right.png",
						iconCls: "dummy",
						style: "margin-bottom: 5px", 
						disabled: true,
						handler: function(){
							// Get selected node
							var node = performerTree.getSelectionModel().getSelectedNode();
							if (node){
								// Create a new record and add it
								var attr = node.attributes;
								var addRegular = function(){
									var record = new store.recordType({fullname:node.text, description: attr.description||"", type: attr.type || "", uid: attr.uid || ""});
									store.add(record);
									this.disable();
								}.bind(this);
								
								if (!node.isLeaf() && ["parallel", "sequential"].include((me.facade.getSelection()[0].properties["oryx-looptype"]||"").toLowerCase())){
									Ext.Msg.confirm(Ext.ux.getI18N("panel.no_parallel_title"), Ext.ux.getI18N("panel.no_parallel_description"), function(btn){
										if (btn == "yes"){
											Ext.Ajax.request({
								                method:"get",
								                url: self.url+"&"+Ext.urlEncode(attr),
								                success: function(e){
								                	try {
								                		var json = e.responseText.evalJSON();
								                		if (json instanceof Array){
								                			json = json.findAll(function(child){
								                				return ["GRPMEMBER", "USER"].include(child.type);
								                			});
								                			json.each(function(child){
																store.add(new store.recordType(child));
								                			});
								                		}
								                		if (!(json instanceof Array) || json.length <= 0){
								                			Ext.Msg.alert(Ext.ux.getI18N("panel.no_parallel_title"), Ext.ux.getI18N("panel.no_parallel_no_user")).setIcon(Ext.Msg.INFO).getDialog().syncSize();
								                		}
								                	} catch(err){}
								                	performerList.el.unmask();
								                }.bind(this),
								                failure: function(){
								                	performerList.el.unmask();
								                },
								                headers:{Accept: "application/json"}
								            });
											this.disable();
											performerList.el.mask("Date werden geladen...", "x-mask-loading");
										} else {
											addRegular();
										}
									}.bind(this));
								} else {
									addRegular();
								}
								
							}
						}
					}),
					
					// Right -> Left
					new Ext.Button({
						icon: ""+Ext.IMAGE_URL+"/famfamfam/arrow_left.png",
						iconCls: "dummy",
						disabled: true,
						handler: function(){
							// Remove entry
							performerList.getSelectedRecords().each(function(record){
								store.remove(record);
							});
							// Update the list
							performerList.refresh();
						}
					})
				]
			});
			
			// List of all selected performers
			performerList = new Ext.DataView({
		        store: store,
				prepareData: function(data){
					data = Object.clone(data);
					data.descCls = !data.description || data.description === Ext.ux.getI18N("panel.no_description") ? "x-empty" : "";
					data.description = data.description || Ext.ux.getI18N("panel.no_description");
					data.type = self.types[data.type] || data.type;
					return data;
				},
		        tpl: new Ext.XTemplate(
						    '<tpl for=".">',
						        '<div class="thumb-wrap">',
						        	'<div class="x-fullname x-type-{type}">{fullname}</div>',
									'<div class="x-description {descCls}">{description}</div>',
								'</div>',
						    '</tpl>',
						    '<div class="x-clear"></div>'),
				cls: "x-performer-list",
				columnWidth: 0.5,
				height: height,
				autoScroll: true,
		        multiSelect: true,
		        overClass:'x-view-over',
		        itemSelector:'div.thumb-wrap',
		        emptyText: '<span class="x-default">'+Ext.ux.getI18N("panel.no_performer")+'</span>'
		    });


			// Enable/disable buttons in the middle
			performerTree.getSelectionModel().on("selectionchange", function(foo, node){
				var isFirstLevelNode 	= false; //!node.parentNode || !node.parentNode.parentNode;
				var isAlreadyIncluded 	= store.find("fullname", node.text || "") >= 0;
				selector.items.get(0).setDisabled(isFirstLevelNode || isAlreadyIncluded);
			});
			performerList.on("selectionchange", function(foo, sel){ selector.items.get(1).setDisabled(sel.length == 0);});
			
			
			
			return new Ext.Panel({
						border: false,
						layout: "column",
						bodyStyle: "padding-bottom:10px;padding-left:20px;",
						disabled: enabled,
						items: [performerTree, selector, performerList],
						/**
						 * Returns the set of all selected performers
						 */
						getValue: function(){
							if (store.getCount() > 0) {
								return {
									totalCount: store.getCount(),
									items: store.getRange().map(function(record){
										return {
											uid: record.get("uid"),
											fullname: record.get("fullname"),
											description: record.get("description"),
											type: record.get("type")
										};
									})
								};
							} else {
								return undefined;
							}
						}
					});
		},
		
		/**
		 * Returns the current value
		 * @return {String}
		 */
		extractValue: function(){
			
			if (this.panel.items.get(0).getValue()) {
				// Static perfomers
				var performers = this.panel.items.get(4).getValue();
				if (this.panel.items.get(1).getValue()){
					if (performers)
						performers.selectuser = true;
					else 
						performers = {totalCount:0, items:[], selectuser:true};
					
					performers = Ext.apply({}, performers, this.panel.items.get(3).getValue());
				}
				if (performers){
					performers = Object.toJSON(performers);
				}
				return performers;
			} else {
				// Dynamic business rule
				return this.panel.items.get(6).getValue();
			}
		},
		
		/**
		 * Returns the javascript array of all performers which
		 * are defined through the value.
		 * @param {String} value
		 * @return {Object}
		 */
		parsePerformers: function(value){
			return value ? String(value).evalJSON() : {totalCount:0, items:[]};
		}
		
	});	
	
}());
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {} }

new function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.SaperionSkript = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width:350},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			// Get the script_language property
			var sl = (this.properties||[]).find(function(r){ return r.id().endsWith("script_language") });
			var slvalue = this.facade.getSelection()[0].properties[sl.prefix()+"-"+sl.id()];
			
			// Generate the fields
			this.skripLanguage = new Ext.form.ComboBox({
							value: slvalue,
							fieldLabel: sl.title(),
					        store: new Ext.data.SimpleStore({
							        fields: ['value'],
							        data : sl.items().map(function(r){ return [r.title()]; })
							    }),
					        displayField:'value',
					        typeAhead: true,
					        mode: 'local',
					        triggerAction: 'all',
					        selectOnFocus:true,
					        editable: false,
					        readOnly: true,
							listeners: {
								change : function(foo, language){
									if (language) {
										this.skript.store.baseParams.language = language;
									} else {
										delete this.skript.store.baseParams.language;
									}
									delete this.skript.lastQuery;
								}.bind(this)
							}
					    });
		
			var conf = this.property.autocomplete();
			this.skript = new Ext.ux.form.ComboBox({
							hideTrigger: conf.trigger === false,
							forceSelection: conf.optional === false,
					        typeAhead: conf.optional === false, 
					        url: conf.url,
							allowBlank: this.property.optional(),
							fieldLabel: this.property.title()
					    });
			
			if (slvalue){ // Set the scripting language
				this.skript.store.baseParams.language = slvalue;
			}
						
			return new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "form",
				getValue: function(){
					return this.skript.getValue();
				}.bind(this),
				defaults: {
					width: 200
				},
				items: [this.skripLanguage, this.skript]
			})
		},
		
		onSave: function(oldValue, newValue){
			this.setValue(newValue);
			
			// Check if the scripting language has changed
			var slv = this.skripLanguage.getValue(), key = "oryx-script_language", sel = this.facade.getSelection();
			if (sel.any(function(r){ return r.properties[key] !== slv})) {
				var self = this;			
				// Use a command to set the scripting language
				var Command = ORYX.Core.Command.extend({
					construct: function(){
						this.shapes = sel;
						this.key = key;
						this.value = slv;
						this.oldValues = this.shapes.map(function(e){
							return e.properties[this.key];
						})
					},
					execute: function(){
						this.shapes.invoke("setProperty", this.key, this.value);
						if (!this.executed) {
							self.fireEvent('dialogClosed', this, newValue, oldValue);
						}
						this.executed = true;
						this.update();
					},
					rollback: function(){
						this.shapes.each(function(shape, i){
							shape.setProperty(this.key, this.oldValues[i])
						}.bind(this));
						this.update();
					},
					update: function(){
						if (oldValue == newValue) {
							self.facade.setSelection([]);
							self.facade.setSelection(this.shapes);
						}
					}
				});
				this.facade.executeCommands([new Command()]);
			} else {
				this.fireEvent('dialogClosed', this, newValue, oldValue);
			}
		}
		
	});	
	
}()
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner
 *  
 */

if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {} }

new function(){
	
	/**
	 * Specific class to provide a skrip panel for the saperion skript dialog.
	 * 
	 */
	Ext.ux.propertyeditor.SaperionTimeDelay = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
		
		windowCreate: {height:undefined, width:340, resizable: false},
		
		/**
		 * Returns an array with 7 ints which defined the time (from year to milliseconds).
		 * @param {Object} value
		 */
		parseTimes: function(value){
			return value.split(/(.{2})/g)
						.findAll(function(r){return r; })
						.map(function(r){ return parseInt(r) || 0; });
		},
		
		/**
		 * Returns TRUE if the value is a static time delay value
		 * @param {Object} value
		 */
		isStaticValue: function(value){
			return value.length == 6 && !!String(value).match(/^[0-9]*$/);
		},
		
		/**
		 * Returns TRUE if the value is a dynamic time delay value
		 * @param {Object} value
		 */
		isDynamicValue: function(value){
			return !this.isStaticValue(value);
		},

		
		/**
		 * Returns a readable string of the current value
		 * @param {String} value
		 */
		renderer: function(value){
			if (this.isStaticValue(value)){
				var get = Ext.ux.getI18N;
				var labels 	= [get("day"),  get("hour"),  get("minute")];
				var labelss = [get("days"), get("hours"), get("minutes")];
				
				return this.parseTimes(value)
						.map(function(val, i){
							return val ? val + " " + (val==1?labels:labelss)[i] : undefined; 
						}).compact().join(", ");
				
			} else {
				return value;
			}
		},
		
		/**
		 * Returns a panel where the skript form is inside
		 * @param {Object} value
		 */
		getEditor: function(value){
			
			value = String(value).trim();
			var ac = {tag: "input", type: "text", size: "20", autocomplete: "off", maxlength: "2"};
			var defaults = {
				style: "margin-right:5px;padding:1px;",
				allowDecimals: false,
				allowNegative: false,
				width: 90,
				validationEvent: false,
				getLabelPrefix: function(num){
					return "";
				},
				initValue: function(){
					Ext.form.NumberField.prototype.initValue.apply(this, arguments);
					this.initialConfig.listeners.blur.call(this);
				},
				listeners: {
					focus: function(){
						this.setRawValue(parseInt(this.getRawValue())||"");
					},
					blur: function(){
						var num = parseInt(this.getRawValue());
						if (num){
							this.setRawValue(num + " " + this.getLabelPrefix(num));
						}
					}
				}
			};
			
			var defaultsLabel = {
				xtype: "label",
				style: "padding:5px 0px 4px 3px;"
			};
			
			var times = [], br = "";
			if (this.isStaticValue(value)){
				times = this.parseTimes(value);
			} else {
				br = value;
			}
			
			// Day
			this.days = new Ext.form.NumberField(Ext.apply({}, {
								value : times[0] || "",
								autoCreate : Object.clone(ac),
								emptyText : Ext.ux.getI18N("days"),
								getLabelPrefix: function(num){
									return num == 1 ? Ext.ux.getI18N("day"): Ext.ux.getI18N("days");
								}
							}, defaults));
			// Hour
			this.hours = new Ext.form.NumberField(Ext.apply({}, {
								value : times[1] || "",
								autoCreate : Object.clone(ac),
								emptyText : Ext.ux.getI18N("hours"),
								getLabelPrefix: function(num){
									return num == 1 ? Ext.ux.getI18N("hour"): Ext.ux.getI18N("hours");
								}
							}, defaults));
			// Minute
			this.minutes = new Ext.form.NumberField(Ext.apply({}, {
								value : times[2] || "",
								autoCreate : Object.clone(ac),
								emptyText : Ext.ux.getI18N("minutes"),
								getLabelPrefix: function(num){
									return num == 1 ? Ext.ux.getI18N("minute"): Ext.ux.getI18N("minutes");
								}
							}, defaults));
			
			var enableStaticValue = !value || this.isStaticValue(value);
			
			this.panel = new Ext.Panel({
				border: false,
				anchor: "100% 100%",
				layout: "form",
				cls: "ext-el-mask-no-background",
				hideLabels: true,
				getValue: this.extractValue.bind(this),
				items: [
				        
				    // STATIC
					new Ext.form.Radio({
						boxLabel: Ext.ux.getI18N("panel.static"),
						name: "timedelay",
						checked: enableStaticValue,
						listeners: {
							 check: function(f, checked){
								this.ownerCt.items.get(1).setDisabled(!checked);
							}
						}
					}),
					new Ext.Panel({
						border: false,
						layout: "column",
						bodyStyle: "padding-bottom:10px;padding-left:20px;",
						disabled: !enableStaticValue,
						items: [this.days, 		//Ext.apply({}, defaultsLabel, {width: 40, text: Ext.ux.getI18N("days")+""}),
								this.hours, 	//Ext.apply({}, defaultsLabel, {width: 55, text: Ext.ux.getI18N("hours")+""}), 
								this.minutes]//, 	//Ext.apply({}, defaultsLabel, {width: 55, text: Ext.ux.getI18N("minutes")+""})]
					}),
					
					// DYNAMIC
					new Ext.form.Radio({
						boxLabel:Ext.ux.getI18N("panel.dynamic"),
						name:"timedelay",
						checked: !enableStaticValue,
						listeners: {
							 check: function(f, checked){
								this.ownerCt.items.get(3).setDisabled(!checked);
							}
						}
					}),
//					new Ext.form.TextField({
//						width: 280,
//						emptyText: Ext.ux.getI18N("panel.businessrule"),
//						style: "margin-left:20px;",
//						disabled: enableStaticValue,
//						value: br
//						
//					})
					new Ext.ux.form.ComboBox({
						emptyText: Ext.ux.getI18N("panel.businessrule"),
						exceptionText: "Der SAPERION Server ist nicht erreichbar.",
						hideTrigger: false,
						forceSelection: false,
				        typeAhead: true, 
				        url: "./saperion?proxy=script",
						allowBlank: true,
						width: 280,
						disabled: enableStaticValue,
						value: br,
						afterRender: function(){
							Ext.ux.form.ComboBox.prototype.afterRender.apply(this, arguments);
							this.wrap.setStyle("margin-left", "20px");
						}
				    })
				]
			});
			
			return this.panel;
		},
		
		/**
		 * Returns the value of the selected time delay
		 * 
		 */
		extractValue: function(){
			if (this.panel.items.get(0).getValue()){
				// DDHHMM
				return  this.getStringValueOf(this.days.getValue()) +
						this.getStringValueOf(this.hours.getValue()) +
						this.getStringValueOf(this.minutes.getValue());
			} else {
				// Dynamic business rule
				return this.panel.items.get(3).getValue();
			}
		},
		
		/**
		 * Returns a two diggit string of the number with a leading zero
		 * @param {Number} number
		 */
		getStringValueOf: function(number){
			number = String(number) || "00";
			return number.length == 1 ? "0" + number : number;
		}
		
	});	
	
}()
/**
 *  (c) 2011 Signavio GmbH
 *
 *  @author Philipp Giese
 *
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {

    /**
     * Id of the attribute, that is used to indicate, that no selection has
     * been made.
     */
    var NO_SELECTION = "__no_selection__";
    /**
     * Id of the element, that is inserted as a group header for property
     * categories
     */
    var GROUP_SPACER = "__group_header__";

    /**
     * Name of the category, that should be expanded by default
     */
    var EXPAND_GROUP = Ext.ux.getI18N("attribute.mapper.config.meta_properties");

    var NAMESPACE = "http://www.signavio.com/stencilsets/processdoctemplate#";

    /**
     * List of stencilsets, that must NOT show up in the list.
     */
    var BLACKLIST = [
        "http://www.signavio.com/stencilsets/processdoctemplate#"
    ];

    var CACHE = {
        StencilsetPreview: [],
        StencilsetIcons: {},
        Stencilsets: {},
        MetaAttributes: undefined
    };

    var Record = Ext.data.Record.create([
        { name: "checked", mapping: "checked" },
        { name: "icon", mapping: "icon" },
        { name: "id", mapping: "id" },
        { name: "title", mapping: "title" },
        { name: "group", mapping: "group" },
        { name: "root", mapping: "root" },
        { name: "stencilset", mapping: "stencilset" },
        { name: "stencil", mapping: "stencil" },
        { name: "readonly", mapping: "readonly" },
        { name: "meta", mapping: "meta" },
        { name: "list", mapping: "list" },
        { name: "position", mapping: "position" },
        { name: "roles", mapping: "roles" },
        { name: "propertyGroup", mapping: "propertyGroup" },
        { name: "collapsed", mapping: "collapsed" },
        { name: "stencilsetIcon", mapping: "stencilsetIcon" }
    ]);

    var EVENTS = {
        PANEL_EXPANDED: "attribute.mapper.panel.expanded",
        STENCILSETS_LOADED: "attribute.mapper.stencilsets.loaded",
        STENCILSET_LOADED: "attribute.mapper.stencilset.loaded"
    };

    Signavio.Config.registerEvents("AttributeMapper", {
        StencilsetsLoaded: EVENTS.STENCILSETS_LOADED,
        PanelExpanded: EVENTS.PANEL_EXPANDED,
        StencilsetLoaded: EVENTS.STENCILSET_LOADED
    });

    /**
     * This is a generic editor, that is used to map certain attributes
     * to elements in the process documentation templates. It can be used to:
     *
     *  - Select stencil sets
     *  - Select elements
     *  - Select properties of elements
     *
     * The following configuration options can be set in the stencilset
     * definition:
     *
     *  - hideRootElements: Root elements (e.g. BPMNDiagram) won't be shown
     *  - rootElementsOnly: Only root elements will be visible
     *  - singleSelection: Radio buttons are used instead of checkboxes
     *  - positiveLogic: If true, the selected items will be stored, if false, the
     *                   deselected ones are stored
     *  - stencilsetsOnly: Only stencilsets are shown
     *  - stencilsOnly: Only stencils are shown (but also grouped after stencilset)
     */
    Ext.ux.propertyeditor.AttributeMapper = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {

        windowCreate: {
            height: 600,
            width: 630,
            minWidth: 630,
            minHeight: 600,
            resizable: true,
            cls: "y-attribute-mapper",
            bodyStyle: "background-color: #FFFFFF"
        },

        renderer: function(value) {
            var config = this.getConfig();
            var valueConf = this.evalConfig(value);
            value = this.evalValue(value);

            // filling in default values for manager options
            valueConf = Ext.apply(config.managerConf || {}, valueConf);

            if(config.positiveLogic === false) {
                if(valueConf.allElements) {
                    return Ext.ux.getI18N("attribute.mapper.config.all_elements");
                }

                if(valueConf.flowElements) {
                    return Ext.ux.getI18N("attribute.mapper.config.flow_elements");
                }

                if(valueConf.activities) {
                    return Ext.ux.getI18N("attribute.mapper.config.activities");
                }

                // As you can't tell, how many attributes are selected,
                // because you only know, how many are not selected,
                // a more generic value is shown.
                if(value.length > 0) {
                    return Ext.ux.getI18N('attribute.mapper.exclusion_active');
                }

                return Ext.ux.getI18N('attribute.mapper.excluion_inactive');
            }

            if(valueConf.selectName) {
                return Ext.ux.getI18N('attribute.mapper.config.name');
            }

            if(valueConf.selectDescription) {
                return Ext.ux.getI18N('attribute.mapper.config.description');
            }

            if(valueConf.allAttributes) {
                return Ext.ux.getI18N('attribute.mapper.config.all_attributes');
            }

            if(valueConf.ownAttributes) {
                return Ext.ux.getI18N('attribute.mapper.config.own_attributes');
            }

            var tpl = new Template(Ext.ux.getI18N("attribute.mapper.attributes_selected"));

            return tpl.evaluate({
                count: value.map(function(item) {
                    return item.title;
                }).uniq().length
            });
        },

        parseJSONObject: function(json, key) {
            try {
                return (json || "{}").evalJSON(true)[key];
            } catch(e) {
                // ignore that
                return null;
            }
        },

        /**
         * Parses the current value for an options part, that is used
         * if this panel is going to be a managed one.
         *
         * @param value current editor value
         * @returns {Object}
         */
        evalOptions: function(value) {
            return this.parseJSONObject(value, "options") || {};
        },

        /**
         * Parses the current value for a config part, that is used
         * if this panel is going to be managed one.
         *
         * @param value current editor value
         * @returns {Object}
         */
        evalConfig: function(value) {
            return this.parseJSONObject(value, "config") || {};
        },

        /**
         * Evaluates the string in value to a JSON Object and returns the
         * array under 'items'. If an error occurs, an empty array will
         * be returned.
         *
         * @param value String value
         * @returns Array of items.
         */
        evalValue: function(value) {
            return this.parseJSONObject(value, "items") || [];
        },

        /**
         * Returns the stencilset configuration for this editor
         * @returns
         */
        getConfig: function() {
            return this.property.config();
        },

        getSelection: function() {
            if(this.facade.getSelection) {
                return this.facade.getSelection();
            }

            return [];
        },

        /**
         * If the shape this property is defined on is a child of any shape
         * that can put restrictions on its children, this parent will be found
         * and the restrictions will be read.
         *
         * @returns {Object}
         */
        getRestrictions: function() {
            if(!this.restrictions) {
                var selection = this.getSelection();
                var shape = selection.first();
                var restrictions = {};
                var elementRestrictions = {
                    stencilsets: [],
                    stencils: [],
                    attributes: [],
                    managers: []
                };
                var stencilsetRestrictions = {
                    stencilsets: [],
                    stencils: [],
                    attributes: [],
                    managers: []
                };

                if(this.isRestrictedShape(shape)) {
                    var parent = shape.parent;
                    var parents = [];

                    while(parent) {
                        if(this.isRestrictiveShape(parent)) {
                            parents.push(parent);
                        }

                        parent = parent.parent;
                    }

                    if(parents.size() > 0) {
                        parents.each(function(p) {
                            this.createRestrictions(elementRestrictions, p, "Elements");
                            this.createRestrictions(stencilsetRestrictions, p, "Stencilsets");
                        }.bind(this));
                    }
                }

                restrictions.stencilsets = stencilsetRestrictions;
                restrictions.elements = elementRestrictions;

                this.restrictions = restrictions;
            }

            return this.restrictions;
        },

        /**
         * This method will fill the container parameter with restriction content.
         * If the {element} has the property {property}, restrictions are being set up.
         *
         * @param container Object, that will be filled with restrictions
         * @param element            Element to parse restrictions from
         * @param {String} property  Property, that should be read from the element
         */
        createRestrictions: function(container, element, property) {
            property = (property || "").toLowerCase();
            var positiveLogic = true;

            if(element.hasProperty(property)) {
                positiveLogic = element.getStencil().property("oryx-" + property).config().positiveLogic !== false;

                // fetch actual JSON property
                property = (element.getProperty(property) || "{}").evalJSON(true);

                (property.items || []).each(function(restriction) {
                    container.stencilsets.push(restriction.stencilset);
                    container.stencils.push(restriction.stencil ? restriction.stencilset + restriction.stencil : undefined);
                    container.attributes.push(restriction.id);
                    container.positiveLogic = positiveLogic;
                });

                container.managers.push(property.manager);

                container.stencilsets = container.stencilsets.compact().uniq();
                container.stencils = container.stencils.compact().uniq();
                container.attributes = container.attributes.compact().uniq();
                container.managers.compact().uniq();

                container.config = Ext.apply(container.config || {}, property.config);
            }
        },

        /**
         * Indicates whether a shape can be restricted by another one.
         *
         * @param shape
         * @returns {true} if restriction could be set, {false} otherwise.
         */
        isRestrictedShape: (function() {
            var shapes = [NAMESPACE + "TableElementsAttribute",
                          NAMESPACE + "ListElementsAttribute",
                          NAMESPACE + "TableElementsAttributeMulti",
                          NAMESPACE + "ListElementsAttributeMulti",
                          NAMESPACE + "TableElements",
                          NAMESPACE + "ListElements",
                          NAMESPACE + "DiagramAttribute",
                          NAMESPACE + "DiagramAttributeMulti"];

            return function(shape) {
                if(!shape) {
                    return false;
                }

                var id = shape.getStencil().id();

                return shapes.include(id);
            };
        }()),

        /**
         * Indicates whether a shape is able to put restrictions onto another one.
         *
         * @param shape
         * @returns {true} if the shape can restrict other shapes, {false} otherwise
         */
        isRestrictiveShape: (function() {
            var shapes = [NAMESPACE + "TableElements",
                          NAMESPACE + "ListElements",
                          NAMESPACE + "SectionPerDiagram",
                          NAMESPACE + "SectionPerDirectory"];

            return function(shape) {
                var id = shape.getStencil().id();

                return shapes.include(id);
            };
        }()),

        getEditor: function(currentValue) {
            this.oldItems = this.evalValue(currentValue);
            this.oldConfig = this.evalConfig(currentValue);

            var config = this.getConfig();
            var panel = this.getPanel();

            panel.getValue = this.getEditorValue.bind(panel, this);

            if(config.manager) {
                this.oldConfig = Ext.apply(config.managerConf || {}, this.oldConfig);

                panel = this.registerManager(config.manager, panel, this.oldConfig, this.evalOptions(currentValue));
            }

            if(panel) {
                panel.on("render", this.handleRender.bind(this));
            }

            this.positiveLogic = config.positiveLogic !== false;

            return panel;
        },

        registerManager: function(manager, panel, conf, options) {
            var base = Ext.ux.propertyeditor;

            if(base[manager]) {
                this.isManaged = true;

                var config = this.getConfig();

                panel = new base[manager]({
                    panel: panel,
                    buttonConf: conf || {},
                    options: options || {},
                    config: config.managerConfig || {}
                });

                this.manager = panel;

                return panel;
            }

            return null;
        },

        // scope Panel
        getEditorValue: function(self) {
            var value = [];

            if(this.items.length > 1) {
                // skip empty first panel (dummy)
                var start = 1;
                var end = this.items.indexOf(this.items.last());
                this.items.getRange(start, end).each(function(item) {
                    value = value.concat(item.getValue());
                });
            }

            return $H({
                items: value.concat(self.oldItems || []),
                exclude: !self.positiveLogic
            }).toJSON();
        },

        /**
         * After the initial editor window has been rendered, the available
         * stencilsets are being loaded and the first in the list is expanded,
         * to show its contents.
         *
         * @param panel Then panel, that was rendered.
         */
        handleRender: function(panel) {
            window.setTimeout(function() {
                var title = Ext.ux.getI18N("attribute.mapper.loading") +
                    " " +
                    Ext.ux.getI18N("attribute.mapper.stencilsets");

                panel.getEl().mask(title, "disabled");

                var config = this.getConfig();

                if(config.stencilsetsOnly) {
                    this.getStencilsets(function(stencilsets) {
                        var grid = this.getGrid();
                        var records = [];

                        stencilsets.each(function(stencilset) {
                            records.push(new Record({
                                checked: this.isActive(stencilset.namespace),
                                title: this.getTitle(stencilset),
                                stencilset: stencilset.namespace,
                                icon: stencilset.icon
                            }));
                        }.bind(this));

                        grid.getStore().add(records);

                        var p = new Ext.Panel({
                            title: Ext.ux.getI18N('attribute.mapper.stencilsets').capitalize(),
                            header: true,
                            items: [this.getSelectionHelpers(grid), grid],
                            collapsible: true,
                            collapsed: false,
                            layout: "anchor",
                            cls: "y-custom-groups",
                            border: false
                        });

                        p.getGrid = function() {
                            return grid;
                        };

                        p.getValue = this.getPanelValue.bind(this, p);
                        p.getContainer = this.createGetContainer(panel);

                        panel.add(p);
                        panel.doLayout();

                        p.expanded = true;
                        this.styleExpanded($(p.getEl().first(".x-panel-header", true)));
                        this.stylePanel(p);

                        panel.getEl().unmask();
                    }.bind(this));
                } else {
                    this.getStencilsets(function(stencilsets) {
                        var panels = this.createPanels(stencilsets);
                        var that = this;

                        // a panel is hot wired, if a shortcut is currently active
                        // thus no panel will be expanded, BUT all options have to be
                        // applied to the panel, when it is expanded for the first time.
                        // The touched attribute normally prevents options to be applied
                        // in order to ensure, that old selections are not overridden.
                        // We set the touchy attribute to the hot wired status in order to
                        // apply options only if the panel has been loaded in a hot wired mode.
                        var touchy = panel.hotWired();

                        panels.each(function(p) {
                            p.getContainer = that.createGetContainer(panel);
                            p.touched = touchy;
                        });

                        var p = panels.first();

                        if(p) {
                            p.on("render", function() {
                                panel.getEl().unmask();

                                if(!panel.hotWired()) {
                                    window.setTimeout(function() {
                                        p.expand(true);
                                        p.expanded = true;

                                        that.styleExpanded($(p.getEl().first(".x-panel-header", true)));
                                    }, 0);
                                }

                                that.stylePanel(p);
                            });

                            panel.add(p);

                            panels.slice(1).each(function(item){
                                item.on("render", that.stylePanel.bind(that));

                                panel.add(item);
                            });
                        } else {
                            panel.getEl().unmask();
                        }

                        panel.doLayout();
                    }.bind(this));
                }

                var container = this.createGetContainer(panel)();
                container.getScroll = function() {
                    return container.el.dom.firstChild.firstChild.scrollTop;
                };

                container.setScroll = function(scroll) {
                    container.el.dom.firstChild.firstChild.scrollTop = scroll;
                };

            }.bind(this), 0);
        },

        createGetContainer: function(panel) {
            if(this.isManaged) {
                return function() {
                    return panel.getManagedPanel();
                };
            }

            return function() {
                return panel;
            };
        },

        stylePanel: function(panel) {
            this.makeClickable(panel);
            this.removeExpander(panel);
        },

        removeExpander: function(panel) {
            panel.getEl().select(".x-tool-toggle").each(function(el) {
                el.hide();
            });
        },

        styleCollapsed: function(header) {
            header.setStyle({ backgroundPosition: "10px 5px" });
        },

        styleExpanded: function(header) {
            header.setStyle({ backgroundPosition: "10px -45px" });
        },

        /**
         * Enables the user to click anywhere on the panel to expand it, and
         * not only on the (now hidden) expander button.
         *
         * @param panel
         */
        makeClickable: function(panel) {
            var el = panel.getEl();
            var header = el.first(".x-panel-header");

            header.on("click", function() {
                var head = $(header.dom);

                if(panel.expanded) {
                    panel.collapse(true);
                    panel.expanded = false;

                    this.styleCollapsed(head);
                } else {
                    panel.expand(true);
                    panel.expanded = true;

                    this.styleExpanded(head);
                }
            }.bind(this));
        },

        /**
         * If a panel is expanded the stencilset belonging to it is loaded
         * from the server and the contained attributes/ stencils are shown.
         *
         * @param grid          The grid, that will keep the data
         * @param stencilset    Stencilset information
         * @param panel         Panel, that was expanded
         */
        handleGroupExpand: function(grid, stencilset, panel) {
            var title = Ext.ux.getI18N("attribute.mapper.loading") + " " + this.getTitle(stencilset);

            panel.scrollPosition = panel.getContainer().getScroll();
            panel.ownerCt.getEl().mask(title, "disabled");
            //panel.setTitle(panel.initialTitle);

            if(Ext.isOpera) {
                // as settings the title will already falsify the scroll position
                // in opera we update the scroll here once in order to avoid
                // flickering in the ui.
                panel.updateScroll();
            }

            var that = this;

            // to show the mask immediately the following actions are appended at the
            // end of the executino chain
            Signavio.Utils.defer(function() {
                if(grid.getStore().getCount() === 0) {
                    that.loadStencilData(grid.getStore(), stencilset.uri);
                    grid.getStore().sort("title");
                }
            });
        },

        /**
         * After a panel was expanded the first group of the contained grid
         * should be expanded (if there is a grouping view).
         *
         * @param grid
         * @param panel
         */
        handleAfterExpand: function(grid, panel) {
            if(grid.getStore().getCount() > 0 && !panel.alreadyExpanded) {
                var value = grid.getStore().getAt(0).get("group");
                var id = grid.getView().getGroupId(value);

                grid.getView().toggleGroup(id);

                panel.layoutPropertyCategories(grid);

                if(grid.extended) {
                    // the touched variable prevents the options to be applied
                    // when the editor is loaded for the first time and settings
                    // are about to be restored
                    if(panel.touched) {
                        $H(panel.options || {}).keys().each(function(key) {
                            grid[key].apply(this, panel.options[key]);
                        });
                    } else {
                        panel.touched = true;
                    }
                }

                panel.alreadyExpanded = true;
            }

            panel.adjustHeight(grid);
            panel.updateScroll();

            this.facade.raiseEvent(EVENTS.PANEL_EXPANDED, panel, grid);

            panel.ownerCt.getEl().unmask();
        },

        getExpanderButton: function(groupHeader) {
            // please lord forgive me...
            return groupHeader.firstChild.firstChild.firstChild.firstChild.firstChild.firstChild;
        },

        layoutElement: function(record, el) {
            var className = el.className;

            if(record.get("id") === GROUP_SPACER) {
                var padding = 10; // padding defined in y-attribute-inset
                var expanderButton = this.getExpanderButton(el);

                this.updateExpanderButton(expanderButton, record.get("collapsed"));

                var extEl = Ext.get(el);

                extEl.setWidth(extEl.getWidth() + padding);
            } else {
                if(record.get("collapsed") && !className.include("y-mapper-element-hidden")) {
                    className += " y-mapper-element-hidden";
                }
            }

            if(record.get("id") !== GROUP_SPACER && record.get("id") !== NO_SELECTION) {
                if(!className.include("y-attribute-inset")) {
                    className += " y-attribute-inset";
                }
            }

            if(className !== el.className) {
                el.className = className;
            }
        },

        showPropertyCategories: function() {
            var config = this.getConfig();

            return !config.stencilsetsOnly && !config.stencilsOnly;
        },

        layoutPropertyCategories: function(grid) {
            var that = this;

            if(this.showPropertyCategories()) {
                grid.doSuspended(function() {
                    var rows = grid.getView().getRows();
                    var gridBody = grid.getEl().dom.firstChild;
                    var gridDom = grid.getEl().dom;

                    gridDom.removeChild(gridBody);

                    rows.each(function(el, index) {
                        var record = grid.getStore().getAt(index);

                        if(record.get("propertyGroup") === EXPAND_GROUP) {
                            record.set("collapsed", false);
                        }

                        that.layoutElement(record, el);
                    }, true);

                    gridDom.appendChild(gridBody);
                });
            }
        },

        /**
         * Gathers data from a stencilset and loads it into the store.
         *
         * @param store     Store for the data
         * @param uri       URI of the stencilset
         * @param title     Title of the stencilset
         */
        loadStencilData: function(store, uri) {
            var loadData = function(json) {
                var records = this.createRecordsFromStencilSet(json, uri);

                store.add(records);

                var overflow = this.oldItems.select(function(item) {
                    return item.stencilset === json.namespace;
                });

                if(overflow.length > 0) {
                    // TODO: Inform about missing properties and also remove them from the oldItems list
                }
            }.bind(this);

            if(CACHE.Stencilsets[uri]) {
                loadData(CACHE.Stencilsets[uri]);

                return;
            }

            Signavio.Utils.Request.execute("/stencilsets" + uri, {
                async: true,
                success:function(json) {
                	// this event allows us to modify the content of
                	// the loaded stencilset before it is used
                	// this is necessary if the configured currency has
                	// to be injected into the property titles
                	// the first raiseEvent works with the Editor's mechanism
                	this.facade.raiseEvent({
                        type: EVENTS.STENCILSET_LOADED, 
                        arg: json
                    });
                	// the second raiseEvent has the right parameters for the Explorer's version
                    this.facade.raiseEvent(EVENTS.STENCILSET_LOADED, {
                        arg: json, 
                        callImmediatly: true
                    });
                    
                	loadData(json);

                    CACHE.Stencilsets[uri] = json;
                }.bind(this)
            });
        },

        /**
         * Checks whether a stencilset group is empty
         *
         * @param items
         * @returns {Boolean}
         */
        isEmpty: function(items) {
            return items.getCount() === 1 && !items.first().get("element").title;
        },

        /**
         * Creates the editor panel and adds a first dummy child
         * element to it. This is needed in order for Ext to get the
         * layouting right.
         *
         * @returns {Ext.Panel}
         */
        getPanel: function() {
            return new Ext.Panel({
                anchor: "100% 100%",
                border: false,
                layout: "anchor",
                autoScroll: true,
                cls: "y-content-wrap",
                hotWired: function() {
                    return this.isHotWired;
                },
                items: [this.getDummyPanel()]
            });
        },

        /**
         * Creates the grid, used by the panels to present the data.
         * This method also extends the regular grid with some utility
         * functions, that should ease development
         *
         * @returns {Ext.grid.EditorGridPanel}
         */
        getGrid: function() {
            var view = this.getView();
            var grid = new Ext.grid.GridPanel({
                store: this.getStore(),
                cm: this.getColumnModel(),
                view: view,
                border: false,
                trackMouseOver: false,
                hideHeaders: true,
                cls: "y-grouped-grid",
                stripeRows: true
            });

            if(this.showPropertyCategories()) {
                var that = this;

                view.on("refresh", function() {
                    var rows = grid.getView().getRows();

                    var gridDom = grid.getEl().dom;
                    var gridBody = gridDom.firstChild;

                    grid.scrollPosition = grid.getPanel().getContainer().getScroll();

                    gridDom.removeChild(gridBody);

                    rows.each(function(row, index) {
                        var record = grid.getStore().getAt(index);

                        if(record && row) {
                            that.layoutElement(record,row);
                        }
                    });

                    gridDom.appendChild(gridBody);
                    grid.updateScroll();
                });
            }

            grid.on("rowmousedown", this.handleRowMouseDown.bind(this));

            grid.getNoSelectionID = function() {
                return NO_SELECTION;
            };

            grid.updateScroll = function() {
                grid.getPanel().getContainer().setScroll(grid.scrollPosition || 0);
            };

            // Shortcut, that will retrieve the Ext Element of
            // the group with the provided name
            grid.getGroup = function(name) {
                var id = grid.getView().getGroupId(name);

                return Ext.get(id);
            };

            grid.isGroupCollapsed = function(group) {
                if(!(group instanceof Ext.Element)) {
                    group = grid.getGroup(group);
                }

                return !grid.getView().state[group.dom.id];
            };

            grid.groupIndex = function(group) {
                if(!(group instanceof Ext.Element)) {
                    group = grid.getGroup(group);
                }

                return $A(grid.getView().getGroups()).indexOf(group.dom);
            };

            // This function will perform actions while events on
            // the store are suspended. Thus manipulations on the data
            // won't result in update events. After these actions are
            // done, firing events is resumed and the datachanged Event
            // is fired once, to tell all containers to refresh their
            // views.
            grid.doSuspended = function(fn, blockUpdate) {
                fn = fn instanceof Function ? fn : Ext.emptyFn;

                var store = grid.getStore();

                if(!store.eventsSuspended) {
                    store.suspendEvents();

                    fn();   // do stuff

                    store.commitChanges(true);
                    store.resumeEvents();

                    if(!blockUpdate) {
                        store.fireEvent("datachanged");
                    }
                } else {
                    // if events are already suspended, just execute the function
                    fn();
                }
            };

            return grid;
        },

        /**
         * Creates the sorting function for the grids.
         * Sorting is done the following way:
         *
         * <ul>
         *  <li>Root elements go first (e.g. BPMN Diagrams)</li>
         *  <li>Groups should be sorted alphabetically</li>
         *  <li>The "no selection" items should go first in every list</li>
         *  <li>The list items are sorted alphabetically</li>
         * </ul>
         * @returns {Function}
         */
        getSortingFunction: function() {
            return function(f, direction) {
                if(f === "title") {
                    direction = direction || "ASC";

                    var st = this.fields.get(f).sortType;
                    var fn = function(r1, r2) {
//                        Ordering like in shape menu -> take ordering from stencilset file
//                        var t1 = r1.get(f);
//                        var t2 = r2.get(f);

                        var g1 = st(r1.get("position"));
                        var g2 = st(r2.get("position"));

                        var root1 = st(r1.get("root"));
                        var root2 = st(r2.get("root"));

                        var id1 = st(r1.get("id"));
                        var id2 = st(r2.get("id"));

                        var down = 1;
                        var up = -1;

                        return root1 && !root2 ? down :                 // Root elements on top
                               root2 && !root1 ? up :
                                   g1 < g2 ? down :                     // Sort groups and group values
                                   g1 > g2 ? up :
                                        id1 === NO_SELECTION ? down :   // No selection button should always
                                        id2 === NO_SELECTION ? up :     // be on top
                                           // t1 < t2 ? down :
                                           // t1 > t2 ? up :            // Then sort items in groups
                                                0;
                    };

                    this.data.sort(direction, fn);

                    if(this.snapshot && this.snapshot !== this.data) {
                        this.snapshot.sort(direction, fn);
                    }
                }
            };
        },

        /**
         * Creates a view, that is used by a grid in order to present its data.
         *
         * @returns {Ext.grid.GridView}
         */
        getView: function() {
            var config = this.getConfig();
            var view, tpl;

            var viewConfig = $H({
                emptyText: "<i>" + Ext.ux.getI18N("attribute.mapper.no_attributes") + "</i>"
            });

            if(config.stencilsetsOnly) {
                return new Ext.grid.GridView(viewConfig);
            }

            if(config.rootElementsOnly) {
                tpl = "<span class='y-mapper-title y-title-image' style='background-image:url({[values.rs.first().data.stencilsetIcon]}); padding-top: 0px'>" +
                        "{[values.rs.first().data.group]}" +
                        " " +
                        (config.singleSelection ? "" : "{[Ext.ux.propertyeditor.AttributeMapper.getGroupInfo(values)]}") +
                      "</span>";
            } else {
                if(config.stencilsOnly) {
                    tpl = "<span class='y-mapper-title'>" +
                            "{[values.rs.first().data.group]}" +
                            " " +
                            "{[Ext.ux.propertyeditor.AttributeMapper.getGroupInfo(values)]}" +
                          "</span>";
                } else {
                    if(config.singleSelection) {
                        tpl = "<span class='y-mapper-title y-title-image' style='background-image:url({[values.rs.first().data.icon]}); padding-top: 0px'>" +
                                "{[values.rs.first().data.group]}" +
                              "</span>";
                    } else {
                        tpl = "<span class='y-mapper-title y-title-image' style='background-image:url({[values.rs.first().data.icon]}); padding-top: 0px'>" +
                                "{[values.rs.first().data.group]}" +
                                " " +
                                "{[Ext.ux.propertyeditor.AttributeMapper.getGroupInfo(values)]}" +
                              "</span>";
                    }
                }
            }

            viewConfig = viewConfig.merge({
                startCollapsed: true,
                groupTextTpl: tpl
            });

            if(viewConfig.toObject) {
                viewConfig = viewConfig.toObject();
            }

            return new Ext.grid.GroupingView(viewConfig);
        },

        /**
         * Creates the ColumnModel, that will be used by the grids.
         *
         * @returns {Ext.grid.ColumnModel}
         */
        getColumnModel: function() {
            var config = this.getConfig();

            return new Ext.grid.ColumnModel([
                {
                    menuDisabled: true,
                    hideable: false,
                    sortable: false,
                    dataIndex: 'checked',
                    readonly: true,
                    width: 25,
                    fixed: true,
                    renderer: function(checked, meta, record) {
                        var type = "checkbox";
                        var group = "y-attribute-group-" + record.get("stencilset") + record.get("stencil");
                        var disabled = record.get("readonly") ? "disabled='disabled'" : "";
                        checked = checked ? "checked='checked'" : "";

                        if(config.singleSelection) {
                            type = "radio";
                        }

                        if(record.get("id") === GROUP_SPACER) {
                            return "<span class='y-attribute-expander y-attribute-mapper-group-expanded" +
                                    (record.get("collapsed") ? " y-attribute-mapper-group-collapsed" : "") +
                                    "'></span>";
                        }

                        return "<input type='" + type + "' "
                                + "name='" + group + "' "
                                + "class='y-mapper-switch' "
                                + checked + " "
                                + disabled + " />";
                    }
                },
                {
                    menuDisabled: true,
                    hideable: false,
                    sortable: false,
                    dataIndex: "title",
                    readonly: true,
                    fixed: true,
                    width: 500,
                    renderer: function(title, meta, record) {
                        if(record.get("id") === GROUP_SPACER) {
                            return "<span class='y-attribute-mapper-group-spacer'>" + record.get("title") + "</span>";
                        }

                        if(config.stencilsOnly || config.stencilsetsOnly) {
                            title = "<span style='background-image:url(" + record.get("icon") + ")' class='y-mapper-title y-title-image'>" + title + "</span>";
                        }

                        if(record.get("list")) {
                            title = title + " <span class='y-mapper-tip'>(" + Ext.ux.getI18N('attribute.mapper.list') + ")</span>";
                        }

                        return title;
                    }
                },
                {
                    hidden: true,
                    dataIndex: 'group'
                }
            ]);
        },

        /**
         * Creates a store, that will be used by the grids.
         *
         * @returns {Ext.data.GroupingStore}
         */
        getStore: function() {
            var store = new Ext.data.GroupingStore({
                reader: this.getReader(),
                fields: this.getFields(),
                data: [],
                groupField: "group",
                sortInfo: {
                    field: "title",
                    direction: "ASC"
                }
            });

            /**
             * @Override
             *
             * Custom sorting function for the store, so that root elements
             * are sorted to the top, then items are grouped and in these
             * groups regular sorting is applied.
             */
            store.sortData = this.getSortingFunction();
            /**
             * @Override
             *
             * Custom afterEdit function, that does not fire
             * the update event, if suspendEvents() has been
             * called beforehand on the store.
             *
             * @param {Object} record
             */
            store.afterEdit = function(record){
                if(this.modified.indexOf(record) === -1){
                    this.modified.push(record);
                }

                if(!this.eventsSuspended) {
                    this.fireEvent("update", this, record, Ext.data.Record.EDIT);
                }
            };
            /**
             * @Override
             *
             * Custom commit changes function, that commits records
             * silently to prevent the update event to be fired.
             *
             * To update views, that are using the store, fire the
             * 'datachanged' event.
             */
            store.commitChanges = function(silent){
                var m = this.modified.slice(0), i, len;
                this.modified = [];
                for(i = 0, len = m.length; i < len; i = i + 1){
                    m[i].commit(silent === true);
                }
            };

            return store;
        },

        /**
         * This function can be used to define a "default" stencilset.
         * This stencilset will appear as the first item in the list
         * of stencilset. It is identified by its namespace.
         *
         * @returns {String}
         */
        getDefaultStencilSet: function() {
            return "http://b3mn.org/stencilset/bpmn2.0#";
        },

        /**
         * Whenever the collapsed panels were created there was a layouting error
         * when one was expanded. Ext could not manage to resize the first Panel to
         * a width, so that no vertical scrollbar was shown.
         *
         * This is why an empty Panel has to be inserted as the first element in order
         * to avoid this behaviour.
         */
        getDummyPanel: function() {
            return new Ext.Panel({
                border: false,
                collapsed: true,
                collapsible: true,
                width: 200
            });
        },

        /**
         * This method will create a panel for each stencilset. The panels
         * are set up to be extendable and will handle the actions needed in
         * order to present their corresponding data correctly themselves.
         *
         * @param stencilsets List of stencilsets availlable.
         *
         * @returns {Array}
         */
        createPanels: function(stencilsets) {
            var panels = [];

            stencilsets.each(function(stencilset) {
                var grid = this.getGrid();
                var config = this.getConfig();

                grid.getView().on("refresh", function() {
                    if(!config.singleSelection) {
                        this.addSelectionHelpersToGroups(grid);
                    }
                }.bind(this));

                var selectionHelpers = this.getSelectionHelpers(grid);

                var panel = new Ext.Panel({
                    title: this.getTitle(stencilset),
                    initialTitle: this.getTitle(stencilset),
                    collapsible: true,
                    collapsed: true,
                    items: [selectionHelpers, grid],
                    cls: "y-custom-groups",
                    border: false,
                    listeners: {
                        beforeexpand: this.handleGroupExpand.bind(this, grid, stencilset),
                        expand: this.handleAfterExpand.bind(this, grid),
                        collapse: this.handleCollapse.bind(this, stencilset)
                    }
                });

                var that = this;

                // to get the layout correctly, we need to
                // recalculate the height of the grid panel after
                // a group is expanded.
                // As Ext lacks an event for that, we just extend the original
                // a little bit.
                grid.getView().toggleGroup = function(id) {
                    grid.scrollPosition = panel.getContainer().getScroll();

                    Ext.grid.GroupingView.prototype.toggleGroup.apply(grid.getView(), arguments);

                    var group = Ext.get(id);
                    var index = grid.groupIndex(group);
                    var expanded = !grid.isGroupCollapsed(group);
                    var selectionHelpers = (grid.groupHelpers || [])[index];
                    var head = group.child(".x-grid-group-hd");

                    if(selectionHelpers) {
                        if(expanded) {
                            selectionHelpers.show();
                            head.addClass("y-selection-helpers-hide-border");
                        } else {
                            selectionHelpers.hide();
                            head.removeClass("y-selection-helpers-hide-border");
                        }
                    }

                    that.adjustGridHeight(grid);
                };

                grid.getPanel = function() {
                    return panel;
                };

                if(this.isManaged) {
                    panel.options = panel.options || this.manager.getOptions() || {};
                }

                panel.getValue = this.getPanelValue.bind(this, panel);
                panel.getGrid = function() {
                    return grid;
                };

                panel.getSelectionHelpers = function() {
                    return {
                        selectionHelpers: selectionHelpers,
                        addToGroups: this.addSelectionHelpersToGroups.bind(this)
                    };
                }.bind(this);

                panel.updateScroll = function() {
                    panel.getContainer().setScroll(panel.scrollPosition || 0);
                };

                panel.adjustHeight = this.adjustGridHeight.bind(this);
                panel.layoutPropertyCategories = this.layoutPropertyCategories.bind(this);

                panels.push(panel);
            }.bind(this));

            return panels;
        },

        adjustGridHeight: function(grid) {
            var gridBody = Ext.get(grid.getGridEl().child(".x-grid3-body", true));
            var padding = 40; // just for safety reasons

            grid.setHeight(gridBody.getHeight() + padding);
            grid.updateScroll();
        },

        /**
         * Creates the buttons for the selection helpers. If {all} is set to true,
         * this method will create the "Select all" button, otherwise an "Select None"
         * button is created.
         *
         * @param grid  The grid, these buttons should operate on
         * @param all   Indicator, whether an "Select All" or "Select None" button should be created
         * @returns {Ext.Panel}
         */
        getSelectionButton: function(grid, all, checkFn) {
            var checkbox = "<input type='checkbox' " + (all ? "checked='checked'" : "") + " readonly='readonly' />";
            checkFn = checkFn instanceof Function ? checkFn : Ext.emptyFn;

            var enabled = true;

            var button = new Ext.Panel({
                border: false,
                cls: "y-attribute-mapper-helper-button",
                items: [
                    new Ext.Button({
                        text: all ? Ext.ux.getI18N('glossary.mapper.select_all') : Ext.ux.getI18N('glossary.mapper.select_none'),
                        handler: function() {
                            if(grid.readonly) {
                                return;
                            }

                            grid.doSuspended(function() {
                                var store = grid.getStore();

                                store.each(function(record) {
                                    if(checkFn(record) !== false) {
                                        record.set("checked", all);
                                    }
                                });
                            });

                            if(all) {
                                var record = grid.getStore().getAt(0);
                                var stencilset = record.get("stencilset");

                                this.oldItems = this.oldItems.select(function(value) {
                                    if(value.stencilset === stencilset) {
                                        return false;
                                    }

                                    return true;
                                });
                            }
                        }.bind(this),
                        template: new Ext.Template("<span>" + checkbox + " <a href='#'>{0}</a></span>"),
                        onRender: function() {
                            this.el = Ext.get(this.template.overwrite(this.container.dom, [this.text]));
                            this.el.on("click", function(e){
                                if(enabled) {
                                    this.handler.apply(this, arguments);
                                }

                                e.stopEvent();
                                return false;
                            }.bind(this));
                        }
                    })
                ]
            });

            button.disable = function() {
                enabled = false;

                button.getEl().setStyle({
                    opacity: 0.5
                });
            };

            button.enable = function() {
                enabled = true;

                button.getEl().setStyle({
                    opacity: 1
                });
            };

            return button;
        },

        /**
         * Selection helpers are two buttons, that enable the user
         * to either select all contents of a grid or nothing.
         *
         * @param grid The grid, to operate on.
         * @returns
         */
        getSelectionHelpers: function(grid) {
            var config = this.getConfig();

            if(config.singleSelection || config.rootElementsOnly) {
                return this.getDummyPanel();
            }

            var selectFn = function(record) {
                return record.get("id") !== GROUP_SPACER;
            };

            var selectAll = this.getSelectionButton(grid, true, selectFn);
            var selectNone = this.getSelectionButton(grid, false, selectFn);

            var helpers = new Ext.Panel({
                items: [selectAll, selectNone],
                collapsible: false,
                anchor: "-75",
                border: false,
                layout: "column",
                cls: "y-selection-helpers"
            });

            helpers.disable = function() {
                selectAll.disable();
                selectNone.disable();
            };

            helpers.enable = function() {
                selectAll.enable();
                selectNone.enable();
            };

            return helpers;
        },

        getGroups: function(grid) {
            var groups = [];

            grid.getStore().each(function(record) {
                if(!groups.include(record.get("group"))) {
                    groups.push(record.get("group"));
                }
            });

            return groups;
        },

        addSelectionHelpersToGroup: function(grid, group) {
            if(!grid.groupHelpers) {
                grid.groupHelpers = [];
            }

            var groupEl = grid.getGroup(group);
            var index = grid.groupIndex(groupEl);

            var selectFn = function(record) {
                return record.get("group") === group && record.get("id") !== GROUP_SPACER;
            };

            var selectAll = this.getSelectionButton(grid, true, selectFn);
            var selectNone = this.getSelectionButton(grid, false, selectFn);

            var helpers = new Ext.Panel({
                items: [selectAll, selectNone],
                collapsible: false,
                anchor: "-75",
                border: false,
                layout: "column",
                cls: "y-selection-helpers y-selection-helpers-inline" + (Ext.isChrome ? " y-selection-helpers-chrome" : "")
            });

            var head = groupEl.child(".x-grid-group-hd");

            helpers.render(head.dom.firstChild);

            $(helpers.getEl().dom).observe("mousedown", function(e) {
                Event.stop(e);
            });

            if(grid.isGroupCollapsed(groupEl)) {
                helpers.hide();
            } else {
                head.addClass("y-selection-helpers-hide-border");
            }

            grid.groupHelpers[index] = helpers;
        },

        addSelectionHelpersToGroups: function(grid) {
            if(grid.readonly) {
                grid.groupHelpers = [];
                return;
            }

            this.getGroups(grid).each(this.addSelectionHelpersToGroup.bind(this, grid));
        },

        /**
         * If a panel is collapes a small indicator will show how many elements
         * are selected inside of it.
         *
         * @param stencilset    Stencilset information of this panel
         * @param panel
         */
        handleCollapse: function(stencilset, panel) {
            if(!this.evaluateOptions(panel)) {
                // Only show info in header, if options do not render
                // the information useless.
                panel.setTitle(panel.initialTitle);
                return;
            }

            var value = this.getPanelValue(panel);

            if(value.length > 0) {
                panel.setTitle(panel.initialTitle + " " + this.getTitleInfo(value.length));
            } else {
                var deselectedProperties = 0;

                this.oldItems.each(function(item) {
                    if(item.stencilset === stencilset.namespace) {
                        ++deselectedProperties;
                    }
                });

                if(deselectedProperties > 0) {
                    panel.setTitle(panel.initialTitle + " " + this.getTitleInfo(deselectedProperties));
                } else {
                    panel.setTitle(panel.initialTitle);
                }
            }
        },

        /**
         * If certain options are set on a panel, no info message
         * should be displayed in its header. This method is used
         * to evaluate the options of a panel.
         *
         * @param panel
         * @returns {Boolean}
         */
        evaluateOptions: function(panel) {
            var options = panel.options || {};

            if(options.selectAll instanceof Array) {
                return false;
            }

            if(options.selectOwn instanceof Array) {
                return false;
            }

            return true;
        },

        /**
         * The title info shows how many children of a
         * panel are selected or deselected depending on the
         * type of logic this mapper operates on.
         *
         * @param count
         * @returns {String}
         */
        getTitleInfo: function(count) {
            var selectionInfo = new Template(Ext.ux.getI18N("attribute.mapper.deselected"));

            if(this.positiveLogic) {
                selectionInfo = new Template(Ext.ux.getI18N("attribute.mapper.selected"));
            }

            return "<span class='y-attribute-mapper-panel-info'> - " + selectionInfo.evaluate({ count: count }) + "</span>";
        },

        getPanelValue: function(panel) {
            var grid = panel.getGrid();

            return this.getGridValue(grid);
        },

        /**
         * Gathers the information of a grid and stores it as a JSON object
         * in the result array.
         *
         * @param grid      Grid, from which the data should be gathered
         * @returns {Array}
         */
        getGridValue: function(grid) {
            var store = grid.getStore();
            var records = store.query("checked", this.positiveLogic);
            var values = [];

            records.each(function(record) {
                if(record.get("id") === NO_SELECTION) {
                    return;
                }

                values.push({
                    stencilset: record.get("stencilset"),
                    stencil: record.get("stencil"),
                    id: record.get("id"),
                    title: record.get("title")
                });
            });

            return values;
        },

        /**
         * Parses an element for its title in the correct language.
         * Assuming, that there are "title_languagecode" properties.
         *
         * @param el
         * @returns
         */
        getTitle: function(el) {
            return this.getI18Nattribute(el, "title");
        },

        getGroup: function(stencil) {
            return this.getI18Nattribute(stencil, "groups").first() || Ext.ux.getI18N("attribute.mapper.untitled_group");
        },

        getI18Nattribute: (function() {
            var language = Ext.ux.getLang();

            return function(stencil, attr) {
                return stencil[attr + "_" + language] || stencil[attr];
            };
        }()),

        handleRowMouseDown: function(grid, index) {
            if(!this.handleClick(grid, index)) {
                return false;
            }
        },

        /**
         * Will set the checked value of the correct record in the store
         * and also update the checkbox.
         *
         * @param store
         * @param index
         * @returns {Boolean}
         */
        handleClick: function(grid, index) {
            var store = grid.getStore();
            var record = store.getAt(index);

            if(record.get("id") === GROUP_SPACER) {
                this.handlePropertyGroupClick(grid, index);

                return false;
            }

            if(record.get("readonly")) {
                return false;
            }

            var status = record.get("checked");
            var config = this.getConfig();
            var id = record.get("id");

            grid.doSuspended(function() {
                if(config.singleSelection) {
                    if(!status) {
                        record.set("checked", true);

                        var records = store.query("group", record.get("group"));

                        records.each(function(r) {
                            if(r.get("id") !== id) {
                                r.set("checked", false);
                            }
                        });
                    }
                } else {
                    record.set("checked", !status);
                }

                if(grid.getView() instanceof Ext.grid.GroupingView && !config.singleSelection) {
                    this.updateGroupHeader(grid, record.get("group"));
                }
            }.bind(this));

            return false;
        },

        handlePropertyGroupClick: function(grid, index) {
            var that = this;

            grid.doSuspended(function() {
                var pos = 0;
                var indices = [];
                var store = grid.getStore();
                var record = store.getAt(index);
                var group = record.get("title");
                var rows = grid.getView().getRows();
                var stencilGroup = record.get("group");
                var stencilset = record.get("stencilset");

                store.each(function(r) {
                    if(r.get("propertyGroup") === group
                        && r.get("group") === stencilGroup
                        && r.get("stencilset") === stencilset) {

                        indices.push(pos);
                        r.set("collapsed", !r.get("collapsed"));
                    }

                    pos++;
                });

                var collapsed = store.getAt(indices.first()).get("collapsed");
                var groupHeader = rows[indices.first()];

                var expander = that.getExpanderButton(groupHeader);

                that.updateExpanderButton(expander, collapsed);

                indices = indices.slice(1);

                rows = rows.slice(indices.first() - 1, indices.last());

                rows.each(function(row) {
                    if(collapsed) {
                        row.style.visibility = "hidden";
                        row.style.display = "none";
                    } else {
                        row.style.visibility = "visible";
                        row.style.display = "block";
                    }
                });
            });

            this.adjustGridHeight(grid);
        },

        updateExpanderButton: function(expander, collapsed) {
            var className = expander.className;

            if(!collapsed && className.include("y-attribute-mapper-group-collapsed")) {
                className = className.sub("y-attribute-mapper-group-collapsed", "");
            } else if(collapsed && !className.include("y-attribute-mapper-group-collapsed")) {
                className += "y-attribute-mapper-group-collapsed";
            }

            if(className !== expander.className) {
                expander.className = className;
            }
        },

        updateGroupHeader: function(grid, group) {
            var el = grid.getGroup(group);
            var headerContainer = el.child(".x-grid-group-hd");
            var title = $(headerContainer.dom.firstChild);
            var selectedCount = this.selectedCount(grid.getStore(), group);

            if(selectedCount) {
                title.update(group
                    + " "
                    + "<span class='y-attribute-group-info'>("
                        + (new Template(Ext.ux.getI18N('attribute.mapper.selected'))).evaluate({
                              count: selectedCount
                          })
                    + ")</span>");
            } else {
                title.update(group);
            }

            var config = this.getConfig();

            this.updateParentTitle(grid, group);

            if(!config.singleSelection) {
                this.addSelectionHelpersToGroup(grid, group);
            }
        },

        updateParentTitle: function(grid, group) {
            var panel = grid.ownerCt;
            var selectedCount = this.getPanelValue(panel).length;

            if(selectedCount) {
                panel.setTitle(panel.initialTitle + " " + this.getTitleInfo(selectedCount));
            } else {
                panel.setTitle(panel.initialTitle);
            }
        },

        selectedCount: function(store, group) {
            var selectedCount = 0;

            store.each(function(record) {
                if(record.get("group") === group && record.get("checked")) {
                    selectedCount++;
                }
            });

            return selectedCount;
        },

        /**
         * Selection function used to determine, if a stencil should
         * go into a result set or not.
         *
         * @param stencil
         * @returns {Boolean}
         */
        isAllowedStencil: function(stencilset, stencil) {
            var config = this.getConfig();
            var restrictions = this.getRestrictions().elements;
            var allowed = stencil.type === "node";

            if(config.rootElementsOnly) {
                allowed = allowed && !!stencil.mayBeRoot;
            }

            if(config.hideRootElements) {
                allowed = allowed && !stencil.mayBeRoot;
            }

            if(!config.rootElementsOnly || config.hideRootElements) {
                allowed = allowed && (config.enforceRootElements || !stencil.hide);
            }

            if(restrictions.stencils.length > 0) {
                if(restrictions.positiveLogic) {
                    allowed = allowed && restrictions.stencils.include(stencilset + stencil.id);
                } else {
                    allowed = allowed && !restrictions.stencils.include(stencilset + stencil.id); // NOT
                }
            }

            restrictions.managers.each(function(manager) {
                allowed = allowed && Ext.ux.propertyeditor.AbstractConfigurationPanel.isAllowedStencil(manager, stencilset, stencil, restrictions.config);
            });

            return allowed;
        },

        /**
         * Parses a stencil for all properties needed to create a new record
         * for the store.
         *
         * @param stencilset    Complete stencilset.
         * @param title         Title of the stencilset
         * @param uri           URI of the stencilset
         * @returns {Array}
         */
        createRecordsFromStencilSet: function(stencilset, uri) {
            var records = [];
            var config = this.getConfig();
            var addedStencils = [];

            this.sortStencils(stencilset.stencils
                      .select(this.isAllowedStencil.bind(this, stencilset.namespace)))
                      .each(function(stencil) {

                var newRecords = [];

                var stencilIdentfier = stencilset.namespace + "#" + this.getGroup(stencil) + "#" + this.getTitle(stencil);

                if(addedStencils.include(stencilIdentfier)) {
                    return;
                }

                addedStencils.push(stencilIdentfier);

                if(config.stencilsOnly) {
                    newRecords = this.createRecordFromStencil(stencil, stencilset.namespace, this.parseBaseURI(uri));
                } else {
                    newRecords = this.createRecordsFromProperties(stencil, stencilset, this.parseBaseURI(uri));
                }

                records = records.concat(newRecords);
            }.bind(this));

            return records;
        },

        sortStencils: function(stencils) {
            var knownGroups = [];
            var groupMap = {};
            var sortedStencils = [];

            stencils.each(function(stencil) {
                var group = stencil.groups.first();

                if(!knownGroups.include(group)) {
                    knownGroups.push(group);
                    groupMap[group] = [stencil];
                } else {
                    groupMap[group].push(stencil);
                }
            });

            knownGroups.each(function(group) {
                sortedStencils = sortedStencils.concat(groupMap[group]);
            });

            return sortedStencils;
        },

        /**
         * Selection function used to determine, if a property should
         * go into a result set or not.
         *
         * @param property
         * @returns {Boolean}
         */
        isAllowedProperty: function(property) {
            var restrictions = this.getRestrictions().elements;

            var allowed = true;

            if(property.visible === false) {
                allowed = false;
            }

            if(restrictions.attributes.length > 0) {
                allowed = allowed && restrictions.attributes.include(property.id);
            }

            return allowed && this.validProperty(property);
        },

        validProperty: function() {
            return true;
        },

        parseBaseURI: function(uri) {
            return "/stencilsets" + uri.substr(0, uri.lastIndexOf("/"));
        },

        /**
         * Creates a record for the store directly from a stencil and not
         * from a property.
         *
         * @param stencil
         * @param stencilset
         * @param baseURI
         * @returns {Record}
         */
        createRecordFromStencil: function(stencil, stencilset, baseURI) {
            return new Record({
                checked : this.isActive(stencilset, stencil, null),
                icon: baseURI + "/icons/" + stencil.icon,
                stencilset: stencilset,
                title: this.getTitle(stencil),
                group: this.getGroup(stencil),
                stencil: stencil.id,
                roles: stencil.roles,
                stencilsetIcon: CACHE.StencilsetIcons[stencilset.namespace],
                root: stencil.mayBeRoot
            });
        },

        createRecordsFromProperties: function(stencil, stencilset, baseURI) {
            var allProperties = this.mergeProperties(stencil, stencilset.propertyPackages, stencilset.namespace);
            var records = [];
            var config = this.getConfig();

            if(config.singleSelection) {
                // If single selection is active a dummy record is
                // pushed first, to generate the "none" button on
                // top of each group

                if(allProperties.size() > 0) {
                    records.push(new Record({
                        checked: this.initialNoneSelection(stencil.id),
                        id: NO_SELECTION,
                        title: "<i style='color:#717171'>" + Ext.ux.getI18N("attribute.mapper.no_selection") + "</i>",
                        group: this.getTitle(stencil),
                        root: stencil.mayBeRoot,
                        icon: baseURI + "/icons/" + stencil.icon,
                        stencilset: stencilset.namespace,
                        stencil: stencil.id,
                        stencilsetIcon: CACHE.StencilsetIcons[stencilset.namespace],
                        position: stencilset.stencils.indexOf(stencil)
                    }));
                }
            }

            var currentGroup = "";

            allProperties
                .select(this.isAllowedProperty.bind(this))
                .sort(this.sortProperties.bind(this))
                .each(function(property) {

                var group = this.getPropertyCategory(property);

                if(currentGroup !== group) {
                    currentGroup = group;

                    records.push(new Record({
                        id: GROUP_SPACER,
                        title: group,
                        group: this.getTitle(stencil),
                        propertyGroup: group,
                        collapsed: true,
                        root: stencil.mayBeRoot,
                        position: stencilset.stencils.indexOf(stencil),
                        stencil: stencil.id,
                        stencilset: stencilset.namespace,
                        stencilsetIcon: CACHE.StencilsetIcons[stencilset.namespace],
                        icon: baseURI + "/icons/" + stencil.icon
                    }));
                }

                records.push(new Record({
                    checked: this.isActive(stencilset.namespace, stencil, property),
                    icon: baseURI + "/icons/" + stencil.icon,
                    id: property.id,
                    stencilset: stencilset.namespace,
                    title: this.getTitle(property),
                    group: this.getTitle(stencil),
                    stencil: stencil.id,
                    propertyGroup: group,
                    collapsed: true,
                    root: stencil.mayBeRoot,
                    position: stencilset.stencils.indexOf(stencil),
                    meta: property.meta === true,
                    list: property.list === true,
                    stencilsetIcon: CACHE.StencilsetIcons[stencilset.namespace]
                }));
            }.bind(this));

            return records;
        },

        getPropertyCategory: function(property) {
            if(property.popular || this.parseRefToView(property)) {
                return Ext.ux.getI18N("attribute.mapper.config.main_properties");
            }

            if(property.meta) {
                return Ext.ux.getI18N("attribute.mapper.config.meta_properties");
            }

            return Ext.ux.getI18N("attribute.mapper.config.more_properties");
        },

        sortProperties: function(a, b) {
            var refA = this.parseRefToView(a);
            var refB = this.parseRefToView(b);

            return a.meta && !b.meta ? -1 :                                 // Custom Attributes
                   !a.meta && b.meta ? 1 :
                       a.popular && !b.popular ? -1 :                       // Main Attributes
                       !a.popular && b.popular ? 1 :
                            refA && !refB ? -1 :
                            !refA && refB ? 1 :
                                this.getTitle(a) < this.getTitle(b) ? -1 :  // Other Attributes
                                this.getTitle(a) > this.getTitle(b) ? 1 :
                                    0;
        },

        parseRefToView: function(prop) {
            if(prop.refToView) {
                return true;
            }

            if((prop.type || "").toLowerCase() === Signavio.Config.TYPE_CHOICE) {
                var flag = false;

                prop.items.each(function(item) {
                    if(item.refToView) {
                        flag = true;

                        throw $break;
                    }
                });

                return flag;
            }

            return false;
        },

        /**
         * This method checks for each stencil if an
         * attribute is already selected.
         *
         * @param stencil
         * @returns {Boolean}
         */
        initialNoneSelection: function(stencil) {
            var active = true;

            this.oldItems.each(function(item) {
                if(item.stencil === stencil) {
                    active = false;

                    throw $break;
                }
            });

            return active;
        },

        /**
         * Checks whether an entry should be initially selected in
         * the grid or not.
         *
         * @param stencilset
         * @param stencil
         * @param property
         * @returns {Boolean}
         */
        isActive: function(stencilset, stencil, property) {
            var active = !this.positiveLogic;
            var found = null;

            (this.oldItems || []).each(function(value, index) {
                if(value.stencilset === stencilset
                    && (!stencil || value.stencil === stencil.id)
                    && (!property || value.id === property.id)) {

                    active = !active;
                    found = index;
                    throw $break;
                }
            });

            if((this.positiveLogic && active) || (!this.positiveLogic && !active)) {
                this.oldItems[found] = undefined;
                this.oldItems = this.oldItems.compact();
            }

            return active;
        },

        /**
         * Merges all properties of a stencil into one list. This list then
         * also contains all properties, that were referenced by a property
         * package.
         *
         * @param stencil
         * @param propertyPackages
         * @returns {Array}
         */
        mergeProperties: function(stencil, propertyPackages, stencilset) {
            var me = this;
            var readProperties = [];
            var properties = [];

            (stencil.properties || []).each(function(property) {
                if (!me.isHiddenProperty(property)) {
                    readProperties.push(property.id);
                    properties.push(property);
                }
            });

            (stencil.propertyPackages || []).each(function(propertyPackage) {
                var packedProperties = propertyPackages.map(function(p) {
                    if(p.name === propertyPackage) {
                        return p.properties;
                    }
                }).compact();

                // flattens the property list
                packedProperties.each(function(p) {
                    p.each(function(prop) {
                        if(!readProperties.include(prop.id) && !me.isHiddenProperty(prop)) {
                            properties.push(prop);
                        }
                    });
                });
            });

            ((this.metaAttributes[stencilset] || [])[stencil.id] || []).each(function(meta) {
                if (!me.isHiddenProperty(meta)) {
                    properties.push(meta);
                }
            });

            return properties;
        },

        
        /**
         * Checks for properties to be hidden in Portal
         * 
         * Hidden property are:
         * <ul>
         *  <li>Black lists: Signavio.Portal.Config.HIDDEN_PROPERTIES, Signavio.Portal.Config.HIDDEN_PROPERTY_TYPES</li>
         *  <li>properties having a refToView defined</li>
         *  <li>properties/stencils having a flag hideInPortal set to true</li>
         * </ul>
         *
         * @return {Boolean} Return
         */
        isHiddenProperty: function(prop) {
            if (!prop) {
                return false;
            }

            var id = (prop.id?prop.id.toLowerCase():undefined), type = (prop.type?prop.type.toLowerCase():undefined);

            return Signavio.Config.HIDDEN_PROPERTIES.include(id) 
                || Signavio.Config.HIDDEN_PROPERTY_TYPES.include(type);
                //|| prop.hideInPortal
                //|| prop.refToView;
        },

        /**
         * Selection function to determine, if a stencilset is allowed in
         * a result set or not.
         *
         * @param stencilset
         * @returns {Boolean}
         */
        isAllowedStencilSet: function(stencilset) {
            var restrictions = this.getRestrictions().stencilsets;
            var allowed = !BLACKLIST.include(stencilset.namespace);

            if(restrictions.stencilsets.length > 0) {
                if(restrictions.positiveLogic) {
                    return allowed && restrictions.stencilsets.include(stencilset.namespace);
                }

                return allowed && !restrictions.stencilsets.include(stencilset.namespace);  // NOT
            }

            return allowed;
        },

        /**
         * Retrieve all stencilsets, that are allowed for a user. The finish
         * callback will then be called, with all panels, that have been
         * created.
         *
         * @param callback
         */
        getStencilsets: function(callback) {
            if(CACHE.StencilsetPreview.length > 0) {
                this.getMetaAttributes();

                callback(CACHE.StencilsetPreview.select(this.isAllowedStencilSet.bind(this)));

                this.facade.raiseEvent(EVENTS.STENCILSETS_LOADED);

                return;
            }

            Signavio.Utils.Request.execute(Signavio.Config.STENCILSET_URI, {
                async: true,
                success: function(response) {
                    (response || []).each(function(stencilset) {
                        CACHE.StencilsetPreview.push({
                            title: this.getTitle(stencilset),
                            uri: stencilset.uri,
                            namespace: stencilset.namespace,
                            icon: Signavio.Config.IMAGE_PATH + stencilset.icon_url
                        });

                        CACHE.StencilsetIcons[stencilset.namespace] = Signavio.Config.IMAGE_PATH + stencilset.icon_url;
                    }.bind(this));

                    CACHE.StencilsetPreview.sort(function(a, b) {
                        if(a.namespace === this.getDefaultStencilSet()) {
                            return -1;
                        }

                        if(b.namespace === this.getDefaultStencilSet()) {
                            return 1;
                        }

                        return a.title < b.title ? -1 :
                               a.title > b.title ? 1 :
                                   0;
                    }.bind(this));

                    this.getStencilsets(callback);
                }.bind(this)
            });
        },

        /**
         * Retrieves attributes, that were defined by the user
         * and adds them to list of known meta attribuets,
         * so that they can be used, if the mapper is shown.
         */
        getMetaAttributes: function() {
            var meta = {};

            if(CACHE.MetaAttributes) {
                this.metaAttributes = CACHE.MetaAttributes;

                return;
            }

            Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + "/meta", {
                success: function(response) {
                    (response || []).each(function(item) {
                        var bindings = item.rep.stencilsetBindings;

                        bindings.each(function(binding) {
                            if(!meta[binding.namespace]) {
                                meta[binding.namespace] = {};
                            }

                            if(!meta[binding.namespace][binding.stencil]) {
                                meta[binding.namespace][binding.stencil] = [];
                            }

                            meta[binding.namespace][binding.stencil].push({
                                id: item.rep.id,
                                title: item.rep.name,
                                list: item.rep.isList,
                                meta: true,
                                type: item.rep.type,
                                lineWrap: item.rep.lineWrap
                            });
                        });
                    });

                    CACHE.MetaAttributes = meta;
                }
            });

            this.metaAttributes = meta;
        },

        getReader: function() {
            return new Ext.data.ArrayReader({}, this.getFields());
        },

        getFields: function() {
            return [
                { name: "checked" },
                { name: "icon" },
                { name: "id" },
                { name: "title" },
                { name: "group" },
                { name: "stencilset" },
                { name: "stencil" },
                { name: "root" },
                { name: "readonly" },
                { name: "meta" },
                { name: "list" },
                { name: "position" },
                { name: "roles" },
                { name: "propertyGroup" },
                { name: "collapsed" },
                { name: "stencilsetIcon" }
            ];
        }

    });

    Ext.ux.propertyeditor.AttributeMapper.getGroupInfo = function(values) {
        var selectedCount = 0;

        values.rs.each(function(record) {
            if(record.get("group") === values.group && record.get("checked")) {
                selectedCount++;
            }
        });

        if(selectedCount) {
            return "<span class='y-attribute-group-info'>("
                + (new Template(Ext.ux.getI18N('attribute.mapper.selected'))).evaluate({
                      count: selectedCount
                  })
                + ")</span>";
        }

        return "";
    };

}());
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Philipp Giese
 *  
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {
	    
    var Record = Ext.data.Record.create([
        { name: "checked", mapping: "checked" },
        { name: "title", mapping: "title" },
        { name: "type", mapping: "type" }
	]);
    
    Ext.ux.propertyeditor.GlossaryMapper = Ext.extend(Ext.ux.propertyeditor.AbstractPropertyEditor, {
    	
    	possibleCategories: 0,
    	
    	windowCreate: {
    		height: 300,
    		width: 250,
    		resizable: false
    	},
    	
    	renderer: function(value) {
    		value = this.evalValue(value);
    		
    		if(!this.possibleCategories
    				|| value.length === 0) {
    			
    			return Ext.ux.getI18N("glossary.mapper.all_categories");
    		}
    		
    		return this.possibleCategories - value.length 
    				+ " / " 
    				+ this.possibleCategories 
    				+ " " 
    				+ Ext.ux.getI18N('glossary.mapper.categories_chosen');
    	},
    	
    	getEditor: function(currentValue) {
    		var panel = this.getPanel();
    		
    		this.excludedValues = this.evalValue(currentValue);
    		
    		panel.on("render", this.handleRender.bind(this));
    		panel.getValue = this.getEditorValue.bind(panel, this);
    		
    		return panel;
    	},
    	
    	evalValue: function(value) {
    		try {
    			var json = (value.toString()
    					|| "{}").evalJSON(true);
    			
    			value = json.exclude || [];
    			this.possibleCategories = json.categoryCount;
    		} catch(e) {
    			value = [];
    		}
    		
    		return value;
    	},
    	
    	// scope: panel
    	getEditorValue: function(self) {
    		var values = [];
    		
    		var grid = this.items.get(1);
    		var store = grid.getStore();
    		
    		store.each(function(record) {
    			if(!record.get("checked")) {
    				values.push(record.get("type"));
    			}
    		});
    		
    		values = values.concat(self.excludedValues || []);
    		
//    		if(values.length === store.getCount()) {
//    			values = [];
//    		}
    		
    		return $H({
    			exclude: values,
    			categoryCount: store.getCount()
    		}).toJSON();
    	},
    	
    	getPanel: function() {
    		return new Ext.Panel({
                anchor: "100% 100%",
                border: false,
                layout: "fit",
                autoScroll: true,
                items: [this.getDummyPanel()] 
            });
    	},
    	
    	getDummyPanel: function() {
            return new Ext.Panel({
                border: false,
                collapsed: true,
                collapsible: true,
                width: 200
            });
        },
        
        handleRender: function(panel) {
        	window.setTimeout(function() {
        		
        		panel.getEl().mask(Ext.ux.getI18N('glossary.mapper.loading_groups'));
        		
        		var grid = this.getGrid();
        		grid.on("rowmousedown", this.handleClick);
        		grid.on("mousedown", this.removeCellSelection.bind(this, grid));
        		
        		panel.add(grid);
        		
        		this.getItems(function(items) {
        			grid.getStore().add(items);
        			
        			panel.doLayout();
        			panel.getEl().unmask();
        		});
        		
        	}.bind(this), 100);
        },
        
        handleClick: function(grid, index) {
        	var store = grid.getStore();
        	var record = store.getAt(index);
        	var status = record.get("checked");
        	
        	record.set("checked", !status);
        	store.commitChanges();
        	
        	return false;
        },
        
        removeCellSelection: function(grid) {
        	grid.getEl().select(".x-grid3-cell-selected").each(function(el) {
                el.addClass("y-mapper-grid-no-background");
            });
        },
        
        getItems: function(fn) {
        	var records = [];
        	
        	Signavio.Utils.Request.execute(Signavio.Config.BACKEND_PATH + "/glossary", {
                async: true,
                success: function(response) {
                	var available = response.map(function(el){return el.rep.id;}).compact();
                	this.excludedValues = this.excludedValues.findAll(function(el) {return available.include(el);});
            		(response || []).each(function(item) {
            			var rep = item.rep;
            			if (item.rel === "cat") {
//            				if(rep.type) {
//            					records.push(new Record({
//                					checked: this.isActive(rep),
//                					title: Ext.ux.getI18N("glossary.mapper.type." + rep.type),
////                					type: rep.id
//                					type: rep.type
//                				}));
//            				} else {
            					records.push(new Record({
            						checked: this.isActive(rep),
            						title: rep.name, //Ext.ux.getI18N("glossary.mapper.type." + rep.type),
            						type: rep.id
            					}));
//            				}
            			}
            		}.bind(this));
            		
            		fn(records);
            	}.bind(this)
            });
        },
        
        isActive: function(rep) {
        	var active = true;
        	var found = undefined;
        	
        	(this.excludedValues || []).each(function(item, index) {
        		if(item === rep.id) {
        			active = false;
        			found = index;
        			
        			throw $break;
        		}
        	});
        	
        	if(!active) {
        		this.excludedValues[found] = undefined;
        		this.excludedValues = this.excludedValues.compact();
        	}        	
        	
        	return active;
        },
        
        getGrid: function() {
        	return new Ext.grid.EditorGridPanel({
        		store: this.getStore(),
        		cm: this.getColumnModel(),
        		border: false,
        		hideHeaders: true,
        		stripeRows: true,
        		anchor: "100% 100%"
        	});
        },
        
        getColumnModel: function() {
        	return new Ext.grid.ColumnModel([
        	    {
        	    	menuDisabled: true,
        	    	hideable: false,
        	    	sortable: false,
        	    	dataIndex: 'checked',
        	    	readonly: true,
        	    	width: 25,
        	    	fixed: true,
        	    	renderer: function(checked) {
        	    		return "<input type='checkbox' " + (checked ? "checked='checked'" : "") + "/>";
        	    	}
        	    },
        	    {
        	    	menuDisabled: true,
        	    	hideable: false,
        	    	sortable: false,
        	    	dataIndex: 'title',
        	    	width: 180,
        	    	readonly: true,
        	    	fixed: true
        	    }
        	]);
        },
        
        getStore: function() {
        	return new Ext.data.SimpleStore({
        		reader: this.getReader(),
        		fields: this.getFields(),
        		data: [],
        		sortInfo: {
        			field: "title",
        			direction: "ASC"
        		}
        	});
        },
        
        getReader: function() {
        	return new Ext.data.ArrayReader({}, this.getFields());
        },
        
        getFields: function() {
        	return [
        	    { name: "checked" },
        	    { name: "title" },
        	    { name: "type" }
        	];
        }
    	
    });
	
})();
/**
 *  (c) 2011 Signavio GmbH
 *
 *  @author Philipp Giese
 *
 */

if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {

    var $notImplementedException = {};
    var knownImplementors = [];

    Ext.ux.propertyeditor.AbstractConfigurationPanel = function(attr) {
        attr = attr || {};

        var configurationHeight = 0;
        var that = this;

        if(attr.topPanel) {
            configurationHeight += attr.topPanel.initialConfig.height;
        }

        if(attr.bottomPanel) {
            configurationHeight += attr.bottomPanel.initialConfig.height;
        }

        // wrapper panel, so that configuration of panel
        // handed in via attributes does not affect layouting
        var managedPanel = new Ext.Panel({
            anchor: "100% -" + configurationHeight,
            layout: "anchor",
            border: false,
            header: false,
            items: attr.panel
        });

        this.extendPanel(attr.panel);

        attr.panel.getEl = this.getEl.bind(this);

        attr.anchor = "100% 100%";
        attr.layout = "anchor",
        attr.border = false;
        attr.header = false;
        attr.items = [
            attr.topPanel,
            managedPanel,
            attr.bottomPanel
        ].compact();

        var addReadonlyCapability = function(component, mixins) {
            if(!component) {
                return;
            }

            if(!component.setReadonly) {
                component.setReadonly = Ext.emptyFn;
            }

            var handler = component.setReadonly;

            component.setReadonly = function(value, complete) {
                // the complete flag indicates, that the whole
                // component should be readonly and not only
                // the display panel and the grid.
                if(!complete) {
                    return;
                }

                // to stop standard behaviour, return false
                // in any implementation of the setReadonly
                // method.
                if(handler(value, complete) === false) {
                    return;
                }

                mixins = mixins || [];

                if(value) {
                    mixins.invoke("disable");

                    return;
                }

                mixins.invoke("enable");
            };
        };

        addReadonlyCapability(attr.topPanel, attr.topPanelMixins);
        addReadonlyCapability(attr.bottomPanel, attr.bottomPanelMixins);

        var processMixins = function(component, mixins) {
            if(component) {
                (mixins || []).each(function(mixin) {
                    component.add(mixin);
                });
            }
        };

        this.topMixins = attr.topPanelMixins || [];
        this.bottomMixins = attr.bottomPanelMixins || [];

        processMixins(attr.topPanel, attr.topPanelMixins);
        processMixins(attr.bottomPanel, attr.bottomPanelMixins);

        this.controlPanels = [attr.topPanel, attr.bottomPanel].compact();

        this.getManagedPanel = function() {
        	return attr.panel;
        };

        this.hotWired = function() {
        	return attr.panel.hotWired();
        };

        Ext.ux.propertyeditor.AbstractConfigurationPanel.superclass.constructor.call(this, attr);

        /**
         * Adding an element to this panel, will actually add it to the
         * managed panel. This is needed in order to keep the original code
         * working, not knowing that there is magic going on.
         *
         * @Override
         */
        this.add = function() {
            attr.panel.add.apply(attr.panel, arguments);

            if(arguments.length === 1) {
                var panel = arguments[0];

                panel.on("expand", this.handleChildExpand.bind(this, panel, attr.panel));
            }
        };

        /**
         * As add, this function does not only layout this panel, but
         * also the managed one.
         *
         * @Override
         */
        this.doLayout = function() {
            Ext.ux.propertyeditor.StencilConfigurationPanel.superclass.doLayout.apply(this, arguments);
            attr.panel.doLayout.apply(attr.panel, arguments);
        };
    };

    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager = function(manager) {
    	if(!knownImplementors.include(manager)) {
    		knownImplementors.push(manager);
    	}
    };

    Ext.ux.propertyeditor.AbstractConfigurationPanel.isAllowedStencil = function() {
        var manager = arguments[0] || "";

        if(knownImplementors.include(manager)) {
            manager = eval(manager);

            if(manager.isAllowedStencil && manager.isAllowedStencil instanceof Function) {
                return manager.isAllowedStencil.apply(this, $A(arguments).slice(1));
            }
        }

        return true;
    };

    Ext.extend(Ext.ux.propertyeditor.AbstractConfigurationPanel, Ext.Panel, {

        getComponentHeight: function(entryHeight, items, mixins) {
            var padding = 35;

            return (items.length * entryHeight) + ((mixins || []).length * entryHeight) + padding;
        },

    	getRadio: function(option) {
    		return new Ext.form.Radio(Ext.apply({
    			name: "x-attr-selection",
    			height: 20,
    			cls: "y-attribute-mapper-checkbox"
    		}, option || {}));
    	},

        getOptions: function() {
            throw $notImplementedException;
        },

        getValue: function() {
            throw $notImplementedException;
        },

        /**
         * This method extends a panel object with additional methods,
         * that are necessary in order to work correctly with the
         * control panels.
         *
         * @param panel
         * @param buttonConf
         */
        extendPanel: function(panel) {
            /**
             * This method will execute a given command
             * on the grid elements of each panel, that is
             * a direct child of the parent panel.
             *
             * It also stores the command/ argument
             * information in the options field of each panel,
             * so that also currently collapsed panels
             * know the correct configuration, when they
             * are expanded.
             */
            panel.execute = function(cmd) {
                var start = 1;
                var end = panel.items.indexOf(panel.items.last());
                var args = $A(arguments).slice(1);

                if(panel.items.length > 1) {
                    panel.items.getRange(start, end).each(function(p) {
                        // remove old options
                        p.options = {};
                        // set a flag on each panel, even if currently
                        // not expanded
                        p.options[cmd] = args;

                        var grid = this.extendGrid(p.getGrid());

                        if(cmd === "setReadonly") {
                            var value = args.first();
                            var helpers = p.getSelectionHelpers();

                            grid.readonly = value;
                            panel.isHotWired = value;

                            if(value) {
                                helpers.selectionHelpers.disable();
                            } else {
                                helpers.selectionHelpers.enable();
                                helpers.addToGroups(grid);
                            }
                        } else {
                        	if(p.expanded || p.alreadyExpanded) {
                        		grid[cmd].apply(this, args);
                        	}
                        }

                        p.adjustHeight(grid);
                    }.bind(this));
                }
            };

            /**
             * Removes the info section from each panel
             * header.
             */
            panel.revertTitle = function() {
                var start = 1;
                var end = panel.items.indexOf(panel.items.last());

                if(panel.items.length > 1) {
                    panel.items.getRange(start, end).each(function(p) {
                        p.setTitle(p.initialTitle);
                    });
                }
            };

            panel.setReadonly = function(value, complete) {
                panel.execute.call(this, "setReadonly", value, complete);

                this.controlPanels.each(function(c) {
                    c.setReadonly(value, complete);
                });
            }.bind(this);

            panel.isHotWired = this.isReadonly();

            panel.on("add", this.handleAdd.bind(this));
        },

        handleAdd: function(panel, child) {
            this.extendGrid(child.getGrid());
        },

        handleChildExpand: Ext.emptyFn,

        isReadonly: function() {
            return false;
        },

        /**
         * Extends a grid object with additional functionality, that
         * is needed in order for the control panels to work
         * correctly.
         *
         * Extension is only done, if the grid hasn't been already extended
         * in the past.
         *
         * @param grid
         * @returns
         */
        extendGrid: function(grid) {
            if(!grid.extended) {
                grid.extended = true;

                grid.each = function(iterator) {
                    var store = grid.getStore();

                    grid.doSuspended(function() {
                    	store.each(iterator);
                    });
                };

                /**
                 * Do a bulk change on all records in
                 * the grids store.
                 */
                grid.changeAllValues = function(key, value, readonly) {
                    grid.each(function(record) {
                        record.set(key, value);
                        record.set("readonly", !!readonly);
                    });
                };

                grid.setReadonly = function(value) {
                    grid.each(function(record) {
                        record.set("readonly", value);
                    });
                };
            }

            return grid;
        },

        isAllowedStencil: function() {
            return true;
        }

    });

}());
/**
 *  (c) 2011 Signavio GmbH
 *
 *  @author Philipp Giese
 *
 */

if(!window.Ext) { window.Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.propertyeditor) { Ext.ux.propertyeditor = {}; }

(function() {

    var ENTRY_HEIGHT = 20;

	Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel = function(attr) {
		attr = attr || {};

		this.createConfiguration(attr.buttonConf);

        var allAttributes = new Ext.form.Radio({
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.all_attributes'),
            name: "x-attr-selection",
            height: ENTRY_HEIGHT,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectAll(),
            listeners: {
                check: this.useAllAttributes.bind(this, attr.panel)
            }
        });

        var ownAttributes = new Ext.form.Radio({
        	fieldLabel: Ext.ux.getI18N('attribute.mapper.config.own_attributes'),
            name: "x-attr-selection",
            height: ENTRY_HEIGHT,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectOwn(),
            listeners: {
                check: this.useOwnAttributes.bind(this, attr.panel)
            }
        });

        var selectAttributes = new Ext.form.Radio({
        	fieldLabel: Ext.ux.getI18N('attribute.mapper.config.select_attributes'),
            name: "x-attr-selection",
            height: ENTRY_HEIGHT,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectCustom(),
            listeners: {
                check: this.selectAttributes.bind(this, attr.panel)
            }
        });

        var items = [allAttributes, ownAttributes, selectAttributes].compact();

        if(attr.buttonConf.hideAll) {
            items = [];
        }

        var configPanel = new Ext.Panel(Ext.apply(items.length ? {items: items} : {html: ""}, {
        	anchor: "100%",
        	height: this.getComponentHeight(ENTRY_HEIGHT, items, attr.topPanelMixins),
        	layout: "form",
        	cls: "y-attribute-selection y-attribute-selection-top",
        	header: false,
        	border: false,
        	labelWidth: 180,
            setReadonly: function(value) {
                if(value) {
                    items.invoke("disable");

                    return;
                }

                items.invoke("enable");
            }})
        );

        /**
         * Proxy method to mix in some extra attributes to the
         * old getValue function of the original panel
         */
        this.getValue = function() {
        	var value = {};

        	if(selectAttributes.getValue() || attr.buttonConf.hideAll) {
        		// only store items, if the user selected them
        		value = attr.panel.getValue().evalJSON(true);
        	}

        	value.config = {
        		allAttributes: allAttributes.getValue(),
        		ownAttributes: ownAttributes.getValue(),
        		selectAttributes: selectAttributes.getValue() || attr.buttonConf.hideAll
        	};

        	return $H(value).toJSON();
        };

        attr.topPanel = configPanel;

		Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel.superclass.constructor.call(this, attr);
	};

	Ext.extend(Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel, Ext.ux.propertyeditor.AbstractConfigurationPanel, {

		/**
         * This method can be called by each panel with a configuration
         * in order to acquire a set-up options object.
         *
         * @param config
         * @returns {Object}
         */
        getOptions: function() {
            var options = {};

            if(this.isSelectAll()) {
                options.setReadonly = [true];
                options.selectAll = [];
            }

            if(this.isSelectOwn()) {
                options.setReadonly = [true];
                options.selectOwn = [];
            }

            if(this.isSelectCustom()) {
                options.setReadonly = [false];
                options.selectNone = [];
            }

            return options;
        },

		createConfiguration: function(conf) {
            conf = conf || {};

            // To change the default value of the config selection, change
            // the logic here
            this.conf = {
                selectAll: !!conf.allAttributes,
                selectOwn: !!conf.ownAttributes,
                selectCustom: !!conf.selectAttributes || (!conf.allAttributes && !conf.ownAttributes)
            };
        },

        createCustomSetValue: function(label) {
            return function(v){
                var text = v;
                var displayText = "";
                if(this.valueField){
                    var r = this.findRecord(this.valueField, v);
                    if(r){
                        text = r.data[this.displayField];
                    }else if(this.valueNotFoundText !== undefined){
                        text = this.valueNotFoundText;
                    }

                    var tpl = new Template(label);
                    displayText = tpl.evaluate({
                        value: text
                    });
                }
                this.lastSelectionText = text;
                if(this.hiddenField){
                    this.hiddenField.value = v;
                }
                Ext.form.ComboBox.superclass.setValue.call(this, displayText);
                this.value = v;
            };
        },

    	handleChildExpand: function(panel, parent) {
			if(this.isSelectAll()) {
    			this.useAllAttributes(parent, this, true);
    		} else if(this.isSelectOwn()) {
    			this.useOwnAttributes(parent, this, true);
    		} else {
    			this.selectAttributes(parent, this, true);
    		}
    	},

    	isSelectAll: function() {
    		return this.conf.selectAll;
    	},

    	isSelectOwn: function() {
    		return this.conf.selectOwn;
    	},

    	isSelectCustom: function() {
    		return this.conf.selectCustom;
    	},

    	updateConf: function(all, own, custom) {
    		this.conf.selectAll = all;
            this.conf.selectOwn = own;
            this.conf.selectCustom = custom;
    	},

        useAllAttributes: function(panel, self, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectAll();
                panel.revertTitle();
                panel.customAttributes = false;

                this.updateConf(true, false, false);
            }
        },

        useOwnAttributes: function(panel, self, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectOwnAttributes();
                panel.revertTitle();
                panel.customAttributes = false;

                this.updateConf(false, true, false);
            }
        },

        selectAttributes: function(panel, self, value) {
            if(value && !panel.customAttributes) {
            	panel.setReadonly(false);
                panel.selectNone();
                panel.customAttributes = true;

                this.updateConf(false, false, true);
            }
        },

        extendPanel: function(panel) {
            Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel.superclass.extendPanel.call(this, panel);

            panel.selectAll = panel.execute.bind(this, "selectAll");
            panel.selectNone = panel.execute.bind(this, "selectNone");
            panel.selectOwnAttributes = panel.execute.bind(this, "selectOwn");
        },

        isReadonly: function() {
        	return this.isSelectAll() || this.isSelectOwn();
        },

        /**
         * Extends a grid object with additional functionality, that
         * is needed in order for the control panels to work
         * correctly.
         *
         * Extension is only done, if the grid hasn't been already extended
         * in the past.
         *
         * @param grid
         * @returns
         */
        extendGrid: function(grid) {
        	if(!grid.extended) {
        		Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel.superclass.extendGrid.call(this, grid);

                grid.selectAll = grid.changeAllValues.bind(this, "checked", true, true);
                grid.selectNone = grid.changeAllValues.bind(this, "checked", false);
                grid.selectOwn = this.gridSelectOwnValues.bind(this, grid);
        	}

        	return grid;
        },

        gridSelectOwnValues: function(grid) {
            var store = grid.getStore();

            grid.doSuspended(function() {
            	store.query("meta", true).each(function(record) {
        			record.set("checked", true);
        			record.set("readonly", true);
                });

                store.query("meta", false).each(function(record) {
                	record.set("checked", false);
                	record.set("readonly", true);
                });
            });
        }

	});

}());
/**
 *  (c) 2011 Signavio GmbH
 *
 *  @author Philipp Giese
 *
 */

if (!Ext){ var Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {

    /**
     * This class can be used together with an Ext.ux.propertyeditor.AttributeMapper.
     * It will add two extra above and under the attribute selection.
     *
     * The top panel yields the possibility to instantly select all attributes or
     * the meta attributes, the uses has defined.
     *
     * It is also possible to hide empty attributes and to decide how multiple
     * attributes should be separated.
     *
     * @param attr
     */
    Ext.ux.propertyeditor.AttributeConfigurationPanel = function(attr) {
        attr = attr || {};

        var showAttributeLabel = new Ext.form.Checkbox({
        	checked: typeof attr.options.showAttributeLabel !== 'undefined' ? attr.options.showAttributeLabel : true, //default value: checked,
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.show_attribute_label')
        });
        
        //migrate old values
        if (!attr.options.hideAttributes && typeof attr.options.hideEmptyAttributes !== 'undefined') {
    		if (attr.options.hideEmptyAttributes) {
    			attr.options.hideAttributes = Signavio.Const.Template.HIDE_ATTR_DEFAULT;
        	} else {
        		attr.options.hideAttributes = Signavio.Const.Template.HIDE_ATTR_NONE;
        	}
    		delete attr.options.hideEmptyAttributes;
        }
        
        var hideAttributes = new Ext.form.ComboBox({
            mode: "local",
            triggerAction: "all",
            editable: false,
            readOnly: true,
            cls: "y-attribute-mapper-form-element",
            emptyText: Ext.ux.getI18N("attribute.mapper.config.hide_attributes_if") + "...",
            store: new Ext.data.SimpleStore({
                data: [
                    [Ext.ux.getI18N("attribute.mapper.config.hide_attributes_none"), Signavio.Const.Template.HIDE_ATTR_NONE],
                    [Ext.ux.getI18N("attribute.mapper.config.hide_attributes_empty"), Signavio.Const.Template.HIDE_ATTR_EMPTY],
                    [Ext.ux.getI18N("attribute.mapper.config.hide_attributes_default"), Signavio.Const.Template.HIDE_ATTR_DEFAULT]
                ],
                fields: [
                    { name: "title" },
                    { name: "value" }
                ]
            }),
            displayField: "title",
            valueField: "value",
            value: attr.options.hideAttributes || Signavio.Const.Template.HIDE_ATTR_DEFAULT,
            width: 400,
            fieldLabel: Ext.ux.getI18N("attribute.mapper.config.hide_attributes_if")
        });

        var separateBy = new Ext.form.ComboBox({
            mode: "local",
            triggerAction: "all",
            editable: false,
            readOnly: true,
            cls: "y-attribute-mapper-form-element",
            emptyText: Ext.ux.getI18N("attribute.mapper.config.separate_labels") + "...",
            store: new Ext.data.SimpleStore({
                data: [
                    [Ext.ux.getI18N("attribute.mapper.config.separator_comma"), ", "],
                    [Ext.ux.getI18N("attribute.mapper.config.separator_space"), " "],
                    [Ext.ux.getI18N("attribute.mapper.config.separator_linebreak"), "\n"]
                ],
                fields: [
                    { name: "title" },
                    { name: "value" }
                ]
            }),
            displayField: "title",
            valueField: "value",
            value: attr.options.separateBy || "\n",
            width: 400,
            fieldLabel: Ext.ux.getI18N("attribute.mapper.config.separate_labels")
        });

        var options = new Ext.Panel({
            border: false,
            header: false,
            layout: "form",
            anchor: "100%",
            defaultType: "textfield",
            labelWidth: 180,
            height: 100,
            cls: "y-attribute-selection y-attribute-selection-bottom",
            items: [
                showAttributeLabel,
                hideAttributes,
                separateBy
            ]
        });

        if(!attr.config.hideBottom) {
            attr.bottomPanel = options;
        }

        Ext.ux.propertyeditor.AttributeConfigurationPanel.superclass.constructor.call(this, attr, "Ext.ux.propertyeditor.AttributeConfigurationPanel");

        var getValue = this.getValue;

        /**
         * Proxy method to mix in some extra attributes to the
         * old getValue function of the original panel
         */
        this.getValue = function() {
            var value = getValue();

            value = value.evalJSON(true);

            value.options = {
            	showAttributeLabel: showAttributeLabel.getValue(),
                hideAttributes: hideAttributes.getValue(),
                separateBy: separateBy.getValue()
            };

            value.manager = "Ext.ux.propertyeditor.AttributeConfigurationPanel";

            return $H(value).toJSON();
        };
    };

    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager("Ext.ux.propertyeditor.AttributeConfigurationPanel");

    Ext.extend(Ext.ux.propertyeditor.AttributeConfigurationPanel, Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel);

}());
if(!window.Ext) { var Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if(!Ext.ux.propertyeditor) { Ext.ux.propertyeditor = {}; }

(function() {

    Ext.ux.propertyeditor.ModellingsGuidelinesManager = function(attr) {
        attr = attr || {};

        attr.topPanelMixins = attr.topPanelMixins || [];

        var name = new Ext.form.TextField({
            allowBlank: false,
            emptyText: Ext.ux.getI18N('attribute.mapper.config.name'),
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.name'),
            value: attr.config.name || "",
            height: 20,
            width: 300
        });
        
        attr.topPanelMixins.push(new Ext.form.Label({
        	text: attr.config.description,
        	style: "margin-bottom:10px;display: block;"
        }));
        attr.topPanelMixins.push(name);
        attr.buttonConf.hideAll = true;

        Ext.ux.propertyeditor.ModellingsGuidelinesManager.superclass.constructor.call(this, attr);

        var getValue = this.getValue;

        this.getValue = function() {
            var value = getValue();

            value = value.evalJSON(true);
            value.config.name = name.getValue();

            value.manager = "Ext.ux.propertyeditor.ModellingsGuidelinesManager";

            return $H(value).toJSON();
        };
    };

    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager("Ext.ux.propertyeditor.ModellingsGuidelinesManager");

    Ext.extend(Ext.ux.propertyeditor.ModellingsGuidelinesManager, Ext.ux.propertyeditor.AbstractAttributeConfigurationPanel, {
    	getComponentHeight: function(entryHeight, items, mixins) {
            var padding = 30;

            return (items.length * entryHeight) + ((mixins || []).length * entryHeight) + padding;
        },
        extendPanel: function(panel){
        	Ext.ux.propertyeditor.ModellingsGuidelinesManager.superclass.extendPanel.apply(this,arguments);
        	panel.customAttributes = true;
        }
    });

}());
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Philipp Giese
 *  
 */

if (!Ext){ var Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {
    
    var IDENTIFIERS = {
        NAME: ["name"],
        DESCRIPTION: ["documentation"]
    };
    
    Ext.ux.propertyeditor.SingleAttributeConfigurationPanel = function(attr) {
        attr = attr || {};
        
        this.createConfiguration(attr.buttonConf);
        
        var descriptionOnly = new Ext.form.Radio({
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.description'),
            name: "x-attr-selection",
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectDescription(),
            listeners: {
                check: this.selectDescription.bind(this, attr.panel)
            }
        });
        
        var nameOnly = new Ext.form.Radio({
        	fieldLabel: Ext.ux.getI18N('attribute.mapper.config.name'),
            name: "x-attr-selection",
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectName(),
            listeners: {
                check: this.selectName.bind(this, attr.panel)
            }
        });
        
        var custom = new Ext.form.Radio({
        	fieldLabel: Ext.ux.getI18N("attribute.mapper.config.select_attributes"),
            name: "x-attr-selection",
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            checked: this.isSelectCustom(),
            listeners: {
                check: this.selectCustom.bind(this, attr.panel)
            }
        });
        
        var configPanel = new Ext.Panel({
            anchor: "100%",
            height: 95,
            layout: "form",
            labelWidth: 180,
            cls: "y-attribute-selection y-attribute-selection-top",
            header: false,
            border: false,
            items: [
                nameOnly,
                descriptionOnly,
                custom
            ]
        });
        
        var showAttributeLabel = new Ext.form.Checkbox({
        	checked: typeof attr.options.showAttributeLabel !== 'undefined' ? attr.options.showAttributeLabel : true, //default value: checked,
            height: 20,
            cls: "y-attribute-mapper-checkbox",
            fieldLabel: Ext.ux.getI18N('attribute.mapper.config.show_attribute_label')
        });
        
      //migrate old values
        if (!attr.options.hideAttributes && typeof attr.options.hideEmptyAttributes !== 'undefined') {
    		if (attr.options.hideEmptyAttributes) {
    			attr.options.hideAttributes = Signavio.Const.Template.HIDE_ATTR_DEFAULT;
        	} else {
        		attr.options.hideAttributes = Signavio.Const.Template.HIDE_ATTR_NONE;
        	}
    		delete attr.options.hideEmptyAttributes;
        }
        
        var hideAttributes = new Ext.form.ComboBox({
            mode: "local",
            triggerAction: "all",
            editable: false,
            readOnly: true,
            cls: "y-attribute-mapper-form-element",
            emptyText: Ext.ux.getI18N("attribute.mapper.config.hide_attributes_if") + "...",
            store: new Ext.data.SimpleStore({
                data: [
                    [Ext.ux.getI18N("attribute.mapper.config.hide_attributes_none"), Signavio.Const.Template.HIDE_ATTR_NONE],
                    [Ext.ux.getI18N("attribute.mapper.config.hide_attributes_empty"), Signavio.Const.Template.HIDE_ATTR_EMPTY],
                    [Ext.ux.getI18N("attribute.mapper.config.hide_attributes_default"), Signavio.Const.Template.HIDE_ATTR_DEFAULT]
                ],
                fields: [
                    { name: "title" },
                    { name: "value" }
                ]
            }),
            displayField: "title",
            valueField: "value",
            value: attr.options.hideAttributes || Signavio.Const.Template.HIDE_ATTR_DEFAULT,
            width: 400,
            fieldLabel: Ext.ux.getI18N("attribute.mapper.config.hide_attributes_if")
        });
        
        var options = new Ext.Panel({
        	border: false,
        	header: false,
        	layout: "form",
        	anchor: "100%",
            defaultType: "textfield",
            labelWidth: 180,
        	height: 80,
        	cls: "y-attribute-selection y-attribute-selection-bottom",
        	items: [
        	    showAttributeLabel,
        	    hideAttributes
        	]
        });
        
        this.getValue = function() {
            var value = {};
            
            if(custom.getValue()) {
                value = attr.panel.getValue().evalJSON(true);
            }
            
            value.config = {
                selectName: nameOnly.getValue(),
                selectDescription: descriptionOnly.getValue(),
                selectCustom: custom.getValue()
            };
            
            value.options = {
                hideAttributes: hideAttributes.getValue(),
        	    showAttributeLabel: showAttributeLabel.getValue()
            };
            
            value.manager = "Ext.ux.propertyeditor.SingleAttributeConfigurationPanel";
            
            return $H(value).toJSON();
        };
        
        attr.topPanel = configPanel;
        attr.bottomPanel = options;
        
        Ext.ux.propertyeditor.SingleAttributeConfigurationPanel.superclass.constructor.call(this, attr);
    }; 
    
    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager("Ext.ux.propertyeditor.SingleAttributeConfigurationPanel");
    
    Ext.extend(Ext.ux.propertyeditor.SingleAttributeConfigurationPanel, Ext.ux.propertyeditor.AbstractConfigurationPanel, {
    
        getOptions: function() {
            var options = {};
            
            if(this.isSelectName()) {
                options.selectName = [];
            } else if(this.isSelectDescription()) {
                options.selectDescription = [];
            } else if(this.isSelectCustom()) {
                options.selectCustom = [];
            }
            
            return options;
        },
        
        handleChildExpand: function(panel, parent) {
        	if(panel.alreadyExpanded) {
        		return;
        	}
        	
            if(this.isSelectName()) {
                this.selectName(parent, this, true);
            } else if(this.isSelectDescription()) {
                this.selectDescription(parent, this, true);
            } else {
                this.selectCustom(parent, this, true);
            }
        },
        
        createConfiguration: function(conf) {
            conf = conf || {};
            
            this.conf = {
                selectName: !!conf.selectName,
                selectDescription: !!conf.selectDescription,
                selectCustom: !!conf.selectCustom || (!conf.selectName && !conf.selectDescription)
            };
        },
        
        isSelectName: function() {
            return this.conf.selectName;
        },
        
        isSelectDescription: function() {
            return this.conf.selectDescription;
        },
        
        isSelectCustom: function() {
            return this.conf.selectCustom;
        },
        
        isReadonly: function() {
        	return this.isSelectName() || this.isSelectDescription();
        },
        
        updateConf: function(name, description, custom) {
            this.conf.selectName = name;
            this.conf.selectDescription = description;
            this.conf.selectCustom = custom;
        },
        
        selectName: function(panel, self, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectName();
                panel.revertTitle();
                panel.customAttributes = false;
                
                this.updateConf(true, false, false);
            }
        },
        
        selectDescription: function(panel, self, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectDescription();
                panel.revertTitle();
                panel.customAttributes = false;
                
                this.updateConf(false, true, false);
            }
        },
        
        selectCustom: function(panel, self, value) {
            if(value && !panel.customAttributes) {
            	panel.setReadonly(false);
                panel.selectCustom();
                panel.customAttributes = true;
                
                this.updateConf(false, false, true);
            }
        },
        
        extendPanel: function(panel) {
            Ext.ux.propertyeditor.SingleAttributeConfigurationPanel.superclass.extendPanel.call(this, panel);
            
            panel.selectName = panel.execute.bind(this, "selectName");
            panel.selectDescription = panel.execute.bind(this, "selectDescription");
            panel.selectCustom = panel.execute.bind(this, "selectCustom");
        },
        
        extendGrid: function(grid) {
            if(!grid.extended) {
                Ext.ux.propertyeditor.SingleAttributeConfigurationPanel.superclass.extendGrid.call(this, grid);
                
                grid.selectName = this.checkIfContained.bind(this, IDENTIFIERS.NAME, grid);
                grid.selectDescription = this.checkIfContained.bind(this, IDENTIFIERS.DESCRIPTION, grid);
                grid.selectCustom = this.checkCustom.bind(this, grid);
            }
            
            return grid;
        },
        
        checkCustom: function(grid) {
        	//console.log("grid each - check custom");
        	
            grid.each(function(record) {
                if(record.get("id") === grid.getNoSelectionID()) {
                    record.set("checked", true);
                } else {
                	record.set("checked", false);
                }
                
                record.set("readonly", false);
            });
        },
        
        checkIfContained: function(whiteList, grid) {
        	//console.log("grid each - check if contained");
        	
            grid.each(function(record) {
                if(whiteList.include(record.get("id"))) {
                    record.set("checked", true);
                } else {
                	record.set("checked", false);
                }
                
                record.set("readonly", true);
            });
        }
    
    });
    
}());
/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Philipp Giese
 *  
 */
 
if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.propertyeditor){ Ext.ux.propertyeditor = {}; }

(function() {
    
    var SEQUENCE_FLOW_ELEMENTS = {
        "http://b3mn.org/stencilset/bpmn1.1#" : [
            "sequence_start",
            "sequence_end",
            "Exclusive_Eventbased_Gateway",
            "FromEventbasedGateway"
        ],
        "http://b3mn.org/stencilset/bpmn2.0#" : [
            "sequence_start",
            "sequence_end",
            "choreography_sequence_start",
            "choreography_sequence_end",
            "Exclusive_Eventbased_Gateway",
            "FromEventbasedGateway",
            "EventbasedGateway"
        ],
        "http://b3mn.org/stencilset/bpmn2.0choreography#": [
            "sequence_start",
            "sequence_end",
            "choreography_sequence_start",
            "choreography_sequence_end",
            "Exclusive_Eventbased_Gateway",
            "FromEventbasedGateway",
            "EventbasedGateway"
        ]
    };
    
    var ACTIVITIES = {
    	"http://b3mn.org/stencilset/bpmn1.1#" : [
            "Task",
            "CollapsedSubprocess",
            "Subprocess"
        ],
    	"http://b3mn.org/stencilset/bpmn2.0#": [
            "Task",
            "CollapsedSubprocess",
            "Subprocess",
            "CollapsedEventSubprocess",
            "EventSubprocess"
	    ]
    };

    var isActivity = function(stencilset, stencil) {
    	var hasActvities = ACTIVITIES[stencilset];
    	
    	if(hasActvities) {
    		return ACTIVITIES[stencilset].include(stencil);
    	}
    	
    	return false;
    };
    
    var isFlowElement = function(stencilset, roles) {
        var connectingStencilsRoles = SEQUENCE_FLOW_ELEMENTS[stencilset];
        var accept = false;
        
        if(connectingStencilsRoles) {
            (roles || []).each(function(role) {
                if(connectingStencilsRoles.include(role)) {
                    accept = true;
                    
                    throw $break;
                }
            });
        }
        
        return accept;
    };
    
    Ext.ux.propertyeditor.AbstractConfigurationPanel.registerManager("Ext.ux.propertyeditor.StencilConfigurationPanel");
    
    Ext.ux.propertyeditor.StencilConfigurationPanel = function(attr) {
        attr = attr || {};
        
        this.createConfiguration(attr.buttonConf);
        
        var selectAll = this.getRadio({
            fieldLabel: Ext.ux.getI18N("attribute.mapper.config.all_elements"),
            checked: this.isSelectAll(),
            listeners: {
                check: this.selectAll.bind(this, attr.panel)
            }
        });
        
        var selectFlowElements = this.getRadio({
        	fieldLabel: Ext.ux.getI18N("attribute.mapper.config.flow_elements"),
            checked: this.isSelectFlow(),
            listeners: {
                check: this.selectFlow.bind(this, attr.panel)
            }
        });
        
        var selectActivities = this.getRadio({
        	fieldLabel: Ext.ux.getI18N("attribute.mapper.config.activities"),
        	checked: this.isSelectActivities(),
        	listeners: {
        		check: this.selectActivies.bind(this, attr.panel)
        	}
        });
        
        var selectCustom = this.getRadio({
        	fieldLabel: Ext.ux.getI18N("attribute.mapper.config.select_elements"),
            checked: this.isSelectCustom(),
            listeners: {
                check: this.selectCustom.bind(this, attr.panel)
            }
        });
        
        var configPanel = new Ext.Panel({
            anchor: "100%",
            height: 130,
            layout: "form",
            labelWidth: 180,
            cls: "y-attribute-selection y-attribute-selection-top",
            header: false,
            border: false,
            items: [
                selectAll,
                selectFlowElements,
                selectActivities,
                selectCustom
            ]        
        });
        
        this.getValue = function() {
            var value = {};
            
            if(selectCustom.getValue()) {
                value = attr.panel.getValue().evalJSON(true);
            }
            
            value.config = {
                allElements: selectAll.getValue(),
                flowElements: selectFlowElements.getValue(),
                activities: selectActivities.getValue(),
                customElements: selectCustom.getValue()
            };
            
            value.manager = "Ext.ux.propertyeditor.StencilConfigurationPanel";
            
            return $H(value).toJSON();
        };
        
        attr.topPanel = configPanel;
        
        Ext.ux.propertyeditor.StencilConfigurationPanel.superclass.constructor.call(this, attr, "Ext.ux.propertyeditor.StencilConfigurationPanel");
    };
    
    Ext.ux.propertyeditor.StencilConfigurationPanel.isAllowedStencil = function(stencilset, stencil, restrictions) {
        if(restrictions.flowElements) {
            return isFlowElement(stencilset, stencil.roles);
        }
        
        if(restrictions.activities) {
        	return isActivity(stencilset, stencil.id);
        }
        
        return true;
    };
    
    Ext.extend(Ext.ux.propertyeditor.StencilConfigurationPanel, Ext.ux.propertyeditor.AbstractConfigurationPanel, {
        
        handleChildExpand: function(panel, parent) {
            if(this.isSelectAll()) {
                this.selectAll(parent, this, true);
            } else if(this.isSelectFlow()) {
                this.selectFlow(parent, this, true);
            } else if(this.isSelectActivities()) {
            	this.selectActivies(parent, this, true);
            } else {
                this.selectCustom(parent, this, true);
            }
        },
        
        /**
         * This method can be called by each panel with a configuration
         * in order to acquire a set-up options object. 
         * 
         * @param config
         * @returns {Object}
         */
        getOptions: function() {
            var options = {};
            
            if(this.isSelectAll()) {
                options.setReadonly = [true];
                options.selectAll = [];
            }
            
            if(this.isSelectFlow()) {
                options.setReadonly = [true];
                options.selectFlow = [];
            }
            
            if(this.isSelectActivities()) {
            	options.setReadonly = [true];
            	options.selectActivities = [];
            }
            
            if(this.isSelectCustom()) {
                options.setReadonly = [false];
                options.selectCustom = [];
            }
            
            return options;
        },
        
        createConfiguration: function(conf) {
            conf = conf || {};
            
            this.conf = {
                allElements: !!conf.allElements,
                flowElements: !!conf.flowElements,
                activities: (typeof conf.activities === "undefined") ? true : conf.activities,
                customElements: conf.customElements || (!conf.allElements && !conf.flowElements && conf.actvities === false)
            };  
        },
        
        updateConfiguration: function(all, flow, activities, custom) {
            this.conf.allElements = all;
            this.conf.flowElements = flow;
            this.conf.activities = activities;
            this.conf.customElements = custom;
        },
        
        selectAll: function(panel, that, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectAll();
                panel.customAttributes = false;
                
                this.updateConfiguration(true, false, false, false);
            }
        },
        
        selectFlow: function(panel, that, value) {
            if(value) {
            	panel.setReadonly(true);
                panel.selectFlow();
                panel.customAttributes = false;
                
                this.updateConfiguration(false, true, false, false);
            }
        },
        
        selectActivies: function(panel, that, value) {
        	if(value) {
        		panel.setReadonly(true);
        		panel.selectActivities();
        		panel.customAttributes = false;
        		
        		this.updateConfiguration(false, false, true, false);
        	}
        },
        
        selectCustom: function(panel, that, value) {
            if(value && !panel.customAttributes) {
            	panel.setReadonly(false);
                panel.selectCustom();
                panel.customAttributes = true;
                
                this.updateConfiguration(false, false, false, true);
            }
        },
        
        isSelectAll: function() {
            return this.conf.allElements;
        },
        
        isSelectFlow: function() {
            return this.conf.flowElements;
        },
        
        isSelectActivities: function() {
        	return this.conf.activities;
        },
        
        isSelectCustom: function() {
            return this.conf.customElements;
        },
        
        isReadonly: function() {
        	return this.isSelectAll() || this.isSelectFlow() || this.isSelectActivities();
        },
        
        extendPanel: function(panel) {
            Ext.ux.propertyeditor.StencilConfigurationPanel.superclass.extendPanel.call(this, panel);
            
            panel.selectAll = panel.execute.bind(this, "selectAll");
            panel.selectFlow = panel.execute.bind(this, "selectFlow");
            panel.selectActivities = panel.execute.bind(this, "selectActivities");
            panel.selectCustom = panel.execute.bind(this, "selectCustom");
        },
        
        extendGrid: function(grid) {
            if(!grid.extended) {
                Ext.ux.propertyeditor.StencilConfigurationPanel.superclass.extendGrid.call(this, grid);
                
                grid.selectAll = grid.changeAllValues.bind(this, "checked", true, true);
                grid.selectFlow = this.selectFlowElements.bind(this, grid);
                grid.selectActivities = this.selectActivites.bind(this, grid);
                grid.selectCustom = grid.changeAllValues.bind(this, "checked", true);
            }
            
            return grid;
        },
        
        selectActivites: function(grid) {
        	grid.each(function(record) {
    			record.set("checked", isActivity(record.get("stencilset"), record.get("stencil")));
        		record.set("readonly", true);
        	});
        },
        
        selectFlowElements: function(grid) {
            grid.each(function(record) {
                record.set("checked", isFlowElement(record.get("stencilset"), record.get("roles")));
                record.set("readonly", true);
            });
        }
        
    });

}());
/**
 *  (c) 2014 Signavio GmbH
 *
 *  @author Christian Wiggert
 *
 *  UX is a shared javascript library which provides common
 *  functionalities for all applications in the Signavio Process Editor
 *
 */

(function() {
    // contains some adjustments to the included prototype libraries


    if (Prototype.Browser.WebKit || Prototype.Browser.IE) Object.extend(String.prototype, {
        // fix for Prototype bug
        escapeHTML: function() {
            return this.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g, '&quot;');
        },
        unescapeHTML: function() {
            return this.stripTags().replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&quot;/g, '"').replace(/&amp;/g,'&');
        }
    });

    if (Prototype.Browser.Gecko) {
        var escapeHTML = String.prototype.escapeHTML;
        var unescapeHTML = String.prototype.unescapeHTML;
        // in case of FF the escaping / unescaping is handled differently but didn't consider quotes
        // however, escaping quotes is usefull when the string is used as an attribute value
        Object.extend(String.prototype, {
            escapeHTML: function() {
                var content = escapeHTML.call(this);
                return content.replace(/"/g, '&quot;');
            },
            unescapeHTML: function() {
                var content = this.replace(/&quot;/g, '"');
                return unescapeHTML.call(content);
            }
        }); 
    }
})();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand, Willi Tscheschner
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { window.Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }

new function() {
    
    Ext.ux.Richtext = {
            
        /**
         * A list of the allowed tag names
         */
        _allowedNodes : $w("blockquote span div img p font h1 h2 h3 hr li ul ol b i u br a"),
        
        /**
         * A list of the allowed attribute names
         */
        _allowedAttributes : $w("href style caption width src"),
        
        /**
         * A list of the allowed css attribute names
         */
        _allowedCSSAttributes : $w("color font-size font-weight text-align margin-left background background-color"),
        
        /**
         * A list of the attribute names defining styles which are not css attributes
         */
        _styleAttributes : $w("color size fontWeight align"),
        
        /**
         * A map of style attribute names and valid css tags
         * maps css tag -> style tag
         */
        _mappedStyles : $H({
            color       : "color",
            size        : "font-size",
            fontWeight  : "font-weight",
            align       : "text-align"
        }),
        
        /**
         * A list of all attributes which imply a line break
         */
        _blockAttributes : $w("h1 h2 h3 hr li br div blockquote"),

        /**
         *  A list of all tags that have content length 0 but imply length 1
         */ 
         _forceSingleSpaceContent : $w("img"),

        /**
         * A list of all list attributes
         */
        _listAttributes : $w("ul ol"),

        /**
         * A list of attributes which cannot have text content
         */
        _emptyAttributes : $w('hr br img'),
        
        /**
         * A map of valid css font sizes to transform the size attribute 
         */
        _fontSizes : $w("8px 10px 12px 16px 18px 24px 32px 48px"),
        
        /**
         * A map of tag names, which should be used instead
         */
        _nodeMapping: {
            "#comment"      : "#text",
//              "span"          : "font",
            "p"             : "div",
            "blockquote"    : "div",
            "strong"        : "b",
            "em"            : "i"
        },
        
        _encodeNodeMapping : {
            "div"           : "blockquote"
        },

        _blockquoteMargin : "40px",

        /**
         * Encodes the given text with the richtext attributes provided in a json
         * @param {String} text The given text to encode
         * @param {Object[]} format The richtext attributes
         * @returns {String} The formatted text with proper escaped text content
         */
        encode : function(text, format) {
            // If no text is provided, return
            if ("string" !== typeof text) { return; }
            text = text.replace(/[\r]/g, ""); // Replace all \r, becuase of Opera is added those to the string
            
            
            if ("undefined" === typeof format) {
                // If no format is defined, just return the escaped text
                return this._encode(text, []);
            } else if ("string" === typeof json) {
                // If the format is given as a string, try to parse it to an array
                try {
                    format = Ext.decode(format);
                } catch(e) {
                    // If it's not possible to parse the string, just return the escaped text
                    return this._encode(text, []);
                }
            }
            
            // Clone the format object
            if (format instanceof Array){
                format = format.map(function(r){ return Object.clone(r); });
            } else {
                return this._encode(text, []);
            }
            
            // Copy
            //format = Ext.decode(Ext.encode(format));
            
            format.filter(function(f) {
                return this._blockAttributes.include(f.tag);
            }.bind(this))
            // Get all end positions
            .pluck("to")
            // Sort
            .sortBy(function(pos) {
                return Number(pos);
            })
            // Remove new lines at the given positions
            .each(function(pos) {
                if (text.charAt(pos) === "\n") {
                    text = text.substr(0, pos) + text.substr(pos+1);
                }
            });

            //if (!Ext.isIE6 && !Ext.isIE7 && !Ext.isIE8) {
                // Encode the modified text with the given format
                return this._encode(text, format);
//              } else {
//                  var found=0, newlinePositions = [];
//                  format = [].concat(format); // Clone formats
//                  
//                  // Find all \n linefeeds and replace with whitespaces, remember all positions
//                  while(text.indexOf("\n") !== -1) {
//                      found = text.indexOf("\n", found||0);
//                      newlinePositions.push(found);
//                      text = text.substr(0, found) + " " + text.substr(found+1);
//                  }
//                  // Create a new format definition object for each newline and append it to the
//                  // existing format definitions
//                  newlinePositions.reverse().each(function(pos) {
//                      format.push({from:pos, to:pos, tag:"br"});
//                  });
//                  
//                  // Encode the modified text with the given format
//                  return this._encode(text, format);
//              }
            
        },
        
        /**
         * Private function to encode the given text and format
         * @param {String} text The given text to encode
         * @param {Object[]} format the richtext attributes
         * @returns {String} The formatted text with proper escaped text content
         */
        _encode : function(text, format) {
            
            // Create the root node (helper div)
            var root = document.createElement("div");
            // Add the text to the root node
            root.appendChild(document.createTextNode(text));
            
            var cachedNodes = {};
            // Iterate over all richtext attributes
            
            for (var i = 0, size = format.length; i < size; ++i){
                // The current text position
                var att = format[i],
                    index = {pos:att.from};

                // Get the surrounding node of the current text element
                var node = this.findNode(root, index, att.from === att.to);
                
                if (node) {
                    // check if tag is an allowed node, if not, fall back to div
                    att.tag = this._allowedNodes.include(att.tag) ? att.tag : "div";
                    
                    // Check if the node needs another kind of element being created
                    if ((Ext.isChrome || Ext.isSafari) && att.tag ==="div" && att.style && att.style["margin-left"]) {
                        att.tag = this.getEncodeNodeName(att.tag);
                    }
                    
                    // Create a new node according to the given tag,
                    // cache it because of performance (it is a little faster (around 30%) 
                    // to copy than to create)
                    var newNode = cachedNodes[att.tag];
                    if (!newNode){
                        newNode = cachedNodes[att.tag] = document.createElement(att.tag);
                    }
                    newNode = newNode.cloneNode(false);
                    
                    // Filter all allowed attributes and the style object from the json
                    for (var key in att){
                        if (this._allowedAttributes.include(key) && key !== "style") {

                            // deactivate images is ie7
                            if ((Ext.isIE7 || Ext.isIE6) && att.tag === 'img') {
                                continue;
                            }

                            // If the node is a link, add some attributes for safety
                            if (key === "href") {
                                newNode.setAttribute("target", "_blank");
                                newNode.setAttribute("rel", "external");
                            }

                            // If node is an image
                            // get its absolute URI
                            if (att['tag'] === "img"){
                                if (key === "src") {
                                    att[key] = this.getURIFor(this.parseImageId(att[key]));
                                } else if (key === "caption") {
                                    // hotfix: use IMAGE_CAPTION_ATTRIBUTE attribute instead of caption (HTML-valid)
                                    att[this.IMAGE_CAPTION_ATTRIBUTE] = att['caption'];
                                    key = this.IMAGE_CAPTION_ATTRIBUTE;
                                    delete att['caption'];
                                }
                            }

                            // Append all allowed attributes to the new node 
                            newNode.setAttribute(key, att[key]);
                        }
                    }
                    if ((Ext.isIE8 || Ext.isIE9) && att['tag'] === "img") {
                        this.fixImageWidthInIE89(newNode, att);
                    }
                    
                    // Get a hash map of the valid css attributes
                    var nodeAtts = {};
                    var styleAtts = {};
                    /*
                     * Iterate over all incoming styles and check if they should
                     * be added as a node attribute or a style attribute
                     */
                    $H(att.style).keys().each(function(key) {
                        var validKey;
                        /*
                         * Look-up the key of the entry in the list of the valid css
                         * attributes where the value is the key of the provided style
                         */
                        if (this.isValidCSSAttribute(key)) {
                            /* 
                             * Check if the style attribute should be added as a node attribute
                             * for compatibility issues. This only needs to be done in FF 11 or previous OR supported IE younger than 11
                             */
                            if (this.isNodeAttribute(key)&&(Ext.isIE9 || Ext.isIE10 || (Ext.isFF&&Ext.getBrowserVersion()<12))) {
                                validKey = this.getNodeStyleKey(key);
                                /*
                                 * Push the found key/value pair to the list of the attributes
                                 * which should be added to the node
                                 */
                                var value = att.style[key];
                                if (!value) { return; }
                                
                                // Translate RGB -> HEX for color attributes
                                if (value.startsWith("rgb(")){
                                    value = this.rgb2hex(value);
                                }

                                if (validKey === "size") {
                                    value = this.getValidFontSize(value);
                                }
                                // If the attribute is the font size attribute, look-up the browser-defined font size
                                nodeAtts[validKey] = value;
                            }
                            /*
                             * If the found style attribute should not be added to the node,
                             * keep it as a style attribute.
                             */
                            else {
                                // Add the attribute as a css value
                                styleAtts[key] = att.style[key];
                            }
                        }
                    }.bind(this));

                    // Add the additional style attributes to the node
                    for (var key in nodeAtts){
                        if (Object.prototype[key] !== nodeAtts[key]) {
                            newNode.setAttribute(key, nodeAtts[key]);
                        }
                    }

                    var styleString = this.serializeCSSAttributes(styleAtts);
                    
                    if (styleString) {
                        if (Ext.isIE7 || Ext.isIE6) {
                            newNode.style.setAttribute("cssText", styleString);
                        } else {
                            newNode.setAttribute("style", styleString);
                        }
                    }

                    // add a margin for horizontalrules in IE (similar to --webkit-margin-before)
                    if (Ext.isIE && att.tag === "hr") {
                        newNode.style.setProperty("margin-top", "0.5em");
                        newNode.style.setProperty("margin-bottom", "0.5em");
                    }
                    
                    var tc = this._getTextContent(node),
                        from = tc.length + index.pos,
                        to = from + att.to-att.from;

                    // Slice the text content of the surrounding node
                    var prefix  = tc.slice(0, from);
                    var newText = tc.slice(from, to);
                    var suffix  = tc.slice(to); //((Ext.isIE6 || Ext.isIE7 || Ext.isIE8) && att.tag === "br" ? to+1 : to)

                    // deactivate images ie7
                    if ((Ext.isIE7 || Ext.isIE6) && att.tag === "img") {
                        newNode = document.createElement("div"); // one empty space will be appended below
                    }

                    // Create the new text node
                    if (att.from !== att.to) {
                        // cannot attach an empty space to an img node
                        // the textcontent " " is faked in findNode function
                        // do not use att.tag here, since with disables images, those are represented with empty div
                        if (!this._forceSingleSpaceContent.include(this.getNodeName(newNode))) {
                            newNode.appendChild(document.createTextNode(newText));
                        }
                    }
                    node.nodeValue = prefix;

                    // If the current tag is a non child containing block 
                    // element,append those after all similar elements.
                    if (att.from === att.to && this._emptyAttributes.include(att.tag)){
                        while(node.nextSibling && 1 === node.nextSibling.nodeType &&
                                this._emptyAttributes.include(node.nextSibling.tagName.toLowerCase())) {
                            node = node.nextSibling;
                        }
                    }
                    
                    // Push the new node to the end of the old node
                    node.parentNode.insertBefore(newNode, node.nextSibling);
                    // Push the suffix to the end of the old node
                    node.parentNode.insertBefore(document.createTextNode(suffix), newNode.nextSibling);
                }
            }
            
            // create the image structures for image nodes (div - div with width attribtues - img (+ caption))
            this.fixImages(root);

            // Handle linebreaks differently in ie7 and ie8
            if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
                return root.innerHTML.replace(/[\n\r]/g, "");
            }

            if (Ext.isIE) {
                this.fixIndentationIE(root);
                this.fixTextNodesOnRootLevelIE(root);
            }

            // return the inner HTML of the helper div, convert \n line feeds to xml-valid br tags
            return root.innerHTML
                    .replace(/\n/ig, "<br/>")
                    .replace(/<hr[^>]*>/ig, "<hr/>");
        },

        // IE can only indent blockquote but noch div.
        fixIndentationIE: function(root) {
            var block;
            $A(root.getElementsByTagName("div")).each(function(div) {
                if (div.style && div.style.getAttribute("margin-left")) {
                    div.style.removeAttribute("margin-left");
                    var newBlock = (typeof block === 'undefined') ?
                            document.createElement("blockquote") :
                            block.cloneNode(false);
                    newBlock.style.setAttribute("margin-left", "40px");
                    div.parentNode.insertBefore(newBlock, div);
                    newBlock.appendChild(div);
                }
            });
        },

        // If ie finds two neighboring text nodes on root level, it puts them in one block
        // e.g. when indenting one of them, so both will be indented. Fix thsi.
        fixTextNodesOnRootLevelIE: function(root) {
            var p;
            $A(root.childNodes).each(function(child) {
                // each text node on root level
                if (child.nodeType === 3 && child.textContent !== "") {
                    // remove following br
                    if (child.nextSibling && child.nextSibling.nodeName &&
                            child.nextSibling.nodeName.toLowerCase() === 'br') {
                        root.removeChild(child.nextSibling);
                    }
                    // create a p that encapsulated the text node
                    var newP = (typeof p === 'undefined') ?
                            document.createElement("p") :
                            p.cloneNode(false);
                    root.insertBefore(newP, child);
                    newP.appendChild(child);
                }
            });
        },

        /**
         * Returns the unescaped text content of the node
         * @param {HTMLElement} node
         * @returns {String}
         */
        _getTextContentUnexcaped: function(node){
            return Signavio.Utils.unescapeHTML(node.textContent||node.nodeValue||"");
        },

        /**
         * Returns the plain, untouched text content of the node as the browser returns it
         * @param {HTMLElement} node
         * @returns {String}
         */
        _getTextContent: function(node){
            return node.textContent||node.nodeValue||"";
        },

        /**
         * Decodes a given Node to a json array
         * @param {HTMLElement} root The node to decode
         * @param @private {Object} length for internal use only
         * @param @private {Object[]} res for internal use only
         * @returns {JSON[]}
         */
        decode : function(root) {
            
            var format = [],
                text;

            // Check if the given root is a html element
            if (root && 1 === root.nodeType) {
                // Use a working copy for the decode
                root = root.cloneNode(true);
                // remove style elements
                $A(root.getElementsByTagName("style")).each(function(node) {
                    node.parentElement.removeChild(node);
                });

                // Strip all illegal line breaks
                var inHTML = root.innerHTML
                    // first replace line breaks between two words with one space
                    .replace(/([^\s<>]){1}(\n)+([^\s<>]){1}/g, function(match, g1, g2, g3) {
                        return g1.concat(" ", g3);
                    })
                    // finally strip the remaining line breaks
                    .replace(/\n/ig, "");

                root.innerHTML = inHTML;

                // Bring img containers to correct format and set an empty space as innerHTML
                // to give it length 1 in format string
                var that = this;
                $A(root.getElementsByTagName("img")).each(function(imgNode) {
                    that.compressImageStructure(imgNode);
                });

                // Get the plain text
                text = this._getTextContent(root);
            } else {
                // If root is not a HTMLElement, just return the text without any format
                return {text: String(root), format: format};
            }

            // Remember all positions for line breaks
            this.insertBreaks = new Hash();
            
            // Get the decoded node
            this._decode(root, {pos : 0}, format);

            // for each img in format, add an emptyspace manually
            format.each(function (ea) {
                if (ea.tag === "img") {
                    text = text.substr(0,ea.from) + " " + text.substr(ea.from);
                }
            });

            format = this.convertNonStandardCSSAttributes(format);
            
            // Remove all forbidden/unneeded nodes
            format = format.findAll(function(node){

                // Convert spans to other tags
                this.convertSpanTag(node);
                
                // If a style is defined
                if (node.style) {
                    // Filter all forbidden style attributes
                    // TODO: check specifically allowed attributes for each node
                    node.style = this.getValidStyles(node.style);
                }
                
                // handle empty div containers as br
                if (node.tag === "div" && node.from === node.to){
                    node.tag = "br";
                }
                
                // Remove all divs which have no style, remove them from the list of breaks as well
                if (node.tag === "div" && (!node.style || Object.keys(node.style).length === 0 ||
                        // this construct will only be able when pasing powerpoint into internet explorer, and should be deleted
                        (Object.keys(node.style).length === 1 && node.style["text-align"] == "left"))) {
                    if (this.insertBreaks[node.to].include("div")) {
                        this.insertBreaks[node.to].remove("div");
                    }
                    return false;
                }
                
                // Filter spans without any style attributes
                if (["span"].include(node.tag) && !node.style) {
                    return false;
                }
                
                // Filter all non-block elements which have no content and no style definition
                if (["font", "span", "b", "i", "u", "h1", "h2", "h3"].include(node.tag) && node.from === node.to) {
                    return false;
                }
                
                return true;
            }.bind(this));
            
            // Get all positions of elements which force a line break
            var insertBreakPositions = [];
            for (var key in this.insertBreaks) {
                if (!isNaN(Number(key))) {
                    insertBreakPositions.push(Number(key));
                }
            }
            
            // Sort them ascending
            insertBreakPositions.sortBy(function(pos) {
                return Number(pos);
            })
            // Invert range
            .reverse()
            // Insert new line for each block element
            .each(function(pos) {
                text = text.substr(0, pos) + "\n".times(this.insertBreaks[pos].length) + text.substr(pos);
            }.bind(this));

            return {text: text, format: format};
        },
        
        /**
         * Private function to actually decode a given root
         * @param {HTMLElement} root The node to decode
         * @param {Object} length The current position of the carret, must be an object to be altered without return
         * @param {Object[]} res The result set
         * @returns The decoded node as {text:text, format:format}
         */
        _decode : function(root, length, res) {

            // Unify the DOM in all browsers
            this.unifyRootStructure(root);
            
            $A(root.childNodes).each(function(node) {
                if (!node) { return; }
                
                if ("undefined" === typeof length) { length = {pos : 0}; }
                if ("undefined" === typeof res) {
                    res = [];
                }
                
                // Get the name of the node
                var nN = this.getNodeName(node);
                
                if (node.nodeType === 1) {
                    // only allow a certain set of tags
                    // Fix IE: inserts two hr tags, one with id set to string null
                    if (this.isAllowedNode(nN) && node.getAttribute('id') !== 'null') {
                        var contentLength = this._forceSingleSpaceContent.include(nN) ?
                            1 : // images get length 1 but can't have text content, adjust manually
                            this._getTextContent(node).length;
                        contentLength += node.getElementsByTagName("img").length; // add an empty space per image
                        // Generate the representation of the tag for the json
                        var rep = {
                                from: length.pos,
                                to  : length.pos + contentLength,
                                tag : nN
                            };
                        
                        // insert breaks for blockAttributes
                        if (this._blockAttributes.include(nN)) {
                            // initialize
                            if (!this.insertBreaks[rep.to]) {
                                this.insertBreaks[rep.to] = [];
                            }
                            // don't insert breaks for div tags (and those mapped to them) that exclusively contain one blockAttribute
                            // Fix for Chrome, who sometimes unneccessarily wraps block attributes in div container
                            if (!(nN === "div" && node.childNodes.length === 1 &&
                                    this._blockAttributes.include(this.getNodeName(node.firstChild)))) {
                                this.insertBreaks[rep.to].push(nN);
                            }
                        }
                        
                        // Get the attributes of the node
                        var attributes = $A(node.attributes);

                        // Prepare a json to store style information
                        var style = {};
                        
                        var styleAttribute = attributes.find(function(att) {
                            return this.isStyle(att.nodeName);
                        }.bind(this));
                        
                        // If a style attribute exists, serialize it
                        if (styleAttribute) {
                            Ext.apply(style, this.getStyleFromString(styleAttribute.nodeValue));
                        }
                        
                        // Check all other attributes if they need to be serialized
                        attributes.without(styleAttribute).each(function(att) {

                            // Get the attribute name
                            var aN = att.nodeName.toLowerCase();

                            // If the given attribute is permitted to save
                            if (this.isAllowedAttribute(aN) && !this.isLinkAttribute(aN)) {
                                rep[aN] = att.nodeValue;
                            } else if (this.isLinkAttribute(aN)) {
                                // Filter all javascript functions or null characters.
                                rep[aN] = att.nodeValue.replace(/[\0]/ig, "").replace(/(javascript:)(.*)/ig, "$2");
                            }
                            // If the given attribute is a style attribute
                            else if (this.isStyleAttribute(aN)) {
                                var styleObject = this.getCSSPair(att);
                                if (styleObject.key && styleObject.value) {
                                    /*
                                     *  Overwrites existing style attributes because it can be taken for granted that
                                     *  dedicated style attributes are newer than any definitions in the style attribute.
                                     */
                                    style[styleObject.key] = styleObject.value;
                                }
                            }
                        }.bind(this));
                        
                        
                        if (nN === "span" && style && (style["background"] || style["background-color"])){
                            this.handleHiliteColor(style);
                        }
                        
//                          var additionalRepresentations = [];
//                          // Check for text background
//                          if (nN === "span") {
//                              var hiliteRep = this.handleHiliteText(rep, style);
//                              if (hiliteRep) {
//                                  additionalRepresentations.push(hiliteRep);
//                              }
//                          }
                        
                        // If in chrome, handle indention separately
                        if ((Ext.isChrome || Ext.isSafari) && nN === "div") {
                            this.handleIndentText(style);
                        }
                        // standardize margin-left, if larger than 1
                        if (style["margin-left"]) {
                            if (parseInt(style["margin-left"]) > 0) {
                                style["margin-left"] = this._blockquoteMargin;
                            } else {
                                delete style["margin-left"];
                            }
                        }

                        // If styles exist, add them to the serialization
                        if ($H(style).keys().length > 0) {
                            rep["style"] = style;
                        }

                        res.push(rep);

                        // Add additional representations after the current one
//                          additionalRepresentations.each(function(r) {
//                              res.push(r);
//                          });
                        if (this._forceSingleSpaceContent.include(nN)) {
                            length.pos += 1; // img nodes have length 1 but no text content, adjust manually
                        }
                    }
                    
                    // Go recursively 
                    this._decode(node, length, res);
                    
                } else if (node.nodeType === 3) {
                    length.pos += (node.textContent||node.nodeValue||"").length;
                }
            }.bind(this));
        },

        convertNonStandardCSSAttributes: function (format) {
            var newFormat = format.clone(),
                i = 0;
            format.each(function (ea) {
                if (ea.tag === "span" && ea.style) {
                    if (ea.style["font-style"] === "italic") {
                        newFormat.splice(i+1, 0, { "tag" : "i", "from" : ea.from, "to" : ea.to });
                        i += 1;
                    }
                }
                i += 1;
            });
            return newFormat;
        },
        
        
        /**
         * 
         * @param node
         */
        convertSpanTag: function(node){
            if (node.tag === "span"){
                var style = $H(node.style);
                if (style.keys().length === 1){
                    // IF <span style="font-weight:bold;">...  use   <b>
                    if (node.style["font-weight"] === "bold"){
                        delete node.style;
                        node.tag = "b";
                    
                    // IF <span style="font-style:italic;">...  use   <i>
                    } else if (node.style["font-style"] === "italic"){
                        delete node.style;
                        node.tag = "i";
                        
                    // IF <span style="color:#..;">...  use   <font style...
                    } else if (node.style["color"]){
                        node.tag = "font";
                    }
                }
            }
            return node;
        },
        
        /**
         * Unifies the structure of the given node to be the same in all browsers
         * @param {HTMLElement}root
         */
        unifyRootStructure : function(root) {
            if (!root) { return; }
            $A(root.childNodes).each(function(node) {
                if (!node || node.nodeType !== 1) { return; }

                var nN = this.getNodeName(node); // translated node name (p becomes div)
                var actualNN = node.nodeName.toLowerCase(); // real node name (p stays p)

                // Remove the last br inside the div
                if (nN === "div" && this.isLastChildBR(node)) {
                    node.removeChild($A(node.childNodes).last());
                // Add a br at the end of p nodes, which will become div nodes but are handeled diffrently by browsers
                } else if (actualNN === "p" && !this.isLastChildBlockElement(node) && !this.isNodeFollowedByBlockElement(node) &&
                    !this.isLastChildInIntention(node)) {
                    node.appendChild(document.createElement("br"));
                }
                // We also remove the last <br> from each <li> (unneccessarily created, since <li> is a _blockElement)
                if (nN === "li" && this.isLastChildBR(node)){
                    node.removeChild(node.lastChild);
                }
                // insert a <br> between Chromes textnodes on root level (or wrapped in i, b, font) & following div node
                if ((Ext.isChrome || Ext.isSafari) && nN === "div" && node.previousSibling &&
                        // add br if div follows a {span img p font b i u a} (aka, do not add if anything else) 
                        !this._blockAttributes.include(this.getNodeName(node.previousSibling)) &&
                        !["ul", "ol"].include(this.getNodeName(node.previousSibling))) {
                    root.insertBefore(document.createElement("br"), node);
                }
                // insert breaklines in chrome between common divs containing text/html
                if ((Ext.isChrome || Ext.isSafari) && nN === "div" && actualNN !== "blockquote" && actualNN !== "p" &&
                        !node.getAttribute("align") && node.nextSibling &&
                        this._blockAttributes.without("br").include(this.getNodeName(node.nextSibling)) &&
                        // During later processing, empty divs will be handeled as br. Do not need to extra add a br.
                        node.innerHTML &&
                        // dont add a br before div containing list first
                        !(node.nextSibling && this._listAttributes.include(this.getNodeName(node.nextSibling.firstChild))) &&
                        // dont add a br after div with last element list
                        !(this._listAttributes.include(this.getNodeName(node.lastChild))) &&
                        // dont add a br after div with last element indention
                        (node.lastChild.nodeName.toLowerCase() !== 'blockquote')) {
                    root.insertBefore(document.createElement("br"), node.nextSibling);
                }
                // Emtpy blockquotes in chrome usually contain a <br>. blockquotes without innerHTML are useless remains, remove those.
                if ((Ext.isChrome || Ext.isSafari) && actualNN === "blockquote" && !node.innerHTML) {
                    node.parentNode.removeChild(node);
                }
            }.bind(this));

        },
        
        /**
         * Serializes a given object representing css-styles
         * @param {Object} attributes
         * @returns {String} The serialized object
         */
        serializeCSSAttributes : function(atts) {
            var styleString = "";
            $H(atts).keys().each(function(key) {
                if (atts[key]) {
                    var value = atts[key];
                    if (value.startsWith("rgb(")) {
                        // use RGB->HEX colors
                        value = this.rgb2hex(value);
                    }
                    styleString += key+":"+value+";";
                }
            }.bind(this));
            return styleString;
        },
        
        handleHiliteColor : function(style) {
            var key = (style["background-color"] ? "background-color" : "background");
            style[key] = this.rgb2hex($A(style[key].split("rgb")).last());
        },
        
        /**
         * Checks if the given font node has a background defined, if so, strip it from the definition and create
         * a separate representation
         * @param @callByReference {Object} style
         * @returns {rep}
         */
        handleHiliteText : function(rep, style) {
            var spanRep;
            if (style && (style["background-color"] || style["background"])) {
                
                // get the key which should be deleted later
                var delKey = style["background-color"] ? "background-color" : "background";
                
                spanRep = {
                        from: rep.from,
                        to  : rep.to,
                        tag : "span",
                        style : {background : this.rgb2hex($A(style[delKey].split("rgb")).last())}
                    };
                delete style[delKey];
            }
            
            return spanRep;
            
        },
        
        /**
         * Checks if the given div node has a margin, if so, get only the margin-left information, store them and
         * discard the old margin information
         * @param @callByReference {Object} style
         */
        handleIndentText : function(style) {
            if (style && style["margin"]) {
                var value = style["margin"];
                // Get the left part
                value = value.split(" ").last();
                // Set margin left
                style["margin-left"] = value;
                // Delete the old style
                delete style["margin"];
            }
        },
        
        /**
         * Returns the node containing the current text position
         * @param {DOM Node} root The root node
         * @param {Object} index The text position
         * @returns {DOM Node} The node containing the text position
         */
        findNode : function(root, index, isEmpty) {
            var result, cn = root.childNodes;
            
            for (var i = 0, size = cn.length; i < size; ++i){
                var node = cn[i];
                if (node.nodeType === 1){
                    if (this._forceSingleSpaceContent.include(this.getNodeName(node))) {
                        index.pos -= 1;
                    } else {
                        result = this.findNode(node, index);
                        if (result) { return result; }
                    }
                } else if(node.nodeType === 3 && this._getTextContent(node).length) {
                    index.pos -= this._getTextContent(node).length;
                    if (!isEmpty && index.pos < 0 ||
                        isEmpty && index.pos <= 0){
                        return node;
                    }
                }
            }
            return result;
        },
        
        /**
         * Returns a browser compatible font size definition (Number in range 0 to 7)
         * @param {String} fontSize
         * @returns
         */
        getValidFontSize : function(fontSize) {
            // If the font string is malformed, return the default size
            if (!["string", "number"].include(typeof fontSize)) {
                return 2;
            }
            
            if ("number" === typeof fontSize) {
                // If the given font size is in the correct form and a valid font size, return it. else return the default size
                return fontSize > 0 && fontSize < 8 && fontSize || 2;
                
            } else if (fontSize.endsWith("px")) {
                // Parse to Number
                fontSize = fontSize.split("px")[0];
            } else if (fontSize.endsWith("pt")) {
                // Parse to Number
                fontSize = Number(fontSize.split("pt")[0]);
                // Translate from pt -> px
                fontSize *= 4/3;
            } else {
                // If the font size could not be determined, return the default size
                return 2;
            }
            
            var closestFS = 2, distance = Infinity, currDistance;
            // Get the closest defined font size
            this._fontSizes.each(function(size, index) {
                // inline assignment for current distance, inline parsing from string to number
                if ((currDistance = Math.abs(fontSize - Number(size.split("px")[0]))) < distance) {
                    distance = currDistance;
                    closestFS = index;
                }
            });
            // Return the font size
            return closestFS;
        },
        
        /**
         * Get a cleaned up styles object to filter all forbidden style attributes.
         * @param {Array} styles
         */
        getValidStyles : function(styles) {
            var allowedStyles;
            styles = $H(styles||[]).each(function(pair) {
                if (this.isValidCSSAttribute(pair.key)) {
                    var value = this.getValidCSSValue(pair);
                    if (value && value !== "0px" && value !== "0pt") {
                        // Initialize only if a valid css entry was found
                        if (!allowedStyles) {
                            allowedStyles = {};
                        }
                        allowedStyles[pair.key] = value;
                    }
                }
            }.bind(this));
            
            return allowedStyles;
        },
        
        /**
         * Returns true if the given node name is in the list of the allowed tag names
         * @param {String} nodeName The name of the node
         * @returns {Boolean}
         */
        isAllowedNode : function(nodeName) {
            nodeName = (nodeName||"").toLowerCase();
            return this._allowedNodes.include(nodeName);
        },
        
        /**
         * Returns true if the given attribute name is in the list of the allowed attribute names
         * @param {String} attName The name of the attribute
         * @returns {Boolean}
         */
        isAllowedAttribute : function(attName) {
            attName = (attName||"").toLowerCase();
            return this._allowedAttributes.include(attName);
        },

        /**
         * Returns true if the last child of the given node is a block element
         * @param {HTMLElement} node
         * @returns {Boolean}
         */
        isLastChildBlockElement : function(node) {
            if (!node) { return false; }
            
            return this._blockAttributes.include(this.getNodeName($A(node.childNodes).last()));
        },

        isLastChildInIntention: function(node) {
            if (!node) { return false; }

            return (node.parentNode && node.parentNode.lastChild === node) &&
                node.parentNode.nodeName.toLowerCase() === 'blockquote';
        },
        
        /**
         * Returns true if the last child of the given node is a line break
         * @param {HTMLElement} node
         * @returns {Boolean}
         */
        isLastChildBR : function(node) {
            if (!node) { return false; }
            
            return this.getNodeName($A(node.childNodes).last()) === "br";
        },
        
        /**
         * Returns true if the given attribute name is href
         * @param {String} attName The name of the attribute
         * @returns {Boolean}
         */
        isLinkAttribute : function(attName) {
            attName = (attName||"").toLowerCase();
            return attName === "href";
        },
        
        /**
         * Returns true if the given attribute name is an allowed node key
         * @param {String} attName
         * @returns {Boolean}
         */
        isNodeAttribute : function(attName) {
            attName = (attName||"").toLowerCase();
            return this._mappedStyles.values().include(attName);
        },
        
        /**
         * Returns true if the following node after the given one is a block element.
         * @param {HTMLElement} node
         * @returns {Boolean}
         */
        isNodeFollowedByBlockElement : function(node) {
            if (!node) { return false; }
            
            return node.nextSibling && this._blockAttributes.include(node.nextSibling.nodeName.toLowerCase());
        },
        
        /**
         * Returns true if the given attribute is the style attribute.
         * @param {String} attName
         * @returns {Boolean}
         */
        isStyle : function(attName) {
            attName = (attName||"").toLowerCase();
            return attName === "style";
        },
        
        /**
         * Returns true if the given attribute name defines a style
         * @param {String} attName
         * @returns {Boolean}
         */
        isStyleAttribute : function(attName) {
            attName = (attName||"").toLowerCase();
            return this._styleAttributes.include(attName);
        },
        
        /**
         * Returns true if the given attribute name is an allowed css key
         * @param {String} attName
         * @returns {Boolean}
         */
        isValidCSSAttribute : function(attName) {
            attName = (attName||"").toLowerCase();
            return this._allowedCSSAttributes.include(attName);
        },
        
        /**
         * Finds all occurences of br tags in the given string.
         * @param string
         * @returns {{tag : "br", start: Number, end: Number}[]}
         */
        getBreakPositions : function(string) {
            var car, ind = [];
            
            while((car = string.search(/<br[^>]*>/i)) !== -1) {
                ind.push(car);
                // Slice out the <br/> tag
                string = string.slice(car + string.match(/<br[^>]*>/i)[0].length);
            }
            ind.each(function(foo, i) {
                ind[i] += (i > 0 ? ind[i-1] : 0);
            });
            
            return ind;
        },
        
        /**
         * Returns the css representation of the given attribute key
         * @param {String} attName The name of the given attribute
         * @returns {String} The valid css key
         */
        getCSSKey : function(attName) {
            attName = (attName||"").toLowerCase();
            return this._mappedStyles[attName] || this._mappedStyles.get instanceof Function && this._mappedStyles.get(attName);
        },
        
        /**
         * Returns a key/value object with a css compatible key
         * @param {Object} att
         * @returns {Object}
         */
        getCSSPair : function(att) {
            var attName = att.nodeName.toLowerCase();
            // If the given node is a size attribute, handle it differently
            if (attName === "size") {
                return {key: "font-size", value: this._fontSizes[att.nodeValue] || this._fontSizes.get instanceof Function && this._fontSizes.get(att.nodeValue)};
            }

            return {key: this.getCSSKey(attName), value: att.nodeValue};
        },
        
        getMarginLeft : function(att) {
            var value = att.nodeValue;
            
        },
        
        /**
         * Transforms rgb -> hex values and filters expressions
         * @param {String} value
         * @returns {String}
         */
        getValidCSSValue : function(pair) {
            if (!pair) { return; }
            
            if (pair.value.include("expression(")) {
                return;
            }
            if (pair.value.startsWith("rgb(")){
                return this.rgb2hex(pair.value);
            }
            
            if (pair.key === "background") {
                return pair.value.split(/!important(;)?/ig)[0].trim().split(" ").last();
            }
            return pair.value;
        },
        
        /**
         * Returns the valid node attribute key for the given css attribute name. 
         * @param {String} attName
         * @returns {String}
         */
        getNodeStyleKey : function(attName) {
            attName = (attName||"").toLowerCase();
            return this._mappedStyles.keys()[this._mappedStyles.values().indexOf(attName)];
        },
        
        /**
         * Returns a JSON object representing the given style string
         * @param {String} string The style string
         * @returns {JSON}
         */
        getStyleFromString : function(string) {
            var parsedStyle = {};
            if (typeof string === "string" && string.length > 0) {
                // If the style string contains 
                if (!string.endsWith(";")) {
                    string += ";";
                }
                string.split(";").each(function(style) {
                    if (style.length > 0 && style.indexOf(":") !== -1) {
                        var stylePair = style.split(":");
                        var key = stylePair[0].trim(), value = stylePair[1].trim();
                        parsedStyle[key] = value;
                    }
                });
            }
            
            return parsedStyle;
        },
        
        /**
         * Applies style attributes to a string and returns a divString
         * @param {ORYX.Core.Label} label
         * @param {String} value
         * @returns divString
         */
        applyStyleToPlainText : function(label, value, styles) {
            
            // if label.style is set, create div string, else return plain value //
            
            if ("string" === typeof styles) {
                var validText = this.getValidLineFeeds(value);
                //this.getStyle(label);
                return "<div "+ "style='" + styles + "'>" +
                        validText +
                        "</div>";
            } else {
                return value;
            }
        },
        
        /**
         * Returns an array of tspans representing the lines of the given div
         * @param divString
         */
        getTspansFromDiv : function(ownerDocument, divString) {
            
            if (divString !== "" && ownerDocument) {
                var style = divString.split("<div style='")[1].split("'>")[0];
                
                var value = divString.slice(divString.indexOf(">") + 1).split("</div")[0];
                value = this.getValidLineFeeds(value);
                var lines = value.split(/<br\/>/g);
                
                return this.createTspans(lines, style, ownerDocument);
            }
            return [];
            
        },
        
        /**
         * Updates a given divString with the new style attributes
         * @param {String} label The divString
         * @param {String} styles The new style attributes
         * @returns {String} The new divString
         */
        updateStylesOnDiv : function(label, styles) {
            var divString = label.text(), value;
            if (divString !== "") {
                value = divString.replace(/<br\/>/g, "\n").stripTags();
                divString = this.applyStyleToPlainText(label, value, styles);
            }
            label.text(divString);
            label.update(true);
            return divString;
        },
        
        /**
         * Applies the given style value to every given line and returns an array of tspans
         * @param {String[]} lines
         * @param {String} style
         * @returns {tspan[]}
         */
        createTspans : function(lines, style, ownerDocument) {
            return lines.map(function(line) {
                var tspan = ownerDocument.createElementNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
                tspan.nodeValue = line.trim();
                if ("undefined" !== typeof style) {
                    tspan.setAttributeNS(null, 'style', style);
                }
                return tspan;
            });
        },
        
        /**
         * Returns valid xhtml tags for line feeds 
         * @param {String} value The value to escape
         * @returns {String}
         */
        getValidLineFeeds : function(value) {
            return value.replace(/\n/g, "<br/>").replace(/<br[^>]*>/gi, "<br/>");
        },
        
        /**
         * Returns valid xhtml tags for line feeds 
         * @param {String} value The value to escape
         * @returns {String}
         */
        getValidHorizontalRules : function(value) {
            return value.replace(/<hr>/g, "<hr/>");
        },
        
        /**
         * Returns valid xhtml tags for img tags
         * @param {String} value The value to escape,
         *    e.g "<img><img ><img src='foo' />foo<img sr='so/met/hing'>  more</img><div></div>"
         * @returns {String} in the example case
         *    "<img /><img /><img src='foo' />foo<img sr='so/met/hing' />  more<div></div>"
         */
        getValidImages : function(value) {
            return value.replace(/<\/img>/gi, "") // closing tags for img is unneccessary
                .replace(/<img[\s]*>/gi, "<img />") // edgecase: some img nodes do not have any attributes
                .replace(/<img([^>]*[^\/])>/gi, "<img$1 />"); // every other case of non-strict tags
                /*
                 *  /<img       the img node starts with "<img"
                 *  (           
                 *      [^>]*   // there can be anything inside, except for ">" --> in src it is already escaped
                 *      [^/]    // it should not ent on "/" before ">" --> those are already valid imd nodes
                 *  )
                 *  >/          the img node ends with ">"
                */

        },


        /**
         * Returns the hex representation of a color attribute for rgb representations
         * e.g. rgb(255,33,0) returns #ff3300
         * @param {String} rgb The RGB-Value
         * @returns {String}
         */
        rgb2hex: function(rgb){
            var hex = "#"+(rgb.replace(/[^0-9,]/gi, "").split(",").slice(0,3).map(function(n){
                            // RGB to HEX
                            n = Math.max(Math.min(parseInt(n, 10), 255), 0).toString(16);
                            return (n.length === 1 ? "0" : "") + n;
                        }).join(""));
            
            return hex.length === 7 ? hex : rgb;
        },
        
        /**
         * Returns the name of the given node
         * @param {HTMLElement} node
         * @returns {String}
         */
        getNodeName: function(node){
            var name = String(node && node.nodeName||"").toLowerCase();
            if (name && this._nodeMapping[name]){
                return this._nodeMapping[name];
            }
            return name;
        },
        
        /**
         * Returns a mapped name of the given node name
         * @param {String} nodeName
         * @returns {Boolean}
         */
        getEncodeNodeName : function(nodeName) {
            return this._encodeNodeMapping[nodeName] || nodeName;
        },
        
        /**
         * Returns the html string representing the richtexted attribute including a preview stub.
         * @param {String} label The label for classes nstuff 
         * @param {String} innerText The richtexted text
         * @param {Number} length The length of the text after which should be the break
         * @param {Boolean} enablePrint If true renders a link to open the full text in a new window
         * @returns {String} The String representing the html of the richtexted text
         */
        getShortRichtextHtmlFrame : function(label, innerText, maxLength, enablePrint,showPrintButtonWithoutMoreLink, printLabel) {
            printLabel = printLabel || Ext.ux.getI18N("richtext.stub.openprint");
            var hideMoreLink = showPrintButtonWithoutMoreLink || false;
            
            if (innerText.stripTags().length < maxLength && hideMoreLink === false) {
                return innerText;
            }
            
            // If the description is too long, create a truncated version and display options to collapse the text
            else {
            
                // Create a container to iterate over the DOM elements
                var div = document.createElement("div");
                div.innerHTML = innerText;
                
                // Create the container to generate the truncated text
                var target = document.createElement("div");
                var shortText = innerText;
                
                // Append all nodes while the size of the containing
                // text nodes are smaller than the given length.
                if (this.truncateTextNodes(div.childNodes, target, {count:maxLength || 500}) === true){
                    shortText = target.innerHTML + "...";
                }
                
                // Appends the 'more' button
                if (hideMoreLink === true){
                    shortText = innerText;
                } else {
                    shortText = this.appendHTMLToLastNode(shortText, "<span class='y-richtext-more'>(<a href='#' class='y-toggle-more y-toggle-"+label+"'>"+Ext.ux.getI18N("richtext.stub.more")+"</a>)</span>");
                }
                
                // Return a new HTML structure to display the given text with a preview stub, the full text and buttons to expand
                return ["<div class='y-richtext-frame y-richtext-frame-"+label+"'>",
                            "<div class='y-richtext-short-text y-richtext-short-text-"+label+" y-isCollapsed'>",
                                shortText,
                                (enablePrint ? [
                                "<br/><span class='y-richtext-more-"+label+" y-richtext-more'>",
                                    "<a href='#' class='y-new-window-link y-window-"+label+"'>"+printLabel+"</a>",
                                "</span>"].join('') : ""),
                            "</div> ",
                        
                            "<div class='y-richtext-content y-richtext-content-"+label+" y-isHidden'>",
                                innerText,
                                "<span class='y-richtext-more-"+label+" y-richtext-more y-richtext-less'>",
                                    "(<a href='#' class='y-toggle-less y-toggle-"+label+"'>"+Ext.ux.getI18N("richtext.stub.less")+"</a>)<br/>"+
                                        (enablePrint ? "<a href='#' class='y-new-window-link y-window-"+label+"'>"+printLabel+"</a>" : ""),
                                "</span>",
                            "</div>",
                        "</div>"
                       ].join("");
            }
            
            // If the text is short enough
            return innerText;
        },
                    
        /**
         * Returns text nodes to generate a stub of the original text with style attributes according to the desired count.
         * The nodes are prepended to the target.
         * @param nodes
         * @param target
         * @param count
         * @returns {Boolean} Returns TRUE if the target has been the truncated text, otherwise FALSE
         */
        truncateTextNodes : function(nodes, target, count) {
            var result = false;
            $A(nodes).each(function(node) {
                if (node.nodeType === 3) {
                    if (count.count - this._getTextContent(node).length <= 0) {
                        result = true;
                        node.nodeValue = this._getTextContent(node).slice(0, count.count);
                        target.appendChild(node);
                        throw $break;
                    } else {
                        count.count -= this._getTextContent(node).length;
                        target.appendChild(node);
                    }
                } else if (node.nodeType === 1) {
                    if (this.truncateTextNodes(node.childNodes, target.appendChild(node.cloneNode(false)), count) === true) {
                        result = true;
                        throw $break;
                    }
                }
            }.bind(this));
            return result === true;
        },
        
        /**
         * Appends the given html snipped to the last child of text snipped
         * @param text
         * @param html
         * @returns
         */
        appendHTMLToLastNode: function(text, html){
            var node = $j("<div/>").html(text),
                cnode = node.get(0),
                last = cnode.lastChild;
            while (last && 1 === last.nodeType){
                last = last.lastChild;
            }
            if (last){
                last.parentNode.innerHTML = last.parentNode.innerHTML+""+html;
                return node.html();
            } else {
                return text+""+html;
            }
        },

        /**
         * Image Helper
         */

        DEFAULT_IMAGE_WIDTH: '100%',
        IMAGE_CAPTION_ATTRIBUTE: 'data-caption',
        DIV_CAPTION_ATTRIBUTE: 'data-tag',
        RELATIVE_UNIT: '%',
        ABSOLUTE_UNIT: 'px',
        RT_IMAGE_CLASS: 'y-richtext-image',

        /** 
         * Parses an imageId from a relative resouce to the image, the image representation or an absolute href.
         * supported forms - returns ID: /file/ID/content, file/ID/content, /ID, /ID/, ID/content, ID,
         *                  /file/ID, http://[window.location.host]/editor/file/ID/content
         *                  returns "" : http://[some external resource]/[link to some src]
         */
        parseImageId: function(value) {
            if (value === undefined || typeof value !== "string") { return; };
            // handle external files
            if (value.include('http') && !value.include(""+window.location.host)) { return ""; }
            return value.replace(/.*\/?file\//, '').replace(/^\//, '').replace(/\/.*/, '');
        },
        /** Builds the URI around an image id */
        getURIFor: function(id) {
            var origin = window.location.protocol + '//' + window.location.host + this.getFilteredPath(window.location.pathname);
            return origin
                    +'/file/'
                    +id
                    +'/content?inline=true';
        },
        getFilteredPath: function(path) {
            if (!path) return '';
            path = this.getPathWithoutLanguage(path); // fileter the language
            path = path.substring(0, path.lastIndexOf('/')); // filter application ending
            path = this.getPathWithCorrectOrigin(path); // fix the source path
            return path;
        },
        getPathWithoutLanguage: function(path) {
            if (path.substring(path.lastIndexOf('/')).indexOf('_') >= 0) {
                path = path.substring(0, path.lastIndexOf('/'));
            }
            return path;
        },
        getPathWithCorrectOrigin: function(path) {
            // in case of a Sharepoint webpart, use "intra" instead of "intralink" at the end of the origin string
            if (!path) return '';
            if (path.endsWith("intralink")) {
                path = path.substring(0, path.length-4);
            }
            return path;
        },
        /** Builds the img container structure around all images */
        fixImages: function (root) {
            var that = this;
            // fix img Nodes
            $A(root.getElementsByTagName('img')).each(function (ea) { that.fixImage(ea); });
            // remove all divs that are tagged with "caption" but arent nextSibling of an img node
            $A(root.getElementsByTagName('div'))
                .select(function (ea) {return ea.getAttribute(that.DIV_CAPTION_ATTRIBUTE) === 'caption' && !that.isCaption(ea);})
                .each(function (ea) {ea.parentNode.removeChild(ea);});
        },
        /** builds the image structure **/
        fixImage: function (imgNode) {
            var caption = imgNode.getAttribute(this.IMAGE_CAPTION_ATTRIBUTE),
                captionNode = imgNode.nextSibling;
            if (caption) { // if caption given, show it
                if (!this.isCaption(captionNode)) { // no caption node
                    captionNode = document.createElement('div');
                    captionNode.setAttribute(this.DIV_CAPTION_ATTRIBUTE, 'caption');
                    imgNode.parentNode.insertBefore(captionNode, imgNode.nextSibling);
                    captionNode.appendChild(document.createTextNode(caption));
                } else if (Ext.isIE && captionNode.innerText !== caption) { // wrong caption in IE
                    captionNode.innerText = caption;
                } else if (!Ext.isIE && captionNode.textContent !== caption) { // wrong caption otherwise
                    captionNode.textContent = caption;
                } 
            } else if (this.isCaption(captionNode)) { // if no caption given, remove captions that my be below image
                captionNode.parentNode.removeChild(captionNode);
            }
            // restrict the maximum size of images to 100%
            if (!Ext.isIE8) {
                // for IE8 image width handling is done in portal info.js updateRichtextImageWidth()
                // since it cannot handle max-width with percentage
                imgNode.style.setProperty('max-width', '100%');
            }
            // fix for IE and to make sure images do not get funny aspect ratio
            imgNode.removeAttribute("height");
            // add a class 
            imgNode.className = this.RT_IMAGE_CLASS;
            // remove handlebars in IE
            if (Ext.isIE) {
                imgNode.oncontrolselect = function () { return false; };
            }
        },

        fixImageWidthInIE89: function (newNode, att) {
            var key = 'width';
            if ((Ext.isIE8 || Ext.isIE9) && att[key]) {
                newNode.setAttribute(key, att[key]);
            }
        },

        /**
         * Build the outerHTML of an image container
         * @param {object} conf : contains src, width (in mm or %) and caption
         * @returns {String} The HTML of the image container that contains an img node and, if required, a caption div.
         */
        getImageHTML: function(conf) {
            if (!conf.src) { return ''; }
            // uniformation of parameters
            var id = this.parseImageId(conf.src),
                width = conf.width,
                caption = conf.caption || "",
                imgHTML = '';
            // Build the html (<div tag="img"> contains <img> and possibly <div tag="caption">)
            imgHTML += '<br/>';
            imgHTML += '<img src="'+this.getURIFor(id)+'" ';
            imgHTML += 'class="'+this.RT_IMAGE_CLASS+'" ';
            imgHTML += this.IMAGE_CAPTION_ATTRIBUTE+'="'+caption+'"';
            imgHTML += width == undefined ? '' : 'width = "'+width+'"';
            imgHTML += 'style="max-width:100%"';
            imgHTML += '></img>';
            imgHTML += caption ? '<div '+this.DIV_CAPTION_ATTRIBUTE+'="caption">'+caption+'</div>' : '';
            imgHTML += '<br/>';
            return imgHTML;
        },
        /** Removes the container structure around an image to prepare it for serializing */
        compressImageStructure: function (imgNode) {
            if (this.isImage(imgNode)) {
                // make the source relative
                imgNode.setAttribute('src', '/file/'+this.parseImageId(imgNode.getAttribute('src')));
                // workaround, TODO: inform backend and change to IMAGE_CAPTION_ATTRIBUTE there, too.
                imgNode.setAttribute('caption', imgNode.getAttribute(this.IMAGE_CAPTION_ATTRIBUTE))
                imgNode.removeAttribute(this.IMAGE_CAPTION_ATTRIBUTE);
                // make sure the size is a number
                var width = imgNode.getAttribute('width');
                if (width) {
                    var widthType = imgNode.getAttribute('width').endsWith("%") ? "%" : "px",
                        widthValue = parseFloat(imgNode.getAttribute('width'));
                    imgNode.setAttribute('width', widthValue ? widthValue + widthType : this.DEFAULT_IMAGE_WIDTH);
                } else {
                    imgNode.setAttribute('width', this.DEFAULT_IMAGE_WIDTH);
                }
                // remove caption div, if existing
                var captionNode = imgNode.nextSibling;
                if (this.isCaption(captionNode)) {
                    captionNode.parentNode.removeChild(captionNode);
                }
            }
        },
        /** Checks if a node is a caption **/
        isCaption: function (node) {
            if (!node) { return false; }
            if (node.nodeType === 3) { node = node.parentNode; }
            return node && node.tagName && node.tagName.toLowerCase() === 'div' &&
                (node.getAttribute(this.DIV_CAPTION_ATTRIBUTE) === 'caption') &&
                this.isImage(node.previousSibling);
        },
        /** Checks if a node is an image **/
        isImage: function (node) {
            return node && node.tagName && node.tagName.toLowerCase() === 'img';
        },
        /** Gets the resource for a given image id and executes the callback with that source */
        getImgResource: function (id, successClb, failureClb) {
            Ext.Ajax.request({
                url             : Signavio.Config.BACKEND_PATH + '/file/'+id+'/info',
                method          : 'GET',
                requestHeaders: {"Accept":"application/json"},
                success         : function (res) {
                    try { var cont = JSON.parse(res.responseText); }
                    catch (e) { return; }
                    if (typeof successClb === 'function') {
                        successClb({ href: '/file/'+id, rel: 'file', rep: cont });
                    }
                },
                failure         : function () {
                    if (typeof failureClb === 'function') {
                        failureClb();
                    }
                }
            });
        },

        hideCaptions: function (root) {
            var that = this;
            $A(root.getElementsByTagName('div')).select(function (ea) { return ea.getAttribute(that.DIV_CAPTION_ATTRIBUTE) === 'caption';}).each(function (ea) {
                ea.parentNode.removeChild(ea);
            });
        },

        /** Filter width, caption and src from a given image container */
        getImgTags: function (imgNode) {
            var conf = {src: "", widthType: "", width: "", caption: ""};
            if (imgNode) {
                conf.src = imgNode.getAttribute('src');
                conf.width = imgNode.getAttribute('width');
                if (conf.width == undefined) { // null if no width was set, initial status uses the original image size, == is intended
                    conf.width = Ext.ux.Richtext.DEFAULT_IMAGE_WIDTH+""; 
                }
                conf.widthType = conf.width.indexOf(this.RELATIVE_UNIT) >= 0 ? this.RELATIVE_UNIT : this.ABSOLUTE_UNIT;
                conf.width = parseInt(conf.width, 10);
                conf.caption = imgNode.getAttribute(this.IMAGE_CAPTION_ATTRIBUTE);
            }
            return conf;
        },

        /** set the new attributes for img node and caption **/
        updateImage: function (imgNode, conf) {
            if (!imgNode) return;
            // configure the src
            if (conf.src !== undefined) imgNode.setAttribute('src', this.getURIFor(this.parseImageId(conf.src)));
            // configure the width
            if (conf.width !== undefined) {
                imgNode.setAttribute('width', conf.width);
            }
            // configure the caption
            if (conf.caption !== undefined) {
                imgNode.setAttribute(this.IMAGE_CAPTION_ATTRIBUTE, conf.caption);
                this.fixImage(imgNode);
            }
        }
    };
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if(!window.Ext) { window.Ext = {}; }
if(!Ext.ux) { Ext.ux = {}; }
if (!Ext.ux.Richtext) {Ext.ux.Richtext = {}; }

new function() {
	Ext.ux.Richtext.Test = {
			/**
			 * Tests for richtext encode / decode functionality.
			 * A sample text and format json object are used to check if the encoder/decoder output matches the expected values.
			 * 
			 * @param {Boolean} verbose Set true for further information on each test
			 */
			encodeDecode : function(verbose) {
				try {
					var ff36textout = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata \nsajdklasjdklasjkldjlakasdasd\nsadasdsajdlkajsdljdaklsjdkla\nsanctus est Lorem ipsum dolor sit amet.\nDuis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. \n\nUt wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. \nNam liber tempor\ncum soluta nobis\neleifend option conguenihil\nimperdiet doming id quo\nmazim placerat facer possim assum.\nLorem ipsum dolor sit amet, consectetuer\nadipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. \n\nDuis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis. \n";
					var ff36formats = [{"from": 0, "to": 26, "tag": "b"}, {"from": 16, "to": 26, "tag": "font", "style": {"color": "#ff0000"}}, {"from": 26, "to": 28, "tag": "font", "style": {"color": "#ff0000"}}, {"from": 28, "to": 255, "tag": "i"}, {"from": 28, "to": 45, "tag": "font", "style": {"color": "#ff0000"}}, {"from": 257, "to": 285, "tag": "h2"}, {"from": 314, "to": 353, "tag": "h1"}, {"from": 353, "to": 770, "tag": "div", "style": {"margin-left": "40px"}}, {"from": 353, "to": 769, "tag": "span", "style": {"background-color": "rgb(255, 255, 0)"}}, {"from": 486, "to": 511, "tag": "font", "style": {"color": "#ff0000"}}, {"from": 503, "to": 511, "tag": "b"}, {"from": 511, "to": 520, "tag": "b"}, {"from": 771, "to": 1171, "tag": "div", "style": {"margin-left": "80px"}}, {"from": 1171, "to": 1253, "tag": "ol"}, {"from": 1171, "to": 1187, "tag": "li"}, {"from": 1187, "to": 1203, "tag": "li"}, {"from": 1203, "to": 1230, "tag": "li"}, {"from": 1230, "to": 1253, "tag": "li"}, {"from": 1253, "to": 1327, "tag": "ul"}, {"from": 1253, "to": 1287, "tag": "li"}, {"from": 1287, "to": 1327, "tag": "li"}];
					var ff36serialDOM = '<b>Lorem ipsum dolo<font color="#ff0000">r sit amet</font></b><font color="#ff0000">, </font><i><font color="#ff0000">consetetur sadips</font>cing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata</i> <br><h2>sajdklasjdklasjkldjlakasdasd</h2>sadasdsajdlkajsdljdaklsjdkla<br><h1>sanctus est Lorem ipsum dolor sit amet.</h1><div style="margin-left: 40px;"><span style="background-color: rgb(255, 255, 0);">Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis <font color="#ff0000">at vero eros et a<b>ccumsan </b></font><b>et iusto </b>odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. </span><br></div><br><div style="margin-left: 80px;">Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. <br></div><ol><li>Nam liber tempor</li><li>cum soluta nobis</li><li>eleifend option conguenihil</li><li>imperdiet doming id quo</li></ol><ul><li>mazim placerat facer possim assum.</li><li>Lorem ipsum dolor sit amet, consectetuer</li></ul>adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. <br><br>Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis. <br>';
					
					
					
					var root = document.createElement("div");
					root.innerHTML = ('<h1>H1</h1>Normal<br /><b>Bold</b><b></b><br /><i>Italic</i><i></i><br /><i></i><i><b>Bold</b></i><br /><b></b><i></i><hr /><u>UNDERLINE</u><br /><font>RED</font><font></font><b><font>RED</font></b><br /><span style="background-color: rgb(255, 153, 0);"><font>HIGHLIGHTTEXT</font></span><br /><font><span style="background-color: rgb(153, 204, 0);">HIGHLIGHTTEXTWITHTEXTCOLOR</span></font><br /><br /><ol><li>geordnete Liste</li></ol><ul><li>ungeordnete Liste</li></ul>');//.replace(/<br>/ig, "<br/>").replace(/<hr([^>]*)>/ig, "<hr$1/>");
					
					var expectedJSONString = '[{"from": 91, "to": 108, "tag": "ul"}, {"from": 91, "to": 108, "tag": "li"}, {"from": 76, "to": 91, "tag": "ol"}, {"from": 76, "to": 91, "tag": "li"}, {"from": 76, "to": 76, "tag": "br"}, {"from": 76, "to": 76, "tag": "br"}, {"from": 50, "to": 76, "tag": "font"}, {"from": 50, "to": 76, "tag": "span", "style": {"background-color": "rgb(153, 204, 0)"}}, {"from": 50, "to": 50, "tag": "br"}, {"from": 37, "to": 50, "tag": "span", "style": {"background-color": "rgb(255, 153, 0)"}}, {"from": 37, "to": 50, "tag": "font"}, {"from": 37, "to": 37, "tag": "br"}, {"from": 34, "to": 37, "tag": "b"}, {"from": 34, "to": 37, "tag": "font"}, {"from": 34, "to": 34, "tag": "font"}, {"from": 31, "to": 34, "tag": "font"}, {"from": 31, "to": 31, "tag": "br"}, {"from": 22, "to": 31, "tag": "u"}, {"from": 22, "to": 22, "tag": "hr"}, {"from": 22, "to": 22, "tag": "i"}, {"from": 22, "to": 22, "tag": "b"}, {"from": 22, "to": 22, "tag": "br"}, {"from": 18, "to": 22, "tag": "i"}, {"from": 18, "to": 22, "tag": "b"}, {"from": 18, "to": 18, "tag": "i"}, {"from": 18, "to": 18, "tag": "br"}, {"from": 18, "to": 18, "tag": "i"}, {"from": 12, "to": 18, "tag": "i"}, {"from": 12, "to": 12, "tag": "br"}, {"from": 12, "to": 12, "tag": "b"}, {"from": 8, "to": 12, "tag": "b"}, {"from": 8, "to": 8, "tag": "br"}, {"from": 0, "to": 2, "tag": "h1"}]';
					var calculated = Ext.ux.Richtext.decode(root);
					var calculatedJSONString = calculated.format.toJSON();
					
					if (expectedJSONString !== calculatedJSONString) {
						console.warn("Calculated JSON String differs from expected JSON String!");
						console.log("expectedJSONString  : ", expectedJSONString);
						console.log("calculatedJSONString: ", calculatedJSONString);
					} else {
						console.info("Calculated JSON String matches expected JSON String");
						if (verbose) console.log("JSONString: ", JSON.parse(expectedJSONString));
					}
					
					var expectedText = "H1NormalBoldItalicBoldUNDERLINEREDREDHIGHLIGHTTEXTHIGHLIGHTTEXTWITHTEXTCOLORgeordnete Listeungeordnete Liste";
					var calculatedText = calculated.text;
					
					if (expectedText !== calculatedText) {
						console.warn("Calculated Text differs from expected Text");
						console.log("expectedText  : ", expectedText);
						console.log("calculatedText: ", calculatedText);
					} else {
						console.info("Calculated Text matches expected Text");
						if (verbose) console.log("Text: ", expectedText);
					}
					
					var expectedNode = root;
					var calculatedNode = document.createElement("div");
					calculatedNode.innerHTML = Ext.ux.Richtext.encode(expectedText, JSON.parse(expectedJSONString));
					
					if (expectedNode.innerHTML.replace(/ xmlns="http:\/\/www.w3.org\/1999\/xhtml"/ig, "") !== calculatedNode.innerHTML.replace(/ xmlns="http:\/\/www.w3.org\/1999\/xhtml"/ig, "")) {
						console.warn("Calculated Node differs from expected Node!");
						console.log("expected node  : ", expectedNode.innerHTML.replace(/ xmlns="http:\/\/www.w3.org\/1999\/xhtml"/ig, ""), expectedNode);
						console.log("calculated node: ", calculatedNode.innerHTML.replace(/ xmlns="http:\/\/www.w3.org\/1999\/xhtml"/ig, ""), calculatedNode);
					} else {
						console.info("Calculated Node matches expected Node");
						if (verbose) console.log(expectedNode, calculatedNode);
					}	
				} catch(e) {
					console.log(e);
					console.log(root.innerHTML);
					console.log(expectedText);
				}
					
			}
	};
}();

/**
 * Class Ext.ux.SlideZone
 * @author Jared Gisin
 * @version $Id: Ext.ux.SlideZone.js 93 2007-12-12 04:41:40Z jaredgisin $
 * @license http://www.opensource.org/licenses/mit-license.php
 * 
 * TODO: make sure slider limits work when snap = 1 or snap < slider width/height
 * TODO: API to dynamically modify the snap 
 * TODO: zone with slider zone responds to click and keypress
 * TODO: API to programatically set slider value with animation
 *
 */

Ext.ux.SlideZone = function(config) {
    Ext.apply(this, config); 
    Ext.ux.SlideZone.superclass.constructor.call(this);
} 

Ext.extend(Ext.ux.SlideZone, Ext.BoxComponent, {
	size: 100,
	sliderSnap: [0],
	type: 'horizontal',
	sliderWidth: 20,
	sliderHeight: 20,
	cls: null,
	minValue: 0,
	maxValue: 100,
	allowSliderCrossing: true,
	value: null,
    defaultAutoCreate : {tag: "div", id: Ext.id() },
    sliders: [],
	  
	onRender: function(ct, position) { 
        //alert('SlideZone onRender');
        Ext.ux.SlideZone.superclass.onRender.call(this,ct,position);
		this.size = this.size instanceof Array ? this.size : [this.size];
		this.minValue = this.minValue instanceof Array ? this.minValue : [this.minValue];
		this.maxValue = this.maxValue instanceof Array ? this.maxValue : [this.maxValue];
		this.sliderSnap = this.sliderSnap instanceof Array ? this.sliderSnap : [this.sliderSnap];

        if(!this.el){
            var cfg = this.getAutoCreate();
            if(!cfg.name){
                cfg.name = this.name || this.id;
            }
            this.el = ct.createChild(cfg, position);
        }
		this.el.addClass('x-slide-zone-' + this.type);
		this.el.addClass(this.cls);
		
		switch(this.type) {
			case 'horizontal':
				this.sliderSize = [this.sliderWidth];
				this.el.applyStyles({width:this.size[0] + 'px'});
				this.el.lowLimit = [this.el.getX()];
				this.el.highLimit = [this.el.getRight()];
				break;
							
			case 'vertical':
				this.sliderSize = [this.sliderHeight]
				this.el.applyStyles({height:this.size[0] + 'px'});
				this.el.lowLimit = [this.el.getY()];
				this.el.highLimit = [this.el.getBottom()];
				break;
							
			case 'area':
				this.sliderSize = [this.sliderWidth, this.sliderHeight];
				this.el.applyStyles({width:this.size[0] + 'px'});
				this.el.applyStyles({height:this.size[1] + 'px'});
				this.el.lowLimit = this.el.getXY();
				this.el.highLimit = [this.el.getRight(), this.el.getBottom()];
				break
		}

		//normalize width/height for slider centering calculations
		var l = this.sliderSize.length;
		for(var i = 0; i < l; i++) {
			this.sliderSize[i] = this.sliderSize[i] % 2 ? this.sliderSize[i] + 1: this.sliderSize[i] 
		}


		var s = this.sliders;
	    this.sliders = new Ext.util.MixedCollection();
	    if(s){
	        this.add.apply(this, s);
	    }

	},

    addSlider: function(slider) {
        this.sliders.push(slider);
    },
	
	add: function(){
		var a = arguments, l = a.length
		for(var i = 0; i < l; i++){
			var el = a[i];
			if (el instanceof Ext.ux.Slider) {
				this.initSlider(el);
				this.sliders.add(el)
			} else if (typeof el == 'object') {
				//initalize new slider and add to the items list
				var s = new Ext.ux.ThumbSlider(el);
				this.initSlider(s);
				this.sliders.add(s)
			}
		}
		this.updateValues();
		this.updateConstraints();
 	},
	
	enableCrossing: function() {
		this.allowSliderCrossing = true;
		this.updateConstraints();
	},
	
	disableCrossing: function() {
		this.allowSliderCrossing = false;
		this.updateConstraints();		
	},
	
	getSlider: function(selector) {
		/* Given a slider index or name, returns a slider object
		 * @selector   slider index|name
		 */
		switch (typeof selector)  {
			case 'number':
				return this.sliders.items[selector];
				break;
				
			case 'string':
				var l = this.sliders.length;
				for(var i = 0; i < l; i++){
					if(this.sliders.items[i].name ==  selector) return this.sliders.items[i];
				}
				break;
		}
	},


	updateConstraints: function() {
		if(!this.allowSliderCrossing && this.sliders.length > 1 && this.type != 'area') {
			// multiple sliders exists and sliders can't cross,
			// so we have to take into account the
			// positions of all sliders
			sortFN = function(a,b){
				var v1 = a.value instanceof Array ? a.value[0] : a.value;
				var v2 = b.value instanceof Array ? b.value[0] : b.value;
	            return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
			}
			this.sliders.sort('asc',sortFN);//put in order by their value
			
			var l = this.sliders.length; 
			for (var i=0; i< l; i++) { //forloop required, as we have to get -1 and +1 slider positions
				var leftTravel = 0, rightTravel = 0;
				var sliderL = this.sliders.get(i-1);
				var slider = this.sliders.get(i);
				var sliderR = this.sliders.get(i+1);

				
				if (sliderL && sliderR) {
					if (sliderL instanceof Ext.ux.ThumbSlider) {
						var leftTravel = slider.getTL()[0] - sliderL.getTL()[0] - this.sliderSnap[0];
					}
					if (sliderL instanceof Ext.ux.RangeSlider) {
						var leftTravel = slider.getTL()[0] - sliderL.getBR()[0] - this.sliderSnap[0];					
					}
					if (sliderR instanceof Ext.ux.ThumbSlider) {
						var rightTravel = sliderR.getTL()[0] - slider.getTL()[0] - this.sliderSnap[0];	
					}
					if (sliderR instanceof Ext.ux.RangeSlider) {
						var rightTravel = sliderR.getTL()[0] - slider.getBR()[0] - this.sliderSnap[0] ;							
					}
				} else if(sliderL) {
					if (sliderL instanceof Ext.ux.ThumbSlider) {
						var rightTravel = this.el.highLimit[0] - slider.getTL()[0] - ( 0.5 * this.sliderSize[0]) ;	
						var leftTravel = slider.getTL()[0] - sliderL.getTL()[0] - this.sliderSnap[0];
					}
					if (sliderL instanceof Ext.ux.RangeSlider) {
						var rightTravel = this.el.highLimit[0] - slider.getBR()[0];	
						var leftTravel = slider.getTL()[0] - sliderL.getBR()[0] - this.sliderSnap[0];
					}
				} else if(sliderR) {
					if (sliderR instanceof Ext.ux.ThumbSlider) {
						var leftTravel = slider.getTL()[0] - this.el.lowLimit[0] + ( 0.5 * this.sliderSize[0]);
						var rightTravel = sliderR.getTL()[0] - slider.getTL()[0] - this.sliderSnap[0] ;
					}
					if (sliderR instanceof Ext.ux.RangeSlider) {
						var leftTravel = slider.getTL()[0] - this.el.lowLimit[0];
						var rightTravel = sliderR.getTL()[0] - slider.getBR()[0] - this.sliderSnap[0] ;					
					}
				}
				if(slider instanceof Ext.ux.RangeSlider) {
					slider.resizable.leftTravel = [leftTravel];
					slider.resizable.rightTravel = [rightTravel];
				}
				slider.setConstraint([leftTravel], [rightTravel], this.sliderSnap);
			}
		} else {
			var l = this.sliders.length;
			for (var i=0; i< l; i++) {
				var slider = this.sliders.get(i);
				if (slider instanceof Ext.ux.ThumbSlider ) {
					slider.setConstraint([slider.getTL()[0]-this.el.lowLimit[0]  + ( 1/2 * this.sliderSize[0]),
										  slider.getTL()[1]-this.el.lowLimit[1]  + ( 1/2 * this.sliderSize[1])], 
								[this.el.highLimit[0]- (slider.getTL()[0] + this.sliderSize[0]) + ( 1/2 * this.sliderSize[0]),
								 this.el.highLimit[1]- (slider.getTL()[1] + this.sliderSize[1]) + ( 1/2 * this.sliderSize[1]) ],
								this.sliderSnap)
				}
				if (slider instanceof Ext.ux.RangeSlider) {
					slider.setConstraint([slider.getTL()[0] - this.el.lowLimit[0],
										  slider.getTL()[1] - this.el.lowLimit[1]], 
								[this.el.highLimit[0] - slider.getBR()[0],
								 this.el.highLimit[1] - slider.getBR()[1] ],
								this.sliderSnap)				
				}
			}
		}
	},
	
	updateValues: function() {
		var that = this;
		var vals = {};
		this.sliders.each(function(i) {

			if(this.type == 'area') {
				if (i instanceof Ext.ux.ThumbSlider) {
					i.value = [(i.getTL()[0] + 1/2 * that.sliderSize[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0],
							   (i.getTL()[1] + 1/2 * that.sliderSize[1] - that.el.lowLimit[1]) / (that.size[1]) * (that.maxValue[1] - that.minValue[1]) + that.minValue[1]];
					i.percent = [parseFloat((i.getTL()[0]  + 1/2 * that.sliderSize[0] - that.el.lowLimit[0]) / (that.size[0]) * 100),
								 parseFloat((i.getTL()[1]  + 1/2 * that.sliderSize[1] - that.el.lowLimit[1]) / (that.size[1]) * 100)];
				} 
				if (i instanceof Ext.ux.RangeSlider) {
					i.value = [[
								(i.getTL()[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0],
							    (i.getBR()[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0]


							   ],[
								(i.getTL()[1]  - that.el.lowLimit[1]) / (that.size[1]) * (that.maxValue[1] - that.minValue[1]) + that.minValue[1],
							    (i.getBR()[1]  - that.el.lowLimit[1]) / (that.size[1]) * (that.maxValue[1] - that.minValue[1]) + that.minValue[1]
							   ]];
					i.percent = [[
								  parseFloat((i.getTL()[0] - that.el.lowLimit[0]) / (that.size[0]) * 100).toFixed(2),
								  parseFloat((i.getBR()[0] - that.el.lowLimit[0]) / (that.size[0]) * 100).toFixed(2)
								],[
								  parseFloat((i.getTL()[1] - that.el.lowLimit[1]) / (that.size[1]) * 100).toFixed(2),
								  parseFloat((i.getBR()[1] - that.el.lowLimit[1]) / (that.size[1]) * 100).toFixed(2)
								 ]];
				}
			} else {
				if (i instanceof Ext.ux.ThumbSlider) {
					i.value = (i.getTL()[0] + 1/2 * that.sliderSize[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0];
					i.percent = parseFloat((i.getTL()[0]  + 1/2 * that.sliderSize[0] - that.el.lowLimit[0]) / (that.size[0]) * 100);
				} 
				if (i instanceof Ext.ux.RangeSlider) {
					i.value =  [(i.getTL()[0]  - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0],
							   (i.getBR()[0] - that.el.lowLimit[0]) / (that.size[0]) * (that.maxValue[0] - that.minValue[0]) + that.minValue[0]];
					i.percent = [  parseFloat((i.getTL()[0]  - that.el.lowLimit[0]) / (that.size[0]) * 100),
								   parseFloat((i.getBR()[0] - that.el.lowLimit[0]) / (that.size[0]) * 100)];	
				}
			}
			vals[this.name] = this.value;
		});

		this.value = vals;
	},
	
	initSliderPosition: function(slider) {
		/* Sets a sliders's initial position within the slide zone.
		 * If slideZone has a sliderSnap set, the slider 
		 * is positioned at a multiple of the sliderSnap value that is
		 * closest where the slider's value would otherwise position it.
		 * After positioning, the slider's actual value will be modified
		 * in Ext.ux.SlideZone.updateValues()
		 * to jibe with the actual position in the slide zone given the 
		 * sliderSnap constraint.
		 */
		var initialPosition = [0,0];
		slider.repositionDelta = [0,0];
		var l = this.type == 'area' ? 2 : 1;
		for(var i=0; i < l; i++ ) {
			/* Make sure initial value is in slider bar range, 
			   if it's outside, set to closest limit.
			   The slider value is modified if it's out of range. */
			if(slider.value instanceof Array) {
				if (slider instanceof Ext.ux.ThumbSlider) {

					slider.value[i] = Number(slider.value[i]).constrain(this.minValue[i], this.maxValue[i]);
					initialPosition[i] = parseInt((slider.value[i] - this.minValue[i]) / (this.maxValue[i] - this.minValue[i]) * this.size[i] + this.el.lowLimit[i]);
				}
				if (slider instanceof Ext.ux.RangeSlider) {
					switch (this.type) {
						case 'horizontal':
						case 'vertical':
							slider.value[i] = Number(slider.value[i]).constrain(this.minValue[i], this.maxValue[i]);
							initialPosition[i] = parseInt((slider.value[i] - this.minValue[i]) / (this.maxValue[i] - this.minValue[i]) * this.size[i] + this.el.lowLimit[i]);
							break;
						
						case 'area':
							slider.value[i][0] = Number(slider.value[i][0]).constrain(this.minValue[i], this.maxValue[i]);
							slider.value[i][1] = Number(slider.value[i][1]).constrain(this.minValue[i], this.maxValue[i]);
							
							initialPosition[i] = parseInt((slider.value[i][0] - this.minValue[i]) / (this.maxValue[i] - this.minValue[i]) * this.size[i] + this.el.lowLimit[i]);

							break;
					}
				}
			} else {
				slider.value = Number(slider.value).constrain(this.minValue[i], this.maxValue[i]);
				initialPosition[i] = parseInt((slider.value - this.minValue[i]) / (this.maxValue[i] - this.minValue[i]) * this.size[i] + this.el.lowLimit[i]);
			}
			
			/* Calculate slider value versus closest snap-to location,
			   and calculate an offset value to apply when positioning it. */
			if (this.sliderSnap[i] > 1) {
				var positionToSnapDiff = [0,0];
				positionToSnapDiff[i] = (initialPosition[i] - this.el.lowLimit[i]) % this.sliderSnap[i];
				if (positionToSnapDiff[i]) {
					if(positionToSnapDiff[i] < 1/2 * this.sliderSnap[i]) {
						slider.repositionDelta[i] = -positionToSnapDiff[i];
					} else {
						slider.repositionDelta[i] = this.sliderSnap[i] - positionToSnapDiff[i];
					} 
				}
			} 
		}

		if (slider instanceof Ext.ux.ThumbSlider) {
			slider.setPosition([initialPosition[0] + slider.repositionDelta[0] - (0.5 * this.sliderSize[0]),
								initialPosition[1] + slider.repositionDelta[1] - (0.5 * this.sliderSize[1])]);
		}
		if (slider instanceof Ext.ux.RangeSlider) {

			slider.setPosition([initialPosition[0] + slider.repositionDelta[0],
								initialPosition[1] + slider.repositionDelta[1]]);
		}
	},
	
	initSlider: function(slider) {		
		slider.init(this);
		this.initSliderPosition(slider);
	} 

});  


Ext.ux.Slider = function(config) {

	Ext.apply(this, config);
	
	this.addEvents( {
		"dragstart" : true,
		"dragend" : true,
		"drag" : true,
		"mouseover":true, 
		"mouseout":true
	});	
    Ext.ux.Slider.superclass.constructor.call(this);
}

Ext.extend(Ext.ux.Slider, Ext.BoxComponent, {
	value: 0,
	ddEl: null,
	name: null,
	cls: null,
	
	init: function() {
		//Do nothing
	},

	getTL: function() {
		switch(this.type) {
			case 'horizontal':
				return [this.el.getX()];
				break;
				
			case 'vertical':
				return [this.el.getY()];
				break;
				
			case 'area':
				return this.el.getXY();
				break;
		}
	},
	
	getBR: function() {
		switch(this.type) {
			case 'horizontal':
				return [this.el.getRight()];
				break;
				
			case 'vertical':
				return [this.el.getBottom()];
				break;
				
			case 'area':
				return [this.el.getRight(), this.el.getBottom()];
				break;
		}
		
	},
	
	setPosition: function(position) {
		var l = position.length;
		for (i=0; i<l; i++) {
			position[i] = parseInt(position[i]);
		}

		switch(this.type) {
			case 'horizontal':
				this.el.setX(position[0]);
				break;
				
			case 'vertical':
				this.el.setY(position[0]);
				break;
				
			case 'area':
				this.el.setX(position[0]);
				this.el.setY(position[1]);
				break;
		}		
	},
	
	setConstraint: function(low, high, snap) {
		var l = low.length;
		for (i=0; i<l; i++) {
			low[i] = parseInt(low[i] = low[i] < 0 ? 0 : low[i]);
			high[i] = parseInt(high[i] = high[i] < 0 ? 0 : high[i]);				
		}


		switch(this.type) {
			case 'horizontal':
				this.ddEl.setXConstraint(low[0], high[0], snap[0]);
				this.ddEl.setYConstraint(0, 0);
				break;
				
			case 'vertical':
				this.ddEl.clearConstraints();
				this.ddEl.setXConstraint(0, 0);
				this.ddEl.setYConstraint(low[0], high[0], snap[0]);
				break;
				
			case 'area':
				this.ddEl.setXConstraint(low[0], high[0], snap[0]);
				this.ddEl.setYConstraint(low[1], high[1], snap[1]);
				break;
		}		
		this.ddEl.resetConstraints(true);
	}
	

});

Ext.ux.ThumbSlider = function(config) { 
    Ext.apply(this,config);
	Ext.ux.ThumbSlider.superclass.constructor.call(this, config);	
};


Ext.ux.RangeSlider = function(config) {
	Ext.apply(this,config);
	Ext.ux.RangeSlider.superclass.constructor.call(this, config);	
};

Ext.extend(Ext.ux.ThumbSlider, Ext.ux.Slider, {

	//init must be passed an instance of a SliderZone
	init: function(parentSlideZone) {
		this.type = parentSlideZone.type;

		this.pointer = this.type == 'horizontal' ? 'w-resize' : this.type == 'vertical' ? 'n-resize' : 'move';
		
		this.el = Ext.DomHelper.append(parentSlideZone.el,  { 
						tag: 'div', 
						id: Ext.id(),
						style: 'position:absolute;'+
								'overflow: hidden;'
								}, true);
		this.el.addClass('x-thumb-slider-' + this.type);
		this.el.addClass(parentSlideZone.cls);

		this.ddEl = new Ext.dd.DD(this.el); 

		var sliderInstance = this;
		var slideZoneInstance = parentSlideZone;

		this.el.on('mouseover', function() {
			sliderInstance.fireEvent('mouseover', sliderInstance);
			sliderInstance.el.setStyle('cursor', sliderInstance.pointer); 
		}); 
		this.el.on('mouseout', function() { 
			sliderInstance.fireEvent('mouseout', sliderInstance);
			sliderInstance.el.setStyle('cursor', 'default'); 
		}); 
		this.ddEl.onMouseDown = function(x, y) { 
			sliderInstance.fireEvent('dragstart', sliderInstance);
		}; 
		this.ddEl.onMouseUp = function(x, y) { 
			slideZoneInstance.updateConstraints();
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('dragend', sliderInstance)
		}; 
		this.ddEl.onDrag = function(e) { 
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('drag', sliderInstance);
		}; 

		Ext.ux.ThumbSlider.superclass.init.call(parentSlideZone);
	}
});

Ext.extend(Ext.ux.RangeSlider, Ext.ux.Slider, {
	init: function(parentSlideZone) {
		this.type = parentSlideZone.type;
		
		var el = Ext.DomHelper.append(parentSlideZone.el,  { 
						tag: 'div', 
						id: Ext.id(),
						style: 'position:absolute;'+
								'overflow: hidden;'
								}, true);

		//this.el.addClass(parentSlideZone.cls);
		switch(this.type) {
			case 'horizontal':
				var w = Math.abs(this.value[0] - this.value[1]) / (parentSlideZone.maxValue - parentSlideZone.minValue) * parentSlideZone.size;
				var h = parentSlideZone.sliderHeight;
				var handles = 'e,w';
				this.pointer = 'w-resize';
				break;
				
			case 'vertical':
				var w = parentSlideZone.sliderWidth;
				var h = Math.abs(this.value[0] - this.value[1]) / (parentSlideZone.maxValue - parentSlideZone.minValue) * parentSlideZone.size;
				var handles = 'n,s';
				this.pointer = 'n-resize';
				break;
				
			case 'area':
				var w = Math.abs(this.value[0][0] - this.value[0][1]) / (parentSlideZone.maxValue[0] - parentSlideZone.minValue[0]) * parentSlideZone.size[0];
				var h = Math.abs(this.value[1][0] - this.value[1][1]) / (parentSlideZone.maxValue[1] - parentSlideZone.minValue[1]) * parentSlideZone.size[1];
				var handles = 'all';
				this.pointer = 'move';
				break;
		}

		this.resizable = new Ext.Resizable(el, {
			wrap:false,
			pinned:true, 
			width: w,
			height: h,
			minWidth: 20,
			widthIncrement: parentSlideZone.sliderSnap[0],
			heightIncrement: parentSlideZone.sliderSnap[1],
			minHeight: 20,
			dynamic: true,
			handles: handles,
			draggable: true,
			transparent: false,
			constrainTo: parentSlideZone.el,
			leftTravel: null,
			rightTravel: null
		});
		var sliderInstance = this;
		var slideZoneInstance = parentSlideZone;
		
		this.el = this.resizable.el;
		this.el.addClass('x-range-slider-' + this.type);
		this.el.addClass(this.cls);		
		this.ddEl = this.resizable.dd;
		

		this.resizable.on('beforeresize', function() {
			sliderInstance.fireEvent('dragstart', sliderInstance);	
		})
		
		/* Parts of this.resizable.onMouseMove handler taken from:
		 * http://extjs.com/forum/showthread.php?p=23122&highlight=resizable+constrainto#post23122
		 */
		this.resizable.onMouseMove = function( e ) {
				var box = this.constrainTo.getRegion(), tgt = e.getXY();
				//redefine the constraining box if slider crossing resrictions
				if(!parentSlideZone.allowSliderCrossing) {
					if( parentSlideZone.type == 'vertical') {
							box = {left:   box.left,  right:  box.right,
								   top:    this.startBox.y - this.leftTravel[0],
								   bottom: this.startBox.y + this.startBox.height + this.rightTravel[0] }
					}
					if( parentSlideZone.type == 'horizontal') {
							box = {left:   this.startBox.x - this.leftTravel[0],
								   right:  this.startBox.x + this.startBox.width + this.rightTravel[0],
								   top:    box.top, bottom: box.bottom }
					}
				}

				e.xy = [
					tgt[0] - box.left < 0 ? box.left - this.startBox.x + this.startPoint[0] : tgt[0] - box.right > 0 ? box.right - this.startBox.right + this.startPoint[0] : tgt[0],
					tgt[1] - box.top < 0 ? box.top - this.startBox.y + this.startPoint[1] : tgt[1] - box.bottom > 0 ? box.bottom - this.startBox.bottom + this.startPoint[1] : tgt[1]
				];

				Ext.Resizable.prototype.onMouseMove.call(this, e);
				slideZoneInstance.updateValues();
				sliderInstance.fireEvent('drag', sliderInstance);
			};
			
		this.resizable.on('resize', function(width, height) {
			slideZoneInstance.updateConstraints();
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('dragend', sliderInstance);
		})
		
		this.el.on('mouseover', function() {
			sliderInstance.fireEvent('mouseover', sliderInstance);
			sliderInstance.el.setStyle('cursor', sliderInstance.pointer); 
		}); 
		this.el.on('mouseout', function() { 
			sliderInstance.fireEvent('mouseout', sliderInstance);
			sliderInstance.el.setStyle('cursor', 'default'); 
		}); 
		this.ddEl.onMouseDown = function(x, y) { 
			sliderInstance.fireEvent('dragstart', sliderInstance);
		}; 
		this.ddEl.onMouseUp = function(x, y) { 
			slideZoneInstance.updateConstraints();
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('dragend', sliderInstance)
		}; 
		this.ddEl.onDrag = function(e) { 
			slideZoneInstance.updateValues();
			sliderInstance.fireEvent('drag', sliderInstance);
		}; 

		Ext.ux.ThumbSlider.superclass.init.call(parentSlideZone);

	}
});

/** 
 *  (c) 2011 Signavio GmbH
 *   
 *  @author Sven Wagner-Boysen
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */


if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }

new function(){
	
	/**
	 * Class for a generic paging Toolbar. Forced loading callbacks to submit
	 * query and avoid caching from store, as used in the analytics project.
	 * 
	 */
	Ext.ux.PagingToolbar = function(config){
		Ext.ux.PagingToolbar.superclass.constructor.call(this, config);	    
	};

	Ext.extend(Ext.ux.PagingToolbar, Ext.PagingToolbar, {
		/**
		 * Retrieves the total number of items from the first result of the store.
		 */
//		initComponent : function(){
//	        // VARs
//			var fn, payloadPages;
//			
//			Ext.ux.PagingToolbar.superclass.initComponent.call(this);
//			
//	        fn = function(record) {
//	        	return record.data.rel == "payloadPages";
//	        };
//	        
//	        this.store.clearFilter(true);
//	        payloadPages = this.store.queryBy(fn);
//	        
//	        if(payloadPages) {
//	        	this.totalItemCount = payloadPages.data.rep.totalNumberValues;
//	        }
//	        
//	        this.store.resetFilter();
//	    },
		
		
		/**
		 * Retrieves the total number of items from the first result of the store.
		 */
		onLoad: function(store, r, o) {
			// VARs
			var fn, payloadPages;
			
//			if(this.totalItemCount) {
				fn = function(record) {
		        	return record.data.rel == "payloadPages";
		        };
		        
		        this.store.clearFilter(true);
		        payloadPages = this.store.queryBy(fn);
		        
		        if(payloadPages && payloadPages.items.length > 0) {
		        	this.totalItemCount = payloadPages.items[0].data.rep.totalNumberValues;
		        }
		        
		        this.store.resetFilter();
//			}
			
//			Ext.ux.PagingToolbar.superclass.onLoad.apply(this, arguments);
			
			if(!this.rendered){
	            this.dsLoaded = [store, r, o];
	            return;
	        }
			this.cursor = o.params ? o.params[this.paramNames.start] : 0;
			var d = this.getPageData(), ap = d.activePage, ps = d.pages;
			
			this.afterTextEl.el.innerHTML = String.format(this.afterPageText, d.pages);
			this.beforeTextEl.el.innerHTML = String.format(this.beforePageText, ap);
			this.first.setDisabled(ap <= 1);
			this.prev.setDisabled(ap <= 1);
			this.next.setDisabled(ap >= ps);
			this.last.setDisabled(ap >= ps);
			this.loading.enable();
			this.updateInfo();
		},
		
		// private
	    updateInfo : function(){
	        if(this.displayEl){
	            var count = this.store.getCount();
	            var msg = count == 0 ?
	                this.emptyMsg :
	                String.format(
	                    this.displayMsg,
	                    this.cursor+1, this.cursor+count, this.totalItemCount||this.store.getTotalCount()
	                );
	            this.displayEl.update(msg);
	        }
	    },
		
	    /**
	     * Calculate paging toolbar metrics.
	     */
		// private
	    getPageData : function(){
	        var total = (this.totalItemCount||this.store.getTotalCount());
	        return {
	            total : total,
	            activePage : Math.ceil((this.cursor+this.pageSize)/this.pageSize),
	            pages :  total < this.pageSize ? 1 : Math.ceil(total/this.pageSize)
	        };
	    },
	    
	    // private
	    /**
	     * Renders the customized paging toolbar.
	     */
	    onRender : function(ct, position){
	        Ext.PagingToolbar.superclass.onRender.call(this, ct, position);
	        this.first = this.addButton({
	            tooltip: this.firstText,
	            iconCls: "x-tbar-page-first",
	            disabled: true,
	            handler: this.onClick.createDelegate(this, ["first"])
	        });
	        this.prev = this.addButton({
	            tooltip: this.prevText,
	            iconCls: "x-tbar-page-prev",
	            disabled: true,
	            handler: this.onClick.createDelegate(this, ["prev"])
	        });
	        this.addSeparator();
	        this.beforeTextEl = this.addText(String.format(this.beforePageText, 1));
	        this.afterTextEl = this.addText(String.format(this.afterPageText, 1));
	        this.addSeparator();
	        this.next = this.addButton({
	            tooltip: this.nextText,
	            iconCls: "x-tbar-page-next",
	            disabled: true,
	            handler: this.onClick.createDelegate(this, ["next"])
	        });
	        this.last = this.addButton({
	            tooltip: this.lastText,
	            iconCls: "x-tbar-page-last",
	            disabled: true,
	            handler: this.onClick.createDelegate(this, ["last"])
	        });
	        this.addSeparator();
	        this.loading = this.addButton({
	            tooltip: this.refreshText,
	            iconCls: "x-tbar-loading",
	            handler: this.onClick.createDelegate(this, ["refresh"])
	        });

	        if(this.displayInfo){
	            this.displayEl = Ext.fly(this.el.dom).createChild({cls:'x-paging-info'});
	        }
	        if(this.dsLoaded){
	            this.onLoad.apply(this, this.dsLoaded);
	        }
	    }
	});
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" === typeof window.Ext){ window.Ext = {}; }
if ("undefined" === typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" === typeof Ext.ux.Toolbar){ Ext.ux.Toolbar = {}; }

new function(){
	
	/**
	 * Class for a generic toggle Button. Provides functionality to prevent the button from being enabled/disabled
	 * 
	 */
	Ext.ux.Toolbar.Button = function(config){
		Ext.ux.Toolbar.Button.superclass.constructor.call(this, config);	    
	};
	
	
	Ext.extend(Ext.ux.Toolbar.Button, Ext.Toolbar.Button, {
		/**
		 * @cfg {Boolean} preventFromDisable
		 * If set to true, the Button can't be disabled.
		 */
		preventFromDisable  : false,
		
		/**
		 * @cfg {Boolean} preventFromEnable
		 * If set to true, the Button can't be enabled.
		 */
		preventFromEnable	: false,
		
		/**
		 * Set true to prevent the button from being disabled
		 * @param {Boolean} prevent
		 */
		setPreventFromDisable : function(prevent) {
			this.preventFromDisable = prevent;
		},
		
		/**
		 * Set true to prevent the button from being enabled
		 * @param {Boolean} prevent
		 */
		setPreventFromEnable : function(prevent) {
			this.preventFromEnable = prevent;
		},
		
		/**
		 * Convenient method to check if the button can be disabled.
		 * @returns {Boolean}
		 */
		getPreventFromDisable : function() {
			return this.preventFromDisable;
		},		
		
		/**
		 * Convenient method to check if the button can be enabled.
		 * @returns {Boolean}
		 */
		getPreventFromEnable : function() {
			return this.preventFromEnable;
		},		
		
		/**
	     * Convenient function for setting disabled/enabled by boolean. If preventFromDisable is true, it is not
	     * possible to disable the button.
	     * @override
	     * @param {Boolean} disabled
	     */
	    setDisabled : function(disabled){
        	this[disabled && !this.preventFromDisable ? "disable" : "enable"]();
	    },
	    
	    /**
	     * Disables the button if it's not forbidden
	     * @returns {Ext.ux.Toolbar.Button} this
	     */
	    disable : function() {
	    	if (!this.preventFromDisable) {
		    	if(this.rendered){
		            this.onDisable();
		        }
		        this.disabled = true;
		        this.fireEvent("disable", this);
	    	} 
	        return this;

	    },
	    
	    /**
	     * Enables the button if it's not forbidden
	     * @returns {Ext.ux.Toolbar.Button} this
	     */
	    enable : function() {
	    	if (!this.preventFromEnable) {
	    		if(this.rendered){
		            this.onEnable();
		        }
		        this.disabled = false;
		        this.fireEvent("enable", this);
	    	}
	    	return this;
	    }
    });
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" === typeof window.Ext){ window.Ext = {}; }
if ("undefined" === typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" === typeof Ext.ux.Toolbar){ Ext.ux.Toolbar = {}; }

new function(){
	
	/**
	 * Class for a generic Button displaying a horizontal Menu on click.
	 * 
	 */
	Ext.ux.Toolbar.HorizontalMenu = function(config){
		Ext.ux.Toolbar.HorizontalMenu.superclass.constructor.call(this, config);	    
	};

	Ext.extend(Ext.ux.Toolbar.HorizontalMenu, Ext.Toolbar, {
		items	: [],
		buttons	: [],
		
		enableButtons: function(elements) {
			// Show the Buttons
			this.buttons.each((function(value){
				if (!value.buttonInstance){ // Check if there is a button
					return;
				}
				
				// Enable the button
				value.buttonInstance.enable();
							
				// If there is less elements than minShapes
				if(value.minShape && value.minShape > elements.length)
					value.buttonInstance.disable();
				// If there is more elements than minShapes
				if(value.maxShape && value.maxShape < elements.length)
					value.buttonInstance.disable();	
				// If the plugin is not enabled	
				if(value.isEnabled && !value.isEnabled(value.buttonInstance))
					value.buttonInstance.disable();
				
			}).bind(this));		
		},
		
		onSelectionChanged: function(event) {
			this.enableButtons(event.elements);
		}
	});
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *  
 */

if ("undefined" === typeof window.Ext){ window.Ext = {}; }
if ("undefined" === typeof Ext.ux){ Ext.ux = {}; }
if ("undefined" === typeof Ext.ux.Toolbar){ Ext.ux.Toolbar = {}; }

new function(){
	
	/**
	 * Class for a generic Button displaying a horizontal Menu on click.
	 * 
	 */
	Ext.ux.Toolbar.HorizontalMenuButton = function(config){
		
		this.menuConfig = {
			menuItems		: config.menuConfig.menuItems || []
		};
		
		this.menuConfig.cls += ' y-horizontal-menu-invisible-render-point ' + this.menuConfig.alignCls;
		Ext.ux.Toolbar.HorizontalMenuButton.superclass.constructor.call(this, config);	    
	};
	
	Ext.extend(Ext.ux.Toolbar.HorizontalMenuButton, Ext.Toolbar.SplitButton, {
		listeners	: {
				click	: function(button, event) {
					button.toggle();
				}.bind(this),
				arrowclick : function(button, event) {
					button.toggle();
				}
		},

		/**
		 * Creates a new Ext.ux.Toolbar.HorizontalMenu and renders it to the position of a given button.
		 * @param {Ext.ux.Toolbar.Button} button
		 * @param {Object} cfg The config object
		 */
		initToolbar : function(button, cfg) {
			// The config for the horizontal menu
			
			// Create the toolbar
			button.toolbar = new Ext.ux.Toolbar.HorizontalMenu(cfg);
			cfg.toolbar = button.toolbar;
			
			// Create the overlay to visually connect the button and the toolbar
			var overlay = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", undefined, ["div", {"class":'y-richtext-toolbar-button-expanded-overlay'+(Ext.isIPad ? 'y-richtext-toolbar-button-expanded-overlay-ipad': '')}]);
            button.overlay = overlay;
            
            var flyOver = Ext.fly(overlay);
            flyOver.setWidth(button.el.getWidth());
            
			// Render the toolbar
			button.toolbar.render(button.el.parent('div.x-panel-body'));
			
			
			this.addMenuButtons(cfg.menuItems);
	    	
			button.toolbar.enableButtons([]);
			
			button.toolbar.el.removeClass('y-horizontal-menu-invisible-render-point');
			
			// Align it to the given button position
			button.toolbar.el.alignTo(button.el, 'bl', (Ext.isIPad ? [0,-4] : [0, 2]), false);
			
			// Add the overlay
			button.toolbar.el.parent().appendChild(overlay);
			flyOver.alignTo(button.el, cfg.alignPosition, [0, (Ext.isIPad ? -3 : -2)], cfg.animate);
		},
		
		/**
		 * Adds an item (Button, ComboBox, etc.) to the given horizontal menu for each given itemConfig 
		 * @param {Array} menuItems Containing configuration for each menu item to add.
		 */
		addMenuButtons : function(menuItems) {
	    	if (!menuItems || menuItems.length === 0) {
	    		return;
	    	}
	    	
	    	this.splitButtons = [];
	    	
	    	menuItems.each(function(value) {
	    		if(!value.name) {
	    			return;
	    		}
	    		
	    		/*
	    		 * If an drop down group icon is provided, a split button should be used.
	    		 */
	            if(value.dropDownGroupIcon) {
	            	var splitButton = this.splitButtons[value.dropDownGroupIcon];
	            	if (!splitButton) {
	            		splitButton = this.createNewSplitButton(value);
	            		this.toolbar.add(splitButton);
	            	}
                    
	                // General config button which will be used either to create a normal button
                    // or a check button (if toggling is enabled)
                    var buttonCfg = {
                        icon		: value.icon,
                        text		: value.name,
                        itemId		: value.id,
                        cls			: "x-"+String(value.group.gsub("\\.", "")).toLowerCase(),
                        handler		: value.toggle ? undefined : value.functionality,
                        checkHandler: value.toggle ? value.functionality : undefined,
                        splitButton	: splitButton,
                        toggleGroup	: value.toggleGroup,
                        listeners	: {
                            render: function(item){
                                // After rendering, a tool tip should be added to component
                                if (value.description) {
                                    new Ext.ToolTip({
                                        target	: item.getEl(),
                                        title	: value.description
                                    });
                                }
                            }
                        }
                    };
                    
                    if ("string" === typeof value.style){
                    	buttonCfg.style = value.style;
                    }
                    
                    // Create buttons depending on toggle
                    if(value.toggle) {
                        var button = new Ext.menu.CheckItem(buttonCfg);
                    } else {
                        var button = new Ext.menu.Item(buttonCfg);
                    }
                    
                    splitButton.menu.add(button);
	            }
	            // If a fill area is desired, add fill
	            else if(value.addFill) {
					this.toolbar.addFill();
				}
					
				// If the item to add to the toolbar is a ComboBox
	            else if (value.comboBox instanceof Function) {
					var combo = value.comboBox();
					this.toolbar.addField(combo);
					
				}
		        // create normal, simple button
	            else {
					var icon = value.icon.split('/').length === 4 ? value.icon.replace('/editor/images/', Ext.IMAGE_URL+'/famfamfam/') : value.icon;
					
					var button = new Ext.ux.Toolbar.Button({
	                    icon:           icon,         // icons can also be specified inline
	                    cls:            'x-btn-icon',       // Class who shows only the icon
	                    itemId:         value.id,
						tooltip:        value.description,  // Set the tooltip
	                    tooltipType:    'title',            // Tooltip will be shown as in the html-title attribute
	                    handler:        value.toggle ? null : value.functionality,  // Handler for mouse click
	                    enableToggle:   value.toggle, // Option for enabling toggling
	                    toggleGroup:	value.toggleGroup,
	                    toggleHandler:  value.toggle ? value.functionality : null // Handler for toggle (Parameters: button, active)
	                }); 
	                
					this.toolbar.add(button);	
					
	                button.getEl().onclick = function() {this.blur();};
	            }
				
	        	value['buttonInstance'] = value.isComboBox ? combo : button;
	        	this.toolbar.buttons.push(value);
	    	}.bind(this));
	    },
	    
	    /**
	     * Creates a new Ext.Toolbar.SplitButton for a given item
	     * @param {Object} item The configuration for the split button
	     */
	    createNewSplitButton : function(item) {
    		var button = new Ext.Toolbar.SplitButton({
                cls			: "x-btn-icon",
                icon		: Ext.isIPad ? item.dropDownGroupIcon.replace('/famfamfam/', '/famfamfam/32x32/') : item.dropDownGroupIcon,
                menu		: new Ext.menu.Menu({
                    			items: [] // items are added later on
                			}),
                listeners	: {
                  click	: function(button, event){
                            // The "normal" button should behave like the arrow button
                            if(!button.menu.isVisible() && !button.ignoreNextClick){
                                button.showMenu();
                            } else {
                                button.hideMenu();
                            }
                  } 
                }
            });
    		
    		this.splitButtons[item.dropDownGroupIcon] = button;
	    }
	});
	
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *
 *	This code is proprietary software within the 
 * 	company Signavio GmbH.
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.view){ Ext.ux.view = {} }

new function(){
	
	/**
	 * A PDF Export window for exporting views of a selected diargam 
	 * 
	 * @class Ext.ux.view.PdfExportWindow
	 */
	Ext.ux.view.PdfExportWindow = function(views, modelId, data, facade, sel){
		this.sel = sel;
		this.views = views;
		this.modelId = modelId;
		this.data = data;
		this.facade = facade;
		this.signavioBranding = undefined;
		
		Ext.ux.view.PdfExportWindow.superclass.constructor.apply(this, [{}]);
		this.show();
	}

	Ext.extend(Ext.ux.view.PdfExportWindow, Ext.Window, {
		resizable	: false,
		minimizable	: false,
		modal		: true,
		width		: 345,
		title		: Ext.ux.getI18N("views.offerTitle"),
		bodyStyle	: "background-color:white;",
		buttons		: [
						{
				        	text: Ext.ux.getI18N("views.buttonTitle"),
				        	handler: function(){
								this.ownerCt.onSubmit()
								this.ownerCt.close()
							}
				    	},
				    	{
				    		text : Ext.ux.getI18N("views.closeTitle"),
				    		handler : function(){
				    			this.ownerCt.close();
				    		}
				    	}
					  ],
		
		getCurrentViewId: function(modelUrl){
			if (!this.items){return modelUrl;}
			
			var item = this.items.items.find(function(r){
				return r.checked
			});
			
			if (item && item.href){
				return item.href;
			} else {
				return modelUrl;
			}
		},

		onSubmit: function(){
			var model = this.sel[0];
			if (model && this.data.getSelectionCount() == 1) {
				this.body.mask(Ext.ux.getI18N("views.waiting"), "x-waiting-box");
				
				// Page mode
				var params = "?pageMode="+this.data.getSelectedRecords()[0].get("url");
				// Signavio branding
				params += "&showSignavioBranding=" + this.signavioBranding.items.get(0).getValue();
				// Default scale factor
				params += "&scale=1.4"
				var view = this.items.find(function(item){
					return item instanceof Ext.form.Radio && item.checked;
				}) 
				if(view){
					params += "&view=" + view.href;
				} 
				this.showMap(model, params);
			}
		},
		stripName: function(name){
			// Unescape
			name = name.unescapeHTML();
			// Remove all Windows incompatible letters \/:*?"<>| and the #
			name = name.replace(/[\\\/:*?\"<>|#]/g, "");
			// Encode
			name = encodeURI(name);
			name = name.replace(/&/g, "%26");
			return name;
		},
		showMap: function(model, parameter) {
			var url = Signavio.Config.BACKEND_PATH+model.get("href")+"/pdf/"+this.stripName(model.get("rep").name||"")+".pdf";
			url+=parameter;
			window.open(url);
		},	
		
		initComponent: function(){

			var id = Ext.id();
	
			//add radiobox for each view						  
			this.items = [
							new Ext.form.Label({
			     			   	style	: "display:block;padding-bottom:10px;padding-left:7px;padding-right:5px;padding-top:5px;width:320px;",
					    		text	: Ext.ux.getI18N("views.offerTitleDesc")
					    	}),
						
							this.data
					  ];
			
			this.items.push(
				new Ext.form.Label({
					cls			: "y-export-window-description",
					text		: Ext.ux.getI18N("views.windowDescription")
				})
			);
						
			this.items.push(
				new Ext.form.Radio({
					cls		 : "y-export-radio-original",
					name	 : id,
					hideLabel: true,
					boxLabel : "<i>"+Ext.ux.getI18N("views.resetView")+"</i>",
					href	 : this.modelId,
					checked	 : true
				})
			);
			
			this.items = this.items.concat(this.views.map(function(view){
				return new Ext.form.Radio({
					name	 : id,
					cls		 : "y-export-radio",
					hideLabel: true,
					boxLabel : (view.rep.view && view.rep.view.name) || view.rep.name,
					href	 : view.href.replace("/info", "")
				})
			}));
			var licenses = this.facade.getCurrentUser().getRecords("info")[0].get("rep").licenses;
			this.signavioBranding = new Ext.Panel({
					    		layout		: "form",
					    		style 		: "padding-left:7px",
					    		cls			: "x-form-map-export-branding",
					    		border		: false,
					    		items		: [{
												xtype:'checkbox',
												hideLabel : true,
												name: "showSignavioBranding",
												checked: false,
												disabled: !(licenses.member("premium") || licenses.member("corporate")) || this.facade.getConfig().mode === "Academic",
												boxLabel: Ext.ux.getI18N("views.branding") +" "+ ((!(licenses.member("premium") || licenses.member("corporate")))?' <img ext:qtip="' + Ext.ux.getI18N("views.premiumOnly") +'" src="'+Ext.IMAGE_URL+'/famfamfam/information.png"/>':"")
								 			  }]
			});
			this.items.push(this.signavioBranding);	
			
			Ext.ux.view.PdfExportWindow.superclass.initComponent.call(this)
		}
	});

}()
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand, Adrian Klinger
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *
 *	This code is proprietary software within the 
 * 	company Signavio GmbH.
 *  
 */


if (!window.Ext){ window.Ext = {} }
if (!Ext.ux){ Ext.ux = {} }
if (!Ext.ux.view){ Ext.ux.view = {} }

new function(){


	var REQUEST_TYPES = {
		QUESTION: "Question",
		BUG_REPORT: "Bugreport",
		FEATURE: "Feature"
	};

	
	/**
	 * The feedback window to contact Signavio
	 * 
	 * @class Ext.ux.view.FeedbackWindow
	 */
	Ext.ux.view.FeedbackWindow = function(mode, url, explorerPath, model, supportMailAddress){
		this.mode = mode;
		this.model = model;
		this.url = url;
		this.explorerPath = explorerPath;
		this.supportMailAddress = supportMailAddress;
		Ext.ux.view.FeedbackWindow.superclass.constructor.apply(this, [{}]);
		this.show();
		this.on("resize", this.updateHeight, this);
		this.updateHeight();
	};

	Ext.extend(Ext.ux.view.FeedbackWindow, Ext.Window, {
		resizable	: true,
		closable	: true,
		minimizable	: false,
		stafeful	: false,
		modal		: true,
		width		: '50%',
		minHeight	: 520,
		minWidth	: 400,
		height		: 520,
		layout		: 'anchor',	
		bodyStyle	: "background-color:white;padding:10px;color:black;overflow:visible;",	
		buttons		: [
						{
				        	text: Ext.ux.getI18N("views.sendFeedback"),
				        	handler: function(){
								
								var win = this.ownerCt;
								
								var feedbackForm = this.ownerCt.items.find(function(item){return item.xtype === "form";});
								
								// get request type
								var requestCombobox = feedbackForm.items.find(function(item){return item.id === "feedback-request-combobox"});
								var requestType = requestCombobox.getValue();

								// check validations
								var nameTextbox = feedbackForm.items.find(function(item){return item.name === "shortdescription" && item.requestParent === requestType});
								var descriptionArea = feedbackForm.items.find(function(item){return item.name === "description" && item.requestParent === requestType});

								if (nameTextbox && nameTextbox.isValid(false) === false){ return; }						
								if (descriptionArea && descriptionArea.isValid(false) === false){ return; }								

								// mask window
								win.el.mask(Ext.ux.getI18N("views.feedbackSending","x-waiting-spinner"));

							
								var params = {
									subject: requestType
								};

								// collect all params							
	    						var formItems = feedbackForm.items;
	    						formItems.each(function(formItem){
	    							if (((formItem.id !== "feedback-request-combobox" && formItem.requestParent === requestType) || (formItem.xtype === "hidden")) && (formItem.name !== 'attachModel')){
	    								params[formItem.name] = formItem.getValue();						    			
						    		}
						    	});	    						
								
	    						// reconfigure subject title
	    						params.subject = "[" + params.subject + "] " + params.shortdescription;
	    						delete params.shortdescription;

	    						// add enviornemnt if is nessarcy
	    						params.environment = params.environment || "";

	    						var succCallback = function(){
	    							Ext.Msg.alert(Ext.ux.getI18N("views.feedbackSuccess"), Ext.ux.getI18N("views.feedbackSuccessMsg"))
											.setIcon(Ext.Msg.INFO).getDialog().syncSize();
									win.el.unmask();
		                            win.close();
	    						};

	    						var failCallback = function(){
	    							win.el.unmask();
	    							Ext.Msg.alert(Ext.ux.getI18N("views.feedbackFailure"), Ext.ux.getI18N("views.feedbackFailureMsg"))
											.setIcon(Ext.Msg.WARNING).getDialog().syncSize();
	    						};

	    						// do post	    					
	    						Ext.Ajax.request({
									   url		: feedbackForm.form.url,
									   timeout 	: 2 * 60 * 1000,
									   params	: params,
									   method	: "POST",
									   disableCaching	: true,
									   headers	: {'Accept':"application/json"},
									   success	: succCallback,
									   failure  : failCallback 
								});
							}
				    	},
				    	{
				    		text : Ext.ux.getI18N("views.feedbackCloseTitle"),
				    		handler : function(){
				    			this.ownerCt.close();
				    		}
				    	}
					  ],
					  
		getEnv: function(){
	        var env = "";
	        
	        env += "Browser: " + navigator.userAgent;
	        
	        env += "\n\nBrowser Plugins: ";
	        if (navigator.plugins) {
	            for (var i = 0; i < navigator.plugins.length; i++) {
	                var plugin = navigator.plugins[i];
	                env += plugin.name + ", ";
	            }
	        }
	        
	        if ((typeof(screen.width) != "undefined") && (screen.width && screen.height)) 
	            env += "\n\nScreen Resolution: " + screen.width + 'x' + screen.height;
	        
	        return env;
	    },
		
	    getHint: function(){
	    	var hint;
	    	if (this.mode === "Enterprise"){
	    		hint = Ext.ux.getI18N("views.feedbackenterprise").replace("[mail]",this.supportMailAddress);
	    	}else{
	    		hint = Ext.ux.getI18N("views.feedbacksignavio").replace("[mail]",this.supportMailAddress);
	    	}	    	
	    	return {
	    		xtype: 'panel',
	    		html: hint,
	    		border: false,
	    		bodyStyle: 'margin-bottom: 11px; font-size: 12px;'+ 
	    			'font-style: normal; font-variant: normal; line-height: normal;'
	    	};
	    },
	    
	    getReceiver: function(){
	    	var hint = Ext.ux.getI18N("views.feedbackreceiver") + ":";
	    	if (this.mode === "Enterprise"){
	    		hint += Ext.ux.getI18N("views.feedbackreceiverenterprise").replace("[mail]",this.supportMailAddress);
	    	}else{
	    		hint += Ext.ux.getI18N("views.feedbackreceiversignavio").replace("[mail]",this.supportMailAddress);
	    	}	 
	    	return {
	    		xtype: 'panel',
	    		html: hint,
	    		border: false,
	    		bodyStyle: 'margin-bottom: 11px; font-size: 12px;'+ 
	    			'font-style: normal; font-variant: normal; line-height: normal;'
	    	};
	    },
	    
	    switchComponentsForRequest: function(requestId){

	    	var feedbackForm = this.items.find(function(item){return item.xtype === "form";});
	    	var formItems = feedbackForm.items;

	    	// show only these items which are depending for this requestId
	    	formItems.each(function(formItem){
	    		if (formItem.id !== "feedback-request-combobox" && formItem.xtype !== "hidden"){
	    			// check request parent
	    			var itemParent = formItem.el.parent(".x-form-item");
	    			if (formItem.requestParent === requestId){
	    				(itemParent || formItem.el).setStyle("display","block");
	    			}else{
	    				(itemParent || formItem.el).setStyle("display","none");
	    			}
	    		}
	    	});

	    	// show send button if no feature request is selected
	    	if (requestId === REQUEST_TYPES.FEATURE){
	    		this.buttons[0].hide();
	    	}else{
	    		this.buttons[0].show();
	    	}

	    },

	    getRequestCombobox: function(){

	    	var requestReasons = [[Ext.ux.getI18N("views.feedbackquestion"),REQUEST_TYPES.QUESTION],
	    						  [Ext.ux.getI18N("views.feedbackbugreport"),REQUEST_TYPES.BUG_REPORT]];

	    	// if german tenant, add also feature request
	    	if (Ext.ux.getLang() === "de"){
	    		requestReasons.push([Ext.ux.getI18N("views.feedbackfeaturerequest"),REQUEST_TYPES.FEATURE]);	    		
	    	}
	    							  
	    	return {
					xtype: 'combo',					
					name: 'subject',
					id: "feedback-request-combobox",
					anchor:'100%',
					height:'60px',
					store: new Ext.data.SimpleStore({
						fields: ['title','id'],
						data: requestReasons
					}),
					allowBlank: false,
					blankText: Ext.ux.getI18N("views.feedbackEnterSubject"),
					displayField: 'title',
					valueField : "id",
					value: REQUEST_TYPES.QUESTION,
					editable: false,
					forceSelection: true,
					mode: 'local',			
					typeAhead: true,
					triggerAction: 'all',
					fieldLabel: Ext.ux.getI18N("views.feedbackPSubject"),
					listeners: {
						select: function(component,record){
							this.switchComponentsForRequest(record.get("id"));
						}.bind(this),
						render : function(){
							window.setTimeout(function(){
								this.switchComponentsForRequest(REQUEST_TYPES.QUESTION);
							}.bind(this),100);							
						}.bind(this)
					}					
			};
	    },

	    getBugReportComponents : function(){

	    	return [{
						xtype: 'textfield',
						requestParent: REQUEST_TYPES.BUG_REPORT,
						name: 'shortdescription',
						allowBlank: false,					
						blankText : Ext.ux.getI18N("views.feedbackentersubject"),					
						fieldLabel: Ext.ux.getI18N("views.feedbackbugreporttitle"),
						anchor:'100%'
					},{
						xtype: 'textarea',
						requestParent: REQUEST_TYPES.BUG_REPORT,
						name: 'description',
						allowBlank: false,
						minLength: 40,
						minLengthText: Ext.ux.getI18N("views.feedbackerrorlength"),
						blankText: Ext.ux.getI18N("views.feedbackEnterDescription"),
						fieldLabel: Ext.ux.getI18N("views.feedbackPMsg"),
						emptyText: Ext.ux.getI18N("views.feedbackPEmpty"),
						anchor: (Ext.isIPad ? '-8 ' + (this.model ? '-290' : '-259') : '100% ' + (this.model ? (Ext.isChrome ? '-300' : '-279') :  (Ext.isChrome ? '-260' : '-248')))
					},{
						xtype: 'checkbox',
						requestParent: REQUEST_TYPES.BUG_REPORT,
						itemCls : 'x-support-checkbox',
	                    boxLabel: Ext.ux.getI18N("views.feedbackcopy") + ' <img src="'+Ext.IMAGE_URL+'/famfamfam/information.png" ext:qtip="' + Ext.ux.getI18N("views.feedbackcopydesc") + '"/>',
	                    hideLabel: true,
	                    checked: false,
	                    name: 'sendCopy'
					}, (this.model?{
	                    xtype: 'checkbox',
	                    requestParent: REQUEST_TYPES.BUG_REPORT,
	                    name: "attachModel",
						itemCls : 'x-support-checkbox',
	                    boxLabel: Ext.ux.getI18N("views.feedbackpattach") + ' <img src="'+Ext.IMAGE_URL+'/famfamfam/information.png" ext:qtip="' + Ext.ux.getI18N("views.feedbackpattachdesc") + '"/>',
	                    hideLabel: true,
	                    checked: true,
	                    listeners: {
	                        check: function(checkbox, checked){
	                            var hidden = checkbox.ownerCt.find("name", "model")[0];
	                            if (checked) {
	                                hidden.setValue(this.model);
	                            }
	                            else {
	                                hidden.setValue(undefined);
	                            }
	                        }.bind(this)
	                    }
                	}:undefined),{
						xtype: 'textarea',
						requestParent: REQUEST_TYPES.BUG_REPORT,
						itemCls : 'x-support-textarea',
						name: 'environment',
						fieldLabel: Ext.ux.getI18N("views.feedbackPBrowser") + ' <img src="'+Ext.IMAGE_URL+'/famfamfam/information.png" ext:qtip="' + Ext.ux.getI18N("views.feedbackPBrowserDesc") + '"/>',
						anchor: Ext.isIPad ? '-8' : '100%',
						height:'60px',
						value: this.getEnv()
			}];

	    },

	    getFeatureRequestComponents: function(){

	    	return [{
	    		xtype: 'panel',
	    		requestParent: REQUEST_TYPES.FEATURE,
	    		html: Ext.ux.getI18N("views.feedbackideasdescription"),
	    		border: false,
	    		bodyStyle: 'margin-bottom: 11px; font-size: 12px;'+ 
	    			'margin-top: 18px; padding-left: 3px; padding-right: 5px;'
	    	},{
	    		xtype: 'panel',
	    		requestParent: REQUEST_TYPES.FEATURE,
	    		html: Ext.ux.getI18N("views.feedbackideasdescriptionnote"),
	    		border: false,
	    		style: "bottom: 8px; font-size: 10px; position: absolute;",
	    		bodyStyle: 'font-size: 10px;'+ 
	    			'padding-left: 3px;padding-right: 5px;'
	    	}]; 
	    },

	    getQuestionComponents: function(){

	    	return [{
						xtype: 'textfield',
						requestParent: REQUEST_TYPES.QUESTION,
						name: 'shortdescription',
						blankText : Ext.ux.getI18N("views.feedbackentersubject"),
						allowBlank: false,										
						fieldLabel: Ext.ux.getI18N("views.feedbackquestiontitle"),
						anchor:'100%'
					},
					{
						xtype: 'textarea',
						requestParent: REQUEST_TYPES.QUESTION,
						name: 'description',
						allowBlank: false,
						minLength: 40,
						minLengthText: Ext.ux.getI18N("views.feedbackerrorlength"),
						blankText: Ext.ux.getI18N("views.feedbackEnterDescription"),
						fieldLabel: Ext.ux.getI18N("views.feedbackquestiondescription"),
						emptyText: Ext.ux.getI18N("views.feedbackPEmpty"),
						anchor: (Ext.isIPad ? '-8 ' + (this.model ? '-190' : '-159') : '100% ' + (this.model ? '-179' :  (Ext.isChrome ? '-160' : '-148')))
					}, 
					{
						xtype: 'checkbox',
						requestParent: REQUEST_TYPES.QUESTION,
						itemCls : 'x-support-checkbox',
	                    boxLabel: Ext.ux.getI18N("views.feedbackcopy") + ' <img src="'+Ext.IMAGE_URL+'/famfamfam/information.png" ext:qtip="' + Ext.ux.getI18N("views.feedbackcopydesc") + '"/>',
	                    hideLabel: true,
	                    checked: false,
	                    name: 'sendCopy'
					}];

	    },

		initComponent: function(){
			this.title = this.mode === "Enterprise"?Ext.ux.getI18N("views.feedbackTitleEnterprise"):Ext.ux.getI18N("views.feedbackTitle");
			var hint = this.getHint();
			var receiver = this.getReceiver();
			var requestCombobox = this.getRequestCombobox();
			var feedbackItems = [this.getQuestionComponents(),this.getBugReportComponents()].flatten().compact();
			
			// if german tenant, add also feature request
	    	if (Ext.ux.getLang() === "de"){
	    		feedbackItems.push(this.getFeatureRequestComponents());
	    	}

			var hiddenModelItem = {
						xtype: 'hidden',
						itemId: 'hiddenModel',
						name: 'model'};

			this.items = [hint,receiver,
				{
					xtype: 'form',
					url: this.url,
					anchor: '100% 93%',				
					border: false,
					labelAlign: 'top',
					items: [requestCombobox, hiddenModelItem, feedbackItems].flatten().compact()
				}
			];
			Ext.ux.view.FeedbackWindow.superclass.initComponent.call(this)
		},
		
		/**
		 * Set the height of the second panel 
		 * to 100% regarding the height of 
		 * the first panel.
		 * 
		 */
		updateHeight: function(){			
			this.items.get(2).setHeight(this.getInnerHeight()-this.items.get(0).el.getHeight()-this.items.get(1).el.getHeight()-20);			
		}
	});
}()
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Willi Tscheschner, Lukas Brand
 *   
 *  UX is a shared javascript library which provides common 
 *  functionalities for all applications in the Signavio Process Editor
 *
 *  This code is proprietary software within the 
 *  company Signavio GmbH.
 *  
 */


if (!window.Ext){ window.Ext = {}; }
if (!Ext.ux){ Ext.ux = {}; }
if (!Ext.ux.view){ Ext.ux.view = {}; }

(function(){

    /**
     * A generic wizard providing basic functionality to export single or
     * multiple diagrams in multiple ways.
     * 
     * This class provides an abstraction of a wizard:
     *
     * @param {Object} attributes
     * 
     * @class Ext.ux.view.Wizard
     */
    Ext.ux.view.Wizard = function(attributes) {

        attributes = attributes || {};
        
        // The callback to execute after the wizard
        this.clb = attributes.clb;
        // The name for the button
        this.clbName = attributes.clbName;
        
        // If no buttons are defined or buttons are defined but no button with a cancel text exists, create a cancel button
        if (attributes.closable !== false &&
            (!attributes.buttons || 
            attributes.buttons && !attributes.buttons.find(function(button) {
                return button.text === Ext.MessageBox.buttonText.cancel;
            }))) {
            this.cancel = new Ext.Button({
                text    : Ext.MessageBox.buttonText.cancel,
                handler : function(){
                            // Close the wizard window
                            this.ownerCt.close();       
                            this.ownerCt.destroy();
                }.bind(this),
                template: new Ext.Template("<a href='#' class='x-button-plain'>{0}</a>"), 
                onRender: function(){
                            this.el = Ext.get(this.template.overwrite(this.container.dom, [this.text]));
                            this.el.on("click", function(e,t){
                                this.handler.apply(this, arguments);
                                e.stopEvent(); 
                                return false;
                            }.bind(this));
                }
            }); 
        }
        
        this.lastTab = this.findLastTab(attributes.items);
        
        // The next button
        this.next = new Ext.Button({
                        text    : this.nextLabel,
                        handler : this.nextPage.bind(this)
                    });

        // The previous button
        this.previous = new Ext.Button({
                        text    : this.previousLabel,
                        hidden  : true,
                        handler : this.previousPage.bind(this)
                    });
        
        // Set the next/previous buttons                    
        attributes.buttons = [this.cancel].concat((attributes.buttons||[]), [this.previous, this.next]).compact();
        
        Ext.ux.view.Wizard.superclass.constructor.call(this, attributes);
    };
    
    Ext.extend(Ext.ux.view.Wizard, Ext.TabPanel, {
        /**
         * Initial Configuration
         */
        hideBorders         : true,
        cls                 : 'y-wizard',
        layoutOnTabChange   : true,
        activeTab           : 0,
        nextLabel           : Ext.ux.getI18N("wizard.nextbtnlabel"),
        previousLabel       : Ext.ux.getI18N("wizard.previousbtnlabel"),

        onRender: function(){
            Ext.ux.view.Wizard.superclass.onRender.apply(this, arguments);
            // Hide tabs
            this.header.setStyle("display", "none");
            // Update buttons to display the correct labels
            this.updateButtons();
        },
    
        findLastTab: function(tabs) {
            var last = null;

            tabs.each(function(tab) {
                if(!tab.disabled) {
                    last = tab;

                    return;
                }

                throw $break;
            });

            return last;
        },

        /**
         * Shows previous page
         * @param {Boolean} silent Call it without calling callback
         */
        previousPage: function(silent){
            var tab = (typeof this.activeTab === 'object' ? this.activeTab : this.getItem(this.activeTab)); 
            // If the active tab is the first tab, do nothing
            if (tab === this.items.first()) {
                return;
            } else {
                // Get the previous tab
                var previous = this.getPreviousTab();
                
                // Call method and check if it is ok to go back
                if (silent !== true && (tab.onPrevious && tab.onPrevious(previous) === false)){
                    return;
                }
                
                // Set previous tab
                if (previous) {
                    this.setActiveTab(previous);
                }
                
                this.updateButtons();
            }
        },

        /**
         * Show next page
         * @param {Boolean} silent Call it without calling callback
         */
        nextPage: function(silent){

            var tab = (typeof this.activeTab === 'object' ? this.activeTab : this.getItem(this.activeTab));
            // If the active tab is the last tab and a callback is defined, execute the callback
            // if (tab === this.items.last() && typeof this.clb === 'function') {
            if (tab === this.lastTab && typeof this.clb === 'function') {
                this.clb(this);
                return;
            } else {
                // Get next tab
                var next = this.getNextTab();
                
                // Call method and check if it is ok to move on
                if (silent !== true && (tab.onNext && tab.onNext(next) === false)) {
                    return;
                }

                // Set next tab
                if (next) {
                    this.setActiveTab(next);
                    this.updateButtons();
                }
            }
        },

        /**
         * Updates the next and previous button depending on the active tab
         */
        updateButtons: function(){
            
            var tab = (typeof this.activeTab === 'object' ? this.activeTab : this.getItem(this.activeTab));
            
            // Show/hide previous button
            if (tab === this.items.first() || tab.hideButtons === true ) {
                this.previous.hide();
            } else {
                this.previous.show();
                this.previous.setText((this.getPreviousTab() && this.getPreviousTab().title && ("< " + this.getPreviousTab().title)) || (tab && tab.previousLabel) ||this.previousLabel);
            }
            
            // Show/hide next button
            if (tab === this.lastTab || tab.hideButtons === true) {
                if (this.clb) {
                    this.next.show();
                    this.next.setText(this.clbName || "Funktion rufen");
                } else {
                    this.next.hide();   
                }
            } else {
                this.next.show();
                this.next.setText( (this.getNextTab() && this.getNextTab().title && (this.getNextTab().title + " >")) || (tab && tab.nextLabel) || this.nextLabel);
            }
        },
        
        /**
         * Returns the index of a given page
         * @param {Ext.ux.view.WizardPage} page
         * @returns
         */
        getIndex : function(page) {
            var tabs = this.items;
            return tabs.indexOf(page);
        },
        
        /**
         * Returns the next tab
         * @returns
         */
        getNextTab : function() {
            if (!this.getActiveTab()){
                return this.items.get(Math.min(1, this.items.length-1));
            }
            var next = this.items.get(Math.min(this.items.indexOf(this.getActiveTab())+1, this.items.length-1));
            while (next && next.isNotActive instanceof Function && next.isNotActive()){
                next = this.items.get(Math.max(this.items.indexOf(next)+1, 0));
            }
            return next;
        },
        
        /**
         * Returns the previous tab
         * @returns
         */
        getPreviousTab : function() {
            if (!this.getActiveTab()){
                return this.items.get(0);
            }
            var previous = this.items.get(Math.max(this.items.indexOf(this.getActiveTab())-1, 0));
            while (previous && previous.isNotActive instanceof Function && previous.isNotActive()){
                previous = this.items.get(Math.max(this.items.indexOf(previous)-1, 0));
            }
            return previous;
        },
        
        /**
         * Set the active tab to the given item
         * 
         */
        setTab: function(item){
            this.setActiveTab(item);
            this.updateButtons();
            return item;
        }
    });

    /**
     * This class provides an abstraction for a page within a wizard
     * 
     * @class
     * @param {Object} attributes
     */
    Ext.ux.view.WizardPage = function(attributes){
        attributes = attributes || {};
        Ext.ux.view.WizardPage.superclass.constructor.call(this, attributes);
    };

    Ext.extend(Ext.ux.view.WizardPage, Ext.form.FormPanel, {
        cls     : 'y-wizard-page',
        autoScroll: true,
        defaults: {
            border  : false
        },
        
        /**
         * Adjusts the height of the format selector data view when shown/resized.
         * @param {Ext.ux.view.WizardPage} comp The current wizard page
         * @param {Number} diffHeight Optional value which is subtract to the computed height
         */
        adjustPageContentSize : function(anchor,diffHeight) {
            if(!anchor) {
                return;
            }
            
            var contentHeight = 0;
            var minHeight = 200;
            
            this.items.each(function(item) {
                if(item && item !== anchor) {
                    var el = item.getEl();

                    if(!el || !el.isVisible()) {
                       return;
                    }

                    // var height = el.getHeight();
                   
                    var height = el.getComputedHeight();
                    height += el.getPadding("tb");
                    height += el.getMargins("tb");

                    contentHeight += height;
                }
            });
            
            var computedHeight = Math.max(this.getEl().getHeight() - contentHeight, minHeight);
            
            var addHeight = diffHeight || 0;
            anchor.setHeight(computedHeight-addHeight);
        }
    });
    
    /**
     * This class provides a helper to create a Container for options.
     * 
     * @param {String} title The title for the options container
     * @param @optional {String} desc The description text to display inside the options container
     * @param @optional {String} cls A css class to apply to the options container
     * @param {Object[]} items The items to display inside the options container. 
     */
    Ext.ux.view.OptionsContainer = function(attributes) {
        attributes = attributes || {};
        
        attributes.layout = attributes.layout || "anchor";
        attributes.cls = "y-wizard-options-container " +  (attributes.cls || "");
        
        // If a title is defined, create a new label for it
        var titleLabel = new Ext.form.Label({
            text    : attributes.title || '',
            cls     : 'y-wizard-options-title'
        });
        
        // If a description is defined, create a new label for it
        
        var descLabel = null; 
        if(attributes.desc) {
            descLabel = new Ext.form.Label({
                text  : attributes.desc,
                cls     : 'y-wizard-options-description'
            });
        }
        
        attributes.items = [descLabel].concat(attributes.items || []).compact();
        
        if(attributes.items.length === 0) {
            delete attributes.items;
        }
        
        attributes.titleLabel = titleLabel;
        delete attributes.title;
        
        attributes.listeners = Ext.apply({
            render : function() {
                this.titleLabel.render(this.body.parent().parent());
            }
        }, attributes.listeners || {});
        
        Ext.ux.view.OptionsContainer.superclass.constructor.call(this, attributes);
    };
    
    Ext.extend(Ext.ux.view.OptionsContainer, Ext.Panel);
}());
/**
 * Copyright (c) 2011
 * Sven Wagner-Boysen
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

new function(){
	if(typeof YAHOO == "undefined") {return;}
	/**
	 * Customizes the YAHOO.widget.Slider to select an numeric ranges.
	 * Adds input fields for min and max values.
	 */
	YAHOO.namespace("Signavio");
	
	YAHOO.Signavio.SliderGenerator = function() {
		
	};
	
	YAHOO.lang.augmentObject(YAHOO.Signavio.SliderGenerator, YAHOO.widget.Slider, true);
	
	/**
     * Generates the slider element the registers the callback methods.
     */
	YAHOO.Signavio.SliderGenerator.generateSlider = function(parentElId, tickSize, paramOptions, valuesChangedCB, callbacks, isScrolling) {
    	var slider, range,
    		YElement = YAHOO.util.Element,
    	
        	// slider elements
    		bgElId = YAHOO.util.Dom.generateId(),
    		minThumbId = YAHOO.util.Dom.generateId(),
    		maxThumbId = YAHOO.util.Dom.generateId(),
    		hlElId = YAHOO.util.Dom.generateId(),
    		inStartId = YAHOO.util.Dom.generateId(),
    		inEndId = YAHOO.util.Dom.generateId(),
		
    		// Create elements
    		parentEl = new YElement(YAHOO.util.Dom.get(parentElId));
    	
    	tickSize = 0;
    	
    	/**
    	 * Default Signavio Slider callbacks
    	 */
    	var defaultCallbacks = {
    		// The highlight element
    		_highlight : undefined,
    		
    		/**
    		 * Expects the current selected value ranges and triggers an
    		 * update of the slider and value fields.
    		 * 
    		 */
    		initValues: function(min, max) {
    			if(typeof(min) === "undefined" || typeof(max) === "undefined") {return;}
    			
    			// Setting the element values by exploiting the input
    			// event handler callbacks
    			var options = this._paramOptions,
    			event = function(val) {
    				this.val = val;
    			};
    			
    			event.prototype.element = function() {
    				return {value:this.val};
    			};
    			
    			// avoid slider bubling
    			this.blockUpdate = true;
    			
    			this.inputStartValueChanged(new event(min), options);
    			this.inputEndValueChanged(new event(max), options);
    			
    			this.subscribe('slideEnd',function() {this.blockUpdate = false;}, this, true);
    		},
    		
    		// A method to update the status and update the highlight
    		updateHighlight : function () {
    			var Dom = YAHOO.util.Dom;
    			var delta = this.maxVal - this.minVal;
//    			console.log(this.maxVal);
//    			console.log(this.minVal);
    			//if (this.activeSlider === this.minSlider) {
    				// If the min thumb moved, move the highlight's left edge
    				Dom.setStyle(this._highlight,'left', this.minVal + 'px');
    			//}
    			// Adjust the width of the highlight to match inner boundary
    			Dom.setStyle(this._highlight,'width', Math.max(delta,0) + 'px');
    		},
    		
    		/**
    		 * Returns the pixel position of the left slider thumb corrected by 
    		 * the style sheet offset.
    		 */
    		getMinValNormalized: function() {
    			return this.minVal - 8;
    		},
    		
    		getMaxValNormalized: function() {
    			return this.maxVal - 8;
    		},
     		
    		/**
    		 * Take position of the slider thumbs, transforms them to values
    		 * in parameter value range and displays them.
    		 */
    		updateCaptionValues: function(event, options) {
    			var relPos = function(range, pos) {
    				return pos / range;
    			};
    			
    			var domRange = Math.abs(options._paramOptions.maxVal - options._paramOptions.minVal);
    			var minRelPos = relPos(options._paramOptions.range, this.getMinValNormalized());
    			var maxRelPos = relPos(options._paramOptions.range, this.getMaxValNormalized());
    			var min = options._paramOptions.minVal;
    			var minVal = (min + minRelPos * domRange).toFixed(options._paramOptions.precision);
    			var maxVal = (min + maxRelPos * domRange).toFixed(options._paramOptions.precision);
    			
    			YAHOO.util.Dom.get(options._paramOptions.inStartId).setValue(minVal);
    			YAHOO.util.Dom.get(options._paramOptions.inEndId).setValue(maxVal);
    			
    			options.appendUnitSign(YAHOO.util.Dom.get(options._paramOptions.inStartId), options._paramOptions.unit);
    			options.appendUnitSign(YAHOO.util.Dom.get(options._paramOptions.inEndId), options._paramOptions.unit);
    			
    			options._valuesChangedCB({id:options._paramOptions.id, value: { min:minVal, max:maxVal}, blockUpdate: this.blockUpdate});
    			
//    			// Avoid server update signal during initialisation
//    			this.forceUpdate = true;
    		},
    		
    		inputStartValueChanged: function(event, options) {
    			var val = this._calcSliderValue(options.range, options.minVal, options.maxVal, event.element().value);
    			this.setMinValue(val);
    			this.appendUnitSign(YAHOO.util.Dom.get(options.inStartId), options.unit, true);
    		},
    		
    		inputEndValueChanged: function(event, options) {
    			var val = this._calcSliderValue(options.range, options.minVal, options.maxVal, event.element().value);
    			this.setMaxValue(val);
    			this.appendUnitSign(YAHOO.util.Dom.get(options.inEndId), options.unit, true);
    		},
    		
    		/**
    		 * Calculates the value of the slider thumb from the a user
    		 * defined value of the actual parameter domain.
    		 */
    		_calcSliderValue: function(sliderRange, min, max, value) {
    			// VARs
    			var valNum;
    			
    			if(value) {
    				value = value.replace(/[^0-9.,-]/g, "");
    			}
    			var isNumber = function(n) {
    				  return !isNaN(parseFloat(n)) && isFinite(n);
    			};
    			
    			var decimals = function(x, dec_sep) {
    				var s = '' + x;
    				
    				if(s.indexOf(dec_sep) >= -1) {
    					return s.length - s.indexOf(dec_sep) - 1;
    				} else {
    					return 0;
    				}
    			};
    			
    			if(isNumber(value)) {
    				valNum = parseFloat(value);
    			} else {
    				return;
    			}
    			
    			
    			// Round to same precision for comparision
    			
    			var minD = decimals(min, '.');
    			var maxD = decimals(max, '.');
    			var valueD = decimals(valNum, '.');
    			
    			var d = Math.min(minD, maxD);
    			d = Math.min(d, valueD);
    			
    			min = parseFloat(min.toFixed(d));
    			max = parseFloat(max.toFixed(d));
    			valNum = parseFloat(valNum.toFixed(d));
    			
    			if(!valNum || min > max || min-1 > valNum || max+1 < valNum ) {return;}
    			
    			var domainRange = max - min;
    			// Normalize value and calculate relative position
    			var relPos = (value - min) / domainRange;
    			
    			// Determine the position on the slider
    			return sliderRange * relPos;
    		},
    		
    		/**
    		 * Removes the unit signs from input fields and only shows up the 
    		 * raw value.
    		 */
    		removeUnitSign: function(event, slider) {
				var val = this.getValue();
				this.setValue(val.replace(/[^0-9.,-]/g, ""));
    		},
    		
    		/**
    		 * Appends the unit sign after finished editing.
    		 * 
    		 * @param event
    		 * @param options
    		 */
    		appendUnitSign: function(inputEl, unit, force) {
    			var inStartEl = YAHOO.util.Dom.get(this._paramOptions.inStartId);
    			if(inStartEl.id != document.activeElement.id) {
    				inStartEl.setValue(inStartEl.getValue().replace(/[^0-9.,-]/g, "") + " " + unit);
    			}
    			
    			var inEndEl = YAHOO.util.Dom.get(this._paramOptions.inEndId);
    			if(inEndEl.id != document.activeElement.id) {
    				inEndEl.setValue(inEndEl.getValue().replace(/[^0-9.,-]/g, "") + " " + unit);
    			}
    		},
    		
    		// implements a semaphore to avoid undefined behavior of blur and
    		// focus events
    		_semaphore: {},
    		
    		enter: function(id) {
    			if(!this._semaphore[id]) {
    				this._semaphore[id] = 1;
    				return true;
    			}
    			else {
    				return false;
    			}
    		},
    		
    		exit: function(id) {
    			if(this._semaphore[id]) {
    				this._semaphore[id] = 0;
    				return true;
    			}
    			
    			else {
    				return false;
    			}
    		},
    		
    		/**
    		 * Key event arrow down key
    		 */
    		handleKeyDown: function(event, keyCode, scope) {
    			scope.slider._setNewValueFromKeyEvent(scope, -1);
    		},
    		
    		/**
    		 * Key event arrow up key
    		 */
    		handleKeyUp: function(event, keyCode, scope) {
    			scope.slider._setNewValueFromKeyEvent(scope, 1);
    		},
    		
    		/**
    		 * Set the value of the proper slider thumb and input value field.
    		 * 
    		 * @param scope
    		 * @param upDown
    		 */
    		_setNewValueFromKeyEvent: function(scope, upDown) {
    			var rangeToAdd = scope.slider._getRangePerTick(),
					rangeValueToAdd = scope.slider._getRangeValuePerTick(),
					inputEl = YAHOO.util.Dom.get(scope.elId),
					t = scope.sliderThumb,
					newRangeVal,newVal;
				
				// toCamelCase function
				var cmFn = function(s) {
					return s.charAt(0).toUpperCase() + s.substr(1);
				};
				
				// Calculate new slider thumb value
				rangeToAdd *= upDown;
				rangeValueToAdd *= upDown;
				newRangeVal = scope.slider[t + "Val"] - 8 + rangeToAdd;
				newVal = (parseFloat(inputEl.getValue()) + rangeValueToAdd).toFixed(scope.slider._paramOptions.precision);
				
				if(0 <= newRangeVal && newRangeVal <= scope.slider._paramOptions.range) {
					scope.slider["set" + cmFn(t) + "Value"](newRangeVal);
					inputEl.setValue(newVal);
					scope.slider.appendUnitSign(inputEl, scope.slider._paramOptions.unit);
				}
    		},
    		
    		_getRangePerTick: function() {
    			return this._paramOptions.range / 100;
    		},
    		
    		_getRangeValuePerTick: function() {
    			return Math.abs((this._paramOptions.maxVal - this._paramOptions.minVal)) / 100;
    		}
    	};
		
		// Calculate range
		range = parentEl.get("element").getWidth() - 11 /*(24 + (isScrolling?18:0))*/;
		
		var sliderEl = new YElement(document.createElement("div"));
		sliderEl.addClass("yui-timeframe-slider-container");
		parentEl.appendChild(sliderEl);
		
		// Append the parameter name, if defined
		if(typeof paramOptions.name != "undefined") {
			var labelBox = new YElement(document.createElement("div"));
			labelBox.addClass("yui-timeframe-slider-param-caption-container");
			
			var lineBorderContainerEL = new YElement(document.createElement("span"));
			lineBorderContainerEL.addClass("yui-timeframe-slider-param-caption-border");
			
			var paraEl = new YElement(document.createElement("span"));
			paraEl.addClass("yui-timeframe-slider-param-caption");
			paraEl.get("element").innerHTML = paramOptions.name + "&#09;";
			
			lineBorderContainerEL.appendChild(paraEl);
			labelBox.appendChild(lineBorderContainerEL);
			sliderEl.appendChild(labelBox);
			
			if((typeof paramOptions.min != "undefined") && (typeof paramOptions.max != "undefined")) {
				var mmS = new YElement(document.createElement("span"));
				mmS.get("element").innerHTML = "(" + paramOptions.min.toFixed(paramOptions.precision) + "/" + paramOptions.max.toFixed(paramOptions.precision) + ")";
				paraEl.appendChild(mmS);
			}
		}
		
		var bgEl = new YElement(document.createElement("div"));
		bgEl.addClass("yui-timeframe-slider-bg");
		bgEl.set("id", bgElId);
		
		var hlEl = new YElement(document.createElement("span"));
		hlEl.set("id", hlElId);
		bgEl.appendChild(hlEl);
		
		var sliderTickEl = new YElement(document.createElement("div"));
		sliderTickEl.addClass("yui-timeframe-slider-tick");
		bgEl.appendChild(sliderTickEl);
		
		var rBorderEl = new YElement(document.createElement("div"));
		rBorderEl.addClass("yui-timeframe-slider-border");
		rBorderEl.addClass("yui-timeframe-slider-border-right");
		bgEl.appendChild(rBorderEl);
		
		var lBorderEl = new YElement(document.createElement("div"));
		lBorderEl.addClass("yui-timeframe-slider-border");
		lBorderEl.addClass("yui-timeframe-slider-border-left");
		bgEl.appendChild(lBorderEl);
		
		var minThumbEl = new YElement(document.createElement("div"));
		minThumbEl.addClass("yui-timeframe-slider-thumb");
		minThumbEl.set("id",minThumbId);
		bgEl.appendChild(minThumbEl);
		
		var maxThumbEl = new YElement(document.createElement("div"));
		maxThumbEl.addClass("yui-timeframe-slider-thumb");
		maxThumbEl.set("id",maxThumbId);
		bgEl.appendChild(maxThumbEl);
		
		sliderEl.appendChild(bgEl);
		
		var containerEl = new YElement(document.createElement("div"));
		containerEl.addClass("yui-timeframe-slider-container-values");
		
		var inStartEl = new YElement(document.createElement("input"));
		inStartEl.addClass("yui-timeframe-slider-start-value");
		inStartEl.set("id", inStartId);
		containerEl.appendChild(inStartEl);
		
		var inEndEl = new YElement(document.createElement("input"));
		inEndEl.addClass("yui-timeframe-slider-end-value");
		inEndEl.set("id", inEndId);
		containerEl.appendChild(inEndEl);
		
		sliderEl.appendChild(containerEl);
		
		// generate Slider
		var slider = YAHOO.widget.Slider.getHorizDualSlider(bgElId, minThumbId, maxThumbId, range, tickSize);

		// Apply default callbacks
		YAHOO.lang.augmentObject(slider, defaultCallbacks);
		slider._valuesChangedCB = valuesChangedCB;

		slider._highlight = YAHOO.util.Dom.get(hlElId);
		
		// Attach the highlight method to the slider's change event
        slider.subscribe('change',slider.updateHighlight,slider,true);
        
        
        // Register key events
        var kl = YAHOO.util.KeyListener;
        
        // Key Down code = 40
        var klDown;
        klDown = new kl(inStartId, {keys:40}, {fn: slider.handleKeyDown, scope: {slider: slider, sliderThumb: "min", elId: inStartId}, correctScope: false});
        klDown.enable();
        klDown = new kl(inEndId, {keys:40}, {fn: slider.handleKeyDown, scope: {slider: slider, sliderThumb: "max", elId: inEndId}, correctScope: false});
        klDown.enable();
        
        
        // Key UP code = 38
        var klUp;
        klUp = new kl(inStartId, {keys:38}, {fn: slider.handleKeyUp, scope: {slider: slider, sliderThumb: "min", elId: inStartId}, correctScope: false});
        klUp.enable();
        klUp = new kl(inEndId, {keys:38}, {fn: slider.handleKeyUp, scope: {slider: slider, sliderThumb: "max", elId: inEndId}, correctScope: false});
        klUp.enable();
        
        // Options applied to the event handler
        var options = {
        	range : range,
        	minVal: paramOptions.min,
        	maxVal: paramOptions.max,
        	inStartId : inStartId,
        	inEndId : inEndId,
        	unit : paramOptions.unit,
        	precision: paramOptions.precision,
        	id: paramOptions.id
        };
        
        // Attach the highlight method to the slider's change event
        YAHOO.lang.augmentObject(slider, {_paramOptions:options});
        slider.subscribe('slideEnd',slider.updateCaptionValues, slider, true);
        
        // Register changes in input fields
        YAHOO.util.Event.addListener(inStartId, 'blur', slider.inputStartValueChanged, options, slider);
        YAHOO.util.Event.addListener(inEndId, 'blur', slider.inputEndValueChanged, options, slider);
        
        // Remove unit sign on focus
        YAHOO.util.Event.addListener(inStartId, 'focus', slider.removeUnitSign, slider, false);
        YAHOO.util.Event.addListener(inEndId, 'focus', slider.removeUnitSign, slider, false);
        
        // register user callbacks
        // expected structure: [{event:'...', cb:funcRef},{},...] 
        if(callbacks instanceof Array) {
        	callbacks.each(function(cb) {
        		if(cb.event && cb.cb) {
        			slider.subscribe(cb.event, cb.cb);
        		}
        	});
        }
        
		return slider;
    };
}();
