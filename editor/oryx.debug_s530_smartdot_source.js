/**

 * @namespace Oryx name space for different utility methods
 * @name ORYX.Utils
*/
ORYX.Utils = {
    /**
     * General helper method for parsing a param out of current location url
     * @example
     * // Current url in Browser => "http://oryx.org?param=value"
     * ORYX.Utils.getParamFromUrl("param") // => "value" 
     * @param {Object} name
     */
    getParamFromUrl: function(name){
        name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regexS = "[\\?&]" + name + "=([^&#]*)";
        var regex = new RegExp(regexS);
        var results = regex.exec(window.location.href);
        if (results == null) {
            return null;
        }
        else {
            return results[1];
        }
    },
	
	rgbToHsl: function(r, g, b){
	    r /= 255; 
		g /= 255;
		b /= 255;
		
	    var max = Math.max(r, g, b), min = Math.min(r, g, b);
	    var h, s, l = (max + min) / 2;
	
	    if(max == min){
	        h = s = 0; // achromatic
	    }else{
	        var d = max - min;
	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	        switch(max){
	            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	            case g: h = (b - r) / d + 2; break;
	            case b: h = (r - g) / d + 4; break;
	        }
	        h /= 6;
	    }
	
	    return [h, s, l];
	},
	
	hslToRgb: function(h, s, l){
	    var r, g, b;
	
	    if(s == 0){
	        r = g = b = l; // achromatic
	    }else{
	        function hue2rgb(p, q, t){
	            if(t < 0) t += 1;
	            if(t > 1) t -= 1;
	            if(t < 1/6) return p + (q - p) * 6 * t;
	            if(t < 1/2) return q;
	            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
	            return p;
	        }
	
	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;
	        r = hue2rgb(p, q, h + 1/3);
	        g = hue2rgb(p, q, h);
	        b = hue2rgb(p, q, h - 1/3);
	    }
	
	    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
	},
	
	adjustLightness : function(color, lightness){
		if (!color) {
			return "";
		} else if (lightness === 1){
			return color;
		} else if (lightness === 0){
			return "#ffffff";
		}
		
		color = color.length === 7 && color[0] === "#" ? color : "#ffffff";
		
		var r = Math.min(255, parseInt(color[1]+color[2], 16));
		var g = Math.min(255, parseInt(color[3]+color[4], 16));
		var b = Math.min(255, parseInt(color[5]+color[6], 16));
		
		var hsl = ORYX.Utils.rgbToHsl(r,g,b);
		var old = hsl[2];
		
		hsl[2] = 0.15*Math.tan(2.4*hsl[2]+1.8)+0.8;
		var rgb = ORYX.Utils.hslToRgb(hsl[0],hsl[1],(hsl[2]>1?old:hsl[2]));
		
		var aCol = [ 	
			parseInt(Math.min(255, rgb[0])),
			parseInt(Math.min(255, rgb[1])),
			parseInt(Math.min(255, rgb[2]))
		].map(function(c){
			return (c<16?"0":"")+c.toString(16);
		});
		return "#"+aCol.join("");
	},
	
	adjustGradient: function(gradient, reference){
		
		if (!gradient){return}
		
		var col = reference.getAttributeNS(null, "stop-color") || "#ffffff";
		col = col.length === 7 && col[0] === "#" ? col : "#ffffff";
		
		var r = Math.min(255, parseInt(col[1]+col[2], 16));
		var g = Math.min(255, parseInt(col[3]+col[4], 16));
		var b = Math.min(255, parseInt(col[5]+col[6], 16));
		
		var hsv = ORYX.Utils.rgbToHsl(r,g,b);
        hsv[2] 	= Math.min(hsv[2] +(0.9*hsv[2])+(hsv[2]<=0.2?(2-hsv[2])*0.2:0), 1);
		var rgb = ORYX.Utils.hslToRgb(hsv[0],hsv[1],hsv[2]);
		
		var getAdjustedColor = function(col2){
			var aCol = [ 	
					Math.min(255, rgb[0]),
					Math.min(255, rgb[1]),
					Math.min(255, rgb[2])
					]
					.map(function(c){
						return (c<16?"0":"")+c.toString(16);
					});
			return "#"+aCol.join("");
		}
	
		$A(gradient.getElementsByTagName("stop")).each(function(reference, stop){
			if (stop == reference || (stop.getAttributeNS(null, 'class')||"").include('ignore-adjust')){ return; }
			stop.setAttributeNS(null, "stop-color", getAdjustedColor("#FFFFFF"))
		}.bind(this, reference))
	},
	
	isGlossaryEntry: function(value){
		return typeof value === "string" && (this.isOldGlossarySchema(value) || value.startsWith("/glossary/"));
	},
	
	
	/**
	 * Returns TRUE if the value is in the (old) glossary schema
	 * @deprecated
	 * @param {String} value
	 * @returns {Boolean}
	 */
	isOldGlossarySchema: function(value){
		return typeof value === "string" && !!value.match(/\glossary\:\/\/.+\/[\w\W]+\;\;/g);
	},
	
	/**
	 * Returns the id of an (old) glossary url
	 * @deprecated Please use GlossaryManager
	 * @param {String} glossary
	 * @returns {String}
	 */
	getGlossaryId: function(grecord) {
    	if(ORYX.Utils.isOldGlossarySchema(grecord)) {
    		return (grecord||"").split(";;").invoke("replace", /\glossary\:\/\//g, "").invoke("replace", /\/[\w\W]+/g, "").first();
    	}
    	
    	return "";
    },
    
    glossaryTitle: function(grecord) {
    	if(ORYX.Utils.isOldGlossarySchema(grecord)) {
    		return (grecord||"").replace(/;;$/, "").replace(/\glossary\:\/\/.+?\//g, "");
    	}
    	return "";
    },
	
	getInGlossarySchema: function(id, title) {
		id = (id||"").replace(/([\/]|glossary)/g, "")
    	return "glossary://" + id + "/" + title + ";;";
    },
    
	isIPad: function(){
		return !!Ext.isIPad;
	},
	
	getBrowserVersion: function(){
		return (Ext.getBrowserVersion()||0).toFixed(1);

		// Deprecated
		// var userAgent = window.navigator.userAgent.toLowerCase();
		// var version = "";
		// if (Ext.isIE){
		// 	version = window.navigator.userAgent.toLowerCase().match(/msie.+?;/g).first().replace(/[^0-9\.]/g, "")
		// } else {
		// 	version = window.navigator.userAgent.toLowerCase().split(/\//g).last().split(/\s/g).first().replace(/[^0-9\.]/g, "");
		// }
		
		// version = (version.match(/[0-9]+\.[0-9]+/)||["xxx"]).first();
		// return version;
	},
	
	isMetaKey: function(event) {
		return !!(event.shiftKey || event.ctrlKey || event.metaKey);
	},
	
	buildGetColorForLabel: function(stencil) {
	    return ORYX.Utils.createGenericPropertyCheck(stencil, "color", "value", "");
	},
	
	buildIsRichtextForLabel: function(stencil) {
	    return ORYX.Utils.createGenericPropertyCheck(stencil, "string", "richtextEnabled", false);
	},
	
	createGenericPropertyCheck: function(stencil, type, fn, defaultValue) {
	    var properties = stencil.properties().select(function(property) {
	        return property.type().toLowerCase() === type.toLowerCase();
	    });
	    
	    if(properties.length === 0) {
	        return function() {
	            return defaultValue;
	        };
	    }
	    
	    return function(label) {
	        var id = label.id;
	        
	        var property = properties.find(function(p) {
	            return p.refToView().find(function(ref) {
	                return id.endsWith(ref);
	            });
	        });
	        
	        if(property && property[fn] instanceof Function) {
                return property[fn]();
	        }
	        
	        return defaultValue;
	    };
	}
}
/**
 * @author martin.czuchra
 */

XMLNS = {
	ATOM:	"http://www.w3.org/2005/Atom",
	XHTML:	"http://www.w3.org/1999/xhtml",
	ERDF:	"http://purl.org/NET/erdf/profile",
	RDFS:	"http://www.w3.org/2000/01/rdf-schema#",
	RDF:	"http://www.w3.org/1999/02/22-rdf-syntax-ns#",
	RAZIEL: "http://b3mn.org/Raziel",

	SCHEMA: ""
};

//TODO kann kickstart sich vielleicht auch um die erzeugung von paketen/
// namespaces k?mmern? z.b. requireNamespace("ORYX.Core.SVG");
var Kickstart = {
 	started: false,
	callbacks: [],
	alreadyLoaded: [],
	PATH: '',

	load: function() { Kickstart.kick(); },

	kick: function() {
		//console.profile("loading");
		if(!Kickstart.started) {
			Kickstart.started = true;
			Kickstart.callbacks.each(function(callback){
				// call the registered callback asynchronously.
				window.setTimeout(callback, 1);
			});
		}
	},

	register: function(callback) {
		//TODO Add some mutual exclusion between kick and register calls.
		with(Kickstart) {
			if(started) window.setTimeout(callback, 1);
			else Kickstart.callbacks.push(callback)
		}
	},

	/**
	 * Loads a js, assuring that it has only been downloaded once.
	 * @param {String} url the script to load.
	 */
	require: function(url) {
		// if not already loaded, include it.
		if(Kickstart.alreadyLoaded.member(url))
			return false;
		return Kickstart.include(url);
	},

	/**
	 * Loads a js, regardless of whether it has only been already downloaded.
	 * @param {String} url the script to load.
	 */
	include: function(url) {

		// prepare a script tag and place it in html head.
		var head = document.getElementsByTagNameNS(XMLNS.XHTML, 'head')[0];
		var s = document.createElementNS(XMLNS.XHTML, "script");
		s.setAttributeNS(XMLNS.XHTML, 'type', 'text/javascript');
	   	s.src = Kickstart.PATH + url;

		//TODO macht es sinn, dass neue skript als letztes kind in den head
		// einzubinden (stichwort reihenfolge der skript tags)?
	   	head.appendChild(s);

		// remember this url.
		Kickstart.alreadyLoaded.push(url);

		return true;
	}
}

// register kickstart as the new onload event listener on current window.
// previous listener(s) are triggered to launch with kickstart.
Event.observe(window, 'load', Kickstart.load);/**
 * @author martin.czuchra
 */

var ERDF = {

	LITERAL: 0x01,
	RESOURCE: 0x02,
	DELIMITERS: ['.', '-'],
	HASH: '#',
	HYPHEN: "-",

	schemas: [],
	callback: undefined,
	log: undefined,

	init: function(callback) {
		
		// init logging.
		//ERDF.log = Log4js.getLogger("oryx");
		//ERDF.log.setLevel(Log4js.Level.ALL);
		//ERDF.log.addAppender(new ConsoleAppender(ERDF.log, false));

		//if(ERDF.log.isTraceEnabled())
		//	ERDF.log.trace("ERDF Parser is initialized.");

		// register callbacks and default schemas.
		ERDF.callback = callback;
		ERDF.registerSchema('schema', XMLNS.SCHEMA);
		ERDF.registerSchema('rdfs', XMLNS.RDFS);
	},

	run: function() {

		//if(ERDF.log.isTraceEnabled())
		//	ERDF.log.trace("ERDF Parser is running.");

		// do the work.
		return ERDF._checkProfile() && ERDF.parse();
	},
	
	parse: function() {
		
		//(ERDF.log.isDebugEnabled())
		//	ERDF.log.debug("Begin parsing document metadata.");
		
		// time measuring
		ERDF.__startTime = new Date();

		var bodies = document.getElementsByTagNameNS(XMLNS.XHTML, 'body');
		var subject = {type: ERDF.RESOURCE, value: ''};

		var result = ERDF._parseDocumentMetadata() &&
			ERDF._parseFromTag(bodies[0], subject);
			
		// time measuring
		ERDF.__stopTime = new Date();

		var duration = (ERDF.__stopTime - ERDF.__startTime)/1000.;
		//alert('ERDF parsing took ' + duration + ' s.');
		
		return result;
	},
	
	_parseDocumentMetadata: function() {

		// get links from head element.
		var heads = document.getElementsByTagNameNS(XMLNS.XHTML, 'head');
		var links = heads[0].getElementsByTagNameNS(XMLNS.XHTML, 'link');
		var metas = heads[0].getElementsByTagNameNS(XMLNS.XHTML, 'meta');

		// process links first, since they could contain schema definitions.
		$A(links).each(function(link) {
			var properties = link.getAttribute('rel');
			var reversedProperties = link.getAttribute('rev');
			var value = link.getAttribute('href');
			
			ERDF._parseTriplesFrom(
				ERDF.RESOURCE, '',
				properties,
				ERDF.RESOURCE, value);
				
			ERDF._parseTriplesFrom(
				ERDF.RESOURCE, value,
				reversedProperties,
				ERDF.RESOURCE, '');
		});

		// continue with metas.
		$A(metas).each(function(meta) {
			var property = meta.getAttribute('name');
			var value = meta.getAttribute('content');
			
			ERDF._parseTriplesFrom(
				ERDF.RESOURCE, '',
				property,
				ERDF.LITERAL, value);
		});

		return true;
	},
	
	_parseFromTag: function(node, subject, depth) {
		
		// avoid parsing non-xhtml content.
		if(node.namespaceURI != XMLNS.XHTML) { return; }
		
		// housekeeping.
		if(!depth) depth=0;
		var id = node.getAttribute('id');

		// some logging.
		//if(ERDF.log.isTraceEnabled())
		//	ERDF.log.trace(">".times(depth) + " Parsing " + node.nodeName + " ("+node.nodeType+") for data on " +
		//		((subject.type == ERDF.RESOURCE) ? ('&lt;' + subject.value + '&gt;') : '') +
		//		((subject.type == ERDF.LITERAL) ? '"' + subject.value + '"' : ''));
		
		/* triple finding! */
		
		// in a-tags...
		if(node.nodeName.endsWith(':a') || node.nodeName == 'a') {
			var properties = node.getAttribute('rel');
			var reversedProperties = node.getAttribute('rev');
			var value = node.getAttribute('href');
			var title = node.getAttribute('title');
			var content = node.textContent;

			// rel triples
			ERDF._parseTriplesFrom(
				subject.type, subject.value,
				properties,
				ERDF.RESOURCE, value,
				function(triple) {
					var label = title? title : content;
					
					// label triples
					ERDF._parseTriplesFrom(
						triple.object.type, triple.object.value,
						'rdfs.label',
						ERDF.LITERAL, label);
				});

			// rev triples
			ERDF._parseTriplesFrom(
				subject.type, subject.value,
				reversedProperties,
				ERDF.RESOURCE, '');
				
			// type triples
			ERDF._parseTypeTriplesFrom(
				subject.type, subject.value,
				properties);

		// in img-tags...
		} else if(node.nodeName.endsWith(':img') || node.nodeName == 'img') {
			var properties = node.getAttribute('class');
			var value = node.getAttribute('src');
			var alt = node.getAttribute('alt');

			ERDF._parseTriplesFrom(
				subject.type, subject.value,
				properties,
				ERDF.RESOURCE, value,
				function(triple) {
					var label = alt;
					
					// label triples
					ERDF._parseTriplesFrom(
						triple.object.type, triple.object.value,
						'rdfs.label',
						ERDF.LITERAL, label);
				});

		}
		
		// in every tag
		var properties = node.getAttribute('class');
		var title = node.getAttribute('title');
		var content = node.textContent;
		var label = title ? title : content;
		
		// regular triples
		ERDF._parseTriplesFrom(
			subject.type, subject.value,
			properties,
			ERDF.LITERAL, label);

		if(id) subject = {type: ERDF.RESOURCE, value: ERDF.HASH+id};
		
		// type triples
		ERDF._parseTypeTriplesFrom(
			subject.type, subject.value,
			properties);

		// parse all children that are element nodes.
		var children = node.childNodes;
		if(children) $A(children).each(function(_node) {
			if(_node.nodeType == _node.ELEMENT_NODE)
				ERDF._parseFromTag(_node, subject, depth+1); });
	},
	
	_parseTriplesFrom: function(subjectType, subject, properties,
		objectType, object, callback) {
		
		if(!properties) return;
		properties.toLowerCase().split(' ').each( function(property) {
			
			//if(ERDF.log.isTraceEnabled())
			//	ERDF.log.trace("Going for property " + property);

			var schema = ERDF.schemas.find( function(schema) {
				return false || ERDF.DELIMITERS.find( function(delimiter) {
					return property.startsWith(schema.prefix + delimiter);
				});
			});
			
			if(schema && object) {
				property = property.substring(
					schema.prefix.length+1, property.length);
				var triple = ERDF.registerTriple(
					new ERDF.Resource(subject),
					{prefix: schema.prefix, name: property},
					(objectType == ERDF.RESOURCE) ?
						new ERDF.Resource(object) :
						new ERDF.Literal(object));
						
				if(callback) callback(triple);
			}
		});
	},
	
	_parseTypeTriplesFrom: function(subjectType, subject, properties, callback) {
		
		if(!properties) return;
		properties.toLowerCase().split(' ').each( function(property) {
			
			//if(ERDF.log.isTraceEnabled())
			//	ERDF.log.trace("Going for property " + property);
				
			var schema = ERDF.schemas.find( function(schema) {
				return false || ERDF.DELIMITERS.find( function(delimiter) {
					return property.startsWith(ERDF.HYPHEN + schema.prefix + delimiter);
				});
			});
			
			if(schema && subject) {
				property = property.substring(schema.prefix.length+2, property.length);
				var triple = ERDF.registerTriple(
					(subjectType == ERDF.RESOURCE) ?
						new ERDF.Resource(subject) :
						new ERDF.Literal(subject),
					{prefix: 'rdf', name: 'type'},
					new ERDF.Resource(schema.namespace+property));
				if(callback) callback(triple);
			}
		});
	},
	
	/**
	 * Checks for ERDF profile declaration in head of document.
	 */
	_checkProfile: function() {

		// get profiles from head element.
		var heads = document.getElementsByTagNameNS(XMLNS.XHTML, 'head');
		var profiles = heads[0].getAttribute("profile");
		var found = false;

		// if erdf profile is contained.
		if(profiles && profiles.split(" ").member(XMLNS.ERDF)) {

			// pass check.
			//if(ERDF.log.isTraceEnabled())
			//	ERDF.log.trace("Found ERDF profile " + XMLNS.ERDF);
			return true;
			
		} else {
		
			// otherwise fail check.
			//if(ERDF.log.isFatalEnabled())
			//	ERDF.log.fatal("No ERDF profile found.");
			return false;
		}
	},
	
	__stripHashes: function(s) {
		return (s && s.substring(0, 1)=='#') ? s.substring(1, s.length) : s;
	},
	
	registerSchema: function(prefix, namespace) {
		
		// TODO check whether already registered, if so, complain.
		ERDF.schemas.push({
			prefix: prefix,
			namespace: namespace
		});
		
		//if(ERDF.log.isDebugEnabled())
		//	ERDF.log.debug("Prefix '"+prefix+"' for '"+namespace+"' registered.");
	},
	
	registerTriple: function(subject, predicate, object) {
		
		// if prefix is schema, this is a schema definition.
		if(predicate.prefix.toLowerCase() == 'schema')
			this.registerSchema(predicate.name, object.value);
			
		var triple = new ERDF.Triple(subject, predicate, object);
		ERDF.callback(triple);
		
		//if(ERDF.log.isInfoEnabled())
		//	ERDF.log.info(triple)
		
		// return the registered triple.
		return triple;
	},
	
	__enhanceObject: function() {
		
		/* Resource state querying methods */
		this.isResource = function() {
			return this.type == ERDF.RESOURCE };
		this.isLocal = function() {
			return this.isResource() && this.value.startsWith('#') };
		this.isCurrentDocument = function() {
			return this.isResource() && (this.value == '') };
		
		/* Resource getter methods.*/
		this.getId = function() {
			return this.isLocal() ? ERDF.__stripHashes(this.value) : false; };

		/* Liiteral state querying methods  */
		this.isLiteral = function() {
			return this.type == ERDF.LIITERAL };
	},
	
	serialize: function(literal) {
		
		if(!literal){
			return "";
		}else if(literal.constructor == String) {
			return literal;
		} else if(literal.constructor == Boolean) {
			return literal? 'true':'false';
		} else {
			return literal.toString();
		}
	}
};


ERDF.Triple = function(subject, predicate, object) {
	
	this.subject = subject;
	this.predicate = predicate;
	this.object = object;
	
	this.toString = function() {
		
		return "[ERDF.Triple] " +
			this.subject.toString() + ' ' +
			this.predicate.prefix + ':' + this.predicate.name + ' ' +
			this.object.toString();
		};
};

ERDF.Resource = function(uri) {
	
	this.type = ERDF.RESOURCE;
	this.value = uri;
	ERDF.__enhanceObject.apply(this);
	
	this.toString = function() {
		return '&lt;' + this.value + '&gt;';
	}
	
};

ERDF.Literal = function(literal) {
	
	this.type = ERDF.LITERAL;
	this.value = ERDF.serialize(literal);
	ERDF.__enhanceObject.apply(this);

	this.toString = function() {
		return '"' + this.value + '"';
	}
};/**
 * @author martin.czuchra
 */

/*
 * Save and triple generation behaviour. Use this area to configure
 * data management to your needs.
 */
var USE_ASYNCHRONOUS_REQUESTS =		true;
var DISCARD_UNUSED_TRIPLES =			true;
var PREFER_SPANS_OVER_DIVS =			true;
var PREFER_TITLE_OVER_TEXTNODE =		false;
var RESOURCE_ID_PREFIX =				'resource';

var SHOW_DEBUG_ALERTS_WHEN_SAVING =	false;
var SHOW_EXTENDED_DEBUG_INFORMATION =	false;

/*
 * Back end specific workarounds.
 */

var USE_ARESS_WORKAROUNDS =		true;

/*
 * Data management constants. Do not change these, as they are used
 * both internally and externally to communicate on events and to identify
 * command object actions in triple production and embedding rules.
 */

// Resource constants
var RESOURCE_CREATED =			0x01;
var RESOURCE_REMOVED =			0x02;
var RESOURCE_SAVED =				0x04;
var RESOURCE_RELOADED =			0x08;
var RESOURCE_SYNCHRONIZED = 		0x10;

// Triple constants
var TRIPLE_REMOVE =	0x01;
var TRIPLE_ADD =		0x02;
var TRIPLE_RELOAD =	0x04;
var TRIPLE_SAVE =		0x08;

var PROCESSDATA_REF = 'processdata';

// HTTP status code constants
//
//// 2xx
//const 200_OK =			'Ok';
//const 201_CREATED =		'Created';
//const 202_ACCEPTED =		'Accepted';
//const 204_NO_CONTENT =	'No Content';
//
//// 3xx
//const 301_MOVED_PERMANENTLY =	'Moved Permanently';
//const 302_MOVED_TEMPORARILY =	'Moved Temporarily';
//const 304_NOT_MODIFIED =		'Not Modified';
//
//// 4xx
//const 400_BAD_REQUEST =	'Bad Request';
//const 401_UNAUTHORIZED =	'Unauthorized';
//const 403_FORBIDDEN =		'Forbidden';
//const 404_NOT_FOUND =		'Not Found';
//const 409_CONFLICT =		'Conflict';
//
//// 5xx
//const 500_INTERNAL_SERVER_ERROR =		'Internal Server Error';
//const 501_NOT_IMPLEMENTED =			'Not Implemented';
//const 502_BAD_GATEWAY =				'Bad Gateway';
//const 503_SERVICE_UNAVAILABLE =		'Service Unavailable';
//
/**
 * The Data Management object. Use this one when interacting with page internal
 * data. Initialize data management by DataManager.init();
 * @class DataManager
 */
var DataManager = {
	
	/**
	 * The init method should be called once in the DataManagers lifetime.
	 * It causes the DataManager to initialize itself, the erdf parser, do all
	 * neccessary registrations and configurations, to run the parser and
	 * from then on deliver all resulting triples.
	 * No parameters needed are needed in a call to this method.
	 */
	init: function() {
		ERDF.init(DataManager._registerTriple);
		DataManager.__synclocal();
	},
	
	/**
	 * This triple array is meant to be the whole knowledge of the DataManager.
	 */
	_triples: [],
	
	/**
	 * This method is meant for callback from erdf parsing. It is not to be
	 * used in another way than to add triples to the triple store.
	 * @param {Object} triple the triple to add to the triple store.
	 */
	_registerTriple: function(triple) {
		DataManager._triples.push(triple)
	},
	
	/**
	 * The __synclocal method is for internal usage only.
	 * It performs synchronization with the local document, that is, the triple
	 * store is adjustet to the content of the document, which could have been
	 * changed by any other applications running on the same page.
	 */
	__synclocal: function() {
		DataManager._triples = [];
		ERDF.run();
	},
	
	/**
	 * Makes the shape passed into this method synchronize itself with the DOM.
	 * This method returns the shapes resource object for further manipulation.
	 * @param {Object} shape
	 */
	__synchronizeShape: function(shape) {

		var r = ResourceManager.getResource(shape.resourceId);
		var serialize = shape.serialize();

		// store all serialize values
		serialize.each( function(ser) {
			
			var resource = (ser.type == 'resource');
			var _triple = new ERDF.Triple(
				new ERDF.Resource(shape.resourceId),
				{prefix: ser.prefix, name: ser.name},
				resource ?
					new ERDF.Resource(ser.value) :
					new ERDF.Literal(ser.value)
			);
			DataManager.setObject(_triple);
		});
		
		return r;
	},

	__storeShape: function(shape) {
		
		// first synchronize the shape,
		var resource = DataManager.__synchronizeShape(shape);
		
		// then save the synchronized dom.
		resource.save();
	},
		
	__forceExistance: function(shape) {
		
		if(!$(shape.resourceId)) {
			
			if(!$$('.' + PROCESSDATA_REF)[0])
				DataManager.graft(XMLNS.XHTML,
					document.getElementsByTagNameNS(XMLNS.XHTML, 'body').item(0), ['div', {'class': PROCESSDATA_REF, 'style':'display:none;'}]);
				
			// object is literal
			DataManager.graft(XMLNS.XHTML,
				$$('.' + PROCESSDATA_REF)[0], [
				
				'div', {
                    'id': shape.resourceId,
                    //This should be done in a more dynamic way!!!!!
                    'class': (shape instanceof ORYX.Core.Canvas) ? "-oryx-canvas" : undefined
                }
			]);
			
		} else {
			var resource = $(shape.resourceId)
			var children = $A(resource.childNodes)
			children.each( function(child) {
				resource.removeChild(child);
			});
		};
	},
	
	__persistShape: function(shape) {

		// a shape serialization.
		var shapeData = shape.serialize();
		
		// initialize a triple array and construct a shape resource
		// to be used in triple generation.
		var triplesArray = [];
		var shapeResource = new ERDF.Resource(shape.resourceId);

		// remove all triples for this particular shape's resource
		DataManager.removeTriples( DataManager.query(
			shapeResource, undefined, undefined));

		// for each data set in the shape's serialization
		shapeData.each( function(data) {

			// construct a triple's value
			var value = (data.type == 'resource') ?
				new ERDF.Resource(data.value) :
				new ERDF.Literal(data.value);

			// construct triple and add it to the DOM.
			DataManager.addTriple( new ERDF.Triple(
				shapeResource,
				{prefix: data.prefix, name: data.name},
				value
			));
		});
	},
	
	__persistDOM: function(facade) {

		// getChildShapes gets all shapes (nodes AND edges), deep flag
		// makes it return a flattened child hierarchy.
		
		var canvas = facade.getCanvas();
		var shapes = canvas.getChildShapes(true);
		var result = '';
		
		// persist all shapes.
		shapes.each( function(shape) {
			DataManager.__forceExistance(shape);
		});
		//DataManager.__synclocal();
		
		DataManager.__renderCanvas(facade);
		result += DataManager.serialize(
				$(ERDF.__stripHashes(facade.getCanvas().resourceId)), true);
				
		shapes.each( function(shape) {
			
			DataManager.__persistShape(shape);
			result += DataManager.serialize(
				$(ERDF.__stripHashes(shape.resourceId)), true);
		});
		
		//result += DataManager.__renderCanvas(facade);
		
		return result;
	},

	__renderCanvas: function(facade) {

		var canvas = facade.getCanvas();
		var stencilSets = facade.getStencilSets();
		var shapes = canvas.getChildShapes(true);
		
		DataManager.__forceExistance(canvas);
		
		DataManager.__persistShape(canvas);
		
		var shapeResource = new ERDF.Resource(canvas.resourceId);

		// remove all triples for this particular shape's resource
		DataManager.removeTriples( DataManager.query(
			shapeResource, undefined, undefined));

		DataManager.addTriple( new ERDF.Triple(
			shapeResource,
			{prefix: "oryx", name: "mode"},
			new ERDF.Literal("writable")
		));

		DataManager.addTriple( new ERDF.Triple(
			shapeResource,
			{prefix: "oryx", name: "mode"},
			new ERDF.Literal("fullscreen")
		));

		stencilSets.values().each(function(stencilset) {
			DataManager.addTriple( new ERDF.Triple(
				shapeResource,
				{prefix: "oryx", name: "stencilset"},
				new ERDF.Resource(stencilset.source().replace(/&/g, "%26"))
			));
			
			DataManager.addTriple( new ERDF.Triple(
				shapeResource,
				{prefix: "oryx", name: "ssnamespace"},
				new ERDF.Resource(stencilset.namespace())
			));
			
			stencilset.extensions().keys().each(function(extension) {
				DataManager.addTriple( new ERDF.Triple(
					shapeResource,
					{prefix: "oryx", name: "ssextension"},
					new ERDF.Literal(extension)
				));
			});
		});
						
		shapes.each(function(shape) {
			DataManager.addTriple( new ERDF.Triple(
				shapeResource,
				{prefix: "oryx", name: "render"},
				new ERDF.Resource("#" + shape.resourceId)
			));
		});
	},

	__counter: 0,
	__provideId: function() {
		
		while($(RESOURCE_ID_PREFIX+DataManager.__counter))
			DataManager.__counter++;
			
		return RESOURCE_ID_PREFIX+DataManager.__counter;
	},
		
	serializeDOM: function(facade) {
		
		return DataManager.__persistDOM(facade);
	},
	
	syncGlobal: function(facade) {
		
		return DataManager.__syncglobal(facade);
	},
	
	/**
	 * This method is used to synchronize local DOM with remote resources.
	 * Local changes are commited to the server, and remote changes are
	 * performed to the local document.
	 * @param {Object} facade The facade of the editor that holds certain
	 * resource representations as shapes.
	 */
	__syncglobal: function(facade) {

		// getChildShapes gets all shapes (nodes AND edges), deep flag
		// makes it return a flattened child hierarchy.
		
		var canvas = facade.getCanvas();
		var shapes = canvas.getChildShapes(true);

		// create dummy resource representations in the dom
		// for all shapes that were newly created.

		shapes.select( function(shape) {

			// select shapes without resource id.

			return !($(shape.resourceId));

		}).each( function(shape) {

			// create new resources for them.
			if(USE_ARESS_WORKAROUNDS) {
				
				/*
				 * This is a workaround due to a bug in aress. Resources are
				 * ignoring changes to raziel:type property once they are
				 * created. As long as this is not fixed, the resource is now
				 * being created using a randomly guessed id, this temporary id
				 * is then used in references and the appropriate div is being
				 * populated with properties.
				 * 
				 * AFTER THIS PHASE THE DATA IS INCONSISTENT AS REFERENCES POINT
				 * TO IDS THAT ARE UNKNOWN TO THE BACK END.
				 * 
				 * After the resource is actually created in aress, it gets an id
				 * that is persistent. All shapes are then being populated with the
				 * correct id references and stored on the server.
				 * 
				 * AFTER THE SAVE PROCESS HAS RETURNED, THE DATA IS CONSISTENT
				 * REGARDING THE ID REFERENCES AGAIN.
				 */
				
				var razielType = shape.properties['raziel-type'];
				
				var div = '<div xmlns="http://www.w3.org/1999/xhtml">' +
					'<span class="raziel-type">'+razielType+'</span></div>';

				var r = ResourceManager.__createResource(div);
				shape.resourceId = r.id();
				
			} else {
		
				var r = ResourceManager.__createResource();
				shape.resourceId = r.id();
			}

		});

		shapes.each( function(shape) {
			
			// store all shapes.
			DataManager.__storeShape(shape);
		});
	},
	
	/**
	 * This method serializes a single div into a string that satisfies the
	 * client/server communication protocol. It ingnores all elements that have
	 * an attribute named class that includes 'transient'.
	 * @param {Object} node the element to serialize.
	 * @param {Object} preserveNamespace whether to preserve the parent's
	 *                 namespace. If you are not sure about namespaces, provide
	 *                 just the element to be serialized.
	 */
	serialize: function(node, preserveNamespace) {

		if (node.nodeType == node.ELEMENT_NODE) {
			// serialize an element node.
			
			var children = $A(node.childNodes);
			var attributes = $A(node.attributes);
			var clazz = new String(node.getAttribute('class'));
			var ignore = clazz.split(' ').member('transient');

			// ignore transients.

			if(ignore)
				return '';

			// start serialization.
			
			var result = '<' + node.nodeName;
			
			// preserve namespace?
			if(!preserveNamespace) 
				result += ' xmlns="' + (node.namespaceURI ? node.namespaceURI : XMLNS.XHTML) + '" xmlns:oryx="http://oryx-editor.org"';
			
			// add all attributes.
			
			attributes.each(function(attribute) {
				
				var nodeName = attribute.nodeName, 
					nodeValue = String(attribute.nodeValue || "");
				
		        // Workaround for IE9:
		        // Marker point have " in the attribute value, 
		        // which have to be removed.
		        if (Ext.isIE){
		        	// Remove aspect ration value
		        	if (nodeName.toLowerCase() == "preserveaspectratio"){
		        		return;
		        	}
		        	// Remove empty transformation
		        	if (nodeName.toLowerCase() == "transform" && !nodeValue.trim()){
		        		return;
		        	}
		        	// Revert the fix for an IE9 bug with path markers shining through. The backend can't handle the opacity
		        	// value correctly when rendering PDFs (see https://signavio.plan.io/issues/6509).
		        	if (Ext.isIE9 && nodeName.toLowerCase() == "opacity" && parseFloat(nodeValue) === Signavio.CONFIG.IE9_PATH_OPACITY_FIX_VALUE) {
		        		return;
		        	}
		        	// Use ' instead of " in the attribute
		        	nodeValue = nodeValue.replace(/"/g, "'"); 
		        }
		        
				result += ' ' + nodeName + '="' + nodeValue + '"';
			});
			
			// close if no children.
			
			if(children.length == 0)
				result += '/>';
				
			else {
				
				// serialize all children.
				
				result += '>';
				children.each(function(_node) {
					result += DataManager.serialize(_node, true)});
				result += '</' + node.nodeName + '>'
			}

			return result;
			
		} else if (node.nodeType == node.TEXT_NODE) {
			
			// serialize a text node.
			return  String(node.nodeValue).blank() ? "" : node.nodeValue;
		}
		
		return '';
		
		//TODO serialize cdata areas also.
		//TODO work on namespace awareness.
	},

	addTriple: function(triple) {

		// assert the subject is a resource
		
		if(!triple.subject.type == ERDF.LITERAL)
			throw 'Cannot add the triple ' + triple.toString() +
				' because the subject is not a resource.'
		
		// get the element which represents this triple's subject.
		var elementId = ERDF.__stripHashes(triple.subject.value);
		var element = $(elementId);
				
		// assert the subject is inside this document.
		if(!element)
			throw 'Cannot add the triple ' + triple.toString() +
				' because the subject "'+elementId+'" is not in the document.';

		if(triple.object.type == ERDF.LITERAL)

			// object is literal
			DataManager.graft(XMLNS.XHTML, element, [
				'span', {'class': (triple.predicate.prefix + "-" +
					triple.predicate.name)}, triple.object.value.escapeHTML()
			]);
			
		else {

			// object is resource
			DataManager.graft(XMLNS.XHTML, element, [
				'a', {'rel': (triple.predicate.prefix + "-" +
					triple.predicate.name), 'href': triple.object.value}
			]);
			
		}

		return true;
	},
	
	removeTriples: function(triples) {

		// alert('Removing ' +triples.length+' triples.');

		// from all the triples select those ...
		var removed = triples.select(

			function(triple) {
				
				// TODO remove also from triple store.
				// ... that were actually removed.
				return DataManager.__removeTriple(triple);
			});
		
		// sync and return removed triples.
		// DataManager.__synclocal();
		return removed;
	},
	
	removeTriple: function(triple) {
		
		// remember whether the triple was actually removed.
		var result = DataManager.__removeTriple(triple);

		// sync and return removed triples.
		// DataManager.__synclocal();
		return result;
	},

	__removeTriple: function(triple) {
		
		// assert the subject is a resource
		if(!triple.subject.type == ERDF.LITERAL)
		
			throw 'Cannot remove the triple ' + triple.toString() +
				' because the subject is not a resource.';

		// get the element which represents this triple's subject.
		var elementId = ERDF.__stripHashes(triple.subject.value);
		var element = $(elementId);

		// assert the subject is inside this document.
		if(!element)
		
			throw 'Cannot remove the triple ' + triple.toString() +
				' because the subject is not in the document.';
	  
		if(triple.object.type == ERDF.LITERAL) {
	  
  			// continue searching actively for the triple.
			var result = DataManager.__removeTripleRecursively(triple, element);
			return result;
		}
	},

	__removeTripleRecursively: function(triple, continueFrom) {  

		// return when this node is not an element node.
		if(continueFrom.nodeType != continueFrom.ELEMENT_NODE)
			return false;
		
		var classes = new String(continueFrom.getAttribute('class'));
		var children = $A(continueFrom.childNodes);
		
		if(classes.include(triple.predicate.prefix + '-' + triple.predicate.name)) {
		  
			var content = continueFrom.textContent;
			if(	(triple.object.type == ERDF.LITERAL) &&
				(triple.object.value == content))

				continueFrom.parentNode.removeChild(continueFrom);
			
			return true;
		  
		} else {
		 
			children.each(function(_node) {
			DataManager.__removeTripleRecursively(triple, _node)});
			return false;
		}

	},

	/**
	 * graft() function
	 * Originally by Sean M. Burke from interglacial.com, altered for usage with
	 * SVG and namespace (xmlns) support. Be sure you understand xmlns before
	 * using this funtion, as it creates all grafted elements in the xmlns
	 * provided by you and all element's attribures in default xmlns. If you
	 * need to graft elements in a certain xmlns and wish to assign attributes
	 * in both that and another xmlns, you will need to do stepwise grafting,
	 * adding non-default attributes yourself or you'll have to enhance this
	 * function. Latter, I would appreciate: martin?apfelfabrik.de
	 * @param {Object} namespace The namespace in which
	 * 					elements should be grafted.
	 * @param {Object} parent The element that should contain the grafted
	 * 					structure after the function returned.
	 * @param {Object} t the crafting structure.
	 * @param {Object} doc the document in which grafting is performed.
	 */
	graft: function(namespace, parent, t, doc) {
		
	    doc = (doc || (parent && parent.ownerDocument) || document);
	    var e;
	    if(t === undefined) {
	        echo( "Can't graft an undefined value");
	    } else if(t.constructor == String) {
	        e = doc.createTextNode( t );
	    } else {
	        for(var i = 0; i < t.length; i++) {
	            if( i === 0 && t[i].constructor == String ) {
					var snared = t[i].match( /^([a-z][a-z0-9]*)\.([^\s\.]+)$/i );
	                if( snared ) {
	                    e = doc.createElementNS(namespace, snared[1]);
	                    e.setAttributeNS(null, 'class', snared[2] );
	                    continue;
	                }
	                snared = t[i].match( /^([a-z][a-z0-9]*)$/i );
	                if( snared ) {
	                    e = doc.createElementNS(namespace, snared[1]);  // but no class
	                    continue;
	                }
	
	                // Otherwise:
	                e = doc.createElementNS(namespace, "span");
	                e.setAttribute(null, "class", "namelessFromLOL" );
	            }
	
	            if( t[i] === undefined ) {
	                echo("Can't graft an undefined value in a list!");
	            } else if( t[i].constructor == String || t[i].constructor == Array) {
	                this.graft(namespace, e, t[i], doc );
	            } else if(  t[i].constructor == Number ) {
	                this.graft(namespace, e, t[i].toString(), doc );
	            } else if(  t[i].constructor == Object ) {
	                // hash's properties => element's attributes
	                for(var k in t[i]) { e.setAttributeNS(null, k, t[i][k] ); }
	            } else if(  t[i].constructor == Boolean ) {
	                this.graft(namespace, e, t[i] ? 'true' : 'false', doc );
				} else
					throw "Object " + t[i] + " is inscrutable as an graft arglet.";
	        }
	    }
		
		if(parent) parent.appendChild(e);
	
	    return Element.extend(e); // return the topmost created node
	},

	setObject: function(triple) {

		/**
		 * Erwartungen von Arvid an diese Funktion:
		 * - Es existiert genau ein triple mit dem Subjekt und Praedikat,
		 *   das uebergeben wurde, und dieses haelt uebergebenes Objekt.
		 */

		var triples = DataManager.query(
			triple.subject,
			triple.predicate,
			undefined
		);
		
		DataManager.removeTriples(triples);

		DataManager.addTriple(triple);

		return true;
	},
	
	query: function(subject, predicate, object) {

		/*
		 * Typical triple.
		 *	{value: subject, type: subjectType},
		 *	{prefix: schema.prefix, name: property},
		 *	{value: object, type: objectType});
		 */	
		 	
		return DataManager._triples.select(function(triple) {
			
			var select = ((subject) ?
				(triple.subject.type == subject.type) &&
				(triple.subject.value == subject.value) : true);
			if(predicate) {
				select = select && ((predicate.prefix) ?
					(triple.predicate.prefix == predicate.prefix) : true);
				select = select && ((predicate.name) ?
					(triple.predicate.name == predicate.name) : true);
			}
			select = select && ((object) ?
				(triple.object.type == object.type) &&
				(triple.object.value == object.value) : true);
			return select;
		});
	}
}

Kickstart.register(DataManager.init);

function assert(expr, m) { if(!expr) throw m; };

function DMCommand(action, triple) {
	
	// store action and triple.
	this.action = action;
	this.triple = triple;
	
	this.toString = function() {
		return 'Command('+action+', '+triple+')';
	};
}

function DMCommandHandler(nextHandler) {
	
	/**
	 * Private method to set the next handler in the Chain of Responsibility
	 * (see http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern for
	 * details).
	 * @param {DMCommandHandler} handler The handler that is next in the chain.
	 */
	this.__setNext = function(handler) {
		var _next = this.__next;
		this.__next = nextHandler;
		return _next ? _next : true;
	};
	this.__setNext(nextHandler);

	/**
	 * Invokes the next handler. If there is no next handler, this method
	 * returns false, otherwise it forwards the result of the handling.
	 * @param {Object} command The command object to be processed.
	 */
	this.__invokeNext = function(command) {
		return this.__next ? this.__next.handle(command) : false;
	};
	
	/**
	 * Handles a command. The abstract method process() is called with the
	 * command object that has been passed. If the process method catches the
	 * command (returns true on completion), the handle() method returns true.
	 * If the process() method doesn't catch the command, the next handler will
	 * be invoked.
	 * @param {Object} command The command object to be processed.
	 */
	this.handle = function(command) {
		return this.process(command) ? true : this.__invokeNext(command);
	}
	
	/**
	 * Empty process() method returning false. If javascript knew abstract
	 * class members, this would be one.
	 * @param {Object} command The command object to process.
	 */
	this.process = function(command) { return false; };
};

/**
 * This Handler manages the addition and the removal of meta elements in the
 * head of the document.
 * @param {DMCommandHandler} next The handler that is next in the chain.
 */
function MetaTagHandler(next) {
	
	DMCommandHandler.apply(this, [next]);
	this.process = function(command) {
		
		with(command.triple) {
			
			/* assert prerequisites */
			if( !(
				(subject instanceof ERDF.Resource) &&
				(subject.isCurrentDocument()) &&
				(object instanceof ERDF.Literal)
			))	return false;
		}
		
	};
};

var chain =	new MetaTagHandler();
var command = new DMCommand(TRIPLE_ADD, new ERDF.Triple(
	new ERDF.Resource(''),
	'rdf:tool',
	new ERDF.Literal('')
));

/*
if(chain.handle(command))
	alert('Handled!');
*/

ResourceManager = {
	
	__corrupt: false,
	__latelyCreatedResource: undefined,
	__listeners: $H(),
	__token: 1,
	
	addListener: function(listener, mask) {

		if(!(listener instanceof Function))
			throw 'Resource event listener is not a function!';
		if(!(mask))
			throw 'Invalid mask for resource event listener registration.';

		// construct controller and token.
		var controller = {listener: listener, mask: mask};
		var token = ResourceManager.__token++;
		
		// add new listener.
		ResourceManager.__listeners[token] = controller;
		
		// return the token generated.
		return token;
	},
	
	removeListener: function(token) {
		
		// remove the listener with the token and return it.
		return ResourceManager.__listners.remove(token);
	},
	
	__Event: function(action, resourceId) {
		this.action = action;
		this.resourceId = resourceId;
	},
	
	__dispatchEvent: function(event) {
		
		// get all listeners. for each listener, ...
		ResourceManager.__listeners.values().each(function(controller) {
			
			// .. if listener subscribed to this type of event ...
			if(event.action & controller.mask)
				return controller.listener(event);
		});
	},

	getResource: function(id) {

		// get all possible resources for this.
		id = ERDF.__stripHashes(id);
		var resources = DataManager.query(
			new ERDF.Resource('#'+id),
			{prefix: 'raziel', name: 'entry'},
			undefined
		);

		// check for consistency.
		if((resources.length == 1) && (resources[0].object.isResource())) {
			var entryUrl = resources[0].object.value;
			return new ResourceManager.__Resource(id, entryUrl);
		}

		// else throw an error message.
		throw ('Resource with id ' +id+ ' not recognized as such. ' +
			((resources.length > 1) ?
				' There is more than one raziel:entry URL.' :
				' There is no raziel:entry URL.'));

		return false;
	},

	__createResource: function(alternativeDiv) {
		
		var collectionUrls = DataManager.query(
			new ERDF.Resource(''),
			// TODO This will become raziel:collection in near future.
			{prefix: 'raziel', name: 'collection'},
			undefined
		);

		// check for consistency.
		
		if(	(collectionUrls.length == 1) &&
			(collectionUrls[0].object.isResource())) {

			// get the collection url.
			
			var collectionUrl = collectionUrls[0].object.value;
			var resource = undefined;
			
			// if there is an old id, serialize the dummy div from there,
			// otherwise create a dummy div on the fly.
			
			var serialization = alternativeDiv? alternativeDiv : 
					'<div xmlns="http://www.w3.org/1999/xhtml"></div>';
					
			ResourceManager.__request(
				'POST', collectionUrl, serialization,

				// on success
				function() {
					
					// get div and id that have been generated by the server.
					
					var response = (this.responseXML);
					var div = response.childNodes[0];
					var id = div.getAttribute('id');
					
					// store div in DOM
					if(!$$('.' + PROCESSDATA_REF)[0])
						DataManager.graft(XMLNS.XHTML,
							document.getElementsByTagNameNS(XMLNS.XHTML, 'body').item(0), ['div', {'class': PROCESSDATA_REF, 'style':'display:none;'}]);
				
					$$('.' + PROCESSDATA_REF)[0].appendChild(div.cloneNode(true));

					// parse local erdf data once more.
					
					DataManager.__synclocal();
					
					// get new resource object.

					resource = new ResourceManager.getResource(id);

					// set up an action informing of the creation.
					
					ResourceManager.__resourceActionSucceeded(
						this, RESOURCE_CREATED, undefined);
				},

				function() { ResourceManager.__resourceActionFailed(
					this, RESOURCE_CREATED, undefined);},
				false
			);
			
			return resource;
		}
		
		// else
		throw 'Could not create resource! raziel:collection URL is missing!';
		return false;

	},
	
	__Resource: function(id, url) {
		
		this.__id = id;
		this.__url = url;
		
		/*
		 * Process URL is no longer needed to refer to the shape element on the
		 * canvas. AReSS uses the id's to gather information on fireing
		 * behaviour now.
		 */
		
//		// find the process url.		
//		var processUrl = undefined;
//		
//		var urls = DataManager.query(
//			new ERDF.Resource('#'+this.__id),
//			{prefix: 'raziel', name: 'process'},
//			undefined
//		);
//		
//		if(urls.length == 0) { throw 'The resource with the id ' +id+ ' has no process url.'};
//		
//		urls.each( function(triple) {
//			
//			// if there are more urls, use the last one.
//			processUrl = triple.object.value;
//		});
//		
//		this.__processUrl = processUrl;
//
//		// convenience function for getting the process url.
//		this.processUrl = function() {
//			return this.__processUrl;
//		}


		// convenience finction for getting the id.
		this.id = function() {
			return this.__id;
		}

		// convenience finction for getting the entry url.
		this.url = function() {
			return this.__url;
		}
		
		this.reload = function() {
			var _url = this.__url;
			var _id = this.__id;
			ResourceManager.__request(
				'GET', _url, null,
				function() { ResourceManager.__resourceActionSucceeded(
					this, RESOURCE_RELOADED, _id); },
				function() { ResourceManager.__resourceActionFailed(
					this, RESURCE_RELOADED, _id); },
				USE_ASYNCHRONOUS_REQUESTS
			);
		};
		
		this.save = function(synchronize) {
			var _url = this.__url;
			var _id = this.__id;
			data = DataManager.serialize($(_id));
			ResourceManager.__request(
				'PUT', _url, data,
				function() { ResourceManager.__resourceActionSucceeded(
					this, synchronize ? RESOURCE_SAVED | RESOURCE_SYNCHRONIZED : RESOURCE_SAVED, _id); },
				function() { ResourceManager.__resourceActionFailed(
					this, synchronize ? RESOURCE_SAVED | RESOURCE_SYNCHRONIZED : RESOURCE.SAVED, _id); },
				USE_ASYNCHRONOUS_REQUESTS
			);
		};
		
		this.remove = function() {
			var _url = this.__url;
			var _id = this.__id;
			ResourceManager.__request(
				'DELETE', _url, null,
				function() { ResourceManager.__resourceActionSucceeded(
					this, RESOURCE_REMOVED, _id); },
				function() { ResourceManager.__resourceActionFailed(
					this, RESOURCE_REMOVED, _id);},
				USE_ASYNCHRONOUS_REQUESTS
			);
		};
	},

	request: function(url, requestOptions) {

		var options = {
			method:       'get',
			asynchronous: true,
			parameters:   {}
		};

		Object.extend(options, requestOptions || {});
 		
		var params = Hash.toQueryString(options.parameters);
		if (params) 
			url += (url.include('?') ? '&' : '?') + params;
   
		return ResourceManager.__request(
			options.method, 
			url, 
			options.data, 
			(options.onSuccess instanceof Function ? function() { options.onSuccess(this); } : undefined ), 
			(options.onFailure instanceof Function ? function() { options.onFailure(this); } : undefined ), 
			options.asynchronous && USE_ASYNCHRONOUS_REQUESTS,
			options.headers);
	},
	
	__request: function(method, url, data, success, error, async, headers) {
		
		// get a request object
		var httpRequest = Try.these(

			/* do the Mozilla/Safari/Opera stuff */
			function() { return new XMLHttpRequest(); },
			
			/* do the IE stuff */
			function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
			function() { return new ActiveXObject("Microsoft.XMLHTTP") }
		);

		// if there is no request object ...
        if (!httpRequest) {
			if(!this.__corrupt)
				throw 'This browser does not provide any AJAX functionality. You will not be able to use the software provided with the page you are viewing. Please consider installing appropriate extensions.';
			this.__corrupt = true;
			return false;
        }
		
		if(success instanceof Function)
			httpRequest.onload = success;
		if(error instanceof Function) {
			httpRequest.onerror = error;
		}
		
		var h = $H(headers)
		h.keys().each(function(key) {
			
			httpRequest.setRequestHeader(key, h[key]);
		}); 
		
		try {

			if(SHOW_DEBUG_ALERTS_WHEN_SAVING)
			
				alert(method + ' ' + url + '\n' +
					SHOW_EXTENDED_DEBUG_INFORMATION ? data : '');

			// TODO Remove synchronous calls to the server as soon as xenodot
			// handles asynchronous requests without failure.
	        httpRequest.open(method, url, !async?false:true);
	        httpRequest.send(data);
			
		} catch(e) {
			return false;
		}
		return true;
    },

	__resourceActionSucceeded: function(transport, action, id) {
		
		var status = transport.status;
		var response = transport.responseText;
		
		if(SHOW_DEBUG_ALERTS_WHEN_SAVING)

			alert(status + ' ' + url + '\n' +
				SHOW_EXTENDED_DEBUG_INFORMATION ? data : '');

		// if the status code is not in 2xx, throw an error.
		if(status >= 300)
			throw 'The server responded with an error: ' + status + '\n' + (SHOW_EXTENDED_DEBUG_INFORMATION ? + data : 'If you need additional information here, including the data sent by the server, consider setting SHOW_EXTENDED_DEBUG_INFORMATION to true.');

		switch(action) {
			
			case RESOURCE_REMOVED:

				// get div and id
				var response = (transport.responseXML);
				var div = response.childNodes[0];
				var id = div.getAttribute('id');
				
				// remove the resource from DOM
				var localDiv = document.getElementById(id);
				localDiv.parentNode.removeChild(localDiv);
				break;

			case RESOURCE_CREATED:

				// nothing remains to be done.
				break;
	
			case RESOURCE_SAVED | RESOURCE_SYNCHRONIZED:

				DataManager.__synclocal();

			case RESOURCE_SAVED:

				// nothing remains to be done.
				break;

			case RESOURCE_RELOADED:
			
				// get div and id
				var response = (transport.responseXML);
				var div = response.childNodes[0];
				var id = div.getAttribute('id');
				
				// remove the local resource representation from DOM
				var localDiv = document.getElementById(id)
				localDiv.parentNode.removeChild(localDiv);
				
				// store div in DOM
				if(!$$(PROCESSDATA_REF)[0])
					DataManager.graft(XMLNS.XHTML,
						document.getElementsByTagNameNS(XMLNS.XHTML, 'body').item(0), ['div', {'class': PROCESSDATA_REF, 'style':'display:none;'}]);
				
				$$(PROCESSDATA_REF)[0].appendChild(div.cloneNode(true));
				DataManager.__synclocal();
				break;

			default:
				DataManager.__synclocal();

		}
		 
		// dispatch to all listeners ...
		ResourceManager.__dispatchEvent(

			// ... an event describing the change that happened here.
			new ResourceManager.__Event(action, id)
		);
	},

	__resourceActionFailed: function(transport, action, id) {
		throw "Fatal: Resource action failed. There is something horribly " +
			"wrong with either the server, the transport protocol or your " +
			"online status. Sure you're online?";
	}
}/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * The super class for all classes in ORYX. Adds some OOP feeling to javascript.
 * See article "Object Oriented Super Class Method Calling with JavaScript" on
 * http://truecode.blogspot.com/2006/08/object-oriented-super-class-method.html
 * for a documentation on this. Fairly good article that points out errors in
 * Douglas Crockford's inheritance and super method calling approach.
 * Worth reading.
 * @class Clazz
 */
var Clazz = function() {};

/**
 * Empty constructor.
 * @methodOf Clazz.prototype
 */
Clazz.prototype.construct = function() {};

/**
 * Can be used to build up inheritances of classes.
 * @example
 * var MyClass = Clazz.extend({
 *   construct: function(myParam){
 *     // Do sth.
 *   }
 * });
 * var MySubClass = MyClass.extend({
 *   construct: function(myParam){
 *     // Use this to call constructor of super class
 *     arguments.callee.$.construct.apply(this, arguments);
 *     // Do sth.
 *   }
 * });
 * @param {Object} def The definition of the new class.
 */
Clazz.extend = function(def) {
    var classDef = function() {
        if (arguments[0] !== Clazz) { this.construct.apply(this, arguments); }
    };
    
    var proto = new this(Clazz);
    var superClass = this.prototype;
    
    for (var n in def) {
        var item = def[n];                        
        if (item instanceof Function) item.$ = superClass;
        proto[n] = item;
    }

    classDef.prototype = proto;
    
    //Give this new class the same static extend method    
    classDef.extend = this.extend;        
    return classDef;
};/**
 * @author martin.czuchra
 */
if(!ORYX) var ORYX = {};

if(!ORYX.CONFIG) ORYX.CONFIG = {};

ORYX_LOGLEVEL = 4;

/**
 * Signavio specific variables
 */
//shanglihui 20111118
ORYX.CONFIG.BACKEND_SWITCH 		= 		false;
//ORYX.CONFIG.BACKEND_SWITCH 		= 		true;

ORYX.CONFIG.PANEL_LEFT_WIDTH 	= 		170;
ORYX.CONFIG.PANEL_RIGHT_COLLAPSED 	= 	true;
ORYX.CONFIG.PANEL_RIGHT_WIDTH	= 		300;
ORYX.CONFIG.APPNAME = 					'Signavio';
ORYX.CONFIG.WEB_URL = 					"explorer";

//This is usually the name of the war file!

//shanglihui 20111124
ORYX.CONFIG.ROOT_PATH =					"/v5designer/editor/"; //TODO: Remove last slash!!
ORYX.CONFIG.EXPLORER_PATH =				"/v5designer/explorer";
ORYX.CONFIG.LIBS_PATH =					"/v5designer/libs";
/*
ORYX.CONFIG.ROOT_PATH =					"../editor/"; //TODO: Remove last slash!!
ORYX.CONFIG.EXPLORER_PATH =				"../explorer";
ORYX.CONFIG.LIBS_PATH =					"../libs";
*/

ORYX.CONFIG.HELP_START_URL = 			"../help/en/index.html";
ORYX.CONFIG.HELP_START_URL_DE = 		"../help/de/index.html";

ORYX.CONFIG.DIAGRAMS_IMAGE_PATH = ORYX.CONFIG.EXPLORER_PATH + "/src/img";


ORYX.CONFIG.GLOSSARY_PROPERTY_SUFFIX = 	"_glossary";
ORYX.CONFIG.GLOSSARY_PROPERTY_DIRTY_SUFFIX = "_glossary_dirty";
ORYX.CONFIG.BLANK_IMAGE = ORYX.CONFIG.LIBS_PATH + '/ext-2.0.2/resources/images/default/s.gif';


/* Show grid line while dragging */
ORYX.CONFIG.SHOW_GRIDLINE = 			true;

/* Show size guides while resizing */
ORYX.CONFIG.SHOW_SIZEGUIDES = 			true;

/* Enable automatically containment */
ORYX.CONFIG.CONTAIN_AUTOMATICALY = true;

/* Show ID as a last entry in the propertywindow */
//shanglihui 20111230
ORYX.CONFIG.SHOW_ID_IN_PROPERTYWINDOW = true;
//ORYX.CONFIG.SHOW_ID_IN_PROPERTYWINDOW = false;

/* Disable Richtext Step 2 by default */
ORYX.CONFIG.RICHTEXT_2_ENABLED = false;

/**
 * Regular Config
 */	
/** this url is deprecated!!! */ 
ORYX.CONFIG.VERSION_URL =				"/VERSION";

ORYX.CONFIG.LICENSE_URL =				"/LICENSE";

//dhz 20111230
//ORYX.CONFIG.SERVER_HANDLER_ROOT = 		"../p";
ORYX.CONFIG.SERVER_HANDLER_ROOT = 		"";

ORYX.CONFIG.SERVER_EDITOR_HANDLER =		ORYX.CONFIG.SERVER_HANDLER_ROOT + "/editor";
ORYX.CONFIG.SERVER_MODEL_HANDLER =		ORYX.CONFIG.SERVER_HANDLER_ROOT + "/model";
ORYX.CONFIG.STENCILSET_HANDLER = 		ORYX.CONFIG.SERVER_HANDLER_ROOT + "/editor_stencilset?embedsvg=true&url=true&namespace=";    
ORYX.CONFIG.STENCIL_SETS_URL = 			ORYX.CONFIG.SERVER_HANDLER_ROOT + "/editor_stencilset";
ORYX.CONFIG.SERVER_PUBLISHER_HANDLER = 	ORYX.CONFIG.SERVER_HANDLER_ROOT + "/publisher";
ORYX.CONFIG.SERVER_GLOSSARY_HANDLER = 	ORYX.CONFIG.SERVER_HANDLER_ROOT + "/glossary";
ORYX.CONFIG.SERVER_GLOSSARY_PREFIX = 	ORYX.CONFIG.SERVER_GLOSSARY_HANDLER + "#gitem=";
ORYX.CONFIG.SERVER_DOWNLOAD_HANDLER = 	"/p/downloadla0932ukjpa09092345qfnsaisig";
ORYX.CONFIG.SERVER_EDITOR_DATA_HANDLER = ORYX.CONFIG.SERVER_HANDLER_ROOT + "/editordata";
ORYX.CONFIG.SERVER_EDITOR_CREATE_HANDLER = ORYX.CONFIG.SERVER_HANDLER_ROOT + "/editorcreate";

	/* Editor-Mode */
ORYX.CONFIG.MODE_READONLY =				"readonly";
ORYX.CONFIG.MODE_FULLSCREEN =			"fullscreen";
ORYX.CONFIG.WINDOW_HEIGHT = 			400;	
ORYX.CONFIG.PREVENT_LOADINGMASK_AT_READY = false;
ORYX.CONFIG.MAX_DIAGRAM_TITLE_LENGTH =	200;

	/* Plugins */
ORYX.CONFIG.QUERYEVAL_URL =             ORYX.CONFIG.ROOT_PATH + "query";
ORYX.CONFIG.PLUGINS_ENABLED =			true;

//dhz 20111230
ORYX.CONFIG.PLUGINS_CONFIG =			ORYX.CONFIG.SERVER_HANDLER_ROOT + "/v5designer/editor/config/plugins_s530_smartdot.xml";
//shanglihui 20111124
//ORYX.CONFIG.PLUGINS_CONFIG =			"/v5designer/editor/config/plugins_s530_smartdot.xml";
//ORYX.CONFIG.PLUGINS_CONFIG =			ORYX.CONFIG.SERVER_HANDLER_ROOT + "/editor_plugins";

ORYX.CONFIG.PLUGINS_FOLDER =			"Plugins/";
ORYX.CONFIG.PDF_EXPORT_URL =			"/p/pdf";
ORYX.CONFIG.LOLA_PN_CHECKER =			"/p/lolapnsoundchecker";
ORYX.CONFIG.PN_CHECKER =		 		"/p/pnchecksoundness";

ORYX.CONFIG.PNML_EXPORT_URL =			"/p/pnml";
ORYX.CONFIG.SIMPLE_PNML_EXPORT_URL =	"/p/simplepnmlexporter";
ORYX.CONFIG.DESYNCHRONIZABILITY_URL =	"/p/desynchronizability";
ORYX.CONFIG.IBPMN2BPMN_URL =			"/p/ibpmn2bpmn";
ORYX.CONFIG.DIAGRAM_PRINTER_URL =		"/printsvg";
ORYX.CONFIG.PLAUSIBILITYCHECKER_REQ = [ {
	stencilSet: "http://b3mn.org/stencilset/epc#"
 },
 {
	stencilSet: "http://b3mn.org/stencilset/bpmn1.1#",
	requiredExtension: "http://oryx-editor.org/stencilsets/extensions/timjpdl3#"
 }]	
ORYX.CONFIG.PROCESSMAP_DEFAULT_ARROW_WIDTH = 24;
ORYX.CONFIG.PLAUSIBILITYCHECKER_URL =	ORYX.CONFIG.SERVER_HANDLER_ROOT + "/plausibilitychecker";
ORYX.CONFIG.VALIDATOR_URL =				"/p/validator";
ORYX.CONFIG.AUTO_LAYOUTER_URL =			ORYX.CONFIG.ROOT_PATH + "layouter";
ORYX.CONFIG.SS_EXTENSIONS_FOLDER =		ORYX.CONFIG.ROOT_PATH + "stencilsets/extensions/";

//shanglihui 20111118
ORYX.CONFIG.SS_EXTENSIONS_CONFIG =		"/v5designer/editor/config/extensions.json";
ORYX.CONFIG.ORYX_NEW_URL =				"/v5designer/index.html";	
/*
ORYX.CONFIG.SS_EXTENSIONS_CONFIG =		ORYX.CONFIG.SERVER_HANDLER_ROOT + "/editor_ssextensions";
ORYX.CONFIG.ORYX_NEW_URL =				"/new";
*/

ORYX.CONFIG.STEP_THROUGH =				"/p/stepthrough";
ORYX.CONFIG.STEP_THROUGH_CHECKER =		ORYX.CONFIG.ROOT_PATH + "stepthroughchecker";
ORYX.CONFIG.XFORMS_EXPORT_URL =			"/p/xformsexport";
ORYX.CONFIG.XFORMS_EXPORT_ORBEON_URL =	"/p/xformsexport-orbeon";
ORYX.CONFIG.XFORMS_IMPORT_URL =			"/p/xformsimport";
ORYX.CONFIG.BPEL_EXPORT_URL =			ORYX.CONFIG.ROOT_PATH + "bpelexporter";
ORYX.CONFIG.BPEL4CHOR_EXPORT_URL =		ORYX.CONFIG.ROOT_PATH + "bpel4chorexporter";
ORYX.CONFIG.TREEGRAPH_SUPPORT =			ORYX.CONFIG.ROOT_PATH + "treegraphsupport";
ORYX.CONFIG.XPDL4CHOR2BPEL4CHOR_TRANSFORMATION_URL = ORYX.CONFIG.ROOT_PATH + "xpdl4chor2bpel4chor";
ORYX.CONFIG.RESOURCE_LIST =				ORYX.CONFIG.ROOT_PATH + "resourceList";
//shanglihui
//ORYX.CONFIG.BPMN_LAYOUTER =				"/p/bpmnlayouter";
ORYX.CONFIG.BPMN_LAYOUTER =				"/v5designer/p/bpmnlayouter";
ORYX.CONFIG.BPMN2MIGRATION =			ORYX.CONFIG.ROOT_PATH + "bpmn2migration";
ORYX.CONFIG.SYNTAXCHECKER_URL = 		ORYX.CONFIG.SERVER_HANDLER_ROOT + "/syntaxchecker";
ORYX.CONFIG.BPMN20_SCHEMA_VALIDATION_ON = true;
ORYX.CONFIG.BPMN20_SHAPEREPOSITORY_HIDE_POOLS_LANES = false;
ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS = 20;
ORYX.CONFIG.BPMN20_ENABLE_LANE_MOVE_BUTTONS = false;

ORYX.CONFIG.LAYOUTER = 					ORYX.CONFIG.SERVER_HANDLER_ROOT + "/layouter";
	
	/* Namespaces */
ORYX.CONFIG.NAMESPACE_ORYX =			"http://www.b3mn.org/oryx";
ORYX.CONFIG.NAMESPACE_SVG =				"http://www.w3.org/2000/svg";

	/* UI */
ORYX.CONFIG.CANVAS_WIDTH =				1485; 
ORYX.CONFIG.CANVAS_HEIGHT =				1050;
ORYX.CONFIG.CANVAS_RESIZE_INTERVAL =	300;
ORYX.CONFIG.SELECTED_AREA_PADDING =		4;
ORYX.CONFIG.CANVAS_BACKGROUND_COLOR =	"none";
ORYX.CONFIG.GRID_DISTANCE =				30;
ORYX.CONFIG.GRID_ENABLED =				true;
ORYX.CONFIG.ZOOM_OFFSET =				0.1;
ORYX.CONFIG.DEFAULT_SHAPE_MARGIN =		60;
ORYX.CONFIG.SCALERS_SIZE =				7;
ORYX.CONFIG.MINIMUM_SIZE =				20;
ORYX.CONFIG.MAXIMUM_SIZE =				20000;
ORYX.CONFIG.OFFSET_MAGNET =				15;
ORYX.CONFIG.OFFSET_EDGE_LABEL_TOP =		8;
ORYX.CONFIG.OFFSET_EDGE_LABEL_BOTTOM =	8;
ORYX.CONFIG.OFFSET_EDGE_BOUNDS =		Ext.isIPad ? 15 : 5;
ORYX.CONFIG.COPY_MOVE_OFFSET =			30;
	
ORYX.CONFIG.BORDER_OFFSET =				14;

ORYX.CONFIG.MAX_NUM_SHAPES_NO_GROUP	=	15;

ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER = 30;
ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET = 45;

	/* Shape-Menu Align */
ORYX.CONFIG.SHAPEMENU_RIGHT =			"Oryx_Right";
ORYX.CONFIG.SHAPEMENU_BOTTOM =			"Oryx_Bottom";
ORYX.CONFIG.SHAPEMENU_LEFT =			"Oryx_Left";
ORYX.CONFIG.SHAPEMENU_TOP =				"Oryx_Top";


	/* Morph-Menu Item */
ORYX.CONFIG.MORPHITEM_DISABLED =		"Oryx_MorphItem_disabled";

	/* Property type names */
ORYX.CONFIG.TYPE_STRING =				"string";
ORYX.CONFIG.TYPE_BOOLEAN =				"boolean";
ORYX.CONFIG.TYPE_INTEGER =				"integer";
ORYX.CONFIG.TYPE_FLOAT =				"float";
ORYX.CONFIG.TYPE_COLOR =				"color";
ORYX.CONFIG.TYPE_DATE =					"date";
ORYX.CONFIG.TYPE_CHOICE =				"choice";
ORYX.CONFIG.TYPE_URL =					"url";
ORYX.CONFIG.TYPE_DIAGRAM_LINK =			"diagramlink";
ORYX.CONFIG.TYPE_COMPLEX =				"complex";
ORYX.CONFIG.TYPE_TEXT =					"text";
ORYX.CONFIG.TYPE_EPC_FREQ = 			"epcfrequency";
ORYX.CONFIG.TYPE_GLOSSARY_LINK =		"glossarylink";
ORYX.CONFIG.TYPE_RADIOBUTTON = 			"radiobutton";

	
	/* Vertical line distance of multiline labels */
ORYX.CONFIG.LABEL_LINE_DISTANCE =		1.5;
ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT =	12;

	/* Open Morph Menu with Hover */
ORYX.CONFIG.ENABLE_MORPHMENU_BY_HOVER = false;


	/* Editor constants come here */
ORYX.CONFIG.EDITOR_ALIGN_BOTTOM =		0x01;
ORYX.CONFIG.EDITOR_ALIGN_MIDDLE =		0x02;
ORYX.CONFIG.EDITOR_ALIGN_TOP =			0x04;
ORYX.CONFIG.EDITOR_ALIGN_LEFT =			0x08;
ORYX.CONFIG.EDITOR_ALIGN_CENTER =		0x10;
ORYX.CONFIG.EDITOR_ALIGN_RIGHT =		0x20;
ORYX.CONFIG.EDITOR_ALIGN_SIZE =			0x30;

	/* Event types */
ORYX.CONFIG.EVENT_MOUSEDOWN =			"mousedown";
ORYX.CONFIG.EVENT_MOUSEUP =				"mouseup";
ORYX.CONFIG.EVENT_MOUSEOVER =			"mouseover";
ORYX.CONFIG.EVENT_MOUSEOUT =			"mouseout";
ORYX.CONFIG.EVENT_MOUSEMOVE =			"mousemove";
ORYX.CONFIG.EVENT_DBLCLICK =			"dblclick";
ORYX.CONFIG.EVENT_KEYDOWN =				"keydown";
ORYX.CONFIG.EVENT_KEYUP =				"keyup";

ORYX.CONFIG.EVENT_LOADED =				"editorloaded";
	
ORYX.CONFIG.EVENT_EXECUTE_COMMANDS =		"executeCommands";
ORYX.CONFIG.EVENT_LAST_EXECUTE_COMMANDS =	"lastCommandExecuted";
ORYX.CONFIG.EVENT_STENCIL_SET_LOADED =		"stencilSetLoaded";
ORYX.CONFIG.EVENT_SELECTION_CHANGED =		"selectionchanged";
ORYX.CONFIG.EVENT_SHAPEADDED =				"shapeadded";
ORYX.CONFIG.EVENT_BEFORE_REMOVE =			"beforeremove";
ORYX.CONFIG.EVENT_SHAPEREMOVED =			"shaperemoved";
ORYX.CONFIG.EVENT_PROPERTY_CHANGED =		"propertyChanged";
ORYX.CONFIG.EVENT_DRAGDROP_START =			"dragdrop.start";
ORYX.CONFIG.EVENT_SHAPE_MENU_CLOSE =		"shape.menu.close";
ORYX.CONFIG.EVENT_DRAGDROP_END =			"dragdrop.end";
ORYX.CONFIG.EVENT_RESIZE_START =			"resize.start";
ORYX.CONFIG.EVENT_RESIZE_END =				"resize.end";
ORYX.CONFIG.EVENT_CANVAS_RESIZE	=			"canvas.resize";
ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED =		"dragDocker.docked";
ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW =			"highlight.showHighlight";
ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE =			"highlight.hideHighlight";
ORYX.CONFIG.EVENT_POOLDOCKING_SHOW =	 	"poollanecreation.over";
ORYX.CONFIG.EVENT_POOLDOCKING_HIDE =	 	"poollanecreation.out";
ORYX.CONFIG.EVENT_LOADING_ENABLE =			"loading.enable";
ORYX.CONFIG.EVENT_LOADING_DISABLE =			"loading.disable";
ORYX.CONFIG.EVENT_LOADING_STATUS =			"loading.status";
ORYX.CONFIG.EVENT_OVERLAY_SHOW =			"overlay.show";
ORYX.CONFIG.EVENT_OVERLAY_HIDE =			"overlay.hide";
ORYX.CONFIG.EVENT_ARRANGEMENT_TOP =			"arrangement.setToTop";
ORYX.CONFIG.EVENT_ARRANGEMENT_BACK =		"arrangement.setToBack";
ORYX.CONFIG.EVENT_ARRANGEMENT_FORWARD =		"arrangement.setForward";
ORYX.CONFIG.EVENT_ARRANGEMENT_BACKWARD =	"arrangement.setBackward";
ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED =	"propertyWindow.propertyChanged";
ORYX.CONFIG.EVENT_LAYOUT_ROWS =				"layout.rows";
ORYX.CONFIG.EVENT_LAYOUT_BPEL =				"layout.BPEL";
ORYX.CONFIG.EVENT_LAYOUT_BPEL_VERTICAL =    "layout.BPEL.vertical";
ORYX.CONFIG.EVENT_LAYOUT_BPEL_HORIZONTAL =  "layout.BPEL.horizontal";
ORYX.CONFIG.EVENT_LAYOUT_BPEL_SINGLECHILD = "layout.BPEL.singlechild";
ORYX.CONFIG.EVENT_LAYOUT_BPEL_AUTORESIZE =	"layout.BPEL.autoresize";
ORYX.CONFIG.EVENT_AUTOLAYOUT_LAYOUT =		"autolayout.layout";
ORYX.CONFIG.EVENT_UNDO_EXECUTE =			"undo.execute";
ORYX.CONFIG.EVENT_UNDO_ROLLBACK =			"undo.rollback";
ORYX.CONFIG.EVENT_UNDO_BEFORE_EXECUTE =		"undo.before.execute";
ORYX.CONFIG.EVENT_UNDO_BEFORE_ROLLBACK =	"undo.before.rollback";
ORYX.CONFIG.EVENT_BUTTON_UPDATE =           "toolbar.button.update";
ORYX.CONFIG.EVENT_LAYOUT = 					"layout.dolayout";
ORYX.CONFIG.EVENT_GLOSSARY_LINK_EDIT = 		"glossary.link.edit";
ORYX.CONFIG.EVENT_GLOSSARY_SHOW =			"glossary.show.info";
ORYX.CONFIG.EVENT_GLOSSARY_NEW =			"glossary.show.new";
ORYX.CONFIG.EVENT_DOCKERDRAG = 				"dragTheDocker";	
ORYX.CONFIG.EVENT_ZOOM = 					"view.zoom";
ORYX.CONFIG.EVENT_BPMN20_HASHCHILD =	 	"layout.bpmn20subprocess.hashchild";
ORYX.CONFIG.EVENT_BPMN20_DELETE_HASH =		"layout.bpmn20poollane.deletehash";
ORYX.CONFIG.EVENT_BPMN20_ADJUST_LANES =		"layout.bpmn20poollane.adjustlanes";
ORYX.CONFIG.EVENT_BPMN20_DIAGRAM_ORIENTATION_CHANGED = "layout.bpmn20diagram.orientation.changed";

ORYX.CONFIG.EVENT_SHOW_PROPERTYWINDOW =		"propertywindow.show";
ORYX.CONFIG.EVENT_SHOW_PROPERTYWINDOW_DIALOG = "propertywindow.show.dialog";
ORYX.CONFIG.EVENT_ABOUT_TO_SAVE = 			"file.aboutToSave";
ORYX.CONFIG.EVENT_SAVED = 					"file.saved";
	
	/* Selection Shapes Highlights */
ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE =				5;
ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR =				"#4444FF";
ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR2 =			"#9999FF";
	
ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_CORNER = 		"corner";
ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE = 	"rectangle";
	
ORYX.CONFIG.SELECTION_VALID_COLOR =					"#00FF00";
ORYX.CONFIG.SELECTION_INVALID_COLOR =				"#FF0000";


ORYX.CONFIG.DOCKER_DOCKED_COLOR =		"#00FF00";
ORYX.CONFIG.DOCKER_UNDOCKED_COLOR =		"#FF0000";
ORYX.CONFIG.DOCKER_SNAP_OFFSET =		10;
		
	/* Copy & Paste */
ORYX.CONFIG.EDIT_OFFSET_PASTE =			10;

	/* Key-Codes */
ORYX.CONFIG.KEY_CODE_X = 				88;
ORYX.CONFIG.KEY_CODE_C = 				67;
ORYX.CONFIG.KEY_CODE_V = 				86;
ORYX.CONFIG.KEY_CODE_DELETE = 			46;
ORYX.CONFIG.KEY_CODE_META =				224;
ORYX.CONFIG.KEY_CODE_BACKSPACE =		8;
ORYX.CONFIG.KEY_CODE_LEFT =				37;
ORYX.CONFIG.KEY_CODE_RIGHT =			39;
ORYX.CONFIG.KEY_CODE_UP =				38;
ORYX.CONFIG.KEY_CODE_DOWN =				40;

	// TODO Determine where the lowercase constants are still used and remove them from here.
ORYX.CONFIG.KEY_Code_enter =			12;
ORYX.CONFIG.KEY_Code_left =				37;
ORYX.CONFIG.KEY_Code_right =			39;
ORYX.CONFIG.KEY_Code_top =				38;
ORYX.CONFIG.KEY_Code_bottom =			40;

/* Supported Meta Keys */
	
ORYX.CONFIG.META_KEY_META_CTRL = 		"metactrl";
ORYX.CONFIG.META_KEY_ALT = 				"alt";
ORYX.CONFIG.META_KEY_SHIFT = 			"shift";

/* Key Actions */

ORYX.CONFIG.KEY_ACTION_DOWN = 			"down";
ORYX.CONFIG.KEY_ACTION_UP = 			"up";

/* Multi language */

// This config will be set to TRUE if the plugin is enabled
ORYX.CONFIG.MULTI_LANGUAGES_ENABLED = false;
ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT = "de";

ORYX.CONFIG.MULTI_LANGUAGES = {
		de: "de.png",
		eng: "gb.png"
};

// Canvas orientation
ORYX.CONFIG.CANVAS_ORIENTATION = "horizontal";


//Show SignavioBranding
ORYX.CONFIG.SIGNAVIO_BRANDING_CONFIGURABEL = false;

// Overriding translations of the plugins' group names, because these names are
// actually used for defining the order of the plugins in the toolbar and are
// never visible to the user. Therefore, a translation is not necessary but may
// influence the plugins' order.
if(!ORYX.I18N) { ORYX.I18N = {}; }
if(!ORYX.I18N.Help) { ORYX.I18N.Help = {}; }
ORYX.I18N.Help.group	= "Help";
if(!ORYX.I18N.AddDocker) { ORYX.I18N.AddDocker = {}; }
ORYX.I18N.AddDocker.group = "Docker";
if(!ORYX.I18N.Arrangement) { ORYX.I18N.Arrangement = {}; }
ORYX.I18N.Arrangement.groupZ = "Z-Order";
ORYX.I18N.Arrangement.groupA = "Alignment";
if(!ORYX.I18N.Edit) { ORYX.I18N.Edit = {}; }
ORYX.I18N.Edit.group = "Edit";
if(!ORYX.I18N.File) { ORYX.I18N.File = {}; }
ORYX.I18N.File.group = "File";
if(!ORYX.I18N.Save) { ORYX.I18N.Save = {}; }
ORYX.I18N.Save.group = "File";
if(!ORYX.I18N.Grouping) { ORYX.I18N.Grouping = {}; }
ORYX.I18N.Grouping.group = "Group";
if(!ORYX.I18N.Undo) { ORYX.I18N.Undo = {}; }
ORYX.I18N.Undo.group = "Undo";
if(!ORYX.I18N.View) { ORYX.I18N.View = {}; }
ORYX.I18N.View.group = "Zoom";
if(!ORYX.I18N.SyntaxChecker) { ORYX.I18N.SyntaxChecker = {}; }
ORYX.I18N.SyntaxChecker.group = "Verification";


if(!Signavio) var Signavio = {};
if(!Signavio.I18N) { Signavio.I18N = {}; }
if(!Signavio.I18N.Migration) { Signavio.I18N.Migration = {}; }
Signavio.I18N.Migration.group = "Export";
if(!Signavio.I18N.ViewsEditor) { Signavio.I18N.ViewsEditor = {}; }
Signavio.I18N.ViewsEditor.group	= "Views";
if(!Signavio.I18N.PlausibilityChecker) { Signavio.I18N.PlausibilityChecker = {}; }
Signavio.I18N.PlausibilityChecker.group = "Verification";
if (!Signavio.CONFIG) {Signavio.CONFIG = {}; }
if (!Signavio.CONFIG.PROPERTY) {Signavio.CONFIG.PROPERTY ={}; }
/**
 * Fix for SVG path markers shining through overlay windows (like save dialog) in IE9.
 * See:
 * http://stackoverflow.com/questions/18837012/svg-markers-showing-through-overlaid-content-ie9#
 */
Signavio.CONFIG.IE9_PATH_OPACITY_FIX_VALUE = 0.9999;
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

function printf() {
	
	var result = arguments[0];
	for (var i=1; i<arguments.length; i++)
		result = result.replace('%' + (i-1), arguments[i]);
	return result;
}

// oryx constants.
var ORYX_LOGLEVEL_TRACE = 5;
var ORYX_LOGLEVEL_DEBUG = 4;
var ORYX_LOGLEVEL_INFO = 3;
var ORYX_LOGLEVEL_WARN = 2;
var ORYX_LOGLEVEL_ERROR = 1;
var ORYX_LOGLEVEL_FATAL = 0;
var ORYX_LOGLEVEL = 0;
var ORYX_CONFIGURATION_DELAY = 100;
var ORYX_CONFIGURATION_WAIT_ATTEMPTS = 10;

if(!ORYX) var ORYX = {};

ORYX = Object.extend(ORYX, {

	//set the path in the config.js file!!!!
	PATH: ORYX.CONFIG.ROOT_PATH,
	//CONFIGURATION: "config.js",

	URLS: [
	
		/*
		 * No longer needed, since compiled into one source file that
		 * contains all of this files concatenated in the exact order
		 * as defined in build.xml.
		 */
		
/*
		"scripts/Core/SVG/editpathhandler.js",
		"scripts/Core/SVG/minmaxpathhandler.js",
		"scripts/Core/SVG/pointspathhandler.js",
		"scripts/Core/SVG/svgmarker.js",
		"scripts/Core/SVG/svgshape.js",
		"scripts/Core/SVG/label.js",
		"scripts/Core/Math/math.js",		
		"scripts/Core/StencilSet/stencil.js",
		"scripts/Core/StencilSet/property.js",
		"scripts/Core/StencilSet/propertyitem.js",
		"scripts/Core/StencilSet/rules.js",
		"scripts/Core/StencilSet/stencilset.js",
		"scripts/Core/StencilSet/stencilsets.js",
		"scripts/Core/bounds.js",
		"scripts/Core/uiobject.js",
		"scripts/Core/abstractshape.js",
		"scripts/Core/canvas.js",
		"scripts/Core/main.js",
		"scripts/Core/svgDrag.js",
		"scripts/Core/shape.js",
		"scripts/Core/Controls/control.js",
		"scripts/Core/Controls/docker.js",
		"scripts/Core/Controls/magnet.js",		
		"scripts/Core/node.js",
		"scripts/Core/edge.js"
*/	],

	alreadyLoaded: [],

	configrationRetries: 0,

	Version: '0.1.1',

	availablePlugins: [],

	/**
	 * The ORYX.Log logger.
	 */
	Log: {
	
		__appenders: [
			{ append: function(message) {
				console.log(message); }}
		],
	
		trace: function() {	if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_TRACE)
			ORYX.Log.__log('TRACE', arguments); },
		debug: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_DEBUG)
			ORYX.Log.__log('DEBUG', arguments); },
		info: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_INFO)
			ORYX.Log.__log('INFO', arguments); },
		warn: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_WARN)
			ORYX.Log.__log('WARN', arguments); },
		error: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_ERROR)
			ORYX.Log.__log('ERROR', arguments); },
		fatal: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_FATAL)
			ORYX.Log.__log('FATAL', arguments); },
		
		__log: function(prefix, messageParts) {
			
			messageParts[0] = (new Date()).getTime() + " "
				+ prefix + " " + messageParts[0];
			var message = printf.apply(null, messageParts);
			
			ORYX.Log.__appenders.each(function(appender) {
				appender.append(message);
			});
		},
		
		addAppender: function(appender) {
			ORYX.Log.__appenders.push(appender);
		}
	},

	/**
	 * First bootstrapping layer. The Oryx loading procedure begins. In this
	 * step, all preliminaries that are not in the responsibility of Oryx to be
	 * met have to be checked here, such as the existance of the prototpe
	 * library in the current execution environment. After that, the second
	 * bootstrapping layer is being invoked. Failing to ensure that any
	 * preliminary condition is not met has to fail with an error.
	 */
	load: function() {
		
		if (ORYX.CONFIG.PREVENT_LOADINGMASK_AT_READY !== true) {
			var waitingpanel = new Ext.Window({renderTo:Ext.getBody(),id:'oryx-loading-panel',bodyStyle:'padding: 8px;background:white',title:ORYX.I18N.Oryx.title,width:'auto',height:'auto',modal:true,resizable:false,closable:false,html:'<span style="font-size:11px;">' + ORYX.I18N.Oryx.pleaseWait + '</span>'})
			waitingpanel.show()
		}
		
		ORYX.Log.debug("Oryx begins loading procedure.");
		
		// check for prototype
		if( (typeof Prototype=='undefined') ||
			(typeof Element == 'undefined') ||
			(typeof Element.Methods=='undefined') ||
			parseFloat(Prototype.Version.split(".")[0] + "." +
				Prototype.Version.split(".")[1]) < 1.5)

			throw("Application requires the Prototype JavaScript framework >= 1.5.3");
		
		ORYX.Log.debug("Prototype > 1.5 found.");

		
		/**
		 * APPEND SECURITY ISSUES
		 */
		(function(){

			/**
			 * Returns the currently valid security token
			 * @returns {String}
			 */
			Ext.Ajax.getSecurityToken = function(){
				var token = Signavio.Helper.getCookie("token");
				return (token && 32 == token.length && token) || "-null-";	// zhaofx: empty header cause xhr fail on chrome frame
			};
			
			Ext.Ajax.getSecurityParameter = function(){
				return {"signavio-id": Ext.Ajax.getSecurityToken()};
			};
			
			// Set header parameter for EXT
			Ext.Ajax.defaultHeaders = Ext.apply({}, Ext.Ajax.defaultHeaders || {});
			var doRequest = Ext.Ajax.request;
			Ext.Ajax.request = function(){
				var token = Ext.Ajax.getSecurityToken();
				if (token){
					this.defaultHeaders["x-signavio-id"] = token;
				} else {
					delete this.defaultHeaders["x-signavio-id"];
				}
				return doRequest.apply(this, arguments);
			};
			
			// Set header parameter for PROTOTYPE
			var setRequestHeaders = Ajax.Request.prototype.setRequestHeaders;
			Ajax.Request.prototype.setRequestHeaders = function(){
				setRequestHeaders.apply(this, arguments);
				this.transport.setRequestHeader("x-signavio-id", Ext.Ajax.getSecurityToken()); 
			};

		}());
		
		// continue loading.
		ORYX._load();
	},

	/**
	 * Second bootstrapping layer. The oryx configuration is checked. When not
	 * yet loaded, config.js is being requested from the server. A repeated
	 * error in retrieving the configuration will result in an error to be
	 * thrown after a certain time of retries. Once the configuration is there,
	 * all urls that are registered with oryx loading are being requested from
	 * the server. Once everything is loaded, the third layer is being invoked.
	 */
	_load: function() {
	/*
		// if configuration not there already,
		if(!(ORYX.CONFIG)) {
			
			// if this is the first attempt...
			if(ORYX.configrationRetries == 0) {
				
				// get the path and filename.
				var configuration = ORYX.PATH + ORYX.CONFIGURATION;
	
				ORYX.Log.debug("Configuration not found, loading from '%0'.",
					configuration);
				
				// require configuration file.
				Kickstart.require(configuration);
				
			// else if attempts exceeded ...
			} else if(ORYX.configrationRetries >= ORYX_CONFIGURATION_WAIT_ATTEMPTS) {
				
				throw "Tried to get configuration" +
					ORYX_CONFIGURATION_WAIT_ATTEMPTS +
					" times from '" + configuration + "'. Giving up."
					
			} else if(ORYX.configrationRetries > 0){
				
				// point out how many attempts are left...
				ORYX.Log.debug("Waiting once more (%0 attempts left)",
					(ORYX_CONFIGURATION_WAIT_ATTEMPTS -
						ORYX.configrationRetries));

			}
			
			// any case: continue in a moment with increased retry count.
			ORYX.configrationRetries++;
			window.setTimeout(ORYX._load, ORYX_CONFIGURATION_DELAY);
			return;
		}
		
		ORYX.Log.info("Configuration loaded.");
		
		// load necessary scripts.
		ORYX.URLS.each(function(url) {
			ORYX.Log.debug("Requireing '%0'", url);
			Kickstart.require(ORYX.PATH + url) });
	*/
		// configurate logging and load plugins.
		ORYX.loadPlugins();
	},

	/**
	 * Third bootstrapping layer. This is where first the plugin coniguration
	 * file is loaded into oryx, analyzed, and where all plugins are being
	 * requested by the server. Afterwards, all editor instances will be
	 * initialized.
	 */
	loadPlugins: function() {
		
		// load plugins if enabled.
		if(ORYX.CONFIG.PLUGINS_ENABLED)
			ORYX._loadPlugins()
		else
			ORYX.Log.warn("Ignoring plugins, loading Core only.");

		// init the editor instances.
		init();
	},
	
	_loadPlugins: function() {

		// load plugin configuration file.
		var source = ORYX.CONFIG.PLUGINS_CONFIG;

		ORYX.Log.debug("Loading plugin configuration from '%0'.", source);
	
		new Ajax.Request(source, {
			asynchronous: false,
			method: 'get',
			onSuccess: function(result) {

				/*
				 * This is the method that is being called when the plugin
				 * configuration was successfully loaded from the server. The
				 * file has to be processed and the contents need to be
				 * considered for further plugin requireation.
				 */
				
				ORYX.Log.info("Plugin configuration file loaded.");
		
				// get plugins.xml content
				var resultXml = result.responseXML;
				
				// TODO: Describe how properties are handled.
				// Get the globale Properties
				var globalProperties = [];
				var preferences = $A(resultXml.getElementsByTagName("properties"));
				preferences.each( function(p) {

					var props = $A(p.childNodes);
					props.each( function(prop) {
						var property = new Hash(); 
						
						// get all attributes from the node and set to global properties
						var attributes = $A(prop.attributes)
						attributes.each(function(attr){property[attr.nodeName] = attr.nodeValue});				
						if(attributes.length > 0) { globalProperties.push(property) };				
					});
				});

				
				// TODO Why are we using XML if we don't respect structure anyway?
				// for each plugin element in the configuration..
				var plugin = resultXml.getElementsByTagName("plugin");
				$A(plugin).each( function(node) {
					
					// get all element's attributes.
					// TODO: What about: var pluginData = $H(node.attributes) !?
					var pluginData = new Hash();
					$A(node.attributes).each( function(attr){
						pluginData[attr.nodeName] = attr.nodeValue});				
					
					// ensure there's a name attribute.
					if(!pluginData['name']) {
						ORYX.Log.error("A plugin is not providing a name. Ingnoring this plugin.");
						return;
					}

					// ensure there's a source attribute.
//					if(!pluginData['source']) {
//						ORYX.Log.error("Plugin with name '%0' doesn't provide a source attribute.", pluginData['name']);
//						return;
//					}
					
					// Get all private Properties
					var propertyNodes = node.getElementsByTagName("property");
					var properties = [];
					$A(propertyNodes).each(function(prop) {
						var property = new Hash(); 
						
						// Get all Attributes from the Node			
						var attributes = $A(prop.attributes)
						attributes.each(function(attr){property[attr.nodeName] = attr.nodeValue});				
						if(attributes.length > 0) { properties.push(property) };	
					
					});
					
					// Set all Global-Properties to the Properties
					properties = properties.concat(globalProperties);
					
					// Set Properties to Plugin-Data
					pluginData['properties'] = properties;
					
					// Get the RequieredNodes
					var requireNodes = node.getElementsByTagName("requires");
					var requires;
					$A(requireNodes).each(function(req) {			
						var namespace = $A(req.attributes).find(function(attr){ return attr.name == "namespace"})
						if( namespace && namespace.nodeValue ){
							if( !requires ){
								requires = {namespaces:[]}
							}
						
							requires.namespaces.push(namespace.nodeValue)
						} 
					});					
					
					// Set Requires to the Plugin-Data, if there is one
					if( requires ){
						pluginData['requires'] = requires;
					}


					// Get the RequieredNodes
					var notUsesInNodes = node.getElementsByTagName("notUsesIn");
					var notUsesIn;
					$A(notUsesInNodes).each(function(not) {			
						var namespace = $A(not.attributes).find(function(attr){ return attr.name == "namespace"})
						if( namespace && namespace.nodeValue ){
							if( !notUsesIn ){
								notUsesIn = {namespaces:[]}
							}
						
							notUsesIn.namespaces.push(namespace.nodeValue)
						} 
					});					
					
					// Set Requires to the Plugin-Data, if there is one
					if( notUsesIn ){
						pluginData['notUsesIn'] = notUsesIn;
					}		
					
								
//					var url = ORYX.PATH + ORYX.CONFIG.PLUGINS_FOLDER + pluginData['source'];
//		
//					ORYX.Log.debug("Requireing '%0'", url);
//		
					// Add the Script-Tag to the Site
					//Kickstart.require(url);
		
					ORYX.Log.info("Plugin '%0' successfully loaded.", pluginData['name']);
		
					// Add the Plugin-Data to all available Plugins
					ORYX.availablePlugins.push(pluginData);
		
				});
		
			},
			onFailure:this._loadPluginsOnFails
		});

	},

	_loadPluginsOnFails: function(result) {

		ORYX.Log.error("Plugin configuration file not available.");
	}
});

ORYX.Log.debug('Registering Oryx with Kickstart');
Kickstart.register(ORYX.load);

/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}


/**
 * EditPathHandler
 * 
 * Edit SVG paths' coordinates according to specified from-to movement and
 * horizontal and vertical scaling factors. 
 * The resulting path's d attribute is stored in instance variable d.
 * 
 * @constructor
 */
ORYX.Core.SVG.EditPathHandler = Clazz.extend({
	
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);
		
		this.x = 0;
		this.y = 0;
		this.oldX = 0;
		this.oldY = 0;
		this.deltaWidth = 1;
		this.deltaHeight = 1;
		
		this.d = "";
	},
	
	/**
	 * init
	 * 
	 * @param {float} x Target point's x-coordinate
	 * @param {float} y Target point's y-coordinate
	 * @param {float} oldX Reference point's x-coordinate
	 * @param {float} oldY Reference point's y-coordinate
	 * @param {float} deltaWidth Horizontal scaling factor
	 * @param {float} deltaHeight Vertical scaling factor
	 */
	init: function(x, y, oldX, oldY, deltaWidth, deltaHeight) {
		this.x = x;
		this.y = y;
		this.oldX = oldX;
		this.oldY = oldY;
		this.deltaWidth = deltaWidth;
		this.deltaHeight = deltaHeight;
		
		this.d = "";
	},

	/**
	 * editPointsAbs
	 * 
	 * @param {Array} points Array of absolutePoints
	 */
	editPointsAbs: function(points) {
		if(points instanceof Array) {
			var newPoints = [];
			var x, y;
			for(var i = 0; i < points.length; i++) {
				x = (parseFloat(points[i]) - this.oldX)*this.deltaWidth + this.x;
				i++;
				y = (parseFloat(points[i]) - this.oldY)*this.deltaHeight + this.y;
				newPoints.push(x);
				newPoints.push(y);
			}
			
			return newPoints;
		} else {
			//TODO error
		}
	},
	
	/**
	 * editPointsRel
	 * 
	 * @param {Array} points Array of absolutePoints
	 */
	editPointsRel: function(points) {
		if(points instanceof Array) {
			var newPoints = [];
			var x, y;
			for(var i = 0; i < points.length; i++) {
				x = parseFloat(points[i])*this.deltaWidth;
				i++;
				y = parseFloat(points[i])*this.deltaHeight;
				newPoints.push(x);
				newPoints.push(y);
			}
			
			return newPoints;
		} else {
			//TODO error
		}
	},

	/**
	 * arcAbs - A
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcAbs: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    var pointsAbs = this.editPointsAbs([x, y]);
		var pointsRel = this.editPointsRel([rx, ry]);
		
		this.d = this.d.concat(" A" + pointsRel[0] + " " + pointsRel[1] + 
								" " + xAxisRotation + " " + largeArcFlag + 
								" " + sweepFlag + " " + pointsAbs[0] + " " +
								pointsAbs[1] + " ");					
	},

	/**
	 * arcRel - a
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcRel: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
		var pointsRel = this.editPointsRel([rx, ry, x, y]);
		
		this.d = this.d.concat(" a" + pointsRel[0] + " " + pointsRel[1] + 
								" " + xAxisRotation + " " + largeArcFlag + 
								" " + sweepFlag + " " + pointsRel[2] + " " +
								pointsRel[3] + " ");	
	},

	/**
	 * curvetoCubicAbs - C
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicAbs: function(x1, y1, x2, y2, x, y) {
	    var pointsAbs = this.editPointsAbs([x1, y1, x2, y2, x, y]);
		
		this.d = this.d.concat(" C" + pointsAbs[0] + " " + pointsAbs[1] + 
								" " + pointsAbs[2] + " " + pointsAbs[3] + 
								" " + pointsAbs[4] + " " + pointsAbs[5] + " ");	
	},

	/**
	 * curvetoCubicRel - c
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicRel: function(x1, y1, x2, y2, x, y) {
	    var pointsRel = this.editPointsRel([x1, y1, x2, y2, x, y]);
		
		this.d = this.d.concat(" c" + pointsRel[0] + " " + pointsRel[1] + 
								" " + pointsRel[2] + " " + pointsRel[3] + 
								" " + pointsRel[4] + " " + pointsRel[5] + " ");	
	},

	/**
	 * linetoHorizontalAbs - H
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalAbs: function(x) {
	    var pointsAbs = this.editPointsAbs([x, 0]);
		
		this.d = this.d.concat(" H" + pointsAbs[0] + " ");	
	},

	/**
	 * linetoHorizontalRel - h
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalRel: function(x) {
	    var pointsRel = this.editPointsRel([x, 0]);
		
		this.d = this.d.concat(" h" + pointsRel[0] + " ");	
	},

	/**
	 * linetoAbs - L
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoAbs: function(x, y) {
	    var pointsAbs = this.editPointsAbs([x, y]);
		
		this.d = this.d.concat(" L" + pointsAbs[0] + " " + pointsAbs[1] + " ");
	},

	/**
	 * linetoRel - l
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoRel: function(x, y) {
	    var pointsRel = this.editPointsRel([x, y]);
		
		this.d = this.d.concat(" l" + pointsRel[0] + " " + pointsRel[1] + " ");
	},

	/**
	 * movetoAbs - M
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoAbs: function(x, y) {
	    var pointsAbs = this.editPointsAbs([x, y]);
		
		this.d = this.d.concat(" M" + pointsAbs[0] + " " + pointsAbs[1] + " ");
	},

	/**
	 * movetoRel - m
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoRel: function(x, y) {
	    var pointsRel;
		if(this.d === "") {
			pointsRel = this.editPointsAbs([x, y]);
		} else {
			pointsRel = this.editPointsRel([x, y]);
		}
		
		this.d = this.d.concat(" m" + pointsRel[0] + " " + pointsRel[1] + " ");
	},

	/**
	 * curvetoQuadraticAbs - Q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticAbs: function(x1, y1, x, y) {
	    var pointsAbs = this.editPointsAbs([x1, y1, x, y]);
		
		this.d = this.d.concat(" Q" + pointsAbs[0] + " " + pointsAbs[1] + " " +
								pointsAbs[2] + " " + pointsAbs[3] + " ");
	},

	/**
	 * curvetoQuadraticRel - q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticRel: function(x1, y1, x, y) {
	    var pointsRel = this.editPointsRel([x1, y1, x, y]);
		
		this.d = this.d.concat(" q" + pointsRel[0] + " " + pointsRel[1] + " " +
								pointsRel[2] + " " + pointsRel[3] + " ");
	},

	/**
	 * curvetoCubicSmoothAbs - S
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothAbs: function(x2, y2, x, y) {
	    var pointsAbs = this.editPointsAbs([x2, y2, x, y]);
		
		this.d = this.d.concat(" S" + pointsAbs[0] + " " + pointsAbs[1] + " " +
								pointsAbs[2] + " " + pointsAbs[3] + " ");
	},

	/**
	 * curvetoCubicSmoothRel - s
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothRel: function(x2, y2, x, y) {
	    var pointsRel = this.editPointsRel([x2, y2, x, y]);
		
		this.d = this.d.concat(" s" + pointsRel[0] + " " + pointsRel[1] + " " +
								pointsRel[2] + " " + pointsRel[3] + " ");
	},

	/**
	 * curvetoQuadraticSmoothAbs - T
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothAbs: function(x, y) {
	    var pointsAbs = this.editPointsAbs([x, y]);
		
		this.d = this.d.concat(" T" + pointsAbs[0] + " " + pointsAbs[1] + " ");
	},

	/**
	 * curvetoQuadraticSmoothRel - t
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothRel: function(x, y) {
	    var pointsRel = this.editPointsRel([x, y]);
		
		this.d = this.d.concat(" t" + pointsRel[0] + " " + pointsRel[1] + " ");
	},

	/**
	 * linetoVerticalAbs - V
	 * 
	 * @param {Number} y
	 */
	linetoVerticalAbs: function(y) {
	    var pointsAbs = this.editPointsAbs([0, y]);
		
		this.d = this.d.concat(" V" + pointsAbs[1] + " ");
	},

	/**
	 * linetoVerticalRel - v
	 * 
	 * @param {Number} y
	 */
	linetoVerticalRel: function(y) {
	    var pointsRel = this.editPointsRel([0, y]);
		
		this.d = this.d.concat(" v" + pointsRel[1] + " ");
	},

	/**
	 * closePath - z or Z
	 */
	closePath: function() {
	    this.d = this.d.concat(" z");
	}

});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}


/**
 * MinMaxPathHandler
 * 
 * Determine the minimum and maximum of a SVG path's absolute coordinates.
 * For relative coordinates the absolute value is computed for consideration.
 * The values are stored in attributes minX, minY, maxX, and maxY.
 * 
 * @constructor
 */
ORYX.Core.SVG.MinMaxPathHandler = Clazz.extend({
	
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);
		
		this.minX = undefined;
		this.minY = undefined;
		this.maxX = undefined;
		this.maxY = undefined;
		
		this._lastAbsX = undefined;
		this._lastAbsY = undefined;
	},

	/**
	 * Store minimal and maximal coordinates of passed points to attributes minX, maxX, minY, maxY
	 * 
	 * @param {Array} points Array of absolutePoints
	 */
	calculateMinMax: function(points) {
		if(points instanceof Array) {
			var x, y;
			for(var i = 0; i < points.length; i++) {
				x = parseFloat(points[i]);
				i++;
				y = parseFloat(points[i]);
				
				this.minX = (this.minX !== undefined) ? Math.min(this.minX, x) : x;
				this.maxX = (this.maxX !== undefined) ? Math.max(this.maxX, x) : x;
				this.minY = (this.minY !== undefined) ? Math.min(this.minY, y) : y;
				this.maxY = (this.maxY !== undefined) ? Math.max(this.maxY, y) : y;
					
				this._lastAbsX = x;
				this._lastAbsY = y;
			}
		} else {
			//TODO error
		}
	},

	/**
	 * arcAbs - A
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcAbs: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    this.calculateMinMax([x, y]);
	},

	/**
	 * arcRel - a
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcRel: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    this.calculateMinMax([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoCubicAbs - C
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicAbs: function(x1, y1, x2, y2, x, y) {
	    this.calculateMinMax([x1, y1, x2, y2, x, y]);
	},

	/**
	 * curvetoCubicRel - c
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicRel: function(x1, y1, x2, y2, x, y) {
	    this.calculateMinMax([this._lastAbsX + x1, this._lastAbsY + y1,
							  this._lastAbsX + x2, this._lastAbsY + y2,
							  this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * linetoHorizontalAbs - H
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalAbs: function(x) {
	    this.calculateMinMax([x, this._lastAbsY]);
	},

	/**
	 * linetoHorizontalRel - h
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalRel: function(x) {
	    this.calculateMinMax([this._lastAbsX + x, this._lastAbsY]);
	},

	/**
	 * linetoAbs - L
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoAbs: function(x, y) {
	    this.calculateMinMax([x, y]);
	},

	/**
	 * linetoRel - l
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoRel: function(x, y) {
	    this.calculateMinMax([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * movetoAbs - M
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoAbs: function(x, y) {
	    this.calculateMinMax([x, y]);
	},

	/**
	 * movetoRel - m
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoRel: function(x, y) {
	    if(this._lastAbsX && this._lastAbsY) {
			this.calculateMinMax([this._lastAbsX + x, this._lastAbsY + y]);
		} else {
			this.calculateMinMax([x, y]);
		}
	},

	/**
	 * curvetoQuadraticAbs - Q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticAbs: function(x1, y1, x, y) {
	    this.calculateMinMax([x1, y1, x, y]);
	},

	/**
	 * curvetoQuadraticRel - q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticRel: function(x1, y1, x, y) {
	    this.calculateMinMax([this._lastAbsX + x1, this._lastAbsY + y1, this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoCubicSmoothAbs - S
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothAbs: function(x2, y2, x, y) {
	    this.calculateMinMax([x2, y2, x, y]);
	},

	/**
	 * curvetoCubicSmoothRel - s
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothRel: function(x2, y2, x, y) {
	    this.calculateMinMax([this._lastAbsX + x2, this._lastAbsY + y2, this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoQuadraticSmoothAbs - T
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothAbs: function(x, y) {
	    this.calculateMinMax([x, y]);
	},

	/**
	 * curvetoQuadraticSmoothRel - t
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothRel: function(x, y) {
	    this.calculateMinMax([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * linetoVerticalAbs - V
	 * 
	 * @param {Number} y
	 */
	linetoVerticalAbs: function(y) {
	    this.calculateMinMax([this._lastAbsX, y]);
	},

	/**
	 * linetoVerticalRel - v
	 * 
	 * @param {Number} y
	 */
	linetoVerticalRel: function(y) {
	    this.calculateMinMax([this._lastAbsX, this._lastAbsY + y]);
	},

	/**
	 * closePath - z or Z
	 */
	closePath: function() {
	    return;// do nothing
	}

});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}


/**
 * PathHandler
 * 
 * Determine absolute points of a SVG path. The coordinates are stored 
 * sequentially in the attribute points (x-coordinates at even indices,
 * y-coordinates at odd indices).
 * 
 * @constructor
 */
ORYX.Core.SVG.PointsPathHandler = Clazz.extend({
	
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);
		
		this.points = [];
		
		this._lastAbsX = undefined;
		this._lastAbsY = undefined;
	},

	/**
	 * addPoints
	 * 
	 * @param {Array} points Array of absolutePoints
	 */
	addPoints: function(points) {
		if(points instanceof Array) {
			var x, y;
			for(var i = 0; i < points.length; i++) {
				x = parseFloat(points[i]);
				i++;
				y = parseFloat(points[i]);
				
				this.points.push(x);
				this.points.push(y);
				//this.points.push({x:x, y:y});
					
				this._lastAbsX = x;
				this._lastAbsY = y;
			}
		} else {
			//TODO error
		}
	},

	/**
	 * arcAbs - A
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcAbs: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * arcRel - a
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcRel: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoCubicAbs - C
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicAbs: function(x1, y1, x2, y2, x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * curvetoCubicRel - c
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicRel: function(x1, y1, x2, y2, x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * linetoHorizontalAbs - H
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalAbs: function(x) {
	    this.addPoints([x, this._lastAbsY]);
	},

	/**
	 * linetoHorizontalRel - h
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalRel: function(x) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY]);
	},

	/**
	 * linetoAbs - L
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoAbs: function(x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * linetoRel - l
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoRel: function(x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * movetoAbs - M
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoAbs: function(x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * movetoRel - m
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoRel: function(x, y) {
	    if(this._lastAbsX && this._lastAbsY) {
			this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
		} else {
			this.addPoints([x, y]);
		}
	},

	/**
	 * curvetoQuadraticAbs - Q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticAbs: function(x1, y1, x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * curvetoQuadraticRel - q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticRel: function(x1, y1, x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoCubicSmoothAbs - S
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothAbs: function(x2, y2, x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * curvetoCubicSmoothRel - s
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothRel: function(x2, y2, x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoQuadraticSmoothAbs - T
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothAbs: function(x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * curvetoQuadraticSmoothRel - t
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothRel: function(x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * linetoVerticalAbs - V
	 * 
	 * @param {Number} y
	 */
	linetoVerticalAbs: function(y) {
	    this.addPoints([this._lastAbsX, y]);
	},

	/**
	 * linetoVerticalRel - v
	 * 
	 * @param {Number} y
	 */
	linetoVerticalRel: function(y) {
	    this.addPoints([this._lastAbsX, this._lastAbsY + y]);
	},

	/**
	 * closePath - z or Z
	 */
	closePath: function() {
	    return;// do nothing
	}

});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 *
 * Config variables
 */
NAMESPACE_ORYX = "http://www.b3mn.org/oryx";
NAMESPACE_SVG = "http://www.w3.org/2000/svg/";

/**
 * @classDescription This class wraps the manipulation of a SVG marker.
 * @namespace ORYX.Core.SVG
 * uses Inheritance (Clazz)
 * uses Prototype 1.5.0
 *
 */

/**
 * Init package
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}

ORYX.Core.SVG.SVGMarker = Clazz.extend({

	/**
	 * Constructor
	 * @param markerElement {SVGMarkerElement}
	 */
	construct: function(markerElement) {
		arguments.callee.$.construct.apply(this, arguments);

		this.id = undefined;
		this.element = markerElement;
		this.refX = undefined;
		this.refY = undefined;
		this.markerWidth = undefined;
		this.markerHeight = undefined;
		this.oldRefX = undefined;
		this.oldRefY = undefined;
		this.oldMarkerWidth = undefined;
		this.oldMarkerHeight = undefined;
		this.optional = false;
		this.enabled = true;
		this.minimumLength = undefined;
		this.resize = false;

		this.svgShapes = [];

		this._init(); //initialisation of all the properties declared above.
	},

	/**
	 * Initializes the values that are defined in the constructor.
	 */
	_init: function() {
		//check if this.element is a SVGMarkerElement
		if(!( this.element == "[object SVGMarkerElement]")) {
			throw "SVGMarker: Argument is not an instance of SVGMarkerElement.";
		}

		this.id = this.element.getAttributeNS(null, "id");
		
		//init svg marker attributes
		var refXValue = this.element.getAttributeNS(null, "refX");
		if(refXValue) {
			this.refX = parseFloat(refXValue);
		} else {
			this.refX = 0;
		}
		var refYValue = this.element.getAttributeNS(null, "refY");
		if(refYValue) {
			this.refY = parseFloat(refYValue);
		} else {
			this.refY = 0;
		}
		var markerWidthValue = this.element.getAttributeNS(null, "markerWidth");
		if(markerWidthValue) {
			this.markerWidth = parseFloat(markerWidthValue);
		} else {
			this.markerWidth = 3;
		}
		var markerHeightValue = this.element.getAttributeNS(null, "markerHeight");
		if(markerHeightValue) {
			this.markerHeight = parseFloat(markerHeightValue);
		} else {
			this.markerHeight = 3;
		}

		this.oldRefX = this.refX;
		this.oldRefY = this.refY;
		this.oldMarkerWidth = this.markerWidth;
		this.oldMarkerHeight = this.markerHeight;

		//init oryx attributes
		var optionalAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "optional");
		if(optionalAttr) {
			optionalAttr = optionalAttr.strip();
			this.optional = (optionalAttr.toLowerCase() === "yes");
		} else {
			this.optional = false;
		}

		var enabledAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "enabled");
		if(enabledAttr) {
			enabledAttr = enabledAttr.strip();
			this.enabled = !(enabledAttr.toLowerCase() === "no");
		} else {
			this.enabled = true;
		}

		var minLengthAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "minimumLength");
		if(minLengthAttr) {
			this.minimumLength = parseFloat(minLengthAttr);
		}

		var resizeAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "resize");
		if(resizeAttr) {
			resizeAttr = resizeAttr.strip();
			this.resize = (resizeAttr.toLowerCase() === "yes");
		} else {
			this.resize = false;
		}

		//init SVGShape objects
		//this.svgShapes = this._getSVGShapes(this.element);
	},

	/**
	 *
	 */
	_getSVGShapes: function(svgElement) {
		if(svgElement.hasChildNodes) {
			var svgShapes = [];
			var me = this;
			$A(svgElement.childNodes).each(function(svgChild) {
				try {
					var svgShape = new ORYX.Core.SVG.SVGShape(svgChild);
					svgShapes.push(svgShape);
				} catch (e) {
					svgShapes = svgShapes.concat(me._getSVGShapes(svgChild));
				}
			});
			return svgShapes;
		}
	},

	/**
	 * Writes the changed values into the SVG marker.
	 */
	update: function() {
		//TODO mache marker resizebar!!! aber erst wenn der rest der connectingshape funzt!

//		//update marker attributes
//		if(this.refX != this.oldRefX) {
//			this.element.setAttributeNS(null, "refX", this.refX);
//		}
//		if(this.refY != this.oldRefY) {
//			this.element.setAttributeNS(null, "refY", this.refY);
//		}
//		if(this.markerWidth != this.oldMarkerWidth) {
//			this.element.setAttributeNS(null, "markerWidth", this.markerWidth);
//		}
//		if(this.markerHeight != this.oldMarkerHeight) {
//			this.element.setAttributeNS(null, "markerHeight", this.markerHeight);
//		}
//
//		//update SVGShape objects
//		var widthDelta = this.markerWidth / this.oldMarkerWidth;
//		var heightDelta = this.markerHeight / this.oldMarkerHeight;
//		if(widthDelta != 1 && heightDelta != 1) {
//			this.svgShapes.each(function(svgShape) {
//
//			});
//		}

		//update old values to prepare the next update
		this.oldRefX = this.refX;
		this.oldRefY = this.refY;
		this.oldMarkerWidth = this.markerWidth;
		this.oldMarkerHeight = this.markerHeight;
	},
	
	toString: function() { return (this.element) ? "SVGMarker " + this.element.id : "SVGMarker " + this.element;}
 });/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 *
 * Config variables
 */
NAMESPACE_ORYX = "http://www.b3mn.org/oryx";
NAMESPACE_SVG = "http://www.w3.org/2000/svg/";

/**
 * @classDescription This class wraps the manipulation of a SVG basic shape or a path.
 * @namespace ORYX.Core.SVG
 * uses Inheritance (Clazz)
 * uses Prototype 1.5.0
 * uses PathParser by Kevin Lindsey (http://kevlindev.com/)
 * uses MinMaxPathHandler
 * uses EditPathHandler
 *
 */

//init package
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}

ORYX.Core.SVG.SVGShape = Clazz.extend({

	/**
	 * Constructor
	 * @param svgElem {SVGElement} An SVGElement that is a basic shape or a path.
	 */
	construct: function(svgElem, parent) {
		arguments.callee.$.construct.apply(this, arguments);

		this.type;
		this.element = svgElem;
		this.parent = parent;
		this.x = undefined;
		this.y = undefined;
		this.width = undefined;
		this.height = undefined;
		this.oldX = undefined;
		this.oldY = undefined;
		this.oldWidth = undefined;
		this.oldHeight = undefined;
		this.radiusX = undefined;
		this.radiusY = undefined;
		this.isHorizontallyResizable = false;
		this.isVerticallyResizable = false;
		//this.anchors = [];
		this.anchorLeft = false;
		this.anchorRight = false;
		this.anchorTop = false;
		this.anchorBottom = false;
		
		//attributes of path elements of edge objects
		this.allowDockers = true;
		this.resizeMarkerMid = false;

		this.editPathParser;
		this.editPathHandler;

		this.init(); //initialisation of all the properties declared above.
	},

	/**
	 * Initializes the values that are defined in the constructor.
	 */
	init: function() {

		/**initialize position and size*/
		if(ORYX.Editor.checkClassType(this.element, SVGRectElement) || ORYX.Editor.checkClassType(this.element, SVGImageElement)) {
			this.type = "Rect";
			
			var xAttr = this.element.getAttributeNS(null, "x");
			if(xAttr) {
				this.oldX = parseFloat(xAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var yAttr = this.element.getAttributeNS(null, "y");
			if(yAttr) {
				this.oldY = parseFloat(yAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var widthAttr = this.element.getAttributeNS(null, "width");
			if(widthAttr) {
				this.oldWidth = parseFloat(widthAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var heightAttr = this.element.getAttributeNS(null, "height");
			if(heightAttr) {
				this.oldHeight = parseFloat(heightAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}

		} else if(ORYX.Editor.checkClassType(this.element, SVGCircleElement)) {
			this.type = "Circle";
			
			var cx = undefined;
			var cy = undefined;
			//var r = undefined;

			var cxAttr = this.element.getAttributeNS(null, "cx");
			if(cxAttr) {
				cx = parseFloat(cxAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var cyAttr = this.element.getAttributeNS(null, "cy");
			if(cyAttr) {
				cy = parseFloat(cyAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var rAttr = this.element.getAttributeNS(null, "r");
			if(rAttr) {
				//r = parseFloat(rAttr);
				this.radiusX = parseFloat(rAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			this.oldX = cx - this.radiusX;
			this.oldY = cy - this.radiusX;
			this.oldWidth = 2*this.radiusX;
			this.oldHeight = 2*this.radiusX;

		} else if(ORYX.Editor.checkClassType(this.element, SVGEllipseElement)) {
			this.type = "Ellipse";
			
			var cx = undefined;
			var cy = undefined;
			//var rx = undefined;
			//var ry = undefined;
			var cxAttr = this.element.getAttributeNS(null, "cx");
			if(cxAttr) {
				cx = parseFloat(cxAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var cyAttr = this.element.getAttributeNS(null, "cy");
			if(cyAttr) {
				cy = parseFloat(cyAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var rxAttr = this.element.getAttributeNS(null, "rx");
			if(rxAttr) {
				this.radiusX = parseFloat(rxAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var ryAttr = this.element.getAttributeNS(null, "ry");
			if(ryAttr) {
				this.radiusY = parseFloat(ryAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			this.oldX = cx - this.radiusX;
			this.oldY = cy - this.radiusY;
			this.oldWidth = 2*this.radiusX;
			this.oldHeight = 2*this.radiusY;

		} else if(ORYX.Editor.checkClassType(this.element, SVGLineElement)) {
			this.type = "Line";
			
			var x1 = undefined;
			var y1 = undefined;
			var x2 = undefined;
			var y2 = undefined;
			var x1Attr = this.element.getAttributeNS(null, "x1");
			if(x1Attr) {
				x1 = parseFloat(x1Attr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var y1Attr = this.element.getAttributeNS(null, "y1");
			if(y1Attr) {
				y1 = parseFloat(y1Attr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var x2Attr = this.element.getAttributeNS(null, "x2");
			if(x2Attr) {
				x2 = parseFloat(x2Attr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var y2Attr = this.element.getAttributeNS(null, "y2");
			if(y2Attr) {
				y2 = parseFloat(y2Attr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			this.oldX = Math.min(x1,x2);
			this.oldY = Math.min(y1,y2);
			this.oldWidth = Math.abs(x1-x2);
			this.oldHeight = Math.abs(y1-y2);

		} else if(ORYX.Editor.checkClassType(this.element, SVGPolylineElement) || ORYX.Editor.checkClassType(this.element, SVGPolygonElement)) {
			this.type = "Polyline";
			
			var pointsArray = [];
			if (this.element.points&&this.element.points.numberOfItems){
			    for(var i=0, size=this.element.points.numberOfItems; i<size; i++){
			        pointsArray.push(this.element.points.getItem(i).x)
			        pointsArray.push(this.element.points.getItem(i).y)
			    }
			} else {
				var points = this.element.getAttributeNS(null, "points");
				if(points) {
					points = points.replace(/,/g , " ");
					pointsArray = points.split(" ");
					pointsArray = pointsArray.without("");
				} else {
					throw "Missing attribute in element " + this.element;
				}
			}
			

			if(pointsArray && pointsArray.length && pointsArray.length > 1) {
				var minX = parseFloat(pointsArray[0]);
				var minY = parseFloat(pointsArray[1]);
				var maxX = parseFloat(pointsArray[0]);
				var maxY = parseFloat(pointsArray[1]);

				for(var i = 0; i < pointsArray.length; i++) {
					minX = Math.min(minX, parseFloat(pointsArray[i]));
					maxX = Math.max(maxX, parseFloat(pointsArray[i]));
					i++;
					minY = Math.min(minY, parseFloat(pointsArray[i]));
					maxY = Math.max(maxY, parseFloat(pointsArray[i]));
				}

				this.oldX = minX;
				this.oldY = minY;
				this.oldWidth = maxX-minX;
				this.oldHeight = maxY-minY;
			} else {
				throw "Missing attribute in element " + this.element;
			}

		} else if(ORYX.Editor.checkClassType(this.element, SVGPathElement)) {
			this.type = "Path";
			
			this.editPathParser = new PathParser();
			this.editPathHandler = new ORYX.Core.SVG.EditPathHandler();
			this.editPathParser.setHandler(this.editPathHandler);
		
			var parser = new PathParser();
			var handler = new ORYX.Core.SVG.MinMaxPathHandler();
			parser.setHandler(handler);
			parser.parsePath(this.element);

			this.oldX = handler.minX;
			this.oldY = handler.minY;
			this.oldWidth = handler.maxX - handler.minX;
			this.oldHeight = handler.maxY - handler.minY;

			delete parser;
			delete handler;
			
		} else if(ORYX.Editor.checkClassType(this.element, SVGGElement)) {
			this.type = "G";
			throw "Element is not a shape.";
			
		} else {
			throw "Element is not a shape.";
		}

		/** initialize attributes of oryx namespace */
		//resize
		var resizeAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "resize");
		if(resizeAttr) {
			resizeAttr = resizeAttr.toLowerCase();
			if(resizeAttr.match(/horizontal/)) {
				this.isHorizontallyResizable = true;
			} else {
				this.isHorizontallyResizable = false;
			}
			if(resizeAttr.match(/vertical/)) {
				this.isVerticallyResizable = true;
			} else {
				this.isVerticallyResizable = false;
			}
		} else {
			this.isHorizontallyResizable = false;
			this.isVerticallyResizable = false;
		}

		//anchors
		var anchorAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "anchors");
		if(anchorAttr) {
			anchorAttr = anchorAttr.replace("/,/g", " ");
			var anchors = anchorAttr.split(" ").without("");
			
			for(var i = 0; i < anchors.length; i++) {
				switch(anchors[i].toLowerCase()) {
					case "left":
						this.anchorLeft = true;
						break;
					case "right":
						this.anchorRight = true;
						break;
					case "top":
						this.anchorTop = true;
						break;
					case "bottom":
						this.anchorBottom = true;
						break;
				}
			}
		}
		
		//allowDockers and resizeMarkerMid
		if(ORYX.Editor.checkClassType(this.element, SVGPathElement)) {
			var allowDockersAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "allowDockers"); 
			if(allowDockersAttr) {
				if(allowDockersAttr.toLowerCase() === "no") {
					this.allowDockers = false; 
				} else {
					this.allowDockers = true;
				}
			}
			
			var resizeMarkerMidAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "resizeMarker-mid"); 
			if(resizeMarkerMidAttr) {
				if(resizeMarkerMidAttr.toLowerCase() === "yes") {
					this.resizeMarkerMid = true; 
				} else {
					this.resizeMarkerMid = false;
				}
			}
		}	
			
		this.x = this.oldX;
		this.y = this.oldY;
		this.width = this.oldWidth;
		this.height = this.oldHeight;
		
		this.id = this.element.id;
	},

	/**
	 * Writes the changed values into the SVG element.
	 */
	update: function() {
		
		if(this.x !== this.oldX || this.y !== this.oldY || this.width !== this.oldWidth || this.height !== this.oldHeight) {
			switch(this.type) {
				case "Rect":
					if(this.x !== this.oldX) this.element.setAttributeNS(null, "x", this.x);
					if(this.y !== this.oldY) this.element.setAttributeNS(null, "y", this.y);
				 	if(this.width !== this.oldWidth) this.element.setAttributeNS(null, "width", this.width);
					if(this.height !== this.oldHeight) this.element.setAttributeNS(null, "height", this.height);
					break;
				case "Circle":
					//calculate the radius
					//var r;
//					if(this.width/this.oldWidth <= this.height/this.oldHeight) {
//						this.radiusX = ((this.width > this.height) ? this.width : this.height)/2.0;
//					} else {
					 	this.radiusX = ((this.width < this.height) ? this.width : this.height)/2.0;
					//}
	
					this.element.setAttributeNS(null, "cx", this.x + this.width/2.0);
					this.element.setAttributeNS(null, "cy", this.y + this.height/2.0);
					this.element.setAttributeNS(null, "r", this.radiusX);
					break;
				case "Ellipse":
					this.radiusX = this.width/2;
					this.radiusY = this.height/2;
	
					this.element.setAttributeNS(null, "cx", this.x + this.radiusX);
					this.element.setAttributeNS(null, "cy", this.y + this.radiusY);
					this.element.setAttributeNS(null, "rx", this.radiusX);
					this.element.setAttributeNS(null, "ry", this.radiusY);
					break;
				case "Line":
					if(this.x !== this.oldX)
						this.element.setAttributeNS(null, "x1", this.x);
						
					if(this.y !== this.oldY)
						this.element.setAttributeNS(null, "y1", this.y);
						
					if(this.x !== this.oldX || this.width !== this.oldWidth)
						this.element.setAttributeNS(null, "x2", this.x + this.width);
					
					if(this.y !== this.oldY || this.height !== this.oldHeight)
						this.element.setAttributeNS(null, "y2", this.y + this.height);
					break;
				case "Polyline":
					var points = this.element.getAttributeNS(null, "points");
					if(points) {
						points = points.replace(/,/g, " ").split(" ").without("");
	
						if(points && points.length && points.length > 1) {
	
							//TODO what if oldWidth == 0?
							var widthDelta = (this.oldWidth === 0) ? 0 : this.width / this.oldWidth;
						    var heightDelta = (this.oldHeight === 0) ? 0 : this.height / this.oldHeight;
	
							var updatedPoints = "";
						    for(var i = 0; i < points.length; i++) {
								var x = (parseFloat(points[i])-this.oldX)*widthDelta + this.x;
								i++;
								var y = (parseFloat(points[i])-this.oldY)*heightDelta + this.y;
		    					updatedPoints += x + " " + y + " ";
						    }
							this.element.setAttributeNS(null, "points", updatedPoints);
						} else {
							//TODO error
						}
					} else {
						//TODO error
					}
					break;
				case "Path":
					//calculate scaling delta
					//TODO what if oldWidth == 0?
					var widthDelta = (this.oldWidth === 0) ? 0 : this.width / this.oldWidth;
					var heightDelta = (this.oldHeight === 0) ? 0 : this.height / this.oldHeight;
	
					//use path parser to edit each point of the path
					this.editPathHandler.init(this.x, this.y, this.oldX, this.oldY, widthDelta, heightDelta);
					this.editPathParser.parsePath(this.element);
	
					//change d attribute of path
					this.element.setAttributeNS(null, "d", this.editPathHandler.d);
					break;
			}

			this.oldX = this.x;
			this.oldY = this.y;
			this.oldWidth = this.width;
			this.oldHeight = this.height;
		}
		
		// Remove cached variables
		delete this.visible;
		delete this.handler;
	},
	
	isPointIncluded: function(pointX, pointY) {

		// Check if there are the right arguments and if the node is visible
		if(!pointX || !pointY || !this.isVisible()) {
			return false;
		}

		switch(this.type) {
			case "Rect":
				return (pointX >= this.x && pointX <= this.x + this.width &&
						pointY >= this.y && pointY <= this.y+this.height);
				break;
			case "Circle":
				//calculate the radius
//				var r;
//				if(this.width/this.oldWidth <= this.height/this.oldHeight) {
//					r = ((this.width > this.height) ? this.width : this.height)/2.0;
//				} else {
//				 	r = ((this.width < this.height) ? this.width : this.height)/2.0;
//				}
				return ORYX.Core.Math.isPointInEllipse(pointX, pointY, this.x + this.width/2.0, this.y + this.height/2.0, this.radiusX, this.radiusX);
				break;
			case "Ellipse":
				return ORYX.Core.Math.isPointInEllipse(pointX, pointY, this.x + this.radiusX, this.y + this.radiusY, this.radiusX, this.radiusY);			
				break;
			case "Line":
				return ORYX.Core.Math.isPointInLine(pointX, pointY, this.x, this.y, this.x + this.width, this.y + this.height);
				break;
			case "Polyline":
				var points = this.element.getAttributeNS(null, "points");
	
				if(points) {
					points = points.replace(/,/g , " ").split(" ").without("");
	
					points = points.collect(function(n) {
						return parseFloat(n);
					});
					
					return ORYX.Core.Math.isPointInPolygone(pointX, pointY, points);
				} else {
					return false;
				}
				break;
			case "Path":
				
				// Cache Path handler
				if (!this.handler) {
					var parser = new PathParser();
					this.handler = new ORYX.Core.SVG.PointsPathHandler();
					parser.setHandler(this.handler);
					parser.parsePath(this.element);
				}
				
				return ORYX.Core.Math.isPointInPolygone(pointX, pointY, this.handler.points);

				break;
			default:
				return false;
		}
	},

	/**
	 * Returns true if the element is visible
	 * @param {SVGElement} elem
	 * @return boolean
	 */
	isVisible: function(elem) {
		
		if (this.visible !== undefined){
			return this.visible;
		}
			
		if (!elem) {
			elem = this.element;
		}

		var hasOwnerSVG = false;
		try { 
			hasOwnerSVG = !!elem.ownerSVGElement;
		} catch(e){}
		
		// Is SVG context
		if ( hasOwnerSVG ) {
			// IF G-Element
			if (ORYX.Editor.checkClassType(elem, SVGGElement)) {
				if (elem.className && elem.className.baseVal == "me") {
					this.visible = true;
					return this.visible;
				}
			}

			// Check if fill or stroke is set
			var fill = elem.getAttributeNS(null, "fill");
			var stroke = elem.getAttributeNS(null, "stroke");
			if (fill && fill == "none" && stroke && stroke == "none") {
				this.visible = false;
			} else {
				// Check if displayed
				var attr = elem.getAttributeNS(null, "display");
				if(!attr)
					this.visible = this.isVisible(elem.parentNode);
				else if (attr == "none") 
					this.visible = false;
				else
					this.visible = true;
			}
		} else {
			this.visible = true;
		}
		
		return this.visible;
	},
	
	/**
	 * Hides the svg shape
	 * 
	 */
	hide: function(){
		if (this.hidden){
			return;
		}
		
		if (!this.parent){
			this.parent = this.node.parentNode;
		}
		this.visible = this.hidden = false;
		this.parent.removeChild(this.node);
	},
	
	/**
	 * Show the svg shape
	 * 
	 */
	show: function(){
		if (!this.hidden){
			return;
		}
		this.parent.appendChild(this.node);
		delete this.visible;
		delete this.hidden;
	},

	toString: function() { return (this.element) ? "SVGShape " + this.element.id : "SVGShape " + this.element;}
 });/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner, Lukas Brand
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}

/**
 * @classDescription Class for adding text to a shape.
 * 
 */
ORYX.Core.SVG.Label = Clazz.extend({
	
	_characterSets:[
		"%W",
		"@",
		"m",
		"wDGMOQ?#+=<>~^",
		"ABCHKNRSUVXZ¨¹?&",
		"bdghnopqux?¨¹ETY1234567890?_¡ì${}*¡ä`¦Ì€",
		"aeksvyz?FLP?¡ã23",
		"c-",
		"rtJ\"/()[]:;!|\\",
		"fjI., ",
		"'",
		"il"
		],
	_characterSetValues:[15,14,13,11,10,9,8,7,6,5,4,3],

	/**
	 * Constructor
	 * @param options {Object} :
	 * 	textElement
	 * 
	 */
	construct: function(options) {
		arguments.callee.$.construct.apply(this, arguments);
		
		this.isInitializing = true;
		
		if(!options.textElement) {
			throw "Label: No parameter textElement." 
		} else if (!ORYX.Editor.checkClassType( options.textElement, SVGTextElement ) ) {
			throw "Label: Parameter textElement is not an SVGTextElement."	
		}
		
		this.invisibleRenderPoint = -5000;
		
		this.node = options.textElement;
		
		// The styles of the label
		this.styles = {};
		this.defaultStyles = {
	            'font-family'	: 'Verdana',
	            'font-size'		: this.node.getAttributeNS(null, 'font-size') || '12',
	            'font-weight'	: 'normal',
	            'font-style'	: 'normal',
	            'fill'			: '#000000'
	        };        
	        
		/*
		 * HACK HACK HACK
		 * This enables coloring for process documentation
		 */
		if(options.color) {
			this.setFill(options.color);
		}
		/* HACK HACK HACK */
		
		this.node.setAttributeNS(null, 'stroke-width', '0pt');
		this.node.setAttributeNS(null, 'letter-spacing', '-0.01px');
		
		this.shapeId = options.shapeId;
		
		this.id;
		
		this.fitToElemId;
		
		this.edgePosition;
		
		this.x;
		this.y;
		this.oldX;
		this.oldY;
		this.css = "";
		this.cssprefix = this.node.getAttributeNS(null, 'class');
		
		this.isVisible = true;
		
		this.isRichtext = options.richtext;
		
		this._text;
		this._verticalAlign;
		this._horizontalAlign;
		this._rotate;
		this._rotationPoint;
		
		//this.anchors = [];
		this.anchorLeft;
		this.anchorRight;
		this.anchorTop;
		this.anchorBottom;
		
		this._isChanged = true;

		//if the text element already has an id, don't change it.
		var _id = this.node.getAttributeNS(null, 'id');
		if(_id) {
			this.id = _id;
		}
		
		//initialization	
		
		//set referenced element the text is fit to
		this.fitToElemId = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'fittoelem');
		if(this.fitToElemId)
			this.fitToElemId = this.shapeId + this.fitToElemId;
		
		//set alignment	
		var alignValues = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'align');
		if(alignValues) {
			alignValues = alignValues.replace(/,/g, " ");
			alignValues = alignValues.split(" ");
			alignValues = alignValues.without("");
			
			alignValues.each((function(alignValue) {
				switch (alignValue) {
					case 'top':
					case 'middle':
					case 'bottom':
						if(!this._verticalAlign){this._originVerticalAlign = this._verticalAlign = alignValue;}
						break;
					case 'left':
					case 'center':
					case 'right':
						if(!this._horizontalAlign){this._originHorizontalAlign = this._horizontalAlign = alignValue;}
						break;
				}
			}).bind(this));
		}
		
		//set edge position (only in case the label belongs to an edge)
		this.edgePosition = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'edgePosition');
		if(this.edgePosition) {
			this.originEdgePosition = this.edgePosition = this.edgePosition.toLowerCase();
		}
		
		//get offset top
		this.offsetTop = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'offsetTop') || ORYX.CONFIG.OFFSET_EDGE_LABEL_TOP;
		if(this.offsetTop) {
			this.offsetTop = parseInt(this.offsetTop);
		}
		
		//get offset top
		this.offsetBottom = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'offsetBottom') || ORYX.CONFIG.OFFSET_EDGE_LABEL_BOTTOM;
		if(this.offsetBottom) {
			this.offsetBottom = parseInt(this.offsetBottom);
		}
		
				
		//set rotation
		var rotateValue = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'rotate');
		if(rotateValue) {
			try {
				this._rotate = parseFloat(rotateValue);
			} catch (e) {
				this._rotate = 0;
			}
		} else {
			this._rotate = 0;
		}
		
		//anchors
		var anchorAttr = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "anchors");
		if(anchorAttr) {
			anchorAttr = anchorAttr.replace("/,/g", " ");
			var anchors = anchorAttr.split(" ").without("");
			
			for(var i = 0; i < anchors.length; i++) {
				switch(anchors[i].toLowerCase()) {
					case "left":
						this.originAnchorLeft = this.anchorLeft = true;
						break;
					case "right":
						this.originAnchorRight = this.anchorRight = true;
						break;
					case "top":
						this.originAnchorTop = this.anchorTop = true;
						break;
					case "bottom":
						this.originAnchorBottom = this.anchorBottom = true;
						break;
				}
			}
		}
		
		//if no alignment defined, set default alignment
		if(!this._verticalAlign) { this._verticalAlign = 'bottom'; }
		if(!this._horizontalAlign) { this._horizontalAlign = 'left'; }

		var xValue = this.node.getAttributeNS(null, 'x');
		if(xValue) {
			this.oldX = this.x = parseFloat(xValue);
		} else {
			//TODO error
		}
		
		var yValue = this.node.getAttributeNS(null, 'y');
		if(yValue) {
			this.oldY = this.y = parseFloat(yValue);
		} else {
			//TODO error
		}
		
		//set initial text
		this.text(this.node.textContent);
		
		delete this.isInitializing;
	},
	
	/**
	 * Reset the anchor position to the original value
	 * which was specified in the stencil set
	 * 
	 */
	resetAnchorPosition: function(){
		this.anchorLeft = this.originAnchorLeft || false;
		this.anchorRight = this.originAnchorRight || false;
		this.anchorTop = this.originAnchorTop || false;
		this.anchorBottom = this.originAnchorBottom || false;
	},
	
	isOriginAnchorLeft: function(){ return this.originAnchorLeft || false; },
	isOriginAnchorRight: function(){ return this.originAnchorRight || false; },
	isOriginAnchorTop: function(){ return this.originAnchorTop || false; },
	isOriginAnchorBottom: function(){ return this.originAnchorBottom || false; },
	
	
	isAnchorLeft: function(){ return this.anchorLeft || false; },
	isAnchorRight: function(){ return this.anchorRight || false; },
	isAnchorTop: function(){ return this.anchorTop || false; },
	isAnchorBottom: function(){ return this.anchorBottom || false; },
	
	/**
	 * Returns the x coordinate
	 * @return {number}
	 */
	getX: function(){
		try {
			var x = this.node.x.baseVal.getItem(0).value;
			switch(this.horizontalAlign()){
				case "left": return x;
				case "center": return x - (this.getWidth()/2);
				case "right": return x - this.getWidth();
			}
			return this.node.getBBox().x;
		} catch(e){
			return this.x;
		}
	},
		
	setX: function(x){
		if (this.position)
			this.position.x = x;
		else 
			this.setOriginX(x);
	},
	
	
	/**
	 * Returns the y coordinate
	 * @return {number}
	 */
	getY: function(){
		try {
			return this.node.getBBox().y;
		} catch(e){
			return this.y;
		}
	},
	
	setY: function(y){
		if (this.position)
			this.position.y = y;
		else 
			this.setOriginY(y);
	},
	
	setOriginX: function(x){
		this.x = x;
	},
	
	setOriginY: function(y){
		this.y = y;
	},

	
	/**
	 * Returns the width of the label
	 * @return {number}
	 */
	getWidth: function(){
		try {
			try {
				var width, cn = this.node.childNodes;
				if (cn.length == 0 || !Ext.isGecko) {
					width = this.node.getBBox().width;
				} else {
					for (var i = 0, size = cn.length; i < size; ++i) {
						var w = cn[i].getComputedTextLength();
						if ("undefined" == typeof width || width < w) {
							width = w;
						}
					}
				}
				return width+(width%2==0?0:1);
			} catch (ee) {
				return this.node.getBBox().width;
			}
		} catch(e){
			return 0;
		}
	},
	
	getOriginUpperLeft: function(){
		var x = this.x, y = this.y;
		switch (this._horizontalAlign){
			case 'center' :
				x -= this.getWidth()/2;
				break;
			case 'right' :
				x -= this.getWidth();
				break;
		}
		switch (this._verticalAlign){
			case 'middle' :
				y -= this.getHeight()/2;
				break;
			case 'bottom' :
				y -= this.getHeight();
				break;
		}
		return {x:x, y:y};
	},
	
	/**
	 * Returns the height of the label
	 * @return {number}
	 */
	getHeight: function(){
		try {
			return this.node.getBBox().height;
		} catch(e){
			return 0;
		}
	},
	
	/**
	 * Returns the relative center position of the label 
	 * to its parent shape.
	 * @return {Object}
	 */
	getCenter: function(){
		var up = {x: this.getX(), y: this.getY()};
		up.x += this.getWidth()/2;
		up.y += this.getHeight()/2;
		return up;
	},
	
	/**
	 * Sets the position of a label relative to the parent.
	 * @param {Object} position
	 */
	setPosition: function(position){
		if (!position || position.x === undefined || position.y === undefined) {
			delete this.position;
		} else {
			this.position = position;
		}
		
		if (this.position){
			delete this._referencePoint;
			delete this.edgePosition;
		}
		
		this._isChanged = true;
		this.update();
	},
	
	/**
	 * Return the position
	 */
	getPosition: function(){
		return this.position;
	},
	
	setReferencePoint: function(ref){
		if (ref) {
			this._referencePoint = ref;
		} else {
			delete this._referencePoint;
		}
		if (this._referencePoint){
			delete this.position;
		}
	},
	
	getReferencePoint: function(){
		return this._referencePoint || undefined;
	},
	
	changed: function() {
		this._isChanged = true;
	},
	
	/**
	 * Register a callback which will be called if the label
	 * was rendered.
	 * @param {Object} fn
	 */
	registerOnChange: function(fn){
		if (!this.changeCallbacks){
			this.changeCallbacks = [];
		}
		if (fn instanceof Function && !this.changeCallbacks.include(fn)){
			this.changeCallbacks.push(fn);
		}
	},
	
	removeAllListeners: function() {
		delete this.changeCallbacks;
	},
	
	/**
	 * Unregister the callback for changes.
	 * @param {Object} fn
	 */
	unregisterOnChange: function(fn){
		if (this.changeCallbacks && fn instanceof Function && this.changeCallbacks.include(fn)){
			this.changeCallbacks = this.changeCallbacks.without(fn);
		}
	},
	
	/**
	 * Returns TRUE if the labe is currently in
	 * the update mechanism.
	 * @return {Boolean}
	 */
	isUpdating: function(){
		return !!this._isUpdating;	
	},
	
	
	getOriginEdgePosition: function(){
		return this.originEdgePosition;	
	},
	
	/**
	 * Returns the edgeposition.
	 * 
	 * @return {String} "starttop", "startmiddle", "startbottom", 
	 * "midtop", "midbottom", "endtop", "endbottom" or null
	 */
	getEdgePosition: function(){
		return this.edgePosition || null;	
	},
	
	/**
	 * Set the edge position, must be one of the valid
	 * edge positions (see getEdgePosition).
	 * Removes the reference point and the absolute position as well.
	 * 
	 * @param {Object} position
	 */
	setEdgePosition: function(position){
		if (["starttop", "startmiddle", "startbottom", 
			"midtop", "midbottom", "endtop", "endbottom"].include(position)){
			this.edgePosition = position;
			delete this.position;
			delete this._referencePoint;
		} else {
			delete this.edgePosition;
		}
	},
	
	/**
	 * Replaces line feeds and spaces in a given string with valid xml
	 * @param {String} string
	 * @returns {String}
	 */
    strip: function(string) {
        return string.replace(/\n/g, "<br />")
        			 .replace(/<br>/g, "<br />")
                     .replace(/&nbsp;/g, " ");  
    },
    
    /**
     * Sets the style of the label to bold
     * @param {Boolean} bold
     */
    setBold : function(bold){
        if(!this.isRichtext && !this.isInitializing) {
            return;
        }
        
    	if (bold) {
    		this.styles.bold = true;
    	} else {
    		delete this.styles.bold;
    	}
    },
    
    /**
     * Returns true if the label is bold
     * @returns {Boolean}
     */
    getBold : function() {
    	return !!this.styles.bold;
    },
    
    /**
     * Sets the style of the label to italic
     * @param {Boolean} italic
     */
    setItalic : function(italic) {
        if(!this.isRichtext && !this.isInitializing) {
            return;
        }
        
        if (italic) {
    		this.styles.italic = true;
    	} else {
    		delete this.styles.italic;
    	}
    },
    
    /**
     * Returns true if the label is italic
     * @returns {Boolean}
     */
    getItalic : function() {
    	return !!this.styles.italic;
    },
    
    /**
     * Sets the fill color of the label
     * @param {String} fill
     */
    setFill : function(fill) {
        if(!this.isRichtext && !this.isInitializing) {
            return;
        }
        
    	if (typeof fill === 'string' && fill !== this.defaultStyles['fill']) {
    		this.styles.fill = fill; 
    	} else {
    		delete this.styles.fill;
    	}
    },
    
    /**
     * Returns the fill color of the label
     * @returns {String}
     */
    getFill : function() {
    	return this.styles.fill || this.defaultStyles['fill'];
    },
    
    /**
     * Sets the font of the label
     * @param {String} font
     */
    setFont : function(font) {
        if(!this.isRichtext && !this.isInitializing) {
            return;
        }
        
        if (typeof font === 'string' && font !== this.defaultStyles['font-family']) {
    		this.styles.font = font;
    	} else {
    		delete this.styles.font;
    	}
    },
    
    /**
     * Returns the font of the label
     * @returns {String}
     */
    getFont : function() {
    	return this.styles.font || this.defaultStyles['font-family'];
    },
    
    /**
     * Sets the font size of the label
     * @param {String} size
     */
    setFontSize : function(size) {
        if(!this.isRichtext && !this.isInitializing) {
            return;
        }
        
        if (typeof size === 'string' && size !== this.defaultStyles['font-size']) {
    		this.styles.size = size;
    	} else {
    		delete this.styles.size;
    	}
    },
    
    /**
     * Removes all richtext attributes from the label.
     * @param {Boolean} clear
     */
    setStyle : function(styles) {
    	if (typeof styles === 'object') {
    		this.styles = Object.clone(styles);
    	}
    },
    
    /**
     * Returns the styles object.
     * @returns {Object}
     */
    getStyle : function() {
    	return this.styles;
    },

    /**
     * Internal method to get the minimal x/y-value of the label.
     * @return {Object}
     */
    getCurrentMinValue: function(){
    	try {
    		if (this.node.ownerSVGElement){
    			var screenCTM = this.node.parentNode.getScreenCTM(),
    				viewCTM = this.node.nearestViewportElement.getScreenCTM();
    			
    			return {x:(viewCTM.e-screenCTM.e)+10, y: (viewCTM.f-screenCTM.f)+10};
    		}
    	} catch(e){}

		return {x:undefined, y:undefined};
    },
    
    /**
	 * Update the SVG text element.
	 */
	update: function(force) {
	
		var x = this.x, y = this.y, min = this.getCurrentMinValue();
		if (this.position){
			x = this.position.x;
			y = this.position.y;
		}
		x = Math.max.apply(Math, [Math.floor(x),min.x].compact()); y = Math.max.apply(Math, [Math.floor(y),min.y].compact());
		
		if(this._isChanged || x !== this.oldX || y !== this.oldY || force === true) {
			if (this.isVisible) {
				this._isChanged = false;
				this._isUpdating = true;
				
				// Set x/y
				this.node.setAttributeNS(null, 'x', x);
				this.node.setAttributeNS(null, 'y', y);
				this.node.removeAttributeNS(null, "fill-opacity");

				// Set css class
				var css = (this.cssprefix||"")+(this.css?" "+this.css:"");
				this.node[(css?"set":"remove")+"AttributeNS"](null, "class", css || undefined);
				

				/*
				 * Set the richtext attributes to the label
				 */
				
				// Bold
				if (this.styles.bold) {
					this.node.setAttributeNS(null, 'font-weight', 'bold');
				}else if (this.node.hasAttributeNS(null, 'font-weight')){
					this.node.removeAttributeNS(null, 'font-weight');
				}
					
				// Italic
				if (this.styles.italic) {
					this.node.setAttributeNS(null, 'font-style', 'italic');	
				} else if (this.node.hasAttributeNS(null, 'font-style')){
					this.node.removeAttributeNS(null, 'font-style');
				}
					
				// Font color
				if (this.styles.fill) {
					this.node.setAttributeNS(null, 'fill', this.styles.fill);
				} else if (this.node.hasAttributeNS(null, 'fill')){
					this.node.removeAttributeNS(null, 'fill');
				}
//				if (this.styles.font)
//					this.node.setAttributeNS(null, 'font-family', this.styles.font);
				
				// Font size (in case no special font-size is specified, use the default size determined when the label was initialized)
				if (this.styles.size) {
					this.node.setAttributeNS(null, 'font-size', this.styles.size);
				} else {
					this.node.setAttributeNS(null, 'font-size', this.defaultStyles["font-size"]);
				}
				
				//this.node.setAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'align', this._horizontalAlign + " " + this._verticalAlign);
				
				this.oldX = x;
				this.oldY = y;
				
				//set rotation
				if (!this.position && !this.getReferencePoint()) {
					if (this._rotate !== undefined) {
						if (this._rotationPoint) 
							this.node.setAttributeNS(null, 'transform', 'rotate(' + this._rotate + ' ' + Math.floor(this._rotationPoint.x) + ' ' + Math.floor(this._rotationPoint.y) + ')');
						else 
							this.node.setAttributeNS(null, 'transform', 'rotate(' + this._rotate + ' ' + Math.floor(x) + ' ' + Math.floor(y) + ')');
					}
				} else {
					this.node.setAttributeNS(null, 'transform', 'rotate(0)');
				}
				
				//var tspans = Ext.ux.Richtext.getTspansFromDiv(this.node.ownerDocument, this._text);
				var textLines = this._text.split("\n");
				while (textLines.last() == "") 
					textLines.pop();
					
				if (this.node.ownerDocument) {
					// Only reset the tspans if the text 
					// has changed or has to be wrapped
					if (this.fitToElemId || this._textHasChanged){
						this.node.textContent = ""; // Remove content
						//tspans.each((function(tspan, index){
						textLines.each((function(textLine, index){
							var tspan = this.node.ownerDocument.createElementNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
							tspan.textContent = textLine.trim();

							if (this.fitToElemId) {
								tspan.setAttributeNS(null, 'x', this.invisibleRenderPoint);
								tspan.setAttributeNS(null, 'y', this.invisibleRenderPoint);
							}
							
							/*
							 * Chrome's getBBox() method fails, if a text node contains an empty tspan element.
							 * So, we add a whitespace to such a tspan element.
							 */
							var isNewerChrome = Ext.isChrome && parseInt(window.navigator.userAgent.match("Chrome/([0-9]+)")[1]) >= 18;
							if(tspan.textContent === "" && !isNewerChrome) {
								tspan.textContent = " ";
							}
							
							//append tspan to text node
							this.node.appendChild(tspan);
						}).bind(this));
						delete this._textHasChanged;
						delete this.indices;
					}
					
					//Work around for Mozilla bug 293581
					if (this.isVisible && this.fitToElemId) {
						this.node.setAttributeNS(null, 'visibility', 'hidden');
					}
					
					if (this.fitToElemId) {
						window.setTimeout(this._checkFittingToReferencedElem.bind(this), 0);
					} else {
						//window.setTimeout(this._positionText.bind(this), 0);
						try {
							if (this.node.ownerSVGElement) {
								this._positionText();
							} else {
								throw "Label must be appended to an SVG Element"
							}
						} catch (e) {
							window.setTimeout(this._positionText.bind(this), 1);
						}
					}
				}
			} else {
				//this.node.textContent = "";
				this.node.setAttributeNS(null, "fill-opacity", "0.2");
			}
		} else {
			(this.updateCallbacks || []).each(function(callback) {
				callback.apply(callback);
			});
		}
	},
	
	/**
	 * these updates will be called, each time the update function is called.
	 * it doesn't matter, if the actual updated happens or not
	 */
	registerUpdateCallback: function(callback) {
		if(!this.updateCallbacks) {
			this.updateCallbacks = [];
		}
		
		if(!this.updateCallbacks.include(callback)) {
			this.updateCallbacks.push(callback);
		}
	},
	
	unregisterUpdateCallback: function(callback) {
		if(this.updateCallbacks) {
			this.updateCallbacks.remove(callback);
		}
	},
	
	visible: function() {
		var visible = this.isVisible;
		
		return visible && this.node.getAttributeNS(null, "display") !== "none";
	},
	
	_checkFittingToReferencedElem: function() {
		try {
			var tspans = $A(this.node.getElementsByTagNameNS(Ext.isChrome ? "*" : ORYX.CONFIG.NAMESPACE_SVG, 'tspan'));
			
			//only do this in firefox 3. all other browsers do not support word wrapping!!!!!
			//if (/Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent) && new Number(RegExp.$1)>=3) {
				var newtspans = [];
				
				var refNode = this.node.ownerDocument.getElementById(this.fitToElemId) || Ext.fly(this.node).child("[id="+this.fitToElemId+"]", true);
				
				if (refNode) {
				
					var refbb = refNode.getBBox();
					
					var fontSize = this.getFontSize();
					for (var j = 0; j < tspans.length; j++) {
						var tspan = tspans[j];
						
						var textLength = this._getRenderedTextLength(tspan, undefined, undefined, fontSize);
						
						var refBoxLength = (this._rotate != 0 
								&& this._rotate % 180 != 0 
								&& this._rotate % 90 == 0 ? 
										refbb.height : refbb.width);
						
						// Set width as attribute to the node, so 
						// word wrapping can use this value for 
						// server side wrapping.
						this.node.setAttribute("oryx:textWidth", refBoxLength);
						
						if (textLength > refBoxLength) {
						
							var startIndex = 0;
							var lastSeperatorIndex = 0;
							
							var numOfChars = this.getTrimmedTextLength(tspan.textContent);
							for (var i = 0; i < numOfChars; i++) {
								var sslength = this._getRenderedTextLength(tspan, startIndex, i-startIndex, fontSize);
								
								if (sslength > refBoxLength - 2) {
									var newtspan = this.node.ownerDocument.createElementNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
									if (lastSeperatorIndex <= startIndex) {
										lastSeperatorIndex = (i == 0) ? i : i-1;
										newtspan.textContent = tspan.textContent.slice(startIndex, lastSeperatorIndex).trim();
										//lastSeperatorIndex = i;
									}
									else {
										newtspan.textContent = tspan.textContent.slice(startIndex, ++lastSeperatorIndex).trim();
									}
									
									newtspan.setAttributeNS(null, 'x', this.invisibleRenderPoint);
									newtspan.setAttributeNS(null, 'y', this.invisibleRenderPoint);
									
									//insert tspan to text node
									//this.node.insertBefore(newtspan, tspan);
									newtspans.push(newtspan);
									
									startIndex = lastSeperatorIndex;
									
								}
								else {
									var curChar = tspan.textContent.charAt(i);
									if (curChar == ' ' ||
									curChar == '-' ||
									curChar == "." ||
									curChar == "," ||
									curChar == ";" ||
									curChar == ":") {
										lastSeperatorIndex = i;
									}
								}
							}
							
							tspan.textContent = tspan.textContent.slice(startIndex).trim();
						}
						
						newtspans.push(tspan);
					}
					
					while (this.node.hasChildNodes()) 
						this.node.removeChild(this.node.childNodes[0]);
					
					while (newtspans.length > 0) {
						this.node.appendChild(newtspans.shift());
					}
				}
			//}
		} catch (e) {
			//console.log(e);
		}
		
		window.setTimeout(this._positionText.bind(this), 0);
	},
    
    _getMaxFontSize: function(nodes) {
        var size = 0;
        
        nodes.each(function(node) {
            size = Math.max(size, this._getAttribute('font-size', node));
        }.bind(this));  
        
        return size > 0 ? size : this.defaultStyles['font-size'];
    },
	
    /**
	 * This is a work around method for Mozilla bug 293581.
	 * Before the method getComputedTextLength works, the text has to be rendered.
	 */
	_positionText: function() {
		try {
			var tspans = this.node.getElementsByTagNameNS(Ext.isChrome ? "*" : ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
			
			var fontSize = this.getFontSize(tspans[0]);	
		
			var invalidTSpans = [];
			
			var x = this.x, y = this.y, min = this.getCurrentMinValue();
			if (this.position){
				x = this.position.x;
				y = this.position.y;
			}
			x = Math.max.apply(Math, [Math.floor(x),min.x].compact()); y = Math.max.apply(Math, [Math.floor(y),min.y].compact());
			
			
			var i = 0, indic = []; // Cache indices if the _positionText is called again, before update is called 
			var is =(this.indices || $R(0,tspans.length-1).toArray());
			var length = is.length;
			
			var fontFamily = this.getFont();
			var aspectRatios = {
					arial	: 0.95,
					courier_new : 0.82,
					helvetica : 0.95,
					tahoma	: 1,
					times_new_roman : 0.93,
					verdana : 1
			};
			
			var aspectRatio = (aspectRatios[fontFamily.toLowerCase().replace(/( +)+/g, '_')]||1);
			
			is.each((function(index){
				if ("undefined" == typeof index){
					return;
				}
				
				var tspan = tspans[i++];
				
				if(tspan.textContent.trim() === "") {
					invalidTSpans.push(tspan);
				} else {
					//set vertical position
					var dy = 0;
					switch (this._verticalAlign) {
						case 'bottom':
							dy = -(length - index - 1) * (fontSize);
							break;
						case 'middle':
							
							dy = fontSize/2 * (aspectRatio - ORYX.CONFIG.LABEL_LINE_DISTANCE/6 - (length - 1) + 2*index);
							
//							dy = -(length / 2.0 - index - 1) * (fontSize);
//							dy -= ORYX.CONFIG.LABEL_LINE_DISTANCE * 2;
							break;
						case 'top':
							dy = index * (fontSize);
							dy += fontSize;
							break;
					}
					
					tspan.setAttributeNS(null, 'dy', Math.floor(dy));
					
					tspan.setAttributeNS(null, 'x', x);
					tspan.setAttributeNS(null, 'y', y);
					indic.push(index);
				}
				
			}).bind(this));
			
			indic.length = tspans.length;
			this.indices = this.indices || indic;
			
			invalidTSpans.each(function(tspan) {
				this.node.removeChild(tspan);
			}.bind(this));
			
			//set horizontal alignment
			switch (this._horizontalAlign) {
				case 'left':
					this.node.setAttributeNS(null, 'text-anchor', 'start');
					break;
				case 'center':
					this.node.setAttributeNS(null, 'text-anchor', 'middle');
					break;
				case 'right':
					this.node.setAttributeNS(null, 'text-anchor', 'end');
					break;
			}
			
		} catch(e) {
			//console.log(e);
			this._isChanged = true;
		}
		
		if(this.isVisible) {
			this.node.removeAttributeNS(null, 'visibility');
		}		

		// IF CHROME or SAFARI (version 6 has the same issue):
		// Force to update the labels positions, 
		// otherwise it won't show the label
		if (Ext.isChrome || Ext.isSafari){ 
			var node = this.node,
				parent = node.parentNode, 
				next = node.nextSibling;
			parent.removeChild(node);
			parent[next?"insertBefore":"appendChild"](node, next);  
			
			// Hide text element to prevent silly calculation in Chrome 19+.
			// Calculation of the bbox for text nodes without content leads to 
			// incorrect boundings.
			if (node.textContent === ""){
				node.style.display = "none";
			} else {
				node.style.display = "";
			}
		}
		
		(this.updateCallbacks || []).each(function(callback) {
			callback();
		});
		
		// Finished
		delete this._isUpdating;
	
		if(!this.eventsSuspended) {
			// Raise change event
			(this.changeCallbacks||[]).each(function(fn){
				fn.apply(fn);
			});
			
			if(this.resumeAfterUpdate) {
				this.resumeEvents();
			}
		}
	},
	
	isDirty: function() {
		// TODO: check, if more conditions needed
		
		var x = this.x, y = this.y, min = this.getCurrentMinValue();
		
		if (this.position){
			x = this.position.x;
			y = this.position.y;
		}
		
		x = Math.max.apply(Math, [Math.floor(x),min.x].compact()); y = Math.max.apply(Math, [Math.floor(y),min.y].compact());
		
		return (this._isChanged || x !== this.oldX || y !== this.oldY) && this.isVisible
	},
	
	suspendEvents: function(resumeAfterUpdate) {
		this.eventsSuspended = true;
		this.resumeAfterUpdate = resumeAfterUpdate === true;
	},
	
	resumeEvents: function() {
		delete this.eventsSuspended;
		delete this.resumeAfterUpdate;
	},
	
	/**
	 * Returns the text length of the text content of an SVG tspan element.
	 * For all browsers but Firefox 3 the values are estimated.
	 * @param {TSpanSVGElement} tspan
	 * @param {int} startIndex Optional, for sub strings
	 * @param {int} endIndex Optional, for sub strings
	 */
	_getRenderedTextLength: function(tspan, startIndex, endIndex, fontSize) {
		if (/Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent) && new Number(RegExp.$1) >= 3) {
			if(startIndex === undefined) {
//test string: abcdefghijklmnopqrstuvwxyz??¨¹,.-#+ 1234567890?ABCDEFGHIJKLMNOPQRSTUVWXYZ;:_'*¨¹??!"¡ì$%&/()=?[]{}|<>'~¡ä`\^¡ã¦Ì@€23
//				for(var i = 0; i < tspan.textContent.length; i++) {
//					console.log(tspan.textContent.charAt(i), tspan.getSubStringLength(i,1), this._estimateCharacterWidth(tspan.textContent.charAt(i))*(fontSize/14.0));
//				}
				return tspan.getComputedTextLength();
			} else {
				return tspan.getSubStringLength(startIndex, endIndex);
			}
		} else {
			if(startIndex === undefined) {
				return this._estimateTextWidth(tspan.textContent.trim(), fontSize);
			} else {
				return this._estimateTextWidth(tspan.textContent.substr(startIndex, endIndex).trim(), fontSize);
			}
		}
	},
	
	/**
	 * Estimates the text width for a string.
	 * Used for word wrapping in all browser but FF3.
	 * @param {Object} text
	 */
	_estimateTextWidth: function(text, fontSize) {
		var sum = 0.0;
		for(var i = 0; i < text.length; i++) {
			sum += this._estimateCharacterWidth(text.charAt(i));
		}
		
		return sum*(fontSize/14.0);
	},
	
	/**
	 * Estimates the width of a single character for font size 14.
	 * Used for word wrapping in all browser but FF3.
	 * @param {Object} character
	 */
	_estimateCharacterWidth: function(character) {
		
		for(var i = 0; i < this._characterSets.length; i++) {
 			if(this._characterSets[i].indexOf(character) >= 0) {
 				// If the font style is bold or the font size is smaller than the default size, increase the size to prevent the text from reaching over
 				// the edges of the shape.
				return ((this.styles.bold||this.styles.size < 12) ? 1.2 : 1 ) * this._characterSetValues[i];
			}
 		}	
		return 9;
 	},
	
	getReferencedElementWidth: function() {
		var refNode = this.node.ownerDocument.getElementById(this.fitToElemId) || Ext.fly(this.node.parentNode || this.node).child("[id="+this.fitToElemId+"]", true);
		
		if(refNode) {
			try {
				var refbb = refNode.getBBox();
				if(refbb) {
					return (this._rotate != 0 
							&& this._rotate % 180 != 0 
							&& this._rotate % 90 == 0 ? 
									refbb.height : refbb.width);
				}
			} catch(e){
				return (this._rotate != 0 
						&& this._rotate % 180 != 0 
						&& this._rotate % 90 == 0 ? 
								(refNode.height ? refNode.height.baseVal.value : undefined): 
								(refNode.width ? refNode.width.baseVal.value: undefined)) || undefined;
			}
		}
		return undefined;
	},
	
	/**
	 * If no parameter is provided, this method returns the current text.
	 * @param text {String} Optional. Replaces the old text with this one.
	 */
	text: function() {
		switch (arguments.length) {
			case 0:
				return this._text;
				break;
			
			case 1:
				var oldText = this._text,
					text = String(arguments[0]);
				if(text) {
					this._text = text;
				} else {
					this._text = "";
				}
				if(oldText !== this._text) {
					this._isChanged = true;
					this._textHasChanged = true;
				}
				break;
				
			default: 
				//TODO error
				break;
		}
	},
	
	getOriginVerticalAlign: function(){
		return this._originVerticalAlign;
	},
	
	verticalAlign: function() {
		switch(arguments.length) {
			case 0:
				return this._verticalAlign;
			case 1:
				if(['top', 'middle', 'bottom'].member(arguments[0])) {
					var oldValue = this._verticalAlign;
					this._verticalAlign = arguments[0];
					if(this._verticalAlign !== oldValue) {
						this._isChanged = true;
					}
				}
				break;
				
			default:
				//TODO error
				break;
		}
	},
	
	getOriginHorizontalAlign: function(){
		return this._originHorizontalAlign;
	},
	
	horizontalAlign: function() {
		switch(arguments.length) {
			case 0:
				return this._horizontalAlign;
			case 1:
				if(['left', 'center', 'right'].member(arguments[0])) {
					var oldValue = this._horizontalAlign;
					this._horizontalAlign = arguments[0];
					if(this._horizontalAlign !== oldValue) {
						this._isChanged = true;
					}	
				}
				break;
				
			default:
				//TODO error
				break;
		}
	},
	
	rotate: function() {
		switch(arguments.length) {
			case 0:
				return this._rotate;
			case 1:
				if (this._rotate != arguments[0]) {
					this._rotate = arguments[0];
					this._rotationPoint = undefined;
					this._isChanged = true;
				}
			case 2:
				if(this._rotate != arguments[0] ||
				   !this._rotationPoint ||
				   this._rotationPoint.x != arguments[1].x ||
				   this._rotationPoint.y != arguments[1].y) {
					this._rotate = arguments[0];
					this._rotationPoint = arguments[1];
					this._isChanged = true;
				}
				
		}
	},
	
	hide: function() {
		if(this.isVisible) {
			this.isVisible = false;
			this._isChanged = true;
		}
	},
	
	show: function() {
		if(!this.isVisible) {
			this.isVisible = true;
			this._isChanged = true;
		}
	},
	
	/**
	 * iterates parent nodes till it finds a SVG font-size
	 * attribute.
	 * @param {SVGElement} node
	 */
	getInheritedFontSize: function(node) {
		if(!node || !node.getAttributeNS)
			return;
			
		var attr = node.getAttributeNS(null, "font-size");
//		var attr = node.style.fontSize;
		if(attr) {
			return parseFloat(attr);
		} else if(!ORYX.Editor.checkClassType(node, SVGSVGElement)) {
			return this.getInheritedFontSize(node.parentNode);
		}
	},
	
	getFontSize: function(node) {
		
		var tspans = this.node.getElementsByTagNameNS(Ext.isChrome ? "*" : ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
		
		//trying to get an inherited font-size attribute
		//NO CSS CONSIDERED!
		var fontSize = this.getInheritedFontSize(this.node); 
		
		if (!fontSize) {
			//because this only works in firefox 3, all other browser use the default line height
			if (tspans[0] && /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent) && new Number(RegExp.$1) >= 3) {
				try {
					fontSize = tspans[0].getExtentOfChar(0).height;
				} catch(e){}
			} else {
				fontSize = ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT;
			}
			
			//handling of unsupported method in webkit
			if (fontSize <= 0) {
				fontSize = ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT;
			}
		}
		
		if(fontSize)
			this.node.setAttribute("oryx:fontSize", fontSize);
		
		return fontSize;
	},
	
	/**
	 * Get trimmed text length for use with
	 * getExtentOfChar and getSubStringLength.
	 * @param {String} text
	 */
	getTrimmedTextLength: function(text) {
		text = text.strip().gsub('  ', ' ');
		
		var oldLength;
		do {
			oldLength = text.length;
			text = text.gsub('  ', ' ');
		} while (oldLength > text.length);

		return text.length;
	},
	
	/**
	 * Returns the offset from
	 * edge to the label which is 
	 * positioned under the edge
	 * @return {int}
	 */
	getOffsetBottom: function(){
		return this.offsetBottom;
	},
	
		
	/**
	 * Returns the offset from
	 * edge to the label which is 
	 * positioned over the edge
	 * @return {int}
	 */
	getOffsetTop: function(){
		return this.offsetTop;
	},
	
	hasStyles : function(obj) {
		return $H(obj || this.styles).keys().length > 0;
	},
	
	/**
	 * 
	 * @param {Object} obj
	 */
	deserialize: function(obj, shape){
		if (obj && "undefined" != typeof obj.x && "undefined" != typeof obj.y){			
			this.setPosition({x:Number(obj.x)||0, y:Number(obj.y)||0});
			
			if ("undefined" != typeof obj.distance){
				var from = shape.dockers[obj.from];
				var to = shape.dockers[obj.to];
				if (from && to){
					this.setReferencePoint({
						dirty : true,
						distance : Number(obj.distance) || 0,
						intersection : {x:Number(obj.x)||0, y:Number(obj.y)||0},
						orientation : obj.orientation,
						segment: {
							from: from,
							fromIndex: obj.from,
							fromPosition: from.bounds.center(),
							to: to,
							toIndex: obj.to,
							toPosition: to.bounds.center()
						}
					});
				}
			}
			
			if (obj.left) this.anchorLeft = true;
			if (obj.right) this.anchorRight = true;
			if (obj.top) this.anchorTop = true;
			if (obj.bottom) this.anchorBottom = true;
			if (obj.valign) this.verticalAlign(obj.valign);
			if (obj.align) this.horizontalAlign(obj.align);
			
			// Flag to force NOT to update again
			this.updated = true;
		} else if (obj && "undefined" != typeof obj.edge){
			this.setEdgePosition(obj.edge);
			
			this.updated = true;
		}
		
		// If the styles object is not empty, apply the styles to the label
		if (obj && obj.styles && this.hasStyles(obj.styles)) {
			var styles = obj.styles;
			if (styles.bold) this.setBold(true);
			if (styles.italic) this.setItalic(true);
			if (styles.fill) this.setFill(styles.fill);
			if (styles.font) this.setFont(styles.font);
			if (styles.size) this.setFontSize(styles.size);
		}
		
	},

	/**
	 * 
	 * @return {Object}
	 */
	serialize: function(){
		
		// Get the styles of the label
		var styles = {}, response = {};
		if (this.hasStyles()) {
			styles = {styles:this.styles};
		} else styles = null;
		
		// On edge position
		if (this.getEdgePosition()){
			if (this.getOriginEdgePosition() !== this.getEdgePosition()){
				return Ext.apply(response, {edge: this.getEdgePosition()}, styles);
			} else {
				return styles ? Ext.apply(response, null, styles) : null;
			}
		}
		
		// On self defined position
		if (this.position){
			var pos = {x: this.position.x, y: this.position.y};
			if (this.isAnchorLeft() && this.isAnchorLeft() !== this.isOriginAnchorLeft()){
				pos.left = true;
			}
			if (this.isAnchorRight() && this.isAnchorRight() !== this.isOriginAnchorRight()){
				pos.right = true;
			}
			if (this.isAnchorTop() && this.isAnchorTop() !== this.isOriginAnchorTop()){
				pos.top = true;
			}
			if (this.isAnchorBottom() && this.isAnchorBottom() !== this.isOriginAnchorBottom()){
				pos.bottom = true;
			}
			
			if (this.getOriginVerticalAlign() !== this.verticalAlign()){
				pos.valign = this.verticalAlign();
			}
			if (this.getOriginHorizontalAlign() !== this.horizontalAlign()){
				pos.align = this.horizontalAlign();
			}
			
			return Ext.apply(response, pos, styles);
		}
		
		
		
		// On reference point which is interesting for edges
		if (this.getReferencePoint()){
			var ref = this.getReferencePoint();
			return Ext.apply(response, {
				distance 	: ref.distance,
				x 			: ref.intersection.x,
				y 			: ref.intersection.y,
				from 		: ref.segment.fromIndex,
				to 			: ref.segment.toIndex,
				orientation : ref.iorientation || ref.orientation,
				valign 		: this.verticalAlign(),
				align 		: this.horizontalAlign()
				}, styles);
		}
		return styles ? Ext.apply(response, null, styles) : null;
	},
	
	toString: function() { return "Label " + this.id; }
 });/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.Math) {ORYX.Core.Math = {};}
	
/**
 * Calculate the middle point between two given points
 * @param {x:double, y:double} point1
 * @param {x:double, y:double} point2
 * @return the middle point
 */
ORYX.Core.Math.midPoint = function(point1, point2) {
	return 	{
				x: (point1.x + point2.x) / 2.0,
				y: (point1.y + point2.y) / 2.0
			}
}
			
/**
 * Returns a TRUE if the point is over a line (defined by
 * point1 and point 2). In Addition a threshold can be set,
 * which defines the weight of those line.
 * 
 * @param {int} pointX - Point X
 * @param {int} pointY - Point Y
 * @param {int} lPoint1X - Line first Point X
 * @param {int} lPoint1Y - Line first Point Y
 * @param {int} lPoint2X - Line second Point X
 * @param {int} lPoint2Y - Line second Point y
 * @param {int} offset {optional} - maximal distance to line
 * @class ORYX.Core.Math.prototype
 */
ORYX.Core.Math.isPointInLine = function (pointX, pointY, lPoint1X, lPoint1Y, lPoint2X, lPoint2Y, offset) {

	offset = offset ? Math.abs(offset) : 1;
	
	// Check if the edge is vertical
	if(Math.abs(lPoint1X-lPoint2X)<=offset && Math.abs(pointX-lPoint1X)<=offset && pointY-Math.max(lPoint1Y, lPoint2Y)<=offset && Math.min(lPoint1Y, lPoint2Y)-pointY<=offset) {
		return true
	}

	// Check if the edge is horizontal
	if(Math.abs(lPoint1Y-lPoint2Y)<=offset && Math.abs(pointY-lPoint1Y)<=offset && pointX-Math.max(lPoint1X, lPoint2X)<=offset && Math.min(lPoint1X, lPoint2X)-pointX<=offset) {
		return true
	}

	if(pointX > Math.max(lPoint1X, lPoint2X) || pointX < Math.min(lPoint1X, lPoint2X)) {
		return false
	}

	if(pointY > Math.max(lPoint1Y, lPoint2Y) || pointY < Math.min(lPoint1Y, lPoint2Y)) {
		return false
	}
			
	var s = (lPoint1Y - lPoint2Y) / (lPoint1X - lPoint2X);
	
	return 	Math.abs(pointY - ((s * pointX) + lPoint1Y - s * lPoint1X)) < offset
}

/**
 * Get a boolean if the point is in the polygone
 * 
 */
ORYX.Core.Math.isPointInEllipse = function (pointX, pointY, cx, cy, rx, ry) {

	if(cx === undefined || cy === undefined || rx === undefined || ry === undefined) {
		throw "ORYX.Core.Math.isPointInEllipse needs a ellipse with these properties: x, y, radiusX, radiusY"
	} 
	
    var tx = (pointX - cx) / rx;
    var ty = (pointY - cy) / ry;
	
    return tx * tx + ty * ty < 1.0;
}
	
/**
 * Get a boolean if the point is in the polygone
 * @param {int} pointX
 * @param {int} pointY
 * @param {[int]} Cornerpoints of the Polygone (x,y,x,y,...)
 */
ORYX.Core.Math.isPointInPolygone = function(pointX, pointY, polygone){

	if (arguments.length < 3) {
		throw "ORYX.Core.Math.isPointInPolygone needs two arguments"
	}
	
	var lastIndex = polygone.length-1;
	
	if (polygone[0] !== polygone[lastIndex - 1] || polygone[1] !== polygone[lastIndex]) {
		polygone.push(polygone[0]);
		polygone.push(polygone[1]);
	}
	
	var crossings = 0;

	var x1, y1, x2, y2, d;
	
    for (var i = 0; i < polygone.length - 3; ) {
        x1=polygone[i];
        y1=polygone[++i];
        x2=polygone[++i];
        y2=polygone[i+1];
        d=(pointY - y1) * (x2 - x1) - (pointX - x1) * (y2 - y1);

        if ((y1 >= pointY) != (y2 >= pointY)) {
            crossings += y2 - y1 >= 0 ? d >= 0 : d <= 0;
        }
        if (!d && Math.min(x1,x2) <= pointX && pointX <= Math.max(x1,x2)
            && Math.min(y1,y2) <= pointY && pointY <= Math.max(y1,y2)) {
            return true;
        }
    }
	return (crossings%2)?true:false;
}

/**
 *	Calculates the distance between a point and a line. It is also testable, if 
 *  the distance orthogonal to the line, matches the segment of the line.
 *  
 *  @param {Point} lineP1
 *  	The starting point of the line segment
 *  @param {Point} lineP2
 *  	The end point of the line segment
 *  @param {Point} point
 *  	The point to calculate the distance to.
 *  @param {boolean} toSegmentOnly
 *  	Flag to signal if only the segment of the line shall be evaluated.
 */
ORYX.Core.Math.distancePointLinie = function(
									lineP1, 
									lineP2, 
									point, 
									toSegmentOnly) {
	
	var intersectionPoint = 
				ORYX.Core.Math.getPointOfIntersectionPointLine(lineP1, 
																lineP2, 
																point, 
																toSegmentOnly);
	
	if(!intersectionPoint) {
		return null;
	}
	
	return ORYX.Core.Math.getDistancePointToPoint(point, intersectionPoint);
};

/**
 * Calculates the distance between two points.
 * 
 * @param {point} point1
 * @param {point} point2
 */
ORYX.Core.Math.getDistancePointToPoint = function(point1, point2) {
	return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
};

/**
 * Calculates the relative distance of a point which is between two other points.
 * 
 * @param {point} between1
 * @param {point} between2
 * @param {point} point
 */
ORYX.Core.Math.getDistanceBetweenTwoPoints = function(between1, between2, point) {
	return 	ORYX.Core.Math.getDistancePointToPoint(point, between1) /
			ORYX.Core.Math.getDistancePointToPoint(between1, between2);
};


/**
 * Returns true, if the point is of the left hand
 * side of the regarding the line.
 * 
 * @param {point} lineP1 Line first point
 * @param {point} lineP2 Line second point
 * @param {point} point
 */
ORYX.Core.Math.pointIsLeftOfLine = function(lineP1, lineP2, point){
	
	var vec1 = ORYX.Core.Math.getVector(lineP1, lineP2);
	var vec2 = ORYX.Core.Math.getVector(lineP1, point);
	// if the cross produkt is more than 0
	return ((vec1.x*vec2.y) - (vec2.x*vec1.y)) > 0
};

/**
 * Calculates the a point which is relatively between two other points.
 * 
 * @param {point} point1
 * @param {point} point2
 * @param {number} relative Relative which is between 0 and 1
 */
ORYX.Core.Math.getPointBetweenTwoPoints = function(point1, point2, relative) {
	relative = Math.max(Math.min(relative || 0, 1), 0);
	
	if (relative === 0){
		return point1;
	} else if (relative === 1){
		return point2;
	}
	
	return {
		x: point1.x + ((point2.x - point1.x) * relative),
		y: point1.y + ((point2.y - point1.y) * relative)
	}
};


/**
 * Returns the vector of the both points
 *
 * @param {point} point1
 * @param {point} point2
 */
ORYX.Core.Math.getVector = function(point1, point2){
	return {
		x: point2.x - point1.x,
		y: point2.y - point1.y
	}
}

/**
 * Returns the an identity vector of the given vector, 
 * which has the length ot one.
 *
 * @param {point} vector
 * or 
 * @param {point} point1
 * @param {point} point2
 */
ORYX.Core.Math.getIdentityVector = function(vector){
	
	if (arguments.length == 2){
		vector = ORYX.Core.Math.getVector(arguments[0], arguments[1]);
	}
	
	var length = Math.sqrt((vector.x*vector.x)+(vector.y*vector.y))
	return {
		x: vector.x / (length || 1),
		y: vector.y / (length || 1)
	}
}


ORYX.Core.Math.getOrthogonalIdentityVector = function(point1, point2){
	var vec = arguments.length == 1 ? point1 : ORYX.Core.Math.getIdentityVector(point1, point2);
	return {
		x: vec.y,
		y: -vec.x
	}
}


/**
 * Returns the intersection point of a line and a point that defines a line
 * orthogonal to the given line.
 * 
 *  @param {float} lineP1
 *  	The starting point of the line segment
 *  @param {float} lineP2
 *  	The end point of the line segment
 *  @param {Point} point
 *  	The point to calculate the distance to.
 *  @param {boolean} onSegmentOnly
 *  	Flag to signal if only the segment of the line shell be evaluated.
 */
ORYX.Core.Math.getPointOfIntersectionPointLine = function(
													lineP1, 
													lineP2, 
													point, 
													onSegmentOnly) {

	/* 
	 * [P3 - P1 - u(P2 - P1)] dot (P2 - P1) = 0
	 * u =((x3-x1)(x2-x1)+(y3-y1)(y2-y1))/(p2-p1)2
	 */
	var denominator = Math.pow(lineP2.x - lineP1.x, 2) 
						+ Math.pow(lineP2.y - lineP1.y, 2);
	if(denominator == 0) {
		return undefined;
	}
	
	var u = ((point.x - lineP1.x) * (lineP2.x - lineP1.x)  
			+ (point.y - lineP1.y) * (lineP2.y - lineP1.y))
			/ denominator;
			
	if(onSegmentOnly) {
		if (!(0 <= u && u <= 1)) {
			return undefined;
		}
	}
	
	pointOfIntersection = new Object();
	pointOfIntersection.x = lineP1.x + u * (lineP2.x - lineP1.x);
	pointOfIntersection.y = lineP1.y + u * (lineP2.y - lineP1.y);	
	
	return pointOfIntersection;												
};

/**
 * Translated the point with the given matrix.
 * @param {Point} point
 * @param {Matrix} matrix 
 * @return {Object} Includes x, y
 */
ORYX.Core.Math.getTranslatedPoint = function(point, matrix){
	var x = matrix.a*point.x+matrix.c*point.y+matrix.e*1;
	var y = matrix.b*point.x+matrix.d*point.y+matrix.f*1;
    return {x:x, y:y}
}


/**
 * Returns the inverse matrix of the given SVG transformation matrix
 * @param {SVGTransformationMatrix} matrix
 * @return {Matrix}
 */
ORYX.Core.Math.getInverseMatrix = function(matrix){

	var det = ORYX.Core.Math.getDeterminant(matrix), m = matrix;
	// +-     -+
	// | a c e |
	// | b d f |
	// | 0 0 1 |
	// +-     -+
	return {
		a: det * ((m.d*1)-(m.f*0)),
		b: det * ((m.f*0)-(m.b*1)),
		c: det * ((m.e*0)-(m.c*1)),
		d: det * ((m.a*1)-(m.e*0)),
		e: det * ((m.c*m.f)-(m.e*m.d)),
		f: det * ((m.e*m.b)-(m.a*m.f))
	}
}

/**
 * Returns the determinant of the svg transformation matrix
 * @param {SVGTranformationMatrix} matrix
 * @return {Number}
 *
 */
ORYX.Core.Math.getDeterminant = function(m){
	// a11a22a33+a12a23a31+a13a21a32-a13a22a31-a12a21a33-a11a23a32
	return (m.a*m.d*1)+(m.c*m.f*0)+(m.e*m.b*0)-(m.e*m.d*0)-(m.c*m.b*1)-(m.a*m.f*0);
}

/**
 * Returns the bounding box of the given node. Translates the 
 * origin bounding box with the tranlation matrix.
 * @param {SVGElement} node
 * @return {Object} Includes x, y, width, height
 */
ORYX.Core.Math.getTranslatedBoundingBox = function(node){
	var matrix = node.getCTM();
	var bb = node.getBBox();
	var ul = ORYX.Core.Math.getTranslatedPoint({x:bb.x, y:bb.y}, matrix);
	var ll = ORYX.Core.Math.getTranslatedPoint({x:bb.x, y:bb.y+bb.height}, matrix);
	var ur = ORYX.Core.Math.getTranslatedPoint({x:bb.x+bb.width, y:bb.y}, matrix);
	var lr = ORYX.Core.Math.getTranslatedPoint({x:bb.x+bb.width, y:bb.y+bb.height}, matrix);
	
	var minPoint = {
	    x: Math.min(ul.x, ll.x, ur.x, lr.x),
	    y: Math.min(ul.y, ll.y, ur.y, lr.y)
	}
	var maxPoint = {
	    x: Math.max(ul.x, ll.x, ur.x, lr.x),
	    y: Math.max(ul.y, ll.y, ur.y, lr.y)
	}
	return {
	    x: minPoint.x,
	    y: minPoint.y,
	    width: maxPoint.x - minPoint.x,
	    height: maxPoint.y - minPoint.y
	}
};


/**
 * Returns the angle of the given line, which is representated by the two points
 * @param {Point} p1
 * @param {Point} p2
 * @return {Number} 0 <= x <= 359.99999
 */
ORYX.Core.Math.getAngle = function(p1, p2){
	if(p1.x == p2.x && p1.y == p2.y)
		return 0;

	var angle = Math.asin(Math.sqrt(Math.pow(p1.y-p2.y, 2))
				/(Math.sqrt(Math.pow(p2.x-p1.x, 2)+Math.pow(p1.y-p2.y, 2))))
				*180/Math.PI;
	
	if(p2.x >= p1.x && p2.y <= p1.y)
		return angle;
	else if(p2.x < p1.x && p2.y <= p1.y)
		return 180 - angle;
	else if(p2.x < p1.x && p2.y > p1.y)
		return 180 + angle;
	else
		return 360 - angle;
};


/**
 * Implementation of the cohen-sutherland algorithm
 */
new function(){
	
	var RIGHT = 2, TOP = 8,  BOTTOM = 4, LEFT = 1;
	
 	function computeOutCode (x, y, xmin, ymin, xmax, ymax) {
		var code = 0;
		if (y > ymax)
		    code |= TOP;
		else if (y < ymin)
		    code |= BOTTOM;
		if (x > xmax)
		    code |= RIGHT;
		else if (x < xmin)
		    code |= LEFT;
		return code;
	}
	
	/**
	 * Returns TRUE if the rectangle is over the edge and has intersection points or includes it
	 * @param {Object} x1 Point A of the line
	 * @param {Object} y1
	 * @param {Object} x2 Point B of the line
	 * @param {Object} y2
	 * @param {Object} xmin Point A of the rectangle
	 * @param {Object} ymin
	 * @param {Object} xmax Point B of the rectangle
	 * @param {Object} ymax
	 */
	ORYX.Core.Math.isRectOverLine = function(x1, y1, x2, y2, xmin, ymin, xmax, ymax){
		return !!ORYX.Core.Math.clipLineOnRect.apply(ORYX.Core.Math, arguments);
	}
	
	/**
	 * Returns the point of intersection if there is one, otherwise null.
	 * @param {Object} x1 Point A of the line
	 * @param {Object} y1
	 * @param {Object} x2 Point B of the line
	 * @param {Object} y2
	 * @param {Object} xmin Point A of the rectangle
	 * @param {Object} ymin
	 * @param {Object} xmax Point B of the rectangle
	 * @param {Object} ymax
	 */
	ORYX.Core.Math.getIntersectionPointOfRect = function(x1, y1, x2, y2, xmin, ymin, xmax, ymax){
		var line = ORYX.Core.Math.clipLineOnRect(x1, y1, x2, y2, xmin, ymin, xmax, ymax);
		if (line){
			if ((line.a.x == x1 && line.a.y == y1) || (line.a.x == x2 && line.a.y == y2)){
				return line.b;
			} else if (line.b.x == x1 && line.b.y == y1 || (line.b.x == x2 && line.b.y == y2)){
				return line.a;
			}
		}
		return null;
	}
	
	/**
	 * Returns the clipped line on the given rectangle. If there is 
	 * no intersection, it will return NULL.
	 *  
	 * @param {Object} x1 Point A of the line
	 * @param {Object} y1
	 * @param {Object} x2 Point B of the line
	 * @param {Object} y2
	 * @param {Object} xmin Point A of the rectangle
	 * @param {Object} ymin
	 * @param {Object} xmax Point B of the rectangle
	 * @param {Object} ymax
	 */
	ORYX.Core.Math.clipLineOnRect = function(x1, y1, x2, y2, xmin, ymin, xmax, ymax){
        //Outcodes for P0, P1, and whatever point lies outside the clip rectangle
        var outcode0, outcode1, outcodeOut, hhh = 0;
        var accept = false, done = false;
 
        //compute outcodes
        outcode0 = computeOutCode(x1, y1, xmin, ymin, xmax, ymax);
        outcode1 = computeOutCode(x2, y2, xmin, ymin, xmax, ymax);
 
        do {
            if ((outcode0 | outcode1) == 0 ){
                accept = true;
                done = true;
            } else if ( (outcode0 & outcode1) > 0 ) {
                done = true;
            } else {
                //failed both tests, so calculate the line segment to clip
                //from an outside point to an intersection with clip edge
                var x = 0, y = 0;
                //At least one endpoint is outside the clip rectangle; pick it.
                outcodeOut = outcode0 != 0 ? outcode0: outcode1;
                //Now find the intersection point;
                //use formulas y = y0 + slope * (x - x0), x = x0 + (1/slope)* (y - y0)
                if ( (outcodeOut & TOP) > 0 ) {
                    x = x1 + (x2 - x1) * (ymax - y1)/(y2 - y1);
                    y = ymax;
                } else if ((outcodeOut & BOTTOM) > 0 ) {
                    x = x1 + (x2 - x1) * (ymin - y1)/(y2 - y1);
                    y = ymin;
                } else if ((outcodeOut & RIGHT)> 0) {
                    y = y1 + (y2 - y1) * (xmax - x1)/(x2 - x1);
                    x = xmax;
                } else if ((outcodeOut & LEFT) > 0) {
                    y = y1 + (y2 - y1) * (xmin - x1)/(x2 - x1);
                    x = xmin;
                }
				
                //Now we move outside point to intersection point to clip
                //and get ready for next pass.
                if (outcodeOut == outcode0) {
                    x1 = x;
                    y1 = y;
                    outcode0 = computeOutCode (x1, y1, xmin, ymin, xmax, ymax);
                } else {
                    x2 = x;
                    y2 = y;
                    outcode1 = computeOutCode (x2, y2, xmin, ymin, xmax, ymax);
                }
            }
            hhh ++;
        } while (done  != true && hhh < 5000);
 
        if(accept) {
            return {a:{x:x1, y:y1}, b:{x:x2, y:y2}};
        }
		return null;
    }
}();
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespace
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class Stencil
 * uses Prototpye 1.5.0
 * uses Inheritance
 * 
 * This class represents one stencil of a stencil set.
 */
ORYX.Core.StencilSet.Stencil = {

	/**
	 * Constructor
	 */
	construct: function(jsonStencil, namespace, source, stencilSet, propertyPackages, defaultPosition) {
		arguments.callee.$.construct.apply(this, arguments); // super();
		
		// check arguments and set defaults.
		if(!jsonStencil) throw "Stencilset seems corrupt.";
		if(!namespace) throw "Stencil does not provide namespace.";
		if(!source) throw "Stencil does not provide SVG source.";
		if(!stencilSet) throw "Fatal internal error loading stencilset.";
		//if(!propertyPackages) throw "Fatal internal error loading stencilset.";
		
		this._source = source;
		this._jsonStencil = Object.clone(jsonStencil);
		this._stencilSet = stencilSet;
		this._namespace = namespace;
		this._propertyPackages = propertyPackages;
		
		if(defaultPosition && !this._jsonStencil.position) 
			this._jsonStencil.position = defaultPosition;
		
		this._view;
		this._properties = new Hash();
		this._overwrittenProperties = new Hash();
		
		// check stencil consistency and set defaults.
		/*with(this._jsonStencil) {
			
			if(!type) throw "Stencil does not provide type.";
			if((type != "edge") && (type != "node"))
				throw "Stencil type must be 'edge' or 'node'.";
			if(!id || id == "") throw "Stencil does not provide valid id.";
			if(!title || title == "")
				throw "Stencil does not provide title";
			if(!description) { description = ""; };
			if(!groups) { groups = []; }
			if(!roles) { roles = []; }

			// add id of stencil to its roles
			roles.push(id);
		}*/
		
		//init all JSON values
		if(!this._jsonStencil.type || !(this._jsonStencil.type === "edge" || this._jsonStencil.type === "node")) {
			throw "ORYX.Core.StencilSet.Stencil(construct): Type is not defined.";
		}
		if(!this._jsonStencil.id || this._jsonStencil.id === "") {
			throw "ORYX.Core.StencilSet.Stencil(construct): Id is not defined.";
		}
		if(!this._jsonStencil.title || this._jsonStencil.title === "") {
			throw "ORYX.Core.StencilSet.Stencil(construct): Title is not defined.";
		}

		if(!this._jsonStencil.description) { this._jsonStencil.description = ""; };
		if(!this._jsonStencil.groups) { this._jsonStencil.groups = []; }
		if(!this._jsonStencil.roles) { this._jsonStencil.roles = []; }
		
		//add id of stencil to its roles
		this._jsonStencil.roles.push(this._jsonStencil.id);

		//prepend namespace to each role
		this._jsonStencil.roles.each((function(role, index) {
			this._jsonStencil.roles[index] = namespace + role;
		}).bind(this));

		//delete duplicate roles
		this._jsonStencil.roles = this._jsonStencil.roles.uniq();

		//make id unique by prepending namespace of stencil set
		this._jsonStencil.id = namespace + this._jsonStencil.id;

		this.postProcessProperties();
		
		// init serialize callback
		if(!this._jsonStencil.serialize) {
			this._jsonStencil.serialize = {};
			//this._jsonStencil.serialize = function(shape, data) { return data;};
		}
		
		// init deserialize callback
		if(!this._jsonStencil.deserialize) {
			this._jsonStencil.deserialize = {};
			//this._jsonStencil.deserialize = function(shape, data) { return data;};
		}
		
		// init layout callback
		if(!this._jsonStencil.layout) {
			this._jsonStencil.layout = []
			//this._jsonStencil.layout = function() {return true;}
		}
		
		// init keep state of edges
		if(!this._jsonStencil.keepState) {
			this._jsonStencil.keepState = false;
		}
		
		// make the stencil unavailable e.g. in shape repository and shape menu
		if(!this._jsonStencil.hide) {
			this._jsonStencil.hide = false;
		}
		
		//TODO does not work correctly, if the url does not exist
		//How to guarantee that the view is loaded correctly before leaving the constructor???
		var url = source + "view/" + jsonStencil.view;
		// override content type when this is webkit.
		
		/*
		if(Prototype.Browser.WebKit) {
			
			var req = new XMLHttpRequest;
			req.open("GET", url, false);
			req.overrideMimeType('text/xml');
			req.send(null);
			req.onload = (function() { _loadSVGOnSuccess(req.responseXML); }).bind(this);

		// else just do it.
		} else
		*/
		
		if(this._jsonStencil.view.trim().match(/</)) {
			var parser	= new DOMParser();		
			var xml 	= parser.parseFromString( this._jsonStencil.view ,"text/xml");
			
			//check if result is a SVG document
			if( ORYX.Editor.checkClassType( xml.documentElement, SVGSVGElement )) {
	
				this._view = xml.documentElement;
				
				//updating link to images
				var imageElems = this._view.getElementsByTagNameNS("http://www.w3.org/2000/svg", "image");
				$A(imageElems).each((function(imageElem) {
					var link = imageElem.getAttributeNodeNS("http://www.w3.org/1999/xlink", "href");
					if(link && link.value.indexOf("://") == -1) {
						link.textContent = this._source + "view/" + link.value;
					}
				}).bind(this));
			} else {
				throw "ORYX.Core.StencilSet.Stencil(_loadSVGOnSuccess): The response is not a SVG document."
			}
		} else {
			new Ajax.Request(
				url, {
					asynchronous:false, method:'get',
					onSuccess:this._loadSVGOnSuccess.bind(this),
					onFailure:this._loadSVGOnFailure.bind(this)
			});
		}
	},

	postProcessProperties: function() {

		// add image path to icon
		if(this._jsonStencil.icon && this._jsonStencil.icon.indexOf("://") === -1) {
			this._jsonStencil.icon = this._source + "icons/" + this._jsonStencil.icon;
		} else {
			this._jsonStencil.icon = "";
		}
	
		// init property packages
		if(this._jsonStencil.propertyPackages && this._jsonStencil.propertyPackages instanceof Array) {
			this._jsonStencil.propertyPackages.each((function(ppId) {
				var pp = this._propertyPackages[ppId];
				
				if(pp) {
					pp.each((function(prop){
						this.addProperty(prop, this._namespace);
					}).bind(this));
				}
			}).bind(this));
		}
		
		// init properties
		if(this._jsonStencil.properties && this._jsonStencil.properties instanceof Array) {
			this._jsonStencil.properties.each((function(prop) {
				this.addProperty(prop, this._namespace);
			}).bind(this));
		}
		

	},

	/**
	 * @param {ORYX.Core.StencilSet.Stencil} stencil
	 * @return {Boolean} True, if stencil has the same namespace and type.
	 */
	equals: function(stencil) {
		return (this.id() === stencil.id());
	},

	stencilSet: function() {
		return this._stencilSet;
	},

	type: function() {
		return this._jsonStencil.type;
	},

	namespace: function() {
		return this._namespace;
	},

	id: function() {
		return this._jsonStencil.id;
	},
    
    idWithoutNs: function(){
        return this.id().replace(this.namespace(),"");
    },

	title: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonStencil, "title");
	},

	description: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonStencil, "description");
	},
	
	groups: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonStencil, "groups");
	},
	
	position: function() {
		return (isNaN(this._jsonStencil.position) ? 0 : this._jsonStencil.position);
	},

	view: function() {
		return this._view.cloneNode(true) || this._view;
	},

	icon: function() {
		return this._jsonStencil.icon;
	},
	
	fixedAspectRatio: function() {
		return this._jsonStencil.fixedAspectRatio === true;
	},
	
	hasMultipleRepositoryEntries: function() {
		return (this.getRepositoryEntries().length > 0);
	},
	
	getRepositoryEntries: function() {
		return (this._jsonStencil.repositoryEntries) ?
			$A(this._jsonStencil.repositoryEntries) : $A([]);
	},
	
	properties: function() {
		return this._properties.values();
	},

	property: function(id) {
		return this._properties[id];
	},
	
	overwrittenProperty: function(id){
		return this._overwrittenProperties[id] || undefined;
	},

	roles: function() {
		return this._jsonStencil.roles;
	},
	
	hide: function() {
		return this._jsonStencil.hide;
	},
	
	index: function(){
		return this._jsonStencil.index || null;
	},
	
	/****** Shape Menue alignment functions *****/
	
	/**
	 * 3 Cases:
	 * 	1. No alignment is defined -> return "east" as default
	 *  2. No shape passed -> return first alignment independent from a parent shape
	 *  3. Shape passed -> search an alignment rule that fits a parent shape, otherwise case 2. 
	 *  4. Default alignment for child elements
	 */
	defaultAlign: function(shape) {
		
		// Case 3: reference shape is defined
		if(shape instanceof ORYX.Core.Shape) {
			var parent = shape.getParentShape();
			var hasParentAlignment = this._defaultAlignHasParentDefinition();
			
			while(parent && !(parent instanceof ORYX.Core.Canvas)) {
				
				// Check parent algin definition first
				var stencilId = parent.getStencil().idWithoutNs();
				var alignment = (hasParentAlignment ? this._getAlignForParent(stencilId) : undefined);
				if(alignment && alignment.align) {
					return alignment.align;
				}
				
				// Check for ChildrenDefaultAlign second
				var childrenDefaultAlign = this._getChildrenDefaultAlign(parent);
				if(childrenDefaultAlign) {
					return childrenDefaultAlign;
				}
				
				parent = parent.getParentShape();
			}
		}
		
		// Case 4+2: no reference shape, but default alignment specified
		var orientation = shape.getCanvas().getOrientation();
		var a = this._getDefaultAlignment(orientation);
		if(a) {
			return a;
		}
		
		// Case 1: Nothing defined	
		// Get default orientation from Canvas Object
		if(shape instanceof ORYX.Core.Shape) {
			var o = {horizontal: "east", vertical: "south"};
			if(o[orientation]) {
				return o[orientation];
			}
		}
		
		return "east";
	},
	
	_getDefaultAlignment: function(orientation) {
		// defined as array
		if(this._isDefaultAlignDefined()) {
			
			// orientation based alignment
			var a = (orientation ? this._getAlignForOrientation(orientation) : undefined);
			if(a && a.align) {
				return a.align;
			}
			
			// default alignment
			var alignment = this._jsonStencil.defaultAlign.find(function(a) {
				return !a.parentRole && !a.orientation && a.align;
			});
			
			return (alignment ? alignment.align : undefined);
		}
		
		// as string
		if(typeof this._jsonStencil.defaultAlign === "string") {
			return this._jsonStencil.defaultAlign;
		}
	},
	
	_getAlignForParent: function(stencilId) {
		return this._jsonStencil.defaultAlign.find(function(a) {
			return a.parentRole === stencilId;
		});
	},
	
	_getAlignForOrientation: function(orientation) {
		return this._jsonStencil.defaultAlign.find(function(a) {
			return a.orientation === orientation;
		});
	},
	
	_getChildrenDefaultAlign: function(parentShape) {
		if(!(parentShape instanceof ORYX.Core.Shape)) {return;}
		if(!parentShape.getStencil()._isDefaultAlignDefined()) {return;}
		
		
		var alignment = parentShape.getStencil()._jsonStencil.defaultAlign.find(function(a) {
			return !!a.childrenDefaultAlign;
		});
		
		return (alignment ? alignment.childrenDefaultAlign : undefined);
		
	},
	
	_isDefaultAlignDefined: function() {
		return this._jsonStencil.defaultAlign instanceof Array;
	},
	
	_defaultAlignHasParentDefinition: function() {
		return this._isDefaultAlignDefined() && this._jsonStencil.defaultAlign.any(function(o) {
			return !!o.parentRole;
		});
	},
	
	/****** End Shape Menue alignment functions *****/

	serialize: function(shape, data) {
		return this._jsonStencil.serialize;
		//return this._jsonStencil.serialize(shape, data);
	},
	
	deserialize: function(shape, data) {
		return this._jsonStencil.deserialize;
		//return this._jsonStencil.deserialize(shape, data);
	},
	
	// in which case is targetShape used?
//	layout: function(shape, targetShape) {
//		return this._jsonStencil.layout(shape, targetShape);
//	},
	// layout property to store events for layouting in plugins
	layout: function(shape) {
		return this._jsonStencil.layout
	},

	keepState : function() {
		return this._jsonStencil.keepState;
	},

	/**
	 * Creates and adds a new property to the stencil. If
	 * there is already a property with the same id, than it will
	 * overwrite it.
	 * @param {Object} property
	 * @param {String} namespace
	 * @param {Boolean} ignoreLanguages TRUE if not any of a language, in case of multiple languages, should be created
	 */
	addProperty: function(property, namespace, ignoreLanguages) {
		if (property instanceof ORYX.Core.StencilSet.Property){
			namespace = property.namespace();
			property = property._jsonProp;
		}
		
		if (property && namespace) {
			var oProp = new ORYX.Core.StencilSet.Property(property, namespace, this);
			var id = oProp.prefix() + "-" + oProp.id();
			if (this._properties[id]) {
				if (!this._overwrittenProperties[id])
					this._overwrittenProperties[id] = this._properties[id];
				delete this._properties[id];				
			}
			this._properties[id] = oProp;
			
			/**
			 * Multilanguage - For each String items append a new one for each language
			 */
			if (ignoreLanguages !== true 
				&& $H(ORYX.CONFIG.MULTI_LANGUAGES||{}).size() > 0
				&& [ORYX.CONFIG.TYPE_TEXT, ORYX.CONFIG.TYPE_STRING].include(oProp.type())){
				
				var languages = $H(ORYX.CONFIG.MULTI_LANGUAGES||{}), defaultLanguage = ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT || languages.keys()[0];
				languages.keys().each(function(lang){
					if (lang === defaultLanguage){
						oProp._jsonProp.language = String(lang).toLowerCase();
					} else {
						var prop = Object.clone(property);
						prop.language = String(lang).toLowerCase();
						prop.id = prop.id + "_" + prop.language;
						prop.origin = oProp;
						this.addProperty(prop, namespace, true);
					}
				}.bind(this));
			}
		}
	},
	
	removeProperty: function(propertyId) {
		if(propertyId) {
			var oProp = this._properties.values().find(function(prop) {
				return (propertyId == prop.id());
			});
			if(oProp)
				delete this._properties[oProp.prefix() + "-" + oProp.id()];
		}
	},

	_loadSVGOnSuccess: function(result) {
		
		var xml = null;
		
		/*
		 * We want to get a dom object for the requested file. Unfortunately,
		 * safari has some issues here. this is meant as a fallback for all
		 * browsers that don't recognize the svg mimetype as XML but support
		 * data: urls on Ajax calls.
		 */
		
		// responseXML != undefined.
		// if(!(result.responseXML))
		
			// get the dom by data: url.
			// xml = _evenMoreEvilHack(result.responseText, 'text/xml');
		
		// else
		
			// get it the usual way.
			xml = result.responseXML;

		// IE9 Fix: IE uses an own XML class for representing xml instead of a SVG class as FF does 	
		if( !ORYX.Editor.checkClassType( xml.documentElement, SVGSVGElement )) {
			var parser	= new DOMParser();		
			xml = parser.parseFromString( result.responseText ,"text/xml");
		}
		
		//check if result is a SVG document
		if( ORYX.Editor.checkClassType( xml.documentElement, SVGSVGElement )) {

			this._view = xml.documentElement;
			
			//updating link to images
			var imageElems = this._view.getElementsByTagNameNS("http://www.w3.org/2000/svg", "image");
			$A(imageElems).each((function(imageElem) {
				var link = imageElem.getAttributeNodeNS("http://www.w3.org/1999/xlink", "href");
				if(link && link.value.indexOf("://") == -1) {
					link.textContent = this._source + "view/" + link.value;
				}
			}).bind(this));
		} else {
			throw "ORYX.Core.StencilSet.Stencil(_loadSVGOnSuccess): The response is not a SVG document."
		}
	},

	_loadSVGOnFailure: function(result) {
		throw "ORYX.Core.StencilSet.Stencil(_loadSVGOnFailure): Loading SVG document failed."
	},

	toString: function() { return "Stencil " + this.title() + " (" + this.id() + ")"; }
};

ORYX.Core.StencilSet.Stencil = Clazz.extend(ORYX.Core.StencilSet.Stencil);

/**
 * Transform a string into an xml document, the Safari way, as long as
 * the nightlies are broken. Even more evil version.
 * @param {Object} str
 * @param {Object} contentType
 */
function _evenMoreEvilHack(str, contentType) {
	
	/*
	 * This even more evil hack was taken from
	 * http://web-graphics.com/mtarchive/001606.php#chatty004999
	 */
	
	if (window.ActiveXObject) {
		var d = new ActiveXObject("MSXML.DomDocument");
		d.loadXML(str);
		return d;
	} else if (window.XMLHttpRequest) {
		var req = new XMLHttpRequest;
		req.open("GET", "data:" + (contentType || "application/xml") +
						";charset=utf-8," + encodeURIComponent(str), false);
		if (req.overrideMimeType) {
			req.overrideMimeType(contentType);
		}
		req.send(null);
		return req.responseXML;
	}
}

/**
 * Transform a string into an xml document, the Safari way, as long as
 * the nightlies are broken.
 * @param {Object} result the xml document object.
 */
function _evilSafariHack(serializedXML) {
	
	/*
	 *  The Dave way. Taken from:
	 *  http://web-graphics.com/mtarchive/001606.php
	 *  
	 *  There is another possibility to parse XML in Safari, by implementing
	 *  the DOMParser in javascript. However, in the latest nightlies of
	 *  WebKit, DOMParser is already available, but still buggy. So, this is
	 *  the best compromise for the time being.
	 */		
	
	var xml = serializedXML;
	var url = "data:text/xml;charset=utf-8," + encodeURIComponent(xml);
	var dom = null;
	
	// your standard AJAX stuff
	var req = new XMLHttpRequest();
	req.open("GET", url);
	req.onload = function() { dom = req.responseXML; }
	req.send(null);
	
	return dom;
}
	
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
/**
 * Init namespace
 * @namespace The ORYX.Core.StencilSet Namespace
 * @name ORYX.Core.StencilSet
 */
if ("undefined" == typeof ORYX) {
    var ORYX = {};
}
if ("undefined" == typeof ORYX.Core) {
    ORYX.Core = {};
}
if ("undefined" == typeof ORYX.Core.StencilSet) {
    ORYX.Core.StencilSet = {};
}
new function(){
	/**
	 * @class ORYX.Core.StencilSet.Property
	 * @extends Clazz
	 */
	ORYX.Core.StencilSet.Property = Clazz.extend({
	/** @lends ORYX.Core.StencilSet.Property# */
	    /**
	     * @constructor
	     * @param {ORYX.Core.StencilSet.Property} jsonProp
	     * @param {String} namespace
	     * @param {ORYX.Core.StencilSet.Stencil} stencil
	     */
		construct: function(jsonProp, namespace, stencil){
	        arguments.callee.$.construct.apply(this, arguments);
	        
	        this._jsonProp = jsonProp || ORYX.Log.error("Parameter jsonProp is not defined.");
	        this._namespace = namespace || ORYX.Log.error("Parameter namespace is not defined.");
	        this._stencil = stencil || ORYX.Log.error("Parameter stencil is not defined.");
	        
	        this._items = {};
	        this._complexItems = {};
	        
	        jsonProp.id = jsonProp.id || ORYX.Log.error("ORYX.Core.StencilSet.Property(construct): Id is not defined.");
			jsonProp.id = jsonProp.id.toLowerCase();
			
	        if (!jsonProp.type) {
	            ORYX.Log.info("Type is not defined for stencil '%0', id '%1'. Falling back to 'String'.", stencil, jsonProp.id);
	            jsonProp.type = "string";
	        }
	        else {
	            jsonProp.type = jsonProp.type.toLowerCase();
	        }
	        
	        jsonProp.prefix = jsonProp.prefix || "oryx";
	        jsonProp.title = jsonProp.title || "";
	        jsonProp.value = jsonProp.value || "";
	        jsonProp.description = jsonProp.description || "";
	        jsonProp.readonly = jsonProp.readonly || false;
	        jsonProp.optional = jsonProp.optional !== false;
	        
	        //init refToView
	        if (this._jsonProp.refToView) {
	            if (!(this._jsonProp.refToView instanceof Array)) {
	                this._jsonProp.refToView = [this._jsonProp.refToView];
	            }
	        }
	        else {
	            this._jsonProp.refToView = [];
	        }
	        
			var globalMin = this.getMinForType(jsonProp.type);
	        if (jsonProp.min === undefined || jsonProp.min === null) {
	            jsonProp.min =globalMin;
	        } else if (jsonProp.min < globalMin) {
				jsonProp.min = globalMin;
			}
	        
			var globalMax = this.getMaxForType(jsonProp.type);
	        if (jsonProp.max === undefined || jsonProp.max === null) {
	            jsonProp.max = globalMax;
	        } else if (jsonProp.max > globalMax) {
				jsonProp.min = globalMax;
			}
	        
	        if (!jsonProp.fillOpacity) {
	            jsonProp.fillOpacity = false;
	        }
			
			if ("number" != typeof jsonProp.lightness) {
				jsonProp.lightness = 1;
			} else {
				jsonProp.lightness = Math.max(0, Math.min(1, jsonProp.lightness));
			}
	        
	        if (!jsonProp.strokeOpacity) {
	            jsonProp.strokeOpacity = false;
	        }
	        
	        if (jsonProp.length === undefined || jsonProp.length === null) {
	            jsonProp.length = Number.MAX_VALUE;
	        }
	        
	        if (!jsonProp.wrapLines) {
	            jsonProp.wrapLines = false;
	        }
	        
	        if (!jsonProp.dateFormat) {
	            jsonProp.dateFormat = ORYX.I18N.PropertyWindow.dateFormat || "m/d/y";
	        }
	        
	        if (!jsonProp.fill) {
	            jsonProp.fill = false;
	        }
	        
	        if (!jsonProp.stroke) {
	            jsonProp.stroke = false;
	        }
	        
	        if(!jsonProp.inverseBoolean) {
	        	jsonProp.inverseBoolean = false;
	        }
			
			if(!jsonProp.directlyEditable && jsonProp.directlyEditable != false) {
	        	jsonProp.directlyEditable = true;
	        }
			
			if(jsonProp.visible !== false) {
				jsonProp.visible = true;
			}
			
			if(jsonProp.isList !== true) {
				jsonProp.isList = false;
				
				if(!jsonProp.list || !(jsonProp.list instanceof Array)) {
					jsonProp.list = [];
				}	
			}
			
			if(!jsonProp.category) {
				if (jsonProp.popular) {
					jsonProp.category = "popular";
				}
			}
			
			if(!jsonProp.alwaysAppearInMultiselect) {
				jsonProp.alwaysAppearInMultiselect = false;
			}
	        
			if (!jsonProp.allowCustomValue) {
				jsonProp.allowCustomValue = false;
			}
			
			// Depends on
			jsonProp.dependsOn = $H(jsonProp.dependsOn || {});
			jsonProp.hasDependencies = jsonProp.dependsOn.size() > 0;
			
			// Autocomplete
			jsonProp.autocomplete = jsonProp.autocomplete && jsonProp.autocomplete.url ? jsonProp.autocomplete : false;
			
	        if (jsonProp.type === ORYX.CONFIG.TYPE_CHOICE) {
	            if (jsonProp.items && jsonProp.items instanceof Array) {
	                jsonProp.items.each((function(jsonItem){
	                	var id = (jsonItem.value||jsonItem.id).toLowerCase();
	                	if (id){
		                    this._items[id] = new ORYX.Core.StencilSet.PropertyItem(jsonItem, namespace, this);
	                	}
	                }).bind(this));
	            }
	            else {
	                throw "ORYX.Core.StencilSet.Property(construct): No property items defined."
	            }
	            // extended by Kerstin (start)
	        }
	        else 
	            if (jsonProp.type === ORYX.CONFIG.TYPE_COMPLEX) {
	                if (jsonProp.complexItems && jsonProp.complexItems instanceof Array) {
	                    jsonProp.complexItems.each((function(jsonComplexItem){
	                        this._complexItems[jsonComplexItem.id.toLowerCase()] = new ORYX.Core.StencilSet.ComplexPropertyItem(jsonComplexItem, namespace, this);
	                    }).bind(this));
	                }
	                else {
	                    throw "ORYX.Core.StencilSet.Property(construct): No complex property items defined."
	                }
	            }
	        // extended by Kerstin (end)
	    },
		
		/**
		 * Returns the min value for a given type
		 * @param {Object} type
		 * @returns {Number}
		 */
		getMinForType : function(type) {
			if (type.toLowerCase() == ORYX.CONFIG.TYPE_INTEGER) {
				return -Math.pow(2,31)
			} else {
				return -Number.MAX_VALUE+1;
			}
		}, 
		
		/**
		 * Returns the max value for a given type
		 * @param {Object} type
		 * @returns {Number}
		 */
		getMaxForType : function(type) {
			if (type.toLowerCase() == ORYX.CONFIG.TYPE_INTEGER) {
				return Math.pow(2,31)-1
			} else {
				return Number.MAX_VALUE;
			}
		},
	    
	    /**
	     * @param {ORYX.Core.StencilSet.Property} property
	     * @returns {Boolean} True, if property has the same namespace and id.
	     */
	    equals: function(property){
	        return (this._namespace === property.namespace() &&
	        this.id() === property.id()) ? true : false;
	    },
	    
		/**
		 * Returns the namespace of the property
		 * @returns {Namespace}
		 */
	    namespace: function(){
	        return this._namespace;
	    },
	    
		/**
		 * Returns the contains stencil
		 * @returns {Stencil}
		 */
	    stencil: function(){
	        return this._stencil;
	    },
	    
		/**
		 * Returns the id of the property
		 */
	    id: function(){
	        return this._jsonProp.id;
	    },
	    
	    prefix: function(){
	        return this._jsonProp.prefix;
	    },
	    
		/**
		 * Returns the type of the property
		 */
	    type: function(){
	        return this._jsonProp.type;
	    },
	    
	    inverseBoolean: function() {
	    	return this._jsonProp.inverseBoolean;
	    },
		
		/**
		 * Returns the category of the property
		 */
		category: function() {
			return this._jsonProp.category;
		},
		
		config: function() {
			return this._jsonProp.config || {};
		},
		
		setCategory: function(value) {
			this._jsonProp.category = value;
		},
		
		directlyEditable: function() {
			return this._jsonProp.directlyEditable;
		},
		
		visible: function() {
			return this._jsonProp.visible;
		},
	    
		/**
		 * Returns the translated title of the property
		 */
	    title: function(){
	        return ORYX.Core.StencilSet.getTranslation(this._jsonProp, "title");
	    },
	    
		/**
		 * Returns the default value 
		 */
	    value: function(){
	        return this._jsonProp.value;
	    },
	    
		/**
		 * Returns TRUE if the property is a read only property
		 */
	    readonly: function(){
	        return this._jsonProp.readonly;
	    },
	    
		/**
		 * Returns if the value of the property can be blank
		 */
	    optional: function(){
	        return this._jsonProp.optional;
	    },
	    
		/**
		 * Returns a translated description of the property
		 */
	    description: function(){
	        return ORYX.Core.StencilSet.getTranslation(this._jsonProp, "description");
	    },
		
	    /**
	     * An optional link to a SVG element so that the property affects the
	     * graphical representation of the stencil.
	     */
	    refToView: function(){
	        return this._jsonProp.refToView;
	    },
	    
	    /**
	     * If type is integer or float, min is the lower bounds of value.
	     */
	    min: function(){
	        return this._jsonProp.min;
	    },
	    
	    /**
	     * If type ist integer or float, max is the upper bounds of value.
	     */
	    max: function(){
	        return this._jsonProp.max;
	    },
	    
	    /**
	     * If type is float, this method returns if the fill-opacity property should
	     *  be set.
	     *  @return {Boolean}
	     */
	    fillOpacity: function(){
	        return this._jsonProp.fillOpacity;
	    },
	    
	    /**
	     * If type is float, this method returns if the stroke-opacity property should
	     *  be set.
	     *  @return {Boolean}
	     */
	    strokeOpacity: function(){
	        return this._jsonProp.strokeOpacity;
	    },
	    
	    /**
	     * If type is string or richtext, length is the maximum length of the text.
	     * TODO how long can a string be.
	     */
	    length: function(){
	        return this._jsonProp.length ? this._jsonProp.length : Number.MAX_VALUE;
	    },
	    
	    wrapLines: function(){
	        return this._jsonProp.wrapLines;
	    },
	    
	    /**
	     * If type is date, dateFormat specifies the format of the date. The format
	     * specification of the ext library is used:
	     *
	     * Format  Output      Description
	     *	------  ----------  --------------------------------------------------------------
	     *	  d      10         Day of the month, 2 digits with leading zeros
	     *	  D      Wed        A textual representation of a day, three letters
	     *	  j      10         Day of the month without leading zeros
	     *	  l      Wednesday  A full textual representation of the day of the week
	     *	  S      th         English ordinal day of month suffix, 2 chars (use with j)
	     *	  w      3          Numeric representation of the day of the week
	     *	  z      9          The julian date, or day of the year (0-365)
	     *	  W      01         ISO-8601 2-digit week number of year, weeks starting on Monday (00-52)
	     *	  F      January    A full textual representation of the month
	     *	  m      01         Numeric representation of a month, with leading zeros
	     *	  M      Jan        Month name abbreviation, three letters
	     *	  n      1          Numeric representation of a month, without leading zeros
	     *	  t      31         Number of days in the given month
	     *	  L      0          Whether its a leap year (1 if it is a leap year, else 0)
	     *	  Y      2007       A full numeric representation of a year, 4 digits
	     *	  y      07         A two digit representation of a year
	     *	  a      pm         Lowercase Ante meridiem and Post meridiem
	     *	  A      PM         Uppercase Ante meridiem and Post meridiem
	     *	  g      3          12-hour format of an hour without leading zeros
	     *	  G      15         24-hour format of an hour without leading zeros
	     *	  h      03         12-hour format of an hour with leading zeros
	     *	  H      15         24-hour format of an hour with leading zeros
	     *	  i      05         Minutes with leading zeros
	     *	  s      01         Seconds, with leading zeros
	     *	  O      -0600      Difference to Greenwich time (GMT) in hours
	     *	  T      CST        Timezone setting of the machine running the code
	     *	  Z      -21600     Timezone offset in seconds (negative if west of UTC, positive if east)
	     *
	     * Example:
	     *  F j, Y, g:i a  ->  January 10, 2007, 3:05 pm
	     */
	    dateFormat: function(){
	        return this._jsonProp.dateFormat;
	    },
	    
	    /**
	     * If type is color, this method returns if the fill property should
	     *  be set.
	     *  @return {Boolean}
	     */
	    fill: function(){
	        return this._jsonProp.fill;
	    },
		
		/**
		 * Lightness defines the satiation of the color
		 * 0 is the pure color
		 * 1 is white
		 * @return {Integer} lightness
		 */
		lightness: function(){
			return this._jsonProp.lightness;
		},
	    
	    /**
	     * If type is color, this method returns if the stroke property should
	     *  be set.
	     *  @return {Boolean}
	     */
	    stroke: function(){
	        return this._jsonProp.stroke;
	    },
	    
	    /**
	     * If type is choice, items is a hash map with all alternative values
	     * (PropertyItem objects) with id as keys.
	     */
	    items: function(){
	        return $H(this._items).values();
	    },
	    
	    item: function(value){
	        if (value) {
				return this._items[value.toLowerCase()];
			} else {
				return null;
			}
	    },
	    
	    toString: function(){
	        return "Property " + this.title() + " (" + this.id() + ")";
	    },
	    
	    // extended by Kerstin (start)
	    complexItems: function(){
	        return $H(this._complexItems).values();
	    },
	    
	    complexItem: function(id){
	        if(id) {
				return this._complexItems[id.toLowerCase()];
			} else {
				return null;
			}
			
	    },
	    // extended by Kerstin (end)
	    
	    complexAttributeToView: function(){
	        return this._jsonProp.complexAttributeToView || "";
	    },
	    
	    isList: function() {
	    	return !!this._jsonProp.isList;
	    },
	    
	    getListItems: function() {
	    	return this._jsonProp.list;
	    },
		
		/**
		 * If type is glossary link, the 
		 * type of category can be defined where
		 * the link only can go to.
		 * @return {String} The glossary category id 
		 */
		linkableType: function(){
			return this._jsonProp.linkableType || "";
		},
		
		alwaysAppearInMultiselect : function() {
			return this._jsonProp.alwaysAppearInMultiselect;
		},
		
		allowCustomValue : function() {
			return !this._jsonProp.allowCustomValue;
		},
		
		/**
		 * Returns an object of all given dependencies, which
		 * should be fulfilled to show the property 
		 */
		dependsOn: function(){
			return this._jsonProp.dependsOn;
		},
		
		/**
		 * Returns an array of properties which has a 
		 * dependency to this property
		 * @returns
		 */
		dependentProperties: function(){
			if (!this._dependentProperties){
				var id = this.id();
				this._dependentProperties = this.stencil().properties().findAll(function(property){
					return !!property.dependsOn()[id];
				})
			}
			return this._dependentProperties;
		},
		
		/**
		 * Returns TRUE if a valid dependency to
		 * another property is given (or if no dependency is set).
		 * @param {Object} properties
		 */
		hasValidDependency: function(properties){
			if (this._jsonProp.hasDependencies){
				var dp = this._jsonProp.dependsOn, pre = this.prefix();
				return dp.keys().all(function(key){
					return properties[pre+"-"+key] == dp[key];
				});
			}
			return true;
		},
		
		/**
		 * If autocomplete is defined, it will return an object,
		 * otherwise it will return FALSE
		 * @return {Object} An object with the keys "url" (defines the server api for the request), 
		 * 			"trigger" (TRUE if the trigger should be shown) and 
		 * 			"optional" (FALSE if only one of the selection can be choosen)
		 */
		autocomplete: function(){
			return this._jsonProp.autocomplete;
		},
		
		/**
		 * Return the language code of the property
		 * @returns {String}
		 */
		language: function(){
			return this._jsonProp.language || undefined;
		},
		
		/**
		 * Return the origin property if this property is in another language of it
		 * @returns {ORYX.Core.StencilSet.Property}
		 */
		origin: function(){
			return this._jsonProp.origin || this;
		},
		
		/**
		 * Returns true if the property is a background color.
		 * @returns {Boolean}
		 */
		isBackgroundColor : function() {
			return this._jsonProp.type === 'color' && this._jsonProp.fill && !this._jsonProp.stroke && this._jsonProp.refToView;
		},
		
		/**
		 * Returns true if the property is a border color.
		 * @returns {Boolean}
		 */
		isBorderColor : function() {
			return this._jsonProp.type === 'color' && this._jsonProp.stroke && this._jsonProp.refToView;
		},
		
		/**
		 * Returns true if the property is a complex type and the initial values
		 * should not be removable from the shapes property
		 * @returns {Boolean}
		 */
		defaultValueReadOnly: function(){
			return this._jsonProp.defaultValueReadOnly === true;
		}
	});
}();
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespace
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class Stencil
 * uses Prototpye 1.5.0
 * uses Inheritance
 */
ORYX.Core.StencilSet.PropertyItem = Clazz.extend({

	/**
	 * Constructor
	 */
	construct: function(jsonItem, namespace, property) {
		arguments.callee.$.construct.apply(this, arguments);

		if(!jsonItem) {
			throw "ORYX.Core.StencilSet.PropertyItem(construct): Parameter jsonItem is not defined.";
		}
		if(!namespace) {
			throw "ORYX.Core.StencilSet.PropertyItem(construct): Parameter namespace is not defined.";
		}
		if(!property) {
			throw "ORYX.Core.StencilSet.PropertyItem(construct): Parameter property is not defined.";
		}
		
		this._jsonItem = jsonItem;
		this._namespace = namespace;
		this._property = property;
		
		//init all values
		if(!jsonItem.value) {
			throw "ORYX.Core.StencilSet.PropertyItem(construct): Value is not defined.";
		}
		
		if(this._jsonItem.refToView) {
			if(!(this._jsonItem.refToView instanceof Array)) {
				this._jsonItem.refToView = [this._jsonItem.refToView];
			}
		} else {
			this._jsonItem.refToView = [];
		}
	},

	/**
	 * @param {ORYX.Core.StencilSet.PropertyItem} item
	 * @return {Boolean} True, if item has the same namespace and id.
	 */
	equals: function(item) {
		return (this.property().equals(item.property()) &&
			this.value() === item.value());
	},

	namespace: function() {
		return this._namespace;
	},

	property: function() {
		return this._property;
	},

	value: function() {
		return this._jsonItem.value;
	},
	
	title: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonItem, "title");
	},

	refToView: function() {
		return this._jsonItem.refToView;
	},
	
	icon: function() {
		return (this._jsonItem.icon) ? this.property().stencil()._source + "icons/" + this._jsonItem.icon : "";
	},

	toString: function() { return "PropertyItem " + this.property() + " (" + this.value() + ")"; }
});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class Stencil
 * uses Prototpye 1.5.0
 * uses Inheritance
 */
ORYX.Core.StencilSet.ComplexPropertyItem = Clazz.extend({

	/**
	 * Constructor
	 */
	construct: function(jsonItem, namespace, property) {
		arguments.callee.$.construct.apply(this, arguments);

		if(!jsonItem) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Parameter jsonItem is not defined.";
		}
		if(!namespace) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Parameter namespace is not defined.";
		}
		if(!property) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Parameter property is not defined.";
		}
		
		this._jsonItem = jsonItem;
		this._namespace = namespace;
		this._property = property;
		this._items = new Hash();
		
		//init all values
		if(!jsonItem.name) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Name is not defined.";
		}
		
		if(!jsonItem.type) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Type is not defined.";
		} else {
			jsonItem.type = jsonItem.type.toLowerCase();
		}
		
		if(jsonItem.type === ORYX.CONFIG.TYPE_CHOICE) {
			if(jsonItem.items && jsonItem.items instanceof Array) {
				jsonItem.items.each((function(item) {
					this._items[item.value] = new ORYX.Core.StencilSet.PropertyItem(item, namespace, this);
				}).bind(this));
			} else {
				throw "ORYX.Core.StencilSet.Property(construct): No property items defined."
			}
		}
	},

	/**
	 * @param {ORYX.Core.StencilSet.PropertyItem} item
	 * @return {Boolean} True, if item has the same namespace and id.
	 */
	equals: function(item) {
		return (this.property().equals(item.property()) &&
			this.name() === item.name());
	},

	namespace: function() {
		return this._namespace;
	},

	property: function() {
		return this._property;
	},
	
	title: function() {
		return this.name();
	},

	name: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonItem, "name");
	},
	
	id: function() {
		return this._jsonItem.id;
	},
	
	type: function() {
		return this._jsonItem.type;
	},
	
	optional: function() {
		return this._jsonItem.optional;
	},
	
	isList: function() {
		return !!this._jsonItem.isList;
	},
	
	allowCustomValue: function() {
		if ("undefined" === typeof this._jsonItem.allowCustomValue) {
			return false;
		} else {
			return this._jsonItem.allowCustomValue;
		}
	},
	
	width: function() {
		return this._jsonItem.width;
	},
	
	value: function() {
		return this._jsonItem.value;
	},
	
	items: function() {
		return this._items.values();
	},
	
	disable: function() {
		return this._jsonItem.disable;
	}
});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class Rules uses Prototpye 1.5.0 uses Inheritance
 * 
 * This class implements the API to check the stencil sets' rules.
 */
ORYX.Core.StencilSet.Rules = {

	/**
	 * Constructor
	 */
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);

		this._stencilSets = [];
		this._stencils = [];
		this._containerStencils = [];
		
		this._cachedConnectSET = new Hash();
		this._cachedConnectSE = new Hash();
		this._cachedConnectTE = new Hash();
		this._cachedCardSE = new Hash();
		this._cachedCardTE = new Hash();
		this._cachedContainPC = new Hash();
		this._cachedMorphRS = new Hash();
		
		this._connectionRules = new Hash();
		this._cardinalityRules = new Hash();
		this._containmentRules = new Hash();
		this._containmentRulesExcludes = [];
		this._morphingRules = new Hash();
		this._layoutRules = new Hash();
	},
	
	/**
	 * Call this method to initialize the rules for a stencil set and all of its
	 * active extensions.
	 * 
	 * @param {Object}
	 *            stencilSet
	 */
	initializeRules: function(stencilSet) {
		
		var existingSS = this._stencilSets.find(function(ss) {
							return (ss.namespace() == stencilSet.namespace());
						});
		if (existingSS) {
			// reinitialize all rules
			var stencilsets = this._stencilSets.clone();
			stencilsets = stencilsets.without(existingSS);
			stencilsets.push(stencilSet);
			
			this._stencilSets = [];
			this._stencils = [];
			this._containerStencils = [];
			
			this._cachedConnectSET = new Hash();
			this._cachedConnectSE = new Hash();
			this._cachedConnectTE = new Hash();
			this._cachedCardSE = new Hash();
			this._cachedCardTE = new Hash();
			this._cachedContainPC = new Hash();
			this._cachedMorphRS = new Hash();
			
			this._connectionRules = new Hash();
			this._cardinalityRules = new Hash();
			this._containmentRules = new Hash();
			this._containmentRulesExcludes = [];
			this._morphingRules = new Hash();
			this._layoutRules = new Hash();
			
			stencilsets.each(function(ss){
				this.initializeRules(ss);
			}.bind(this));
			return;
		}
		else {
			this._stencilSets.push(stencilSet);
			
			var jsonRules = new Hash(stencilSet.jsonRules());
			var namespace = stencilSet.namespace();
			var stencils = stencilSet.stencils();
			
			stencilSet.extensions().values().each(function(extension) {
				if(extension.rules) {
					if(extension.rules.connectionRules)
						jsonRules.connectionRules = jsonRules.connectionRules.concat(extension.rules.connectionRules);
					if(extension.rules.cardinalityRules)
						jsonRules.cardinalityRules = jsonRules.cardinalityRules.concat(extension.rules.cardinalityRules);
					if(extension.rules.containmentRules)
						jsonRules.containmentRules = jsonRules.containmentRules.concat(extension.rules.containmentRules);
					if(extension.rules.morphingRules){
						var roles = [].concat(extension.rules.morphingRules).pluck("role");
						jsonRules.morphingRules = [].concat(extension.rules.morphingRules, jsonRules.morphingRules.findAll(function(mr){return !roles.include(mr.role)}));
					}
				}
				if(extension.stencils) 
					stencils = stencils.concat(extension.stencils);
			});
			
			this._stencils = this._stencils.concat(stencilSet.stencils());
			
			// init connection rules
			var cr = this._connectionRules;
			if (jsonRules.connectionRules) {
				jsonRules.connectionRules.each((function(rules){
					if (this._isRoleOfOtherNamespace(rules.role)) {
						if (!cr[rules.role]) {
							cr[rules.role] = new Hash();
						}
					}
					else {
						if (!cr[namespace + rules.role]) 
							cr[namespace + rules.role] = new Hash();
					}
					
					rules.connects.each((function(connect){
						var toRoles = [];
						if (connect.to) {
							if (!(connect.to instanceof Array)) {
								connect.to = [connect.to];
							}
							connect.to.each((function(to){
								if (this._isRoleOfOtherNamespace(to)) {
									toRoles.push(to);
								}
								else {
									toRoles.push(namespace + to);
								}
							}).bind(this));
						}
						
						var role, from;
						if (this._isRoleOfOtherNamespace(rules.role)) 
							role = rules.role;
						else 
							role = namespace + rules.role;
						
						if (this._isRoleOfOtherNamespace(connect.from)) 
							from = connect.from;
						else 
							from = namespace + connect.from;
						
						if (!cr[role][from]) 
							cr[role][from] = toRoles;
						else 
							cr[role][from] = cr[role][from].concat(toRoles);
						
					}).bind(this));
				}).bind(this));
			}
			
			// init cardinality rules
			var cardr = this._cardinalityRules;
			if (jsonRules.cardinalityRules) {
				jsonRules.cardinalityRules.each((function(rules){
					var cardrKey;
					if (this._isRoleOfOtherNamespace(rules.role)) {
						cardrKey = rules.role;
					}
					else {
						cardrKey = namespace + rules.role;
					}
					
					if (!cardr[cardrKey]) {
						cardr[cardrKey] = {};
						for (i in rules) {
							cardr[cardrKey][i] = rules[i];
						}
					}
					
					var oe = new Hash();
					if (rules.outgoingEdges) {
						rules.outgoingEdges.each((function(rule){
							if (this._isRoleOfOtherNamespace(rule.role)) {
								oe[rule.role] = rule;
							}
							else {
								oe[namespace + rule.role] = rule;
							}
						}).bind(this));
					}
					cardr[cardrKey].outgoingEdges = oe;
					var ie = new Hash();
					if (rules.incomingEdges) {
						rules.incomingEdges.each((function(rule){
							if (this._isRoleOfOtherNamespace(rule.role)) {
								ie[rule.role] = rule;
							}
							else {
								ie[namespace + rule.role] = rule;
							}
						}).bind(this));
					}
					cardr[cardrKey].incomingEdges = ie;
				}).bind(this));
			}
			
			// init containment rules
			var conr = this._containmentRules, excludes = this._containmentRulesExcludes;
			if (jsonRules.containmentRules) {
				jsonRules.containmentRules.each((function(rules){
					var conrKey;
					// Check params
					if (!rules.role || (!rules.contains && !rules.exclude)){
						return;
					}
					if (this._isRoleOfOtherNamespace(rules.role)) {
						conrKey = rules.role;
					} else {
						this._containerStencils.push(namespace + rules.role);
						conrKey = namespace + rules.role;
					}
					
					if (rules.exclude === true){
						excludes.push(conrKey);
						return
					}
					
					if (!conr[conrKey]) {
						conr[conrKey] = [];
					}
					
					rules.contains.each((function(containRole){
						if (this._isRoleOfOtherNamespace(containRole)) {
							conr[conrKey].push(containRole);
						}
						else {
							conr[conrKey].push(namespace + containRole);
						}
					}).bind(this));
				}).bind(this));
			}
			
			// init morphing rules
			var morphr = this._morphingRules;
			if (jsonRules.morphingRules) {
				jsonRules.morphingRules.each((function(rules){
					var morphrKey;
					if (this._isRoleOfOtherNamespace(rules.role)) {
						morphrKey = rules.role;
					}
					else {
						morphrKey = namespace + rules.role;
					}
					if (!morphr[morphrKey]) {
						morphr[morphrKey] = [];
					}
					if(!rules.preserveBounds) {
						rules.preserveBounds = false;
					}
					rules.baseMorphs.each((function(baseMorphStencilId){
						var morphStencil = this._getStencilById(namespace + baseMorphStencilId);
						if(morphStencil) {
							morphr[morphrKey].push(morphStencil);
						}
					}).bind(this));
				}).bind(this));
			}
			
			// init layouting rules
			var layoutRules = this._layoutRules;
			if (jsonRules.layoutRules) {
				
				var getDirections = function(o){
					return {
							"edgeRole":o.edgeRole||undefined,
							"orientation":o.orientation||undefined,
							"t": o["t"]||1,
							"r": o["r"]||1,
							"b": o["b"]||1,
							"l": o["l"]||1
						}
				}
				
				jsonRules.layoutRules.each(function(rules){
					var layoutKey;
					if (this._isRoleOfOtherNamespace(rules.role)) {
						layoutKey = rules.role;
					}
					else {
						layoutKey = namespace + rules.role;
					}
					if (!layoutRules[layoutKey]) {
						layoutRules[layoutKey] = {};
					}
					if (rules["in"]){
						layoutRules[layoutKey]["in"] = getDirections(rules["in"]);
					}
					if (rules["ins"]){
						layoutRules[layoutKey]["ins"] = (rules["ins"]||[]).map(function(e){ return getDirections(e) })
					}
					if (rules["out"]) {
						layoutRules[layoutKey]["out"] = getDirections(rules["out"]);
					}
					if (rules["outs"]){
						layoutRules[layoutKey]["outs"] = (rules["outs"]||[]).map(function(e){ return getDirections(e) })
					}
				}.bind(this));
			}			
		}
	},
	
	_getStencilById: function(id) {
		return this._stencils.find(function(stencil) {
			return stencil && stencil.id() == id;
		});
	},
	
	_cacheConnect: function(args) {
		result = this._canConnect(args);
		
		if (args.sourceStencil && args.targetStencil) {
			var source = this._cachedConnectSET[args.sourceStencil.id()];
			
			if(!source) {
				source = new Hash();
				this._cachedConnectSET[args.sourceStencil.id()] = source;
			}
			
			var edge = source[args.edgeStencil.id()];
			
			if(!edge) {
				edge = new Hash();
				source[args.edgeStencil.id()] = edge;
			}
			
			edge[args.targetStencil.id()] = result;
			
		} else if (args.sourceStencil) {
			var source = this._cachedConnectSE[args.sourceStencil.id()];
			
			if(!source) {
				source = new Hash();
				this._cachedConnectSE[args.sourceStencil.id()] = source;
			}
			
			source[args.edgeStencil.id()] = result;

		} else {
			var target = this._cachedConnectTE[args.targetStencil.id()];
			
			if(!target) {
				target = new Hash();
				this._cachedConnectTE[args.targetStencil.id()] = target;
			}
			
			target[args.edgeStencil.id()] = result;
		}
		
		return result;
	},
	
	_cacheCard: function(args) {
			
		if(args.sourceStencil) {
			var source = this._cachedCardSE[args.sourceStencil.id()]
			
			if(!source) {
				source = new Hash();
				this._cachedCardSE[args.sourceStencil.id()] = source;
			}
			
			var max = this._getMaximumNumberOfOutgoingEdge(args);
			if(max == undefined)
				max = -1;
				
			source[args.edgeStencil.id()] = max;
		}	
		
		if(args.targetStencil) {
			var target = this._cachedCardTE[args.targetStencil.id()]
			
			if(!target) {
				target = new Hash();
				this._cachedCardTE[args.targetStencil.id()] = target;
			}
			
			var max = this._getMaximumNumberOfIncomingEdge(args);
			if(max == undefined)
				max = -1;
				
			target[args.edgeStencil.id()] = max;
		}
	},
	
	_cacheContain: function(args) {
		
		var result = [this._canContain(args), 
					  this._getMaximumOccurrence(args.containingStencil, args.containedStencil)]
		
		if(result[1] == undefined) 
			result[1] = -1;
		
		var children = this._cachedContainPC[args.containingStencil.id()];
		
		if(!children) {
			children = new Hash();
			this._cachedContainPC[args.containingStencil.id()] = children;
		}
		
		children[args.containedStencil.id()] = result;
		
		return result;
	},
	
	/**
	 * Returns all stencils belonging to a morph group. (calculation result is
	 * cached)
	 */
	_cacheMorph: function(role) {
		
		var morphs = this._cachedMorphRS[role];
		
		if(!morphs) {
			morphs = [];
			
			if(this._morphingRules.keys().include(role)) {
				morphs = this._stencils.select(function(stencil) {
					return stencil.roles().include(role);
				});
			}
			
			this._cachedMorphRS[role] = morphs;
		}
		return morphs;
	},
	
	/** Begin connection rules' methods */
	
	/**
	 * 
	 * @param {Object}
	 *            args sourceStencil: ORYX.Core.StencilSet.Stencil | undefined
	 *            sourceShape: ORYX.Core.Shape | undefined
	 * 
	 * At least sourceStencil or sourceShape has to be specified
	 * 
	 * @return {Array} Array of stencils of edges that can be outgoing edges of
	 *         the source.
	 */
	outgoingEdgeStencils: function(args) {
		// check arguments
		if(!args.sourceShape && !args.sourceStencil) {
			return [];
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		
		var _edges = [];
		
		// test each edge, if it can connect to source
		this._stencils.each((function(stencil) {
			if(stencil.type() === "edge") {
				var newArgs = Object.clone(args);
				newArgs.edgeStencil = stencil;
				if(this.canConnect(newArgs)) {
					_edges.push(stencil);
				}
			}
		}).bind(this));

		return _edges;
	},

	/**
	 * 
	 * @param {Object}
	 *            args targetStencil: ORYX.Core.StencilSet.Stencil | undefined
	 *            targetShape: ORYX.Core.Shape | undefined
	 * 
	 * At least targetStencil or targetShape has to be specified
	 * 
	 * @return {Array} Array of stencils of edges that can be incoming edges of
	 *         the target.
	 */
	incomingEdgeStencils: function(args) {
		// check arguments
		if(!args.targetShape && !args.targetStencil) {
			return [];
		}
		
		// init arguments
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		
		var _edges = [];
		
		// test each edge, if it can connect to source
		this._stencils.each((function(stencil) {
			if(stencil.type() === "edge") {
				var newArgs = Object.clone(args);
				newArgs.edgeStencil = stencil;
				if(this.canConnect(newArgs)) {
					_edges.push(stencil);
				}
			}
		}).bind(this));

		return _edges;
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args edgeStencil: ORYX.Core.StencilSet.Stencil | undefined
	 *            edgeShape: ORYX.Core.Edge | undefined targetStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined targetShape:
	 *            ORYX.Core.Node | undefined
	 * 
	 * At least edgeStencil or edgeShape has to be specified!!!
	 * 
	 * @return {Array} Returns an array of stencils that can be source of the
	 *         specified edge.
	 */
	sourceStencils: function(args) {
		// check arguments
		if(!args || 
		   !args.edgeShape && !args.edgeStencil) {
			return [];
		}
		
		// init arguments
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		
		if(args.edgeShape) {
			args.edgeStencil = args.edgeShape.getStencil();
		}
		
		var _sources = [];
		
		// check each stencil, if it can be a source
		this._stencils.each((function(stencil) {
			var newArgs = Object.clone(args);
			newArgs.sourceStencil = stencil;
			if(this.canConnect(newArgs)) {
				_sources.push(stencil);
			}
		}).bind(this));

		return _sources;
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args edgeStencil: ORYX.Core.StencilSet.Stencil | undefined
	 *            edgeShape: ORYX.Core.Edge | undefined sourceStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined sourceShape:
	 *            ORYX.Core.Node | undefined
	 * 
	 * At least edgeStencil or edgeShape has to be specified!!!
	 * 
	 * @return {Array} Returns an array of stencils that can be target of the
	 *         specified edge.
	 */
	targetStencils: function(args) {
		// check arguments
		if(!args || 
		   !args.edgeShape && !args.edgeStencil) {
			return [];
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		
		if(args.edgeShape) {
			args.edgeStencil = args.edgeShape.getStencil();
		}
		
		var _targets = [];
		
		// check stencil, if it can be a target
		this._stencils.each((function(stencil) {
			var newArgs = Object.clone(args);
			newArgs.targetStencil = stencil;
			if(this.canConnect(newArgs)) {
				_targets.push(stencil);
			}
		}).bind(this));

		return _targets;
	},

	/**
	 * 
	 * @param {Object}
	 *            args edgeStencil: ORYX.Core.StencilSet.Stencil edgeShape:
	 *            ORYX.Core.Edge |undefined sourceStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined sourceShape:
	 *            ORYX.Core.Node |undefined targetStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined targetShape:
	 *            ORYX.Core.Node |undefined
	 * 
	 * At least source or target has to be specified!!!
	 * 
	 * @return {Boolean} Returns, if the edge can connect source and target.
	 */
	canConnect: function(args) {	
		// check arguments
		if(!args ||
		   (!args.sourceShape && !args.sourceStencil &&
		    !args.targetShape && !args.targetStencil) ||
		    !args.edgeShape && !args.edgeStencil) {
		   	return false; 
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		if(args.edgeShape) {
			args.edgeStencil = args.edgeShape.getStencil();
		}
		
		var result;
		
		if(args.sourceStencil && args.targetStencil) {
			var source = this._cachedConnectSET[args.sourceStencil.id()];
			
			if(!source)
				result = this._cacheConnect(args);
			else {
				var edge = source[args.edgeStencil.id()];

				if(!edge)
					result = this._cacheConnect(args);
				else {	
					var target = edge[args.targetStencil.id()];

					if(target == undefined)
						result = this._cacheConnect(args);
					else
						result = target;
				}
			}
		} else if (args.sourceStencil) {	
			var source = this._cachedConnectSE[args.sourceStencil.id()];
			
			if(!source)
				result = this._cacheConnect(args);
			else {
				var edge = source[args.edgeStencil.id()];
					
				if(edge == undefined)
					result = this._cacheConnect(args);
				else
					result = edge;
			}
		} else { // args.targetStencil
			var target = this._cachedConnectTE[args.targetStencil.id()];
			
			if(!target)
				result = this._cacheConnect(args);
			else {
				var edge = target[args.edgeStencil.id()];
					
				if(edge == undefined)
					result = this._cacheConnect(args);
				else
					result = edge;
			}
		}	
			
		// check cardinality
		if (result) {
			if(args.sourceShape) {
				var source = this._cachedCardSE[args.sourceStencil.id()];
				
				if(!source) {
					this._cacheCard(args);
					source = this._cachedCardSE[args.sourceStencil.id()];
				}
				
				var max = source[args.edgeStencil.id()];
				
				if(max == undefined) {
					this._cacheCard(args);
				}
				
				max = source[args.edgeStencil.id()];
				
				if(max != -1) {
					result = args.sourceShape.getOutgoingShapes().all(function(cs) {
								if((cs.getStencil().id() === args.edgeStencil.id()) && 
								   ((args.edgeShape) ? cs !== args.edgeShape : true)) {
									max--;
									return (max > 0) ? true : false;
								} else {
									return true;
								}
							});
				}
			} 
			
			if (args.targetShape) {
				var target = this._cachedCardTE[args.targetStencil.id()];
				
				if(!target) {
					this._cacheCard(args);
					target = this._cachedCardTE[args.targetStencil.id()];
				}
				
				var max = target[args.edgeStencil.id()];
				
				if(max == undefined) {
					this._cacheCard(args);
				}
				
				max = target[args.edgeStencil.id()];
				
				if(max != -1) {
					result = args.targetShape.getIncomingShapes().all(function(cs){
								if ((cs.getStencil().id() === args.edgeStencil.id()) &&
								((args.edgeShape) ? cs !== args.edgeShape : true)) {
									max--;
									return (max > 0) ? true : false;
								}
								else {
									return true;
								}
							});
				}
			}
		}
		
		return result;
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args edgeStencil: ORYX.Core.StencilSet.Stencil edgeShape:
	 *            ORYX.Core.Edge |undefined sourceStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined sourceShape:
	 *            ORYX.Core.Node |undefined targetStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined targetShape:
	 *            ORYX.Core.Node |undefined
	 * 
	 * At least source or target has to be specified!!!
	 * 
	 * @return {Boolean} Returns, if the edge can connect source and target.
	 */
	_canConnect: function(args) {
		// check arguments
		if(!args ||
		   (!args.sourceShape && !args.sourceStencil &&
		    !args.targetShape && !args.targetStencil) ||
		    !args.edgeShape && !args.edgeStencil) {
		   	return false; 
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		if(args.edgeShape) {
			args.edgeStencil = args.edgeShape.getStencil();
		}

		// 1. check connection rules
		var resultCR;
		
		// get all connection rules for this edge
		var edgeRules = this._getConnectionRulesOfEdgeStencil(args.edgeStencil);

		// check connection rules, if the source can be connected to the target
		// with the specified edge.
		if(edgeRules.keys().length === 0) {
			resultCR = false;
		} else {
			if(args.sourceStencil) {
				resultCR = args.sourceStencil.roles().any(function(sourceRole) {
					var targetRoles = edgeRules[sourceRole];

					if(!targetRoles) {return false;}
		
					if(args.targetStencil) {
						return (targetRoles.any(function(targetRole) {
							return args.targetStencil.roles().member(targetRole);
						}));
					} else {
						return true;
					}
				});
			} else { // !args.sourceStencil -> there is args.targetStencil
				resultCR = edgeRules.values().any(function(targetRoles) {
					return args.targetStencil.roles().any(function(targetRole) {
						return targetRoles.member(targetRole);
					});
				});
			}
		}
		
		return resultCR;
	},

	/** End connection rules' methods */


	/** Begin containment rules' methods */

	/**
	 * Returns TRUE if this shape is a container
	 * and can contain other shapes.
	 * 
	 * @param {ORYX.Core.Shape} shape
	 */
	isContainer: function(shape) {
		return this._containerStencils.member(shape.getStencil().id());
	},

	/**
	 * Returns TRUE if this shape should not be contained in or
	 * contain other shapes. It should always be a child of the canvas.
	 * 
	 * @param {ORYX.Core.Shape} shape
	 */
	isContainable: function(shape){
		if (this._containmentRulesExcludes.length === 0){
			return true;
		}
		if (shape instanceof ORYX.Core.Shape){
			shape = shape.getStencil();
		}
		if (!(shape instanceof ORYX.Core.StencilSet.Stencil)){
			return true;
		}
		
		var roles = shape.roles();
		return !this._containmentRulesExcludes.any(function(exc){
					return roles.include(exc);
				})
	},

	/**
	 * 
	 * @param {Object}
	 *            args containingStencil: ORYX.Core.StencilSet.Stencil
	 *            containingShape: ORYX.Core.AbstractShape containedStencil:
	 *            ORYX.Core.StencilSet.Stencil containedShape: ORYX.Core.Shape
	 */
	canContain: function(args) {
		if(!args ||
		   !args.containingStencil && !args.containingShape ||
		   !args.containedStencil && !args.containedShape) {
		   	return false;
		}
		
		// init arguments
		if(args.containedShape) {
			args.containedStencil = args.containedShape.getStencil();
		}
		
		if(args.containingShape) {
			args.containingStencil = args.containingShape.getStencil();
		}
		
		//if(args.containingStencil.type() == 'edge' || args.containedStencil.type() == 'edge')
		//	return false;
		if(args.containedStencil.type() == 'edge') 
			return false;
		
		var childValues;
		
		var parent = this._cachedContainPC[args.containingStencil.id()];
		
		if(!parent)
			childValues = this._cacheContain(args);
		else {
			childValues = parent[args.containedStencil.id()];
			
			if(!childValues)
				childValues = this._cacheContain(args);
		}

		if(!childValues[0])
			return false;
		else if (childValues[1] == -1)
			return true;
		else {
			if(args.containingShape) {
				var max = childValues[1];
				return args.containingShape.getChildShapes(false).all(function(cs) {
					if(cs.getStencil().id() === args.containedStencil.id()) {
						max--;
						return (max > 0) ? true : false;
					} else {
						return true;
					}
				});
			} else {
				return true;
			}
		}
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args containingStencil: ORYX.Core.StencilSet.Stencil
	 *            containingShape: ORYX.Core.AbstractShape containedStencil:
	 *            ORYX.Core.StencilSet.Stencil containedShape: ORYX.Core.Shape
	 */
	_canContain: function(args) {
		if(!args ||
		   !args.containingStencil && !args.containingShape ||
		   !args.containedStencil && !args.containedShape) {
		   	return false;
		}
		
		// init arguments
		if(args.containedShape) {
			args.containedStencil = args.containedShape.getStencil();
		}
		
		if(args.containingShape) {
			args.containingStencil = args.containingShape.getStencil();
		}
		
//		if(args.containingShape) {
//			if(args.containingShape instanceof ORYX.Core.Edge) {
//				// edges cannot contain other shapes
//				return false;
//			}
//		}

		
		var result;
		
		// check containment rules
		result = args.containingStencil.roles().any((function(role) {
			var roles = this._containmentRules[role];
			if(roles) {
				return roles.any(function(role) {
					return args.containedStencil.roles().member(role);
				});
			} else {
				return false;
			}
		}).bind(this));
		
		return result;
	},
	
	/** End containment rules' methods */
	
	
	/** Begin morphing rules' methods */
	
	/**
	 * 
	 * @param {Object}
	 *           args 
	 *            stencil: ORYX.Core.StencilSet.Stencil | undefined 
	 *            shape: ORYX.Core.Shape | undefined
	 * 
	 * At least stencil or shape has to be specified
	 * 
	 * @return {Array} Array of stencils that the passed stencil/shape can be
	 *         transformed to (including the current stencil itself)
	 */
	morphStencils: function(args) {
		// check arguments
		if(!args.stencil && !args.shape) {
			return [];
		}
		
		// init arguments
		if(args.shape) {
			args.stencil = args.shape.getStencil();
		}
		
		var _morphStencils = [];
		args.stencil.roles().each(function(role) {
			this._cacheMorph(role).each(function(stencil) {
				_morphStencils.push(stencil);
			})
		}.bind(this));


		var baseMorphs = this.baseMorphs();
		// BaseMorphs should be in the front of the array
		_morphStencils = _morphStencils.uniq().sortBy(function(a){ return baseMorphs.indexOf(a) >= 0 ? baseMorphs.indexOf(a) : 1000; });
		return _morphStencils;
	},
	
	/**
	 * @return {Array} An array of all base morph stencils
	 */
	baseMorphs: function() {
		var _baseMorphs = [];
		this._morphingRules.each(function(pair) {
			pair.value.each(function(baseMorph) {
				_baseMorphs.push(baseMorph);
			});
		});
		return _baseMorphs;
	},
	
	/**
	 * Returns true if there are morphing rules defines
	 * @return {boolean} 
	 */
	containsMorphingRules: function(){
		return this._stencilSets.any(function(ss){ return !!ss.jsonRules().morphingRules});
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args 
	 *            sourceStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined 
	 *            sourceShape:
	 *            ORYX.Core.Node |undefined 
	 *            targetStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined 
	 *            targetShape:
	 *            ORYX.Core.Node |undefined
	 * 
	 * 
	 * @return {Stencil} Returns, the stencil for the connecting edge 
	 * or null if connection is not possible
	 */
	connectMorph: function(args) {	
		// check arguments
		if(!args ||
		   (!args.sourceShape && !args.sourceStencil &&
		    !args.targetShape && !args.targetStencil)) {
		   	return false; 
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		
		var incoming = this.incomingEdgeStencils(args);
		var outgoing = this.outgoingEdgeStencils(args);
		
		var edgeStencils = incoming.select(function(e) { return outgoing.member(e); }); // intersection of sets
		var baseEdgeStencils = this.baseMorphs().select(function(e) { return edgeStencils.member(e); }); // again: intersection of sets
		
		if(baseEdgeStencils.size()>0)
			return baseEdgeStencils[0]; // return any of the possible base morphs
		else if(edgeStencils.size()>0)
			return edgeStencils[0];	// return any of the possible stencils
		
		return null; //connection not possible
	},
	
	/**
	 * Return true if the stencil should be located in the shape menu
	 * @param {ORYX.Core.StencilSet.Stencil} morph
	 * @return {Boolean} Returns true if the morphs in the morph group of the
	 * specified morph shall be displayed in the shape menu
	 */
	showInShapeMenu: function(stencil) {
		return 	this._stencilSets.any(function(ss){
				    return ss.jsonRules().morphingRules
							.any(function(r){
								return 	stencil.roles().include(ss.namespace() + r.role) 
										&& r.showInShapeMenu !== false;
							})
				});
	},
	
	preserveBounds: function(stencil) {
		return this._stencilSets.any(function(ss) {
			return ss.jsonRules().morphingRules.any(function(r) {
				
				
				return stencil.roles().include(ss.namespace() + r.role) 
					&& r.preserveBounds;
			})
		})
	},
	
	/** End morphing rules' methods */


	/** Begin layouting rules' methods */
	
	/**
	 * Returns a set on "in" and "out" layouting rules for a given shape
	 * @param {Object} shape
	 * @param {Object} edgeShape (Optional)
	 * @param {String} orientation (Optional) the orientation of the canvas
	 * @return {Object} "in" and "out" with a default value of {"t":1, "r":1, "b":1, "r":1} if not specified in the json
	 */
	getLayoutingRules : function(shape, edgeShape, orientation){
		
		if (!shape||!(shape instanceof ORYX.Core.Shape)){ return }
		
		var layout = {"in":{},"out":{}};
		
		var parseValues = function(o, v, orientation){
			if (o && o[v]){
				["t","r","b","l"].each(function(d){
					layout[v][d]=Math.max(o[v][d],layout[v][d]||0);
				});
			}
			if (o && o[v+"s"] instanceof Array){
				["t","r","b","l"].each(function(d){
					
					// take default rule for specific orientation first
					var defaultRule = undefined;
					if(orientation) {
						defaultRule = o[v+"s"].find(function(e){ return !e.edgeRole && orientation === e.orientation; });
					}
					
					if(!defaultRule) {
						defaultRule = o[v+"s"].find(function(e){ return !e.edgeRole && !e.orientation; });
					}
					
					// prefer edge rule for specific orientation
					var edgeRule = undefined;
					if(orientation && edgeShape instanceof ORYX.Core.Edge) {
						edgeRule = o[v + "s"].find(function(e){return this._hasRole(edgeShape, e.edgeRole) && orientation === e.orientation; }.bind(this));
					}
					
					// nothing found check for orientation unspecific rule
					if(!edgeRule) {
						edgeRule = o[v + "s"].find(function(e){return this._hasRole(edgeShape, e.edgeRole) && !e.orientation; }.bind(this));
					}
					
					layout[v][d]=Math.max(edgeRule?edgeRule[d]:defaultRule[d],layout[v][d]||0);
				}.bind(this));
			}
		}.bind(this)
		
		// For each role
		shape.getStencil().roles().each(function(role) {
			// check if there are layout information
			if (this._layoutRules[role]){
				// if so, parse those information to the 'layout' variable
				parseValues(this._layoutRules[role], "in", orientation);
				parseValues(this._layoutRules[role], "out", orientation);
			}
		}.bind(this));
		
		// Make sure, that every attribute has an value,
		// otherwise set 1
		["in","out"].each(function(v){
			["t","r","b","l"].each(function(d){
					layout[v][d]=layout[v][d]!==undefined?layout[v][d]:1;
				});
		})
		
		return layout;
	},
	
	/** End layouting rules' methods */
	
	/** Helper methods */

	/**
	 * Checks wether a shape contains the given role or the role is equal the stencil id 
	 * @param {ORYX.Core.Shape} shape
	 * @param {String} role
	 */
	_hasRole: function(shape, role){
		if (!(shape instanceof ORYX.Core.Shape)||!role){ return }
		var isRole = shape.getStencil().roles().any(function(r){ return r == role});
		
		return isRole || shape.getStencil().id() == (shape.getStencil().namespace()+role);
	},

	/**
	 * 
	 * @param {String}
	 *            role
	 * 
	 * @return {Array} Returns an array of stencils that can act as role.
	 */
	_stencilsWithRole: function(role) {
		return this._stencils.findAll(function(stencil) {
			return (stencil.roles().member(role)) ? true : false;
		});
	},
	
	/**
	 * 
	 * @param {String}
	 *            role
	 * 
	 * @return {Array} Returns an array of stencils that can act as role and
	 *         have the type 'edge'.
	 */
	_edgesWithRole: function(role) {
		return this._stencils.findAll(function(stencil) {
			return (stencil.roles().member(role) && stencil.type() === "edge") ? true : false;
		});
	},
	
	/**
	 * 
	 * @param {String}
	 *            role
	 * 
	 * @return {Array} Returns an array of stencils that can act as role and
	 *         have the type 'node'.
	 */
	_nodesWithRole: function(role) {
		return this._stencils.findAll(function(stencil) {
			return (stencil.roles().member(role) && stencil.type() === "node") ? true : false;
		});
	},

	/**
	 * 
	 * @param {ORYX.Core.StencilSet.Stencil}
	 *            parent
	 * @param {ORYX.Core.StencilSet.Stencil}
	 *            child
	 * 
	 * @returns {Boolean} Returns the maximum occurrence of shapes of the
	 *          stencil's type inside the parent.
	 */
	_getMaximumOccurrence: function(parent, child) {
		var max;
		child.roles().each((function(role) {
			var cardRule = this._cardinalityRules[role];
			if(cardRule && cardRule.maximumOccurrence) {
				if(max) {
					max = Math.min(max, cardRule.maximumOccurrence);
				} else {
					max = cardRule.maximumOccurrence;
				}
			}
		}).bind(this));

		return max;
	},


	/**
	 * 
	 * @param {Object}
	 *            args sourceStencil: ORYX.Core.Node edgeStencil:
	 *            ORYX.Core.StencilSet.Stencil
	 * 
	 * @return {Boolean} Returns, the maximum number of outgoing edges of the
	 *         type specified by edgeStencil of the sourceShape.
	 */
	_getMaximumNumberOfOutgoingEdge: function(args) {
		if(!args ||
		   !args.sourceStencil ||
		   !args.edgeStencil) {
		   	return false;
		}
		
		var max;
		args.sourceStencil.roles().each((function(role) {
			var cardRule = this._cardinalityRules[role];

			if(cardRule && cardRule.outgoingEdges) {
				args.edgeStencil.roles().each(function(edgeRole) {
					var oe = cardRule.outgoingEdges[edgeRole];

					if(oe && oe.maximum) {
						if(max) {
							max = Math.min(max, oe.maximum);
						} else {
							max = oe.maximum;
						}
					}
				});
			}
		}).bind(this));

		return max;
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args targetStencil: ORYX.Core.StencilSet.Stencil edgeStencil:
	 *            ORYX.Core.StencilSet.Stencil
	 * 
	 * @return {Boolean} Returns the maximum number of incoming edges of the
	 *         type specified by edgeStencil of the targetShape.
	 */
	_getMaximumNumberOfIncomingEdge: function(args) {
		if(!args ||
		   !args.targetStencil ||
		   !args.edgeStencil) {
		   	return false;
		}
		
		var max;
		args.targetStencil.roles().each((function(role) {
			var cardRule = this._cardinalityRules[role];
			if(cardRule && cardRule.incomingEdges) {
				args.edgeStencil.roles().each(function(edgeRole) {
					var ie = cardRule.incomingEdges[edgeRole];
					if(ie && ie.maximum) {
						if(max) {
							max = Math.min(max, ie.maximum);
						} else {
							max = ie.maximum;
						}
					}
				});
			}
		}).bind(this));

		return max;
	},
	
	/**
	 * 
	 * @param {ORYX.Core.StencilSet.Stencil}
	 *            edgeStencil
	 * 
	 * @return {Hash} Returns a hash map of all connection rules for
	 *         edgeStencil.
	 */
	_getConnectionRulesOfEdgeStencil: function(edgeStencil) {
		var edgeRules = new Hash();
		edgeStencil.roles().each((function(role) {
			if(this._connectionRules[role]) {
				this._connectionRules[role].each(function(cr) {
					if(edgeRules[cr.key]) {
						edgeRules[cr.key] = edgeRules[cr.key].concat(cr.value);
					} else {
						edgeRules[cr.key] = cr.value;
					}
				});
			}
		}).bind(this));
		
		return edgeRules;
	},
	
	_isRoleOfOtherNamespace: function(role) {
		return (role.indexOf("#") > 0);
	},

	toString: function() { return "Rules"; }
}
ORYX.Core.StencilSet.Rules = Clazz.extend(ORYX.Core.StencilSet.Rules);

/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
/**
 * Init namespace
 */
if (!ORYX) {
    var ORYX = {};
}
if (!ORYX.Core) {
    ORYX.Core = {};
}
if (!ORYX.Core.StencilSet) {
    ORYX.Core.StencilSet = {};
}

/**
 * This class represents a stencil set. It offers methods for accessing
 *  the attributes of the stencil set description JSON file and the stencil set's
 *  stencils.
 */
ORYX.Core.StencilSet.StencilSet = Clazz.extend({

    /**
     * Constructor
     * @param source {URL} A reference to the stencil set specification.
     *
     */
    construct: function(source){
        arguments.callee.$.construct.apply(this, arguments);
        
        if (!source) {
            throw "ORYX.Core.StencilSet.StencilSet(construct): Parameter 'source' is not defined.";
        }
        
        if (source.endsWith("/")) {
            source = source.substr(0, source.length - 1);
        }
		
		this._extensions = new Hash();
        
        this._source = source;
        this._baseUrl = source.substring(0, source.lastIndexOf("/") + 1);
        
        this._jsonObject = {};
        
        this._stencils = new Hash();
		this._availableStencils = new Hash();
        
		if(ORYX.CONFIG.BACKEND_SWITCH) {
			//get the url of the stencil set json file
			new Ajax.Request(source, {
	            asynchronous: false,
	            method: 'get',
	            onSuccess: this._getJSONURL.bind(this),
	            onFailure: this._cancelInit.bind(this)
	        });
		} else {
			new Ajax.Request(source, {
	            asynchronous: false,
	            method: 'get',
	            onSuccess: this._init.bind(this),
	            onFailure: this._cancelInit.bind(this)
	        });
		}
        
        if (this.errornous) 
            throw "Loading stencil set " + source + " failed.";
    },
    
    /**
     * Finds a root stencil in this stencil set. There may be many of these. If
     * there are, the first one found will be used. In Firefox, this is the
     * topmost definition in the stencil set description file.
     */
    findRootStencilName: function(){
    
        // find any stencil that may be root.
        var rootStencil = this._stencils.values().find(function(stencil){
            return stencil._jsonStencil.mayBeRoot
        });
        
		// if there is none, just guess the first.
		if (!rootStencil) {
			ORYX.Log.warn("Did not find any stencil that may be root. Taking a guess.");
			rootStencil = this._stencils.values()[0];
		}

        // return its id.
        return rootStencil.id();
    },
    
    /**
     * @param {ORYX.Core.StencilSet.StencilSet} stencilSet
     * @return {Boolean} True, if stencil set has the same namespace.
     */
    equals: function(stencilSet){
        return (this.namespace() === stencilSet.namespace());
    },
    
	/**
	 * 
	 * @param {Oryx.Core.StencilSet.Stencil} rootStencil If rootStencil is defined, it only returns stencils
	 * 			that could be (in)direct child of that stencil.
	 */
    stencils: function(rootStencil, rules, sortByGroup){
		if(rootStencil && rules) {
			var stencils = this._availableStencils.values();
			var containers = [rootStencil];
			var checkedContainers = [];
			
			var result = [];
			
			while (containers.size() > 0) {
				var container = containers.pop();
				checkedContainers.push(container);
				var children = stencils.findAll(function(stencil){
					var args = {
						containingStencil: container,
						containedStencil: stencil
					};
					return rules.canContain(args);
				});
				for(var i = 0; i < children.size(); i++) {
					if (!checkedContainers.member(children[i])) {
						containers.push(children[i]);
					}
				}
				result = result.concat(children).uniq();
			}
			
			// Sort the result to the origin order
			result = result.sortBy(function(stencil) {
				return stencils.indexOf(stencil);
			});
			
			
			if(sortByGroup) {
				result = result.sortBy(function(stencil) {
					return stencil.groups().first();
				});
			}
			
			var edges = stencils.findAll(function(stencil) {
				return stencil.type() == "edge";
			});
			result = result.concat(edges);
			
			return result;
			
		} else {
        	if(sortByGroup) {
				return this._availableStencils.values().sortBy(function(stencil) {
					return stencil.groups().first();
				});
			} else {
				return this._availableStencils.values();
			}
		}
    },
    
    nodes: function(){
        return this._availableStencils.values().findAll(function(stencil){
            return (stencil.type() === 'node')
        });
    },
    
    edges: function(){
        return this._availableStencils.values().findAll(function(stencil){
            return (stencil.type() === 'edge')
        });
    },
    
    stencil: function(id){
        return this._stencils[id];
    },
    
    title: function(){
        return ORYX.Core.StencilSet.getTranslation(this._jsonObject, "title");
    },
    
    description: function(){
        return ORYX.Core.StencilSet.getTranslation(this._jsonObject, "description");
    },
    
    namespace: function(){
        return this._jsonObject ? this._jsonObject.namespace : null;
    },
    
    jsonRules: function(){
        return this._jsonObject ? this._jsonObject.rules : null;
    },
    
    source: function(){
        return this._source;
    },
	
	extensions: function() {
		return this._extensions;
	},
	
	addExtension: function(url) {
		
		new Ajax.Request(url, {
            method: 'GET',
            asynchronous: false,
			onSuccess: (function(transport) {
				this.addExtensionDirectly(transport.responseText);
			}).bind(this),
			onFailure: (function(transport) {
				ORYX.Log.debug("Loading stencil set extension file failed. The request returned an error." + transport);
			}).bind(this),
			onException: (function(transport) {
				ORYX.Log.debug("Loading stencil set extension file failed. The request returned an error." + transport);
			}).bind(this)
		
		});
	},
	
	/**
	 * Check if a stencil has already been marked by an earlier loaded extension
	 * as removed. This stencil should not be available.
	 * 
	 * @param stencilId
	 * @param extToSkip
	 * 		Array of extension namespace not to consider
	 */
	_isStencilAlreadyRemoved: function(stencilId, extToSkip) {
		return this._extensions.values().any(function(e) {
			
			// namespace check
			if(e["extends"] !== this.namespace()) {
				return false;
			}
			
			// extensions to skip
			if(extToSkip instanceof Array) {
				var skip = extToSkip.any(function(extNs) {
					return e.namespace === extNs;
				});
				
				if(skip) {
					return false;
				}
			}
			
			//remove stencils
			if(e.removestencils) {
				return $A(e.removestencils).any(function(remstencil) {
					return remstencil === stencilId;
				});
			}
			
		}.bind(this));
	},
	
	addExtensionDirectly: function(str){

		try {
			eval("var jsonExtension = " + str);

			if (jsonExtension["extends"] instanceof Array && jsonExtension["extends"].include(this.namespace())){
				jsonExtension["extends"] = this.namespace();
			}

			if(!(jsonExtension["extends"].endsWith("#")))
					jsonExtension["extends"] += "#";
					
			if(jsonExtension["extends"] == this.namespace()) {
				this._extensions[jsonExtension.namespace] = jsonExtension;
				
				var defaultPosition = this._stencils.keys().size();
				//load new stencils
				if(jsonExtension.stencils) {
					$A(jsonExtension.stencils).each(function(stencil) {
						defaultPosition++;
						var oStencil = new ORYX.Core.StencilSet.Stencil(stencil, this.namespace(), this._baseUrl, this, undefined, defaultPosition);            
						this._stencils[oStencil.id()] = oStencil;
						
						// Check if already removed by other extension
						if(!this._isStencilAlreadyRemoved(oStencil.idWithoutNs())) {
							this._availableStencils[oStencil.id()] = oStencil;
						}
						
					}.bind(this));
				}
				
				//load additional properties
				if (jsonExtension.properties) {
					var stencils = this._stencils.values();
					
					stencils.each(function(stencil){
						var roles = stencil.roles();
						
						jsonExtension.properties.each(function(prop){
							prop.roles.any(function(role){
								role = jsonExtension["extends"] + role;
								if (roles.member(role)) {
									prop.properties.each(function(property){
										stencil.addProperty(property, jsonExtension.namespace);
									});
									
									return true;
								}
								else 
									return false;
							})
						})
					}.bind(this));
				}
				
				//remove stencil properties
				if(jsonExtension.removeproperties) {
					jsonExtension.removeproperties.each(function(remprop) {
						var stencil = this.stencil(jsonExtension["extends"] + remprop.stencil);
						if(stencil) {
							remprop.properties.each(function(propId) {
								stencil.removeProperty(propId);
							});
						}
					}.bind(this));
				}
				
				//remove stencils
				if(jsonExtension.removestencils) {
					$A(jsonExtension.removestencils).each(function(remstencil) {
						delete this._availableStencils[jsonExtension["extends"] + remstencil];
					}.bind(this));
				}
			}
		} catch (e) {
			ORYX.Log.debug("StencilSet.addExtension: Something went wrong when initialising the stencil set extension. " + e);
		}	
	},
	
	removeExtension: function(namespace) {
		var jsonExtension = this._extensions[namespace];
		if(jsonExtension) {
			
			//unload extension's stencils
			if(jsonExtension.stencils) {
				$A(jsonExtension.stencils).each(function(stencil) {
					var oStencil = new ORYX.Core.StencilSet.Stencil(stencil, this.namespace(), this._baseUrl, this);            
					delete this._stencils[oStencil.id()]; // maybe not ??
					delete this._availableStencils[oStencil.id()];
				}.bind(this));
			}
			
			//unload extension's properties
			if (jsonExtension.properties) {
				var stencils = this._stencils.values();
				
				stencils.each(function(stencil){
					var roles = stencil.roles();
					
					jsonExtension.properties.each(function(prop){
						prop.roles.any(function(role){
							role = jsonExtension["extends"] + role;
							if (roles.member(role)) {
								prop.properties.each(function(property){
									stencil.removeProperty(property.id);
									if (stencil.overwrittenProperty(property.prefix+"-"+property.id)){
										stencil.addProperty(stencil.overwrittenProperty(property.prefix+"-"+property.id));
									}
								});
								
								return true;
							}
							else 
								return false;
						})
					})
				}.bind(this));
			}
			
			//restore removed stencil properties
			if(jsonExtension.removeproperties) {
				jsonExtension.removeproperties.each(function(remprop) {
					var stencil = this.stencil(jsonExtension["extends"] + remprop.stencil);
					if(stencil) {
						var stencilJson = $A(this._jsonObject.stencils).find(function(s) { return s.id == stencil.id() });
						remprop.properties.each(function(propId) {
							var propertyJson = $A(stencilJson.properties).find(function(p) { return p.id == propId });
							stencil.addProperty(propertyJson, this.namespace());
						}.bind(this));
					}
				}.bind(this));
			}
			
			//restore removed stencils
			if(jsonExtension.removestencils) {
				$A(jsonExtension.removestencils).each(function(remstencil) {
					var sId = jsonExtension["extends"] + remstencil;
					
					if("undefined" != typeof this._stencils[sId] && this._stencils[sId] && !this._isStencilAlreadyRemoved(this._stencils[sId].idWithoutNs(), [jsonExtension.namespace])) {
						this._availableStencils[sId] = this._stencils[sId];
					}
				}.bind(this));
			}
		}
		delete this._extensions[namespace];
	},
    
    __handleStencilset: function(response){
    
        try {
            // using eval instead of prototype's parsing,
            // since there are functions in this JSON.
            eval("this._jsonObject =" + response.responseText);

        } 
        catch (e) {
            throw "Stenciset corrupt: " + e;
        }
        
        // assert it was parsed.
        if (!this._jsonObject) {
            throw "Error evaluating stencilset. It may be corrupt.";
        }
        
        with (this._jsonObject) {
        
            // assert there is a namespace.
            if (!namespace || namespace === "") 
                throw "Namespace definition missing in stencilset.";
            
            if (!(stencils instanceof Array)) 
                throw "Stencilset corrupt.";
            
            // assert namespace ends with '#'.
            if (!namespace.endsWith("#")) 
                namespace = namespace + "#";
            
            // assert title and description are strings.
            if (!title) 
                title = "";
            if (!description) 
                description = "";
        }
    },
	
	_getJSONURL: function(response) {
		this._baseUrl = response.responseText.substring(0, response.responseText.lastIndexOf("/") + 1);
		this._source = response.responseText;
		new Ajax.Request(response.responseText, {
            asynchronous: false,
            method: 'get',
            onSuccess: this._init.bind(this),
            onFailure: this._cancelInit.bind(this)
        });
	},
    
    /**
     * This method is called when the HTTP request to get the requested stencil
     * set succeeds. The response is supposed to be a JSON representation
     * according to the stencil set specification.
     * @param {Object} response The JSON representation according to the
     * 			stencil set specification.
     */
    _init: function(response){
    
        // init and check consistency.
        this.__handleStencilset(response);
		
		var pps = new Hash();
		
		// init property packages
		if(this._jsonObject.propertyPackages) {
			$A(this._jsonObject.propertyPackages).each((function(pp) {
				pps[pp.name] = pp.properties;
			}).bind(this));
		}
		
		var defaultPosition = 0;
		
        // init each stencil
        $A(this._jsonObject.stencils).each((function(stencil){
        	defaultPosition++;
        	
            // instantiate normally.
            var oStencil = new ORYX.Core.StencilSet.Stencil(stencil, this.namespace(), this._baseUrl, this, pps, defaultPosition);      
			this._stencils[oStencil.id()] = oStencil;
			this._availableStencils[oStencil.id()] = oStencil;
            
        }).bind(this));
    },
    
    _cancelInit: function(response){
        this.errornous = true;
    },
    
    toString: function(){
        return "StencilSet " + this.title() + " (" + this.namespace() + ")";
    }
});
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespace
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class StencilSets
 * uses Prototpye 1.5.0
 * uses Inheritance
 *
 * Singleton
 */
//storage for loaded stencil sets by namespace
ORYX.Core.StencilSet._stencilSetsByNamespace = new Hash();

//storage for stencil sets by url
ORYX.Core.StencilSet._stencilSetsByUrl = new Hash();	

//storage for stencil set namespaces by editor instances
ORYX.Core.StencilSet._StencilSetNSByEditorInstance = new Hash();

//storage for rules by editor instances
ORYX.Core.StencilSet._rulesByEditorInstance = new Hash();

/**
 * 
 * @param {String} editorId
 * 
 * @return {Hash} Returns a hash map with all stencil sets that are loaded by
 * 					the editor with the editorId.
 */
ORYX.Core.StencilSet.stencilSets = function(editorId) {
	var stencilSetNSs = ORYX.Core.StencilSet._StencilSetNSByEditorInstance[editorId];
	var stencilSets = new Hash();
	if(stencilSetNSs) {
		stencilSetNSs.each(function(stencilSetNS) {
			var stencilSet = ORYX.Core.StencilSet.stencilSet(stencilSetNS)
			stencilSets[stencilSet.namespace()] = stencilSet;
		});
	}
	return stencilSets;
};

/**
 * 
 * @param {String} namespace
 * 
 * @return {ORYX.Core.StencilSet.StencilSet} Returns the stencil set with the specified
 * 										namespace.
 * 
 * The method can handle namespace strings like
 *  http://www.example.org/stencilset
 *  http://www.example.org/stencilset#
 *  http://www.example.org/stencilset#ANode
 */
ORYX.Core.StencilSet.stencilSet = function(namespace) {
	ORYX.Log.trace("Getting stencil set %0", namespace);
	var splitted = namespace.split("#", 1);
	if(splitted.length === 1) {
		ORYX.Log.trace("Getting stencil set %0", splitted[0]);
		return ORYX.Core.StencilSet._stencilSetsByNamespace[splitted[0] + "#"];
	} else {
		return undefined;
	}
};

/**
 * 
 * @param {String} id
 * 
 * @return {ORYX.Core.StencilSet.Stencil} Returns the stencil specified by the id.
 * 
 * The id must be unique and contains the namespace of the stencil's stencil set.
 * e.g. http://www.example.org/stencilset#ANode
 */
ORYX.Core.StencilSet.stencil = function(id) {
	ORYX.Log.trace("Getting stencil for %0", id);
	var ss = ORYX.Core.StencilSet.stencilSet(id);
	if(ss) {
		return ss.stencil(id);
	} else {

		ORYX.Log.trace("Cannot fild stencil for %0", id);
		return undefined;
	}
};

/**
 * 
 * @param {String} editorId
 * 
 * @return {ORYX.Core.StencilSet.Rules} Returns the rules object for the editor
 * 									specified by its editor id.
 */
ORYX.Core.StencilSet.rules = function(editorId) {
	if(!ORYX.Core.StencilSet._rulesByEditorInstance[editorId]) {
		ORYX.Core.StencilSet._rulesByEditorInstance[editorId] = new ORYX.Core.StencilSet.Rules();;
	}
	return ORYX.Core.StencilSet._rulesByEditorInstance[editorId];
};

/**
 * 
 * @param {String} url
 * @param {String} editorId
 * 
 * Loads a stencil set from url, if it is not already loaded.
 * It also stores which editor instance loads the stencil set and 
 * initializes the Rules object for the editor instance.
 */
ORYX.Core.StencilSet.loadStencilSet = function(url, editorId) {
	var stencilSet = ORYX.Core.StencilSet._stencilSetsByUrl[url];

	if(!stencilSet) {
		//load stencil set
		stencilSet = new ORYX.Core.StencilSet.StencilSet(url);
		
		//store stencil set
		ORYX.Core.StencilSet._stencilSetsByNamespace[stencilSet.namespace()] = stencilSet;
		
		//store stencil set by url
		ORYX.Core.StencilSet._stencilSetsByUrl[url] = stencilSet;
	}
	
	var namespace = stencilSet.namespace();
	
	//store which editorInstance loads the stencil set
	if(ORYX.Core.StencilSet._StencilSetNSByEditorInstance[editorId]) {
		ORYX.Core.StencilSet._StencilSetNSByEditorInstance[editorId].push(namespace);
	} else {
		ORYX.Core.StencilSet._StencilSetNSByEditorInstance[editorId] = [namespace];
	}

	//store the rules for the editor instance
	if(ORYX.Core.StencilSet._rulesByEditorInstance[editorId]) {
		ORYX.Core.StencilSet._rulesByEditorInstance[editorId].initializeRules(stencilSet);
	} else {
		var rules = new ORYX.Core.StencilSet.Rules();
		rules.initializeRules(stencilSet);
		ORYX.Core.StencilSet._rulesByEditorInstance[editorId] = rules;
	}
};

/**
 * Returns the translation of an attribute in jsonObject specified by its name
 * according to navigator.language
 */
ORYX.Core.StencilSet.getTranslation = function(jsonObject, name) {
	var lang = ORYX.I18N.Language.toLowerCase();
	
	var result = jsonObject[name + "_" + lang];
	
	if(result)
		return result;
		
	result = jsonObject[name + "_" + lang.substr(0, 2)];
	
	if(result)
		return result;
		
	return jsonObject[name];
};
/**
 * Copyright (c) 2006
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}


/**
 * @classDescription With Bounds you can set and get position and size of UIObjects.
 */
ORYX.Core.Command = Clazz.extend({

	/**
	 * Constructor
	 */
	construct: function() {

	},
	
	execute: function(){
		throw "Command.execute() has to be implemented!"
	},
	
	rollback: function(){
		throw "Command.rollback() has to be implemented!"
	}
	
	
 });/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 * @namespace ORYX.Core
 */
if("undefined" == typeof ORYX) {
	var ORYX = {};
}
if("undefined" == typeof ORYX.Core) {
	ORYX.Core = {};
}
new function(){
	/**
	 * @class ORYX.Core.Bounds
	 * @extends Clazz
	 * @classDescription With Bounds you can set and get position and size of UIObjects.
	 */
	ORYX.Core.Bounds = Clazz.extend({
	
		/**
		 * @constructor
		 * @lends ORYX.Core.Bounds#
		 */
		construct: function() {
			this._changedCallbacks = []; //register a callback with changedCallacks.push(this.method.bind(this));
			this.a = {};
			this.b = {};
			this.set.apply(this, arguments);
			this.suspendChange = false;
			this.changedWhileSuspend = false;
		},
		
		/**
		 * Calls all registered callbacks.
		 * @param sizeChanged
		 */
		_changed: function(sizeChanged) {
			if(!this.suspendChange) {
				this._changedCallbacks.each(function(callback) {
					callback(this, sizeChanged);
				}.bind(this));
				this.changedWhileSuspend = false;
			} else
				this.changedWhileSuspend = true;
		},
		
		/**
		 * Registers a callback that is called, if the bounds changes.
		 * @param callback {Function} The callback function.
		 */
		registerCallback: function(callback) {
			if(!this._changedCallbacks.member(callback)) {
				this._changedCallbacks.push(callback);	
			}
		},
		
		/**
		 * Unregisters a callback.
		 * @param callback {Function} The callback function.
		 */
		unregisterCallback: function(callback) {
				this._changedCallbacks = this._changedCallbacks.without(callback);
		},
		
		/**
		 * Sets position and size of the shape dependent of four coordinates
		 * (set(ax, ay, bx, by);), two points (set({x: ax, y: ay}, {x: bx, y: by});)
		 * or one bound (set({a: {x: ax, y: ay}, b: {x: bx, y: by}});).
		 */
		set: function() {
			
			var changed = false;
			
			switch (arguments.length) {
			
				case 1:
					if(this.a.x !== arguments[0].a.x) {
						changed = true;
						this.a.x = arguments[0].a.x;
					}
					if(this.a.y !== arguments[0].a.y) {
						changed = true;
						this.a.y = arguments[0].a.y;
					}
					if(this.b.x !== arguments[0].b.x) {
						changed = true;
						this.b.x = arguments[0].b.x;
					}
					if(this.b.y !== arguments[0].b.y) {
						changed = true;
						this.b.y = arguments[0].b.y;
					}
					break;
				
				case 2:
					var ax = Math.min(arguments[0].x, arguments[1].x);
					var ay = Math.min(arguments[0].y, arguments[1].y);
					var bx = Math.max(arguments[0].x, arguments[1].x);
					var by = Math.max(arguments[0].y, arguments[1].y);
					if(this.a.x !== ax) {
						changed = true;
						this.a.x = ax;
					}
					if(this.a.y !== ay) {
						changed = true;
						this.a.y = ay;
					}
					if(this.b.x !== bx) {
						changed = true;
						this.b.x = bx;
					}
					if(this.b.y !== by) {
						changed = true;
						this.b.y = by;
					}
					break;
				
				case 4:
					var ax = Math.min(arguments[0], arguments[2]);
					var ay = Math.min(arguments[1], arguments[3]);
					var bx = Math.max(arguments[0], arguments[2]);
					var by = Math.max(arguments[1], arguments[3]);
					if(this.a.x !== ax) {
						changed = true;
						this.a.x = ax;
					}
					if(this.a.y !== ay) {
						changed = true;
						this.a.y = ay;
					}
					if(this.b.x !== bx) {
						changed = true;
						this.b.x = bx;
					}
					if(this.b.y !== by) {
						changed = true;
						this.b.y = by;
					}
					break;
			}
			
			if(changed) {
				this._changed(true);
			}
		},
		
		/**
		 * Moves the bounds so that the point p will be the new upper left corner.
		 * @param {Point} p
		 * or
		 * @param {Number} x
		 * @param {Number} y
		 */
		moveTo: function() {
			
			var currentPosition = this.upperLeft();
			switch (arguments.length) {
				case 1:
					this.moveBy({
						x: arguments[0].x - currentPosition.x,
						y: arguments[0].y - currentPosition.y
					});
					break;
				case 2:
					this.moveBy({
						x: arguments[0] - currentPosition.x,
						y: arguments[1] - currentPosition.y
					});
					break;
				default:
					//TODO error
			}
			
		},
		
		/**
		 * Moves the bounds relatively by p.
		 * @param {Point} p
		 * or
		 * @param {Number} x
		 * @param {Number} y
		 * 
		 */
		moveBy: function() {
			var changed = false;
			
			switch (arguments.length) {
				case 1:
					var p = arguments[0];
					if(p.x !== 0 || p.y !== 0) {
						changed = true;
						this.a.x += p.x;
						this.b.x += p.x;
						this.a.y += p.y;
						this.b.y += p.y;
					}
					break;	
				case 2:
					var x = arguments[0];
					var y = arguments[1];
					if(x !== 0 || y !== 0) {
						changed = true;
						this.a.x += x;
						this.b.x += x;
						this.a.y += y;
						this.b.y += y;
					}
					break;	
				default:
					//TODO error
			}
			
			if(changed) {
				this._changed();
			}
		},
		
		/***
		 * Includes the bounds b into the current bounds.
		 * @param {Bounds} b
		 */
		include: function(b) {
			
			if( (this.a.x === undefined) && (this.a.y === undefined) &&
				(this.b.x === undefined) && (this.b.y === undefined)) {
				return b;
			};
			
			var cx = Math.min(this.a.x,b.a.x);
			var cy = Math.min(this.a.y,b.a.y);
			
			var dx = Math.max(this.b.x,b.b.x);
			var dy = Math.max(this.b.y,b.b.y);
	
			
			this.set(cx, cy, dx, dy);
		},
		
		/**
		 * Relatively extends the bounds by p.
		 * @param {Point} p
		 */
		extend: function(p) {
			
			if(p.x !== 0 || p.y !== 0) {
				// this is over cross for the case that a and b have same coordinates.
				//((this.a.x > this.b.x) ? this.a : this.b).x += p.x;
				//((this.b.y > this.a.y) ? this.b : this.a).y += p.y;
				this.b.x += p.x;
				this.b.y += p.y;
				
				this._changed(true);
			}
		},
		
		/**
		 * Widens the scope of the bounds by x.
		 * @param {Number} x
		 */
		widen: function(x) {
			if (x !== 0) {
				this.suspendChange = true;
				this.moveBy({x: -x, y: -x});
				this.extend({x: 2*x, y: 2*x});
				this.suspendChange = false;
				if(this.changedWhileSuspend) {
					this._changed(true);
				}
			}
		},
		
		/**
		 * Returns the upper left corner's point regardless of the
		 * bound delimiter points.
		 */
		upperLeft: function() {
			
			return {x:this.a.x, y:this.a.y};
		},
		
		/**
		 * Returns the lower Right left corner's point regardless of the
		 * bound delimiter points.
		 */
		lowerRight: function() {
			
			return {x:this.b.x, y:this.b.y};
		},
		
		/**
		 * @return {Number} Width of bounds.
		 */
		width: function() {
			return this.b.x - this.a.x;
		},
		
		/**
		 * @return {Number} Height of bounds.
		 */
		height: function() {
			return this.b.y - this.a.y;
		},
		
		/**
		 * @return {Point} The center point of this bounds.
		 */
		center: function() {
			return {
				x: (this.a.x + this.b.x)/2.0, 
				y: (this.a.y + this.b.y)/2.0
			};
		},
	
		
		/**
		 * @return {Point} The center point of this bounds relative to upperLeft.
		 */
		midPoint: function() {
			return {
				x: (this.b.x - this.a.x)/2.0, 
				y: (this.b.y - this.a.y)/2.0
			};
		},
			
		/**
		 * Moves the center point of this bounds to the new position.
		 * @param p {Point} 
		 * or
		 * @param x {Number}
		 * @param y {Number}
		 */
		centerMoveTo: function() {
			var currentPosition = this.center();
			
			switch (arguments.length) {
				
				case 1:
					this.moveBy(arguments[0].x - currentPosition.x,
								arguments[0].y - currentPosition.y);
					break;
				
				case 2:
					this.moveBy(arguments[0] - currentPosition.x,
								arguments[1] - currentPosition.y);
					break;
			}
		},
		/**
		 * 
		 * @param point
		 * @param offset
		 * @returns {Boolean}
		 */
		isIncluded: function(point, offset) {
			
			var pointX, pointY, offset;
	
			// Get the the two Points	
			switch(arguments.length) {
				case 1:
					pointX = arguments[0].x;
					pointY = arguments[0].y;
					offset = 0;
					
					break;
				case 2:
					if(arguments[0].x && arguments[0].y) {
						pointX = arguments[0].x;
						pointY = arguments[0].y;
						offset = Math.abs(arguments[1]);
					} else {
						pointX = arguments[0];
						pointY = arguments[1];
						offset = 0;
					}
					break;
				case 3:
					pointX = arguments[0];
					pointY = arguments[1];
					offset = Math.abs(arguments[2]);
					break;
				default:
					throw "isIncluded needs one, two or three arguments";
			}
					
			var ul = this.upperLeft();
			var lr = this.lowerRight();
			
			if(pointX >= ul.x - offset 
				&& pointX <= lr.x + offset && pointY >= ul.y - offset 
				&& pointY <= lr.y + offset)
				return true;
			else 
				return false;
		},
		
		/**
		 * Returns the relative position of the point towards the bounds.
		 * @param {Point|ORYX.Core.Controls.Docker} point The position or a docker
		 * @returns {String} The side of the point
		 */
		getSide : function(point) {
			// Line 1
    		var p1 = this.upperLeft();
    		var p2 = this.lowerRight();
    		// Line 2
    		var p3 = {x : p1.x, y : p2.y};
    		var p4 = {x : p2.x, y : p1.y};
    		var leftOfA = ORYX.Core.Math.pointIsLeftOfLine(p3, p4, point);
    		var leftOfB = ORYX.Core.Math.pointIsLeftOfLine(p1, p2, point);
    		
    		if (leftOfA && leftOfB) {return ("bottom");}
    		if (leftOfA && !leftOfB) {return ("right");}
    		if (!leftOfA && leftOfB) {return ("left");}
    		if (!leftOfA && !leftOfB) {return ("top");}
		},
		
		
		/**
		 * @return {Bounds} A copy of this bounds.
		 */
		clone: function() {
			//Returns a new bounds object without the callback
			// references of the original bounds
			return new ORYX.Core.Bounds(this);
		},
		
		toString: function() {
			
			return "( "+this.a.x+" | "+this.a.y+" )/( "+this.b.x+" | "+this.b.y+" )";
		},
		
		serializeForERDF: function() {
	
			return this.a.x+","+this.a.y+","+this.b.x+","+this.b.y;
		}
	});
}();
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if("undefined" == typeof ORYX.Core) {ORYX.Core = {};}


/**
 * @classDescription Abstract base class for all objects that have a graphical representation
 * within the editor.
 * @extends Clazz
 */
ORYX.Core.UIObject = {
	/**
	 * Constructor of the UIObject class.
	 * @methodOf ORYX.Core.UIObject#
	 * @public
	 */
	construct: function(options) {	
		
		this.isChanged = true;			//Flag, if UIObject has been changed since last update.
		this.isResized = true;
		this.isVisible = true;			//Flag, if UIObject's display attribute is set to 'inherit' or 'none'
		this.isSelectable = false;		//Flag, if UIObject is selectable.
		this.isResizable = false;		//Flag, if UIObject is resizable.
		this.isMovable = false;			//Flag, if UIObject is movable.

		this.id = ORYX.Editor.provideId();	//get unique id
		this.parent = undefined;		//parent is defined, if this object is added to another uiObject.
		this.node = undefined;			//this is a reference to the SVG representation, either locally or in DOM.
		this.children = [];				//array for all add uiObjects
		
		this.bounds = new ORYX.Core.Bounds();		//bounds with undefined values

		this._changedCallback = this._changed.bind(this);	//callback reference for calling _changed
		this.bounds.registerCallback(this._changedCallback);	//set callback in bounds
		
		if(options && options.eventHandlerCallback) {
			this.eventHandlerCallback = options.eventHandlerCallback;
		}
	},
	
	/**
	 * Sets isChanged flag to true. Callback for the bounds object.
	 */
	_changed: function(bounds, isResized) {
		this.isChanged = true;
		if(this.bounds == bounds)
			this.isResized = isResized || this.isResized;
	},
	
	/**
	 * If something changed, this method calls the refresh method that must be implemented by subclasses.
	 */
	update: function() {
		if(this.isChanged) {
			this.refresh();
			this.isChanged = false;
			
			//call update of all children
			this.children.each(function(value) {
				value.update();
			});
		}
	},
	
	/**
	 * Is called in update method, if isChanged is set to true. Sub classes should call the super class method.
	 */
	refresh: function() {
		
	},
	
	/**
	 * @return {Array} Array of all child UIObjects.
	 */
	getChildren: function() {
		return this.children.clone();
	},
	
	/**
	 * @return {Array} Array of all parent UIObjects.
	 */
	getParents: function(){
		var parents = [];
		var parent = this.parent;
		while(parent){
			parents.push(parent);
			parent = parent.parent;
		}
		return parents;
	},
	
	/**
	 * Returns TRUE if the given parent is one of the UIObjects parents or the UIObject themselves, otherwise FALSE.
	 * @param {UIObject} parent
	 * @return {Boolean} 
	 */
	isParent: function(parent){
		var cparent = this;
		while(cparent){
			if (cparent === parent){
				return true;
			}
			cparent = cparent.parent;
		}
		return false;
	},
	
	/**
	 * @return {String} Id of this UIObject
	 */
	getId: function() {
		return this.id;
	},
	
	/**
	 * Method for accessing child uiObjects by id.
	 * @param {String} id
	 * @param {Boolean} deep
	 * 
	 * @return {UIObject} If found, it returns the UIObject with id.
	 */
	getChildById: function(id, deep) {
		return this.children.find(function(uiObj) {
			if(uiObj.getId() === id) {
				return uiObj;
			} else {
				if(deep) {
					var obj = uiObj.getChildById(id, deep);
					if(obj) {
						return obj;
					}
				}
			}
		});
	},
	
	/**
	 * Adds an UIObject to this UIObject and sets the parent of the
	 * added UIObject. It is also added to the SVG representation of this
	 * UIObject.
	 * @param {UIObject} uiObject
	 */
	add: function(uiObject) {
		//add uiObject, if it is not already a child of this object
		if (!(this.children.member(uiObject))) {
			//if uiObject is child of another parent, remove it from that parent.
			if(uiObject.parent) {
				uiObject.remove(uiObject);
			}
			
			//add uiObject to children
			this.children.push(uiObject);
			
			//set parent reference
			uiObject.parent = this;
			
			//add uiObject.node to this.node
			uiObject.node = this.node.appendChild(uiObject.node);
			
			//register callback to get informed, if child is changed
			uiObject.bounds.registerCallback(this._changedCallback);

			//uiObject.update();
		} else {
			ORYX.Log.info("add: ORYX.Core.UIObject is already a child of this object.");
		}
	},
	
	/**
	 * Removes UIObject from this UIObject. The SVG representation will also
	 * be removed from this UIObject's SVG representation.
	 * @param {UIObject} uiObject
	 */
	remove: function(uiObject) {
		//if uiObject is a child of this object, remove it.
		if (this.children.member(uiObject)) {
			//remove uiObject from children
			this.children = this._uiObjects.without(uiObject);
			
			//delete parent reference of uiObject
			uiObject.parent = undefined;
			
			//delete uiObject.node from this.node
			uiObject.node = this.node.removeChild(uiObject.node);
			
			//unregister callback to get informed, if child is changed
			uiObject.bounds.unregisterCallback(this._changedCallback);
		} else {
			ORYX.Log.info("remove: ORYX.Core.UIObject is not a child of this object.");
		}
		
	},
	
	/**
	 * Calculates absolute bounds of this UIObject.
	 */
	absoluteBounds: function() {
		if(this.parent) {
			var absUL = this.absoluteXY();
			return new ORYX.Core.Bounds(absUL.x, absUL.y,
							absUL.x + this.bounds.width(),
							absUL.y + this.bounds.height());
		} else {
			return this.bounds.clone();
		}
	},

	/**
	 * @return {Point} The absolute position of this UIObject.
	 */
	absoluteXY: function() {
		if(this.parent && this !== this.parent) {
			var pXY = this.parent.absoluteXY();		
			return {x: pXY.x + this.bounds.upperLeft().x , y: pXY.y + this.bounds.upperLeft().y};
			
		} else {
			return {x: this.bounds.upperLeft().x , y: this.bounds.upperLeft().y};
		}
	},

	/**
	 * @return {Point} The absolute position from the Center of this UIObject.
	 */
	absoluteCenterXY: function() {
		if(this.parent) {
			var pXY = this.parent.absoluteXY();		
			return {x: pXY.x + this.bounds.center().x , y: pXY.y + this.bounds.center().y};
			
		} else {
			return {x: this.bounds.center().x , y: this.bounds.center().y};
		}
	},
	
	/**
	 * Hides this UIObject and all its children.
	 */
	hide: function() {
		this.node.setAttributeNS(null, 'display', 'none');
		this.isVisible = false;
		this.children.each(function(uiObj) {
			uiObj.hide();	
		});
	},
	
	/**
	 * Enables visibility of this UIObject and all its children.
	 */
	show: function() {
		this.node.setAttributeNS(null, 'display', 'inherit');
		this.isVisible = true;
		this.children.each(function(uiObj) {
			uiObj.show();	
		});		
	},
	
	addEventHandlers: function(node) {
		
		node.addEventListener(ORYX.CONFIG.EVENT_MOUSEDOWN, this._delegateEvent.bind(this), false);
		node.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this._delegateEvent.bind(this), false);	
		node.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this._delegateEvent.bind(this), false);
		node.addEventListener(ORYX.CONFIG.EVENT_MOUSEOVER, this._delegateEvent.bind(this), false);
		node.addEventListener(ORYX.CONFIG.EVENT_MOUSEOUT, this._delegateEvent.bind(this), false);
		node.addEventListener('click', this._delegateEvent.bind(this), false);
		node.addEventListener(ORYX.CONFIG.EVENT_DBLCLICK, this._delegateEvent.bind(this), false);
			
	},
		
	_delegateEvent: function(event) {
		if(this.eventHandlerCallback) {
			this.eventHandlerCallback(event, this);
		}
	},
	
	toString: function() { return "UIObject " + this.id }
 };
 ORYX.Core.UIObject = Clazz.extend(ORYX.Core.UIObject);/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}

/**
 * Top Level uiobject.
 * @class ORYX.Core.AbstractShape
 * @extends ORYX.Core.UIObject
 */
ORYX.Core.AbstractShape = ORYX.Core.UIObject.extend(
/** @lends ORYX.Core.AbstractShape.prototype */
{

	/**
	 * Constructor
	 */
	construct: function(options, stencil) {
		
		arguments.callee.$.construct.apply(this, arguments);
		
		this.resourceId = ORYX.Editor.provideId(); //Id of resource in DOM
		
		// stencil reference
		this._stencil = stencil;
		// if the stencil defines a super stencil that should be used for its instances, set it.
		if (this._stencil._jsonStencil.superId){
			stencilId = this._stencil.id()
			superStencilId = stencilId.substring(0, stencilId.indexOf("#") + 1) + stencil._jsonStencil.superId;
			stencilSet =  this._stencil.stencilSet();
			this._stencil = stencilSet.stencil(superStencilId);
		}
		
		//Hash map for all properties. Only stores the values of the properties.
		this.properties = new Hash();
		this.propertiesChanged = new Hash();

		// Hash map for all formats
		this.formats = new Hash();
		
		// List of properties which are not included in the stencilset, 
		// but which gets (de)serialized
		this.hiddenProperties = new Hash();
		
		//Initialization of property map and initial value.
		this._stencil.properties().each((function(property) {
			var key = property.prefix() + "-" + property.id();
			this.properties[key] = property.value();
			this.propertiesChanged[key] = true;
		}).bind(this));
		
		// if super stencil was defined, also regard stencil's properties:
		if (stencil._jsonStencil.superId) {
			stencil.properties().each((function(property) {
				var key = property.prefix() + "-" + property.id();
				var value = property.value();
				var oldValue = this.properties[key];
				this.properties[key] = value;
				this.propertiesChanged[key] = true;

				// Raise an event, to show that the property has changed
				// required for plugins like processLink.js
				//window.setTimeout( function(){

					this._delegateEvent({
							type	: ORYX.CONFIG.EVENT_PROPERTY_CHANGED, 
							name	: key, 
							value	: value,
							oldValue: oldValue
						});

				//}.bind(this), 10)

			}).bind(this));
		}

	},

	/**
	 * Sets the resource id of the shape.
	 * A resource id is an id which represents the
	 * svg and the resource themselves. It should
	 * be used to identify a shape.
	 * @param id
	 */
	setResourceId: function(id){
		this.resourceId = id;
		this.node.id = "svg-" + id;		
	},
	
	layout: function() {

	},
	
	/**
	 * Returns the stencil object specifiing the type of the shape.
	 */
	getStencil: function() {
		return this._stencil;
	},
	
	/**
	 * 
	 * @param {Object} resourceId
	 */
	getChildShapeByResourceId: function(resourceId) {

		resourceId = ERDF.__stripHashes(resourceId);
		
		return this.getChildShapes(true).find(function(shape) {
					return shape.resourceId == resourceId
				});
	},
	/**
	 * 
	 * @param {Object} deep
	 * @param {Object} iterator
	 */
	getChildShapes: function(deep, iterator) {
		var result = [];

		this.children.each(function(uiObject) {
			if(uiObject instanceof ORYX.Core.Shape && uiObject.isVisible ) {
				if(iterator) {
					iterator(uiObject);
				}
				result.push(uiObject);
				if(deep) {
					result = result.concat(uiObject.getChildShapes(deep, iterator));
				} 
			}
		});

		return result;
	},
    
    /**
     * Returns TRUE if the shape is one of the direct/indirect children
     * @param {Object} shape
     * @return {boolean} true if any of shape's childs is given shape
     */
    hasChildShape: function(shape){
        return this.getChildShapes().any(function(child){
            return (child === shape) || child.hasChildShape(shape);
        });
    },
	
	/**
	 * Returns TRUE if the parent is a direct/indirect parent
	 * @param {Object} parent
	 */
	isParent: function(parent){
		if (parent instanceof ORYX.Core.Canvas){
			return true;
		}
		var myParent = this;
		while(myParent && parent){
			if (myParent === parent){
				return true;
			}
			myParent = myParent.parent;
		}
		return false;
	},
	
	/**
	 * 
	 * @param {Object} deep
	 * @param {Object} iterator
	 */
	getChildNodes: function(deep, iterator) {
		var result = [];

		this.children.each(function(uiObject) {
			if(uiObject instanceof ORYX.Core.Node && uiObject.isVisible) {
				if(iterator) {
					iterator(uiObject);
				}
				result.push(uiObject);
			}
			if(uiObject instanceof ORYX.Core.Shape) {
				if(deep) {
					result = result.concat(uiObject.getChildNodes(deep, iterator));
				}
			}
		});

		return result;
	},
	
	/**
	 * 
	 * @param {Object} deep
	 * @param {Object} iterator
	 */
	getChildEdges: function(deep, iterator) {
		var result = [];

		this.children.each(function(uiObject) {
			if(uiObject instanceof ORYX.Core.Edge && uiObject.isVisible) {
				if(iterator) {
					iterator(uiObject);
				}
				result.push(uiObject);
			}
			if(uiObject instanceof ORYX.Core.Shape) {
				if(deep) {
					result = result.concat(uiObject.getChildEdges(deep, iterator));
				}
			}
		});

		return result;
	},
	
	/**
	 * Returns a sorted array of ORYX.Core.Node objects.
	 * Ordered in z Order, the last object has the highest z Order.
	 */
	//TODO deep iterator
	getAbstractShapesAtPosition: function() {
		var x, y;
		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				break;
			case 2:	//two or more arguments
				x = arguments[0];
				y = arguments[1];
				break;
			default:
				throw "getAbstractShapesAtPosition needs 1 or 2 arguments!"
		}

		if(this.isPointIncluded(x, y)) {

			var result = [];
			result.push(this);

			//check, if one child is at that position						
			
			
			var childNodes = this.getChildNodes();
			var childEdges = this.getChildEdges();
			
			[childNodes, childEdges].each(function(ne){
				var nodesAtPosition = new Hash();
				
				ne.each(function(node) {
					if(!node.isVisible){ return }
					var candidates = node.getAbstractShapesAtPosition( x , y );
					if(candidates.length > 0) {
						var nodesInZOrder = $A(node.node.parentNode.childNodes);
						var zOrderIndex = nodesInZOrder.indexOf(node.node);
						nodesAtPosition[zOrderIndex] = candidates;
					}
				});
				
				nodesAtPosition.keys().sort().each(function(key) {
					result = result.concat(nodesAtPosition[key]);
				});
 			});
						
			return result;
			
		} else {
			return [];
		}
	},
	
	/**
	 * 
	 * @param key {String} Must be 'prefix-id' of property
	 * @param value {Object} Can be of type String or Number according to property type.
	 */
	setProperty: function(key, value, force) {
		key = (key || "").toLowerCase();
		
		if(!key.startsWith("oryx-")) {
			key = "oryx-" + key;
		}
		
		var oldValue = this.properties[key];
		if(oldValue !== value || force === true) {
			
			// Replace invalid characters (see https://github.com/douglascrockford/JSON-js/blob/master/json2.js for more information)
			if ("string" == typeof value){
				value = value.replace(/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, '');
			}
			
			this.properties[key] = value;
			this.propertiesChanged[key] = true;
			this._changed();
			
			// Raise an event, to show that the property has changed
			//window.setTimeout( function(){

			if (!this._isInSetProperty) {
				this._isInSetProperty = true;
				
				this._delegateEvent({
						type	: ORYX.CONFIG.EVENT_PROPERTY_CHANGED, 
						elements : [this],
						name	: key, 
						value	: value,
						oldValue: oldValue
					});
				
				delete this._isInSetProperty;
			}
			//}.bind(this), 10)
		}
	},
	
	getProperty: function(key) {
		key = (key || "").toLowerCase();
		
		if(!key.startsWith("oryx-")) {
			key = "oryx-" + key;
		}
		
		return this.properties[key];
	},
	
	hasProperty: function(key) {
        key = (key || "").toLowerCase();
    
        if(!key.startsWith("oryx-")) {
            key = "oryx-" + key;
        }
        
        return $H(this.properties).keys().include(key);
	},
	
	/**
	 * Stores the format definition of a property inside the shape.
	 * 
	 * NOTE: This method throws no event! It is supposed to be called
	 * before the setProperty method.
	 *  
	 * @param {String} key The property name
	 * @param {JSON} value The format definition to store
	 */
	setFormat : function(key, value) {
		var oldValue = this.formats[key];
		// TODO: check for entry changes
		if (value instanceof Array) {
			if (value.length > 0) {
				this.formats[key] = value;	
			} else {
				delete this.formats[key];
			}
			this.propertiesChanged[key] = true;
			this._changed();
		}
			/*			
			if (!this._isInSetProperty) {
				this._isInSetProperty = true;
				
				this._delegateEvent({
						type	: ORYX.CONFIG.EVENT_PROPERTY_CHANGED, 
						elements : [this],
						name	: key, 
						value	: value,
						oldValue: oldValue
					});
				
				delete this._isInSetProperty;
			}
			*/			
	},

	/**
	 * Returns the format to the given property id
	 * @param {String} key
	 * @returns {JSON} The formatting
	 */
	getFormat : function(key) {
		return this.formats[key];
	},
	
	/**
	 * Returns TRUE if one of the properties is flagged as dirty
	 * @return {boolean}
	 */
	isPropertyChanged: function(){
		return this.propertiesChanged.any(function(property){ return property.value });
	},

	/**
	 * 
	 * @param {String} Must be 'prefix-id' of property
	 * @param {Object} Can be of type String or Number according to property type.
	 */
	setHiddenProperty: function(key, value) {
		// IF undefined, Delete
		if (value === undefined) {
			delete this.hiddenProperties[key];
			return;
		}
		var oldValue = this.hiddenProperties[key];
		if (oldValue !== value) {
			this.hiddenProperties[key] = value;
		}
	},
	/**
	 * Calculate if the point is inside the Shape
	 * @param {Point}
	 */
	isPointIncluded: function(pointX, pointY, absoluteBounds) {
		var absBounds = absoluteBounds ? absoluteBounds : this.absoluteBounds();
		return absBounds.isIncluded(pointX, pointY);
				
	},
	
	/**
	 * Get the serialized object
	 * return Array with hash-entrees (prefix, name, value)
	 * Following values will given:
	 * 		Type
	 * 		Properties
	 */
	serialize: function() {
		var serializedObject = [];
		
		// Add the type
		serializedObject.push({name: 'type', prefix:'oryx', value: this.getStencil().id(), type: 'literal'});	
	
		// Add hidden properties
		this.hiddenProperties.each(function(prop){
			serializedObject.push({name: prop.key.replace("oryx-", ""), prefix: "oryx", value: prop.value, type: 'literal'});
		}.bind(this));
		
		// Add all properties
		this.getStencil().properties().each((function(property){
			
			var prefix = property.prefix();	// Get prefix
			var name = property.id();		// Get name
			
			//if(typeof this.properties[prefix+'-'+name] == 'boolean' || this.properties[prefix+'-'+name] != "")
				serializedObject.push({name: name, prefix: prefix, value: this.properties[prefix+'-'+name], type: 'literal'});

		}).bind(this));
		
		return serializedObject;
	},
		
		
	deserialize: function(serialize, json){
		// Search in Serialize
		var initializedDocker = 0;
		
		// Sort properties so that the hidden properties are first in the list
		//serialize = serialize.sort(function(a,b){ a = Number(this.properties.keys().member(a.prefix+"-"+a.name)); b = Number(this.properties.keys().member(b.prefix+"-"+b.name)); return a > b ? 1 : (a < b ? -1 : 0) }.bind(this));
		serialize = serialize.sortBy(function(a){ var i = this.properties.keys().indexOf(a.prefix+"-"+a.name); return i >= 0 ? i : 2000; }.bind(this));
		
		serialize.each((function(obj){
			
			var name 	= obj.name;
			var prefix 	= obj.prefix;
			var value 	= obj.value;
			
			// Get the format property
			var format	= json && json.formats && json.formats[name] || obj.format || [];
			
			if (typeof format === "string" && format.length > 0) {
				format = Ext.decode(format);
			}
            
            // Complex properties can be real json objects, encode them to a string
            if(Ext.type(value) === "object") value = Ext.encode(value);

			switch(prefix + "-" + name){
				case 'raziel-parent': 
							// Set parent
							if(!this.parent) {break;}
							
							// Set outgoing Shape
							var parent = this.getCanvas().getChildShapeByResourceId(value);
							if(parent) {
								parent.add(this);
							}
							
							break;											
				default:
							// If list, eval as an array
							var prop = this.getStencil().property(prefix+"-"+name);
							if (prop && prop.isList() && typeof value === "string"){
								if ((value||"").strip()&&!value.startsWith("[")&&!value.startsWith("]"))
									value = "[\""+value.strip()+"\"]";
								value = ((value||"").strip()||"[]").evalJSON();
							}
							
							
							// If a format is defined, set it 
							if (format instanceof Array && format.length > 0) {
								this.formats[prefix+"-"+name] = format;
							}
							
							// Set property
							if(this.properties.keys().member(prefix+"-"+name)) {
								this.setProperty(prefix+"-"+name, value);
							} else if(!(name === "bounds"||name === "parent"||name === "target"||name === "dockers"||name === "docker"||name === "outgoing"||name === "incoming")) {
								this.setHiddenProperty(prefix+"-"+name, value);
							}
			}
		}).bind(this));
	},
	
	toString: function() { return "ORYX.Core.AbstractShape " + this.id; },
    
    /**
     * Converts the shape to a JSON representation.
     * @return {Object} A JSON object with included ORYX.Core.AbstractShape.JSONHelper and getShape() method.
     */
    toJSON: function(){
        var json = {
            resourceId: this.resourceId,
            properties: Ext.apply({}, this.properties, this.hiddenProperties).inject({}, function(props, prop){
            	var key 		= prop.key,
              		value 		= prop.value,
              		property 	= this.getStencil().property(key);
                
				//If complex property, value should be a json object
				if ( property
						&& property.type() === ORYX.CONFIG.TYPE_COMPLEX 
						&& Ext.type(value) === "string"){
						
					try {value = Ext.decode(value);} catch(error){}
			  
				// Parse date
				} else if (value instanceof Date && property){
					try {
						value = value.format(property.dateFormat());
					} catch(e){}
				}
			  
				/**
				 * Don't store values with the 
				 * default values and foreign languages.
				 */
				if (!property
						|| !property.language() 
						|| property.language() === ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT
						|| property.value() !== value){
				  
					//Takes "my_property" instead of "oryx-my_property" as key
					key = key.replace(/^[\w_]+-/, "");
					props[key] = value;
				}
			 	return props;
            }.bind(this)),
            
            stencil: {
                id: this.getStencil().idWithoutNs()
            },
            childShapes: this.getChildShapes().map(function(shape){
                return shape.toJSON();
            })
        };

		var formats = Ext.apply({}, this.formats).inject({}, function(props, prop) {
            var key 	= prop.key,
            	value 	= prop.value || [];
            	
            if (value.length > 0) {
            	key = key.replace(/^[\w_]+-/, "");
				props[key] = value;
			}
			return props;
        });
            
        if ($H(formats).keys().length > 0) {
        	json.formats = formats;
        }
        
        if(this.getOutgoingShapes){
            json.outgoing = this.getOutgoingShapes().map(function(shape){
                return {
                    resourceId: shape.resourceId
                };
            });
        }
        
        if(this.bounds){
            json.bounds = { 
                lowerRight: this.bounds.lowerRight(), 
                upperLeft: this.bounds.upperLeft() 
            };
        }
        
        if(this.dockers){
            json.dockers = this.dockers.map(function(docker){
                var d = docker.getDockedShape() && docker.referencePoint ? docker.referencePoint : docker.bounds.center();
                d.getDocker = function(){return docker;};
                return d;
            })
        }
        
        Ext.apply(json, ORYX.Core.AbstractShape.JSONHelper);
        
        // do not pollute the json attributes (for serialization), so put the corresponding
        // shape is encapsulated in a method
        json.getShape = function(){
            return this;
        }.bind(this);
        
        return json;
    }
 });
 
/**
 * @namespace Collection of methods which can be used on a shape json object (ORYX.Core.AbstractShape#toJSON()).
 * @example
 * Ext.apply(shapeAsJson, ORYX.Core.AbstractShape.JSONHelper);
 */
ORYX.Core.AbstractShape.JSONHelper = {
     /**
      * Iterates over each child shape.
      * @param {Object} iterator Iterator function getting a child shape and his parent as arguments.
      * @param {boolean} [deep=false] Iterate recursively (childShapes of childShapes)
      * @param {boolean} [modify=false] If true, the result of the iterator function is taken as new shape, return false to delete it. This enables modifying the object while iterating through the child shapes.
      * @example
      * // Increases the lowerRight x value of each direct child shape by one. 
      * myShapeAsJson.eachChild(function(shape, parentShape){
      *     shape.bounds.lowerRight.x = shape.bounds.lowerRight.x + 1;
      *     return shape;
      * }, false, true);
      */
     eachChild: function(iterator, deep, modify){
         if(!this.childShapes) return;
         
         var newChildShapes = []; //needed if modify = true
         
         this.childShapes.each(function(shape){
		 	 if (!(shape.eachChild instanceof Function)){
				Ext.apply(shape, ORYX.Core.AbstractShape.JSONHelper);
			 }
             var res = iterator(shape, this);
             if(res) newChildShapes.push(res); //if false is returned, and modify = true, current shape is deleted.
             
             if(deep) shape.eachChild(iterator, deep, modify);
         }.bind(this));
         
         if(modify) this.childShapes = newChildShapes;
     },
     
	 getShape: function(){
	 	return null;
	 },
     getChildShapes: function(deep){
         var allShapes = this.childShapes;
         
         if(deep){
             this.eachChild(function(shape){
			 	 if (!(shape.getChildShapes instanceof Function)){
					Ext.apply(shape, ORYX.Core.AbstractShape.JSONHelper);
				 }
                 allShapes = allShapes.concat(shape.getChildShapes(deep));
             }, true);
         }
         
         return allShapes;
     },
     
     /**
      * @return {String} Serialized JSON object
      */
     serialize: function(){
         return Ext.encode(this);
     }
 }
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}

/**
   @namespace Namespace for the Oryx core elements.
   @name ORYX.Core
*/
if(!ORYX.Core) {ORYX.Core = {};}

/**
 * @class Oryx canvas.
 * @extends ORYX.Core.AbstractShape
 *
 */
ORYX.Core.Canvas = ORYX.Core.AbstractShape.extend({
    /** @lends ORYX.Core.Canvas.prototype */

	/**
	 * Defines the current zoom level
	 */
	zoomLevel:1,
	
	// @unstable
	useAnimation: false,

	/**
	 * Constructor
	 */
	construct: function(options) {
		arguments.callee.$.construct.apply(this, arguments);

		if(!(options && options.width && options.height)) {
		
			ORYX.Log.fatal("Canvas is missing mandatory parameters options.width and options.height.");
			return;
		}
			
		//TODO: set document resource id
		this.resourceId = options.id;

		this.nodes = [];
		
		this.edges = [];
		
		//init svg document
		this.rootNode = ORYX.Editor.graft("http://www.w3.org/2000/svg", options.parentNode,
			['svg', {id: this.id, width: options.width, height: options.height},
				['defs', {}]
			]);
			
		this.rootNode.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
		this.rootNode.setAttribute("xmlns:svg", "http://www.w3.org/2000/svg");

		this._htmlContainer = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", options.parentNode,
			['div', {id: "oryx_canvas_htmlContainer", style:"position:absolute; top:"+(Ext.isIPad?-1:5)+"px"}]);
		
		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.rootNode,
			['g', {},
				['g', {"class": "stencils"},
					['g', {"class": "me"}],
					['g', {"class": "children"}],
					['g', {"class": "edge"}]
				],
				['g', {"class":"svgcontainer"}]
			]);
		
		/*
		var off = 2 * ORYX.CONFIG.GRID_DISTANCE;
		var size = 3;
		var d = "";
		for(var i = 0; i <= options.width; i += off)
			for(var j = 0; j <= options.height; j += off)
				d = d + "M" + (i - size) + " " + j + " l" + (2*size) + " 0 m" + (-size) + " " + (-size) + " l0 " + (2*size) + " m0" + (-size) + " ";
							
		ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node.firstChild.firstChild,
			['path', {d:d , stroke:'#000000', 'stroke-width':'0.15px'},]);
		*/
		
		//Global definition of default font for shapes
		//Definitions in the SVG definition of a stencil will overwrite these settings for
		// that stencil.
		/*if(navigator.platform.indexOf("Mac") > -1) {
			this.node.setAttributeNS(null, 'stroke', 'black');
			this.node.setAttributeNS(null, 'stroke-width', '0.5px');
			this.node.setAttributeNS(null, 'font-family', 'Skia');
			//this.node.setAttributeNS(null, 'letter-spacing', '2px');
			this.node.setAttributeNS(null, 'font-size', ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT);
		} else {
			this.node.setAttributeNS(null, 'stroke', 'none');
			this.node.setAttributeNS(null, 'font-family', 'Verdana');
			this.node.setAttributeNS(null, 'font-size', ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT);
		}*/
		
		this.node.setAttributeNS(null, 'stroke', 'black');
		//dhz
		//this.node.setAttributeNS(null, 'font-family', 'Verdana, sans-serif');
		this.node.setAttributeNS(null, 'font-family', 'Verdana, 宋体, sans-serif');
		this.node.setAttributeNS(null, 'font-size-adjust', 'none');
		this.node.setAttributeNS(null, 'font-style', 'normal');
		this.node.setAttributeNS(null, 'font-variant', 'normal');
		this.node.setAttributeNS(null, 'font-weight', 'normal');
		this.node.setAttributeNS(null, 'line-heigth', 'normal');
		
		this.node.setAttributeNS(null, 'font-size', ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT);
			
		this.bounds.set(0,0,options.width, options.height);
		
		this.addEventHandlers(this.rootNode.parentNode);
		
		//disable context menu
		this.rootNode.oncontextmenu = function() {return false;};
	},
	
	getScrollNode: function(){
		return Ext.get(this.rootNode).parent("div{overflow=auto}", true);	
	},
	
	/**
	 * Returns the top-/left-position of the scrolling node 
	 * @returns
	 */
	getScrollPosition: function(){
		var scroll = this.getScrollNode().firstChild;
		if (Ext.isIPad && scroll.style.webkitTransform){
			try {
				var obj = (scroll.style.webkitTransform || "").replace(/(.*translate.+?)([-0-9\.]+)(.*?)([-0-9\.]+)(.*)/i, "{left:$2, top:$4}");
				obj = obj.startsWith("{") ? obj.evalJSON() : {};
				if (obj && "undefined" != typeof obj.left && "undefined" != typeof obj.top){
					obj.left *= -1; obj.top *= -1;
					return obj;
				}
			} catch(e){}
		}
		
		return {
			left: scroll.parentNode.scrollLeft,
			top: scroll.parentNode.scrollTop
		};
	},
	
	/**
	 * @param {Number|Object} a The left value or an object which contains left and top
	 * @param {Number} b The top value if the first arguments is not an object
	 */
	setScrollPosition: function(a, b){
		
		var left = arguments.length === 1 ? (a||{}).left : a,
			top = arguments.length === 1 ? (a||{}).top : b;
			
		if ("number" !== typeof left || "number" !== typeof top){
			return;
		}
		
		var scroll = this.getScrollNode();
		
		if (!Ext.isIPad){
			scroll.scrollLeft = left;
			scroll.scrollTop = top;
		} else {
			var fc = scroll.firstChild;
			
			if (this.useAnimation){
				fc.style.webkitTransitionProperty = '-webkit-transform';
				fc.style.webkitTransitionTimingFunction = 'cubic-bezier(0,0,0.25,1)';
				fc.style.webkitTransitionDuration = '300ms';
			}
			fc.style.webkitTransform = (fc.style.webkitTransform||"")				// Previous defined transformation, except translation
					.replace(/translate.*?\)/, "")
					.replace(/\s+/g, " ")
					.trim()
					+ " translate("			// Translate
					+ -(Math.min(fc.scrollWidth-fc.parentNode.offsetWidth, Math.max(left, 0)))
					+ "px, "
					+ -(Math.min(fc.scrollHeight-fc.parentNode.offsetHeight, Math.max(top, 0)))	
					+ "px)";
		}
	},
	
	
	getZoom: function(){
		return this.zoomLevel;
	},
	
	setZoom: function(zoom){
		if (!Ext.isIPad || !this.useAnimation || true){
			this.node.setAttributeNS(null, "transform", "scale(" +zoom+ ")");	
		} else {
			
			var doSet = function(fc, scale){
				fc.style.webkitTransitionProperty = '-webkit-transform';
				fc.style.webkitTransitionTimingFunction = 'cubic-bezier(0,0,0.25,1)';
				fc.style.webkitTransitionDuration = '300ms';
				fc.style.webkitTransform = "scale("+scale+")";
			};
			
			doSet(this.node.parentNode.parentNode, zoom);
			doSet(this.getHTMLContainer(), 1/zoom);
		}
		this.zoomLevel = zoom;
	},
	
//	/**
//	 * Prevent Flickering if more than one dom operation is used. StartUpdate
//	 * will remove the canvas from the dom. To end the update endUpdate should
//	 * be called.
//	 * 
//	 */
//	startUpdate: function(){
//		var node = this.rootNode.parentNode.parentNode;
//		if (!this.parentNode){
//			this.parentNode = node.parentNode;
//		}
//		this.parentNode.removeChild(node);
//	},
//	
//	endUpdate: function(){
//		if (!this.parentNode){
//			return;
//		}
//		this.parentNode.appendChild(this.rootNode.parentNode.parentNode);
//		this.updateScrollArea();
//		
//	},
	
	focus: function(){
		
		try {
			// Get a href
			if (!this.focusEl) {
				this.focusEl = Ext.getBody().createChild({
					tag: "a",
					href: "#",
					cls: "x-grid3-focus x-grid3-focus-canvas",
					tabIndex: "-1"
				});
				this.focusEl.swallowEvent("click", true);
			}
			
			// Focus it
			if (Ext.isGecko) {
				this.focusEl.focus();
			}
			else {
				this.focusEl.focus.defer(1, this.focusEl);
			}
			this.focusEl.blur.defer(3, this.focusEl);
			
		} catch(e){}
	},
	
	update: function() {
		
		this.nodes.each(function(node) {
			this._traverseForUpdate(node);
		}.bind(this));
		
		// call stencil's layout callback
		// (needed for row layouting of xforms)
		//this.getStencil().layout(this);
		
		var layoutEvents = this.getStencil().layout();
		
		if(layoutEvents) {
			layoutEvents.each(function(event) {
		
				// setup additional attributes
				event.shape = this;
				event.forceExecution = true;
				event.target = this.rootNode;
				
				// do layouting
				
				this._delegateEvent(event);
			}.bind(this));
		}
		
		this.nodes.invoke("_update");
		
		this.edges.invoke("_update", true);
		
		/*this.children.each(function(child) {
			child._update();
		});*/
	},
	
	_traverseForUpdate: function(shape) {
		var childRet = shape.isChanged;
		shape.getChildNodes(false, function(child) {
			if(this._traverseForUpdate(child)) {
				childRet = true;
			}
		}.bind(this));
		
		if(childRet) {
			shape.layout();
			return true;
		} else {
			return false;
		}
	},
	
	layout: function() {
		
		
		
	},
	
	/**
	 * 
	 * @param {Object} deep
	 * @param {Object} iterator
	 */
	getChildNodes: function(deep, iterator) {
		if(!deep && !iterator) {
			return this.nodes.clone();
		} else {
			var result = [];
			this.nodes.each(function(uiObject) {
				if(iterator) {
					iterator(uiObject);
				}
				result.push(uiObject);
				
				if(deep && uiObject instanceof ORYX.Core.Shape) {
					result = result.concat(uiObject.getChildNodes(deep, iterator));
				}
			});
	
			return result;
		}
	},
	
	/**
	 * buggy crap! use base class impl instead! 
	 * @param {Object} iterator
	 */
/*	getChildEdges: function(iterator) {
		if(iterator) {
			this.edges.each(function(edge) {
				iterator(edge);
			});
		}
		
		return this.edges.clone();
	},
*/	
	/**
	 * Overrides the UIObject.add method. Adds uiObject to the correct sub node.
	 * @param {UIObject} uiObject
	 */
	add: function(uiObject, oindex, silent) {
		//if uiObject is child of another UIObject, remove it.
		if(uiObject instanceof ORYX.Core.UIObject) {
			if (!(this.children.member(uiObject))) {
				//if uiObject is child of another parent, remove it from that parent.
				if(uiObject.parent) {
					uiObject.parent.remove(uiObject, true);
				}

				var rules = ORYX.Core.StencilSet.rules(this.resourceId);
				var getIndex = function(node, container){
					if (node instanceof ORYX.Core.Node && container instanceof Array){
						if (!rules.isContainable(node)){
							return container.length;
						} else {
							if (!rules.isContainable(container.last())){
								// Lookup the last child which is containable
								var copy = [].concat(container), current;
								while((current = copy.pop()) && !rules.isContainable(current)){}
								return Math.min.apply(Math, [oindex,current?copy.length+1:0].compact());
							}
						}
					}
					return oindex;
				};
				
				
				//add uiObject to the Canvas
				//add uiObject to this Shape
				var index = getIndex(uiObject, this.children);
				if(index != undefined)
					this.children.splice(index, 0, uiObject);
				else
					this.children.push(uiObject);

				//set parent reference
				uiObject.parent = this;

				//add uiObject.node to this.node depending on the type of uiObject
				if(uiObject instanceof ORYX.Core.Shape) {
					if(uiObject instanceof ORYX.Core.Edge) {
						uiObject.addMarkers(this.rootNode.getElementsByTagNameNS(NAMESPACE_SVG, "defs")[0]);
						//uiObject.node = this.node.childNodes[0].childNodes[2].appendChild(uiObject.node);
						this.edges.push(uiObject);
					} else {			
						var parent = this.node.childNodes[0].childNodes[1];
						var index  = getIndex(uiObject, this.nodes);
						if ("number" == typeof index) {
							//uiObject.node = parent.insertBefore(uiObject.node, parent.childNodes[index]);
							this.nodes.splice(index, 0, uiObject);
						} else {
							//uiObject.node = parent.appendChild(uiObject.node);
							this.nodes.push(uiObject);
						}
					}
				} else {	//UIObject
					uiObject.node = this.node.appendChild(uiObject.node);
				}

				uiObject.bounds.registerCallback(this._changedCallback);
					
				if(this.eventHandlerCallback && silent !== true)
					this.eventHandlerCallback({type:ORYX.CONFIG.EVENT_SHAPEADDED,shape:uiObject});
			} else {
				
				ORYX.Log.warn("add: ORYX.Core.UIObject is already a child of this object.");
			}
		} else {

			ORYX.Log.fatal("add: Parameter is not of type ORYX.Core.UIObject.");
		}
	},

	/**
	 * Overrides the UIObject.remove method. Removes uiObject.
	 * @param {UIObject} uiObject
	 */
	remove: function(uiObject, silent) {
		//if uiObject is a child of this object, remove it.
		if (this.children.member(uiObject)) {
			//remove uiObject from children
			var parent = uiObject.parent;
						
			this.children = this.children.without(uiObject);

			//delete parent reference of uiObject
			uiObject.parent = undefined;

			//delete uiObject.node from this.node
			if(uiObject instanceof ORYX.Core.Shape) {
				if(uiObject instanceof ORYX.Core.Edge) {
					uiObject.removeMarkers();
					if ($A(this.node.childNodes[0].childNodes[2].childNodes).include(uiObject.node))
						uiObject.node = this.node.childNodes[0].childNodes[2].removeChild(uiObject.node);
					this.edges = this.edges.without(uiObject);
				} else {
					if ($A(this.node.childNodes[0].childNodes[1].childNodes).include(uiObject.node))
						uiObject.node = this.node.childNodes[0].childNodes[1].removeChild(uiObject.node);
					this.nodes = this.nodes.without(uiObject);
				}
			} else {	//UIObject
				if ($A(this.node.childNodes).include(uiObject.node))
					uiObject.node = this.node.removeChild(uiObject.node);
			}

			if(this.eventHandlerCallback && silent !== true)
				this.eventHandlerCallback({type:ORYX.CONFIG.EVENT_SHAPEREMOVED,shape:uiObject, parent:parent});
				
			uiObject.bounds.unregisterCallback(this._changedCallback);
		} else {

			ORYX.Log.warn("remove: ORYX.Core.UIObject is not a child of this object.");
		}
	},
    
    /**
     * Creates shapes out of the given collection of shape objects and adds them to the canvas.
     * @example 
     * canvas.addShapeObjects({
         bounds:{ lowerRight:{ y:510, x:633 }, upperLeft:{ y:146, x:210 } },
         resourceId:"oryx_F0715955-50F2-403D-9851-C08CFE70F8BD",
         childShapes:[],
         properties:{},
         stencil:{
           id:"Subprocess"
         },
         outgoing:[{resourceId: 'aShape'}],
         target: {resourceId: 'aShape'}
       });
     * @param {Object} shapeObjects 
     * @param {Function} [eventHandler] An event handler passed to each newly created shape (as eventHandlerCallback)
     * @return {Array} A collection of ORYX.Core.Shape
     * @methodOf ORYX.Core.Canvas.prototype
     */
    addShapeObjects: function(shapeObjects, eventHandler){
        if(!shapeObjects) return;
		
		this.initializingShapes = true;
        
        /*FIXME This implementation is very evil! At first, all shapes are created on
          canvas. In a second step, the attributes are applied. There must be a distinction
          between the configuration phase (where the outgoings, for example, are just named),
          and the creation phase (where the outgoings are evaluated). This must be reflected
          in code to provide a nicer API/ implementation!!! */
        
        var addShape = function(shape, parent){
			// Create a new Stencil
			var stencil = ORYX.Core.StencilSet.stencil(this.getStencil().namespace() + shape.stencil.id);
			
			if (!stencil) {
				try {
					throw new Error(this.getStencil().namespace() + shape.stencil.id + " is undefined.");
				} catch (e) {
					if (window.console && console.log)
						console.log(e);
				}
				return;
			}
			
			// Create a new Shape
			var ShapeClass = (stencil.type() == "node") ? ORYX.Core.Node : ORYX.Core.Edge;
			var newShape = new ShapeClass({
				'eventHandlerCallback': eventHandler
			}, stencil);
			
			// Set the resource id
			newShape.setResourceId(shape.resourceId);
			
			// Set parent to json object to be used later
			// Due to the nested json structure, normally shape.parent is not set/ must not be set. 
			// In special cases, it can be easier to set this directly instead of a nested structure.
			shape.parent = "#" + ((shape.parent && shape.parent.resourceId) || parent.resourceId);
			
			// Add the shape to the canvas
			this.add(newShape);
			
			return {
				json: shape,
				object: newShape
			};
		}.bind(this);
        
        /** Builds up recursively a flatted array of shapes, including a javascript object and json representation
         * @param {Object} shape Any object that has Object#childShapes
         */
        var addChildShapesRecursively = function(shape){
			var addedShapes = [];
			
			shape.childShapes.each(function(childShape){
				addedShapes.push(addShape(childShape, shape));
				addedShapes = addedShapes.concat(addChildShapesRecursively(childShape));
			});
			
			return addedShapes;
		}.bind(this);

        var shapes = addChildShapesRecursively({
            childShapes: shapeObjects, 
            resourceId: this.resourceId
        }).compact();
                    

        // prepare deserialisation parameter
        shapes.each(function(shape){
			
			var properties = [];
			for (field in shape.json.properties) {
				properties.push({
					prefix: 'oryx',
					name: field,
					value: shape.json.properties[field]
				});
			}
			
			// Outgoings
			shape.json.outgoing.each(function(out){
				if (out) {
					properties.push({
						prefix: 'raziel',
						name: 'outgoing',
						value: "#" + out.resourceId
					});
				}
			});
			
			// Target 
			// (because of a bug, the first outgoing is taken when there is no target,
			// can be removed after some time)
			if (shape.object instanceof ORYX.Core.Edge) {
				var target = shape.json.target || shape.json.outgoing[0];
				if (target) {
					properties.push({
						prefix: 'raziel',
						name: 'target',
						value: "#" + target.resourceId
					});
				}
			}
			
			// Bounds
			if (shape.json.bounds && shape.json.bounds.upperLeft && shape.json.bounds.lowerRight &&
				[shape.json.bounds.upperLeft.x, 	shape.json.bounds.upperLeft.y, 
				 shape.json.bounds.lowerRight.x, 	shape.json.bounds.lowerRight.y].all(function(val){
					 return "number" == typeof val;
				 })) {
				properties.push({
					prefix: 'oryx',
					name: 'bounds',
					value: shape.json.bounds.upperLeft.x + "," + shape.json.bounds.upperLeft.y + "," + shape.json.bounds.lowerRight.x + "," + shape.json.bounds.lowerRight.y
				});
			}
			
			//Dockers [{x:40, y:50}, {x:30, y:60}] => "40 50 30 60  #"
			if (shape.json.dockers) {
				properties.push({
					prefix: 'oryx',
					name: 'dockers',
					value: shape.json.dockers.inject("", function(dockersStr, docker){
						return dockersStr + docker.x + " " + docker.y + " ";
					}) +
					" #"
				});
			}
			
			//Parent
			properties.push({
				prefix: 'raziel',
				name: 'parent',
				value: shape.json.parent
			});
			
			shape.__properties = properties;
		}.bind(this));
  
        // Deserialize the properties from the shapes
        // This can't be done earlier because Shape#deserialize expects that all referenced nodes are already there
        
        // first, deserialize all nodes
        shapes.each(function(shape) {
        	if(shape.object instanceof ORYX.Core.Node) {
        		shape.object.deserialize(shape.__properties, shape.json);
        	}
        });
        
        // second, deserialize all edges
        shapes.each(function(shape) {
        	if(shape.object instanceof ORYX.Core.Edge) {
        		shape.object.deserialize(shape.__properties, shape.json);
				shape.object._oldBounds = shape.object.bounds.clone();
				shape.object._update();
        	}
        });
       
		delete this.initializingShapes;
        return shapes.pluck("object");
    },
    
    /**
     * Updates the size of the canvas, regarding to the containg shapes.
     */
    updateSize: function(){
        // Check the size for the canvas
        var maxWidth    = 0;
        var maxHeight   = 0;
        var offset      = 100;
        this.getChildShapes(true, function(shape){
            var b = shape.bounds;
            maxWidth    = Math.max( maxWidth, b.lowerRight().x + offset);
            maxHeight   = Math.max( maxHeight, b.lowerRight().y + offset);
        }); 
        
        if( this.bounds.width() < maxWidth || this.bounds.height() < maxHeight ){
            this.setSize({width: Math.max(this.bounds.width(), maxWidth), height: Math.max(this.bounds.height(), maxHeight)});
        }
    },

	getRootNode: function() {
		return this.rootNode;
	},
	
	getSvgContainer: function() {
		return this.node.childNodes[1];
	},
	
	getChildContainer: function() {
		return this.node.childNodes[0].childNodes[1];
	},
	
	getEdgeContainer: function() {
		return this.node.childNodes[0].childNodes[2];
	},
	
	getHTMLContainer: function() {
		return this._htmlContainer;
	},	

	/**
	 * Return all elements of the same highest level
	 * @param {Object} elements
	 */
	getShapesWithSharedParent: function(elements) {

		// If there is no elements, return []
		if(!elements || elements.length < 1) { return []; }
		// If there is one element, return this element
		if(elements.length == 1) { return elements; }

		return elements.findAll(function(value){
			var parentShape = value.parent;
			while(parentShape){
				if(elements.member(parentShape)) return false;
				parentShape = parentShape.parent;
			}
			return true;
		});		

	},

	setSize: function(size, dontSetBounds) {
		if(!size || !size.width || !size.height){ return; }
		
		if(this.rootNode.parentNode){
			this.rootNode.parentNode.style.width = size.width + 'px';
			this.rootNode.parentNode.style.height = size.height + 'px';
		}
		
		this.rootNode.setAttributeNS(null, 'width', size.width);
		this.rootNode.setAttributeNS(null, 'height', size.height);

		this.updateScrollArea();
		
		//this._htmlContainer.style.top = "-" + (size.height + 4) + 'px';		
		if( !dontSetBounds ){
			this.bounds.set({a:{x:0,y:0},b:{x:size.width/this.getZoom(),y:size.height/this.getZoom()}});
		}
	},
	
	updateScrollArea: function(){
		if (Ext.isIPad && "undefined" !== window.iScroll && this.iscroll){
			this.iscroll.destroy();
			this.iscroll = new iScroll(this.rootNode.parentNode, {
				touchCount: 2
			});
		}
	},
	
	getShapeSize: function(){
		var x1, y1, x2, y2;
		
		var workaround = false;
			
		// Workaround for Chrome 18.*
		//  http://code.google.com/p/chromium/issues/detail?id=114590
		// Values of a returning getBBox are 
		// incorrect if the element has empty children
		if (Ext.isChrome){ try {
			var bbox = this.getRootNode().childNodes[1].childNodes[0].childNodes[1].getBBox();
			if (bbox.x === 0 || bbox.y === 0){
				var bounds;
				this.getChildShapes(true).each(function(shape) {
					var absBounds = shape.absoluteBounds();
					if (!bounds){
						bounds = absBounds.clone();
					} else {
						bounds.include(absBounds);
					}
					
					shape.getLabels().each(function(label){
						if (label.node.textContent){
							if(Ext.isChrome) {
								// Workaround for Chrome issue 117139
								//  http://code.google.com/p/chromium/issues/detail?id=117139
								if(label.node.getAttributeNS(null, "display") === "none") {
									return;
								}
							}
							
							var bb = ORYX.Core.Math.getTranslatedBoundingBox(label.node);
							bounds.include(new ORYX.Core.Bounds(bb.x, bb.y, bb.x+bb.width, bb.y+bb.height));
						}
					});
				});
				return bounds || new ORYX.Core.Bounds(0, 0, 0, 0);
			}
		} catch(e){} }  

		
		// Workaround for IE9:
		// IE9 calculates the bbox of the edges (path)
		// in an incorrect way (x/y are wrong). So the workaround
		// is that the bbox of all nodes are taken and for each
		// edge the bounds and the label size are used.		
		if (Ext.isIE9) workaround = true;
		
		
		// If workaround is needed...
		if (workaround){	
			// The bbox of the child shapes
			var bb = this.getRootNode().childNodes[1].childNodes[0].childNodes[1].getBBox();
			x1 = bb.x;
			y1 = bb.y;
			x2 = bb.x + bb.width;
			y2 = bb.y + bb.height;
			
			var set = function(cx1, cy1, cx2, cy2){
				if (!cx1 && !cy1 && !cx2 && !cy2){ return; }
				x1 = Math.min(x1, cx1); y1 = Math.min(y1, cy1);
				x2 = Math.max(x2, cx2); y2 = Math.max(y2, cy2);
			};
			this.getChildShapes(false).each(function(shape){
				if (shape instanceof ORYX.Core.Edge){
					// Set edge bounds
					set(shape.bounds.a.x, shape.bounds.a.y, shape.bounds.b.x, shape.bounds.b.y);
					// Set each label size
					shape.getLabels().each(function(label){
						var bbox = label.node.getBBox();
						set(bbox.x, bbox.y, bbox.x+bbox.width, bbox.y+bbox.height);
					});
				}
			});

		} else {
			// Get min/max size of child elements
			try {
				var pe = 9; // The padding of an edge
				
				// Get the bbox of nodes and edges
				var bbs = this.getRootNode().childNodes[1].childNodes[0].childNodes[1].getBBox();
				var bbe = this.getRootNode().childNodes[1].childNodes[0].childNodes[2].getBBox();
				
				// Check if there are empty
				if (!bbs.x&&!bbs.y&&!bbs.width&&!bbs.height){ bbs = bbe; }
				if (!bbe.x&&!bbe.y&&!bbe.width&&!bbe.height){ bbe = bbs; }
				
				// Get min/max value of nodes and edge
				x1 = Math.min(bbs.x, bbe.x+pe); y1 = Math.min(bbs.y, bbe.y+pe);
				x2 = Math.max(bbs.x+bbs.width, bbe.x+bbe.width-pe); y2 = Math.max(bbs.y+bbs.height, bbe.y+bbe.height-pe);
			} catch(e) {
				return this.getShapeBounds();
			}
		}
		return new ORYX.Core.Bounds(x1, y1, x2, y2);
	},
	 
	/**
	 * Returns the bounds of all the child shapes
	 * @returns {ORYX.Core.Bounds}
	 */
	getShapeBounds: function(){
		var bounds;
		this.getChildShapes().each(function(shape) {
			var absBounds = shape.absoluteBounds();
			if (!bounds){
				bounds = absBounds.clone();
			} else {
				bounds.include(absBounds);
			}
		});
		return bounds || new ORYX.Core.Bounds(0, 0, 0, 0);
	},
	
	/**
	 * Returns an SVG document of the current process.
	 * @param {Boolean} escapeText Use true, if you want to parse it with an XmlParser,
	 * 					false, if you want to use the SVG document in browser on client side.
	 */
	getSVGRepresentation: function(escapeText) {
		// Get the serialized svg image source
        var svgClone = this.getRootNode().cloneNode(true);
		
        // Remove all nodes which are irrelevant
		this._removeInvisibleElements(svgClone);
		
		// Get the size of all child shapes
		var size = this.getShapeSize(), margin = 50;
		
		var width = size.width(), 
			height = size.height(), 
			tx = -size.upperLeft().x + (this.children.length?(margin/2):0), 
			ty = -size.upperLeft().y + (this.children.length?(margin/2):0);
		
        // Set the width and height
        svgClone.setAttributeNS(null, 'width', width + margin);
        svgClone.setAttributeNS(null, 'height', height + margin);
		
		svgClone.childNodes[1].firstChild.setAttributeNS(null, 'transform', 'translate(' + tx + ", " + ty + ')');
		
		//remove scale factor
		svgClone.childNodes[1].setAttributeNS(null, 'transform', 'scale(1)');
		svgClone.childNodes[1].setAttributeNS(null, 'transform', '');
		svgClone.childNodes[1].removeAttributeNS(null, 'transform');
		
		try{
			var svgCont = svgClone.childNodes[1].childNodes[1];
			svgCont.parentNode.removeChild(svgCont);
		} catch(e) {}

		if(escapeText) {
			$A(svgClone.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan')).each(function(elem) {
				elem.textContent = elem.textContent.escapeHTML();
			});
			
			$A(svgClone.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'text')).each(function(elem) {
				if(elem.childNodes.length == 0)
					elem.textContent = elem.textContent.escapeHTML();
			});
		}
		
		// generating absolute urls for the pdf-exporter
		$A(svgClone.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'image')).each(function(elem) {
			var href = elem.getAttributeNS("http://www.w3.org/1999/xlink","href");
			
			if(!href.match("^(http|https)://")) {
				href = window.location.protocol + "//" + window.location.host + href;
				elem.setAttributeNS("http://www.w3.org/1999/xlink", "href", href);
			}
		});
		
		
		// escape all links
		$A(svgClone.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'a')).each(function(elem) {
			elem.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", (elem.getAttributeNS("http://www.w3.org/1999/xlink","href")||"").escapeHTML());
		});
		
        return svgClone;
	},
	
	/**   
	* Removes all nodes (and its children) that has the
	* attribute visibility == "hidden" and display == "none"
	* @param {Element} element
	*/
	_removeInvisibleElements: function(element) {
		var index = 0, nl = element.childNodes, size = nl.length;
		while(index < size) {
			var child = nl[index];
			if(child.getAttributeNS &&
				(child.getAttributeNS(null, "visibility") === "hidden" || 
				 child.getAttributeNS(null, "display") === "none" ||
				 (child.getAttribute("stroke") === "none" && child.getAttribute("fill") === "none"))) {
				element.removeChild(child);
				--size;
			} else {
				this._removeInvisibleElements(child);
				++index; 
			}
		}
	},
	
	/**
	 * This method checks all shapes on the canvas and removes all shapes that
	 * contain invalid bounds values or dockers values(NaN)
	 */
	/*cleanUp: function(parent) {
		if (!parent) {
			parent = this;
		}
		parent.getChildShapes().each(function(shape){
			var a = shape.bounds.a;
			var b = shape.bounds.b;
			if (isNaN(a.x) || isNaN(a.y) || isNaN(b.x) || isNaN(b.y)) {
				parent.remove(shape);
			}
			else {
				shape.getDockers().any(function(docker) {
					a = docker.bounds.a;
					b = docker.bounds.b;
					if (isNaN(a.x) || isNaN(a.y) || isNaN(b.x) || isNaN(b.y)) {
						parent.remove(shape);
						return true;
					}
					return false;
				});
				shape.getMagnets().any(function(magnet) {
					a = magnet.bounds.a;
					b = magnet.bounds.b;
					if (isNaN(a.x) || isNaN(a.y) || isNaN(b.x) || isNaN(b.y)) {
						parent.remove(shape);
						return true;
					}
					return false;
				});
				this.cleanUp(shape);
			}
		}.bind(this));
	},*/

	_delegateEvent: function(event) {
		if(this.eventHandlerCallback && ( !event.target || event.target == this.rootNode || event.target == this.rootNode.parentNode )) {
			this.eventHandlerCallback(event, this);
		}
	},
	
	/**
	 * Sets the language of the current diagram and updates
	 * the whole diagram and its children.
	 * @params {String} The language code (e.g. de, eng)
	 * 
	 */
	setLanguage: function(language){
		if (language == this.getLanguage()){
			return false;
		}
		
		// Set the property
		this.language = language;
		
		// Set all shapes as dirty
		this.getChildShapes(true).each(function(shape){
			// Iterate over all properties to find those who has a language and a refToView
			if (shape.getStencil().properties().findAll(function(property){
					if (property.language() === language && property.refToView().length > 0){
						shape.propertiesChanged[property.prefix()+"-"+property.id()] = true;
						return true;
					}
					return false;
				}).length > 0){
				// Set as dirty
				shape._changed();
			}
		});
		
		// Update all shapes
		this.update();
	},
	
	/**
	 * Returns the current language code 
	 */
	getLanguage: function(){
		return this.language || ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT;
	},
	
	/**
	 * Shortcut to retrieve the orientation of the canvas. The flag is serialized 
	 * as a property of the canvas's shape. Default value can be defined as a
	 * String property of the canvas stencil.
	 * 
	 * @param orientation
	 */
	setOrientation: function(orientation) {
		if(orientation !== "horizontal" && orientation !== "vertical") {return;}
		
		// Ensure backwards compatibility and remove old flag
		this.orientation = undefined;
		
		this.setProperty("oryx-orientation", orientation);
	},
	
	/**
	 * Returns the current modeling orientation of the canvas. Values are
	 * "horizontal", "vertical" or "".
	 * @returns
	 */
	getOrientation: function() {
		
		// this.orientation is only checked for backwards compatibility
		return this.orientation || this.properties["oryx-orientation"];
	},
	
	toString: function() { return "Canvas " + this.id; },
	
    /**
     * Calls {@link ORYX.Core.AbstractShape#toJSON} and adds some stencil set information.
     */
    toJSON: function() {
        var json = arguments.callee.$.toJSON.apply(this, arguments);
        
        // Set the language
        if (this.language && this.language !== ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT){
        	json.language = this.language;
        }
        
//		if(ORYX.CONFIG.STENCILSET_HANDLER.length > 0) {
//			json.stencilset = {
//				url: this.getStencil().stencilSet().namespace()
//	        };
//		} else {
			json.stencilset = {
				url: this.getStencil().stencilSet().source(),
				namespace: this.getStencil().stencilSet().namespace()
	        };	
//		}
        
        
        return json;
    }
 });/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

var idCounter = 0;
var ID_PREFIX = "resource";

/**
 * Main initialization method. To be called when loading
 * of the document, including all scripts, is completed.
 */
function init() {

	/* When the blank image url is not set programatically to a local
	 * representation, a spacer gif on the site of ext is loaded from the
	 * internet. This causes problems when internet or the ext site are not
	 * available. */
	Ext.BLANK_IMAGE_URL = (ORYX.CONFIG.BLANK_IMAGE) || (ORYX.CONFIG.LIBS_PATH + '/ext-2.0.2/resources/images/default/s.gif');	

	/* Set the browser user agent to the html tag
	 * so that css rules can be used easily for 
	 * specific browsers.
	 */
	var lang = ORYX.I18N.Language;
	document.documentElement.className += " " + lang.split("_").concat(lang).uniq().join(" ");
	var browser = Ext.isIE7 ? "x-ie x-ie7" : (Ext.isIE ? "x-ie" : (Ext.isGecko ? "x-gecko" : (ORYX.Utils.isIPad() ? "x-ipad" : "x-other")));
	var version = ORYX.Utils.getBrowserVersion();
	document.documentElement.className += " " + browser + " " +  browser + "-" + version.replace(/\./g, "-");
	
	
	ORYX.Log.debug("Querying editor instances");

	// Hack for WebKit to set the SVGElement-Classes
	ORYX.Editor.setMissingClasses();
    
    // If someone wants to create the editor instance himself
    if (window.onOryxResourcesLoaded) {
        window.onOryxResourcesLoaded();
    } 
    // Else if this is a newly created model
    else if(window.location.pathname.include(ORYX.CONFIG.ORYX_NEW_URL)){
		//dhz
        new ORYX.Editor({
            id: 'oryx-canvas123',
            fullscreen: true,
            stencilset: {
                url: "/v5designer/editor/" + ORYX.Utils.getParamFromUrl("stencilset")
            }
        });
    } 
    // Else fetch the model from server and display editor
    else {
        //HACK for distinguishing between different backends
		// Backend of 2008 uses /self URL ending
	    var modelUrl = window.location.href.replace(/#.*/g, "");
		if(modelUrl.endsWith("/self")) {
			modelUrl = modelUrl.replace("/self","/json");
		} else {
			modelUrl = modelUrl.replace(ORYX.CONFIG.SERVER_EDITOR_HANDLER.replace("..", ""),ORYX.CONFIG.SERVER_EDITOR_DATA_HANDLER.replace("..",""));
		}
		
		//shanglihui 20111118
		modelUrl = modelUrl + "&data";

        ORYX.Editor.createByUrl(modelUrl, {
            id: modelUrl
        });
    }
}

/**
   @namespace Global Oryx name space
   @name ORYX
*/
if(!ORYX) {var ORYX = {};}

/**
 * The Editor class.
 * @class ORYX.Editor
 * @extends Clazz
 * @param {Object} config An editor object, passed to {@link ORYX.Editor#loadSerialized}
 * @param {String} config.id Any ID that can be used inside the editor. If fullscreen=false, any HTML node with this id must be present to render the editor to this node.
 * @param {boolean} [config.fullscreen=true] Render editor in fullscreen mode or not.
 * @param {String} config.stencilset.url Stencil set URL.
 * @param {String} [config.stencil.id] Stencil type used for creating the canvas.  
 * @param {Object} config.properties Any properties applied to the canvas.
*/
ORYX.Editor = {
    /** @lends ORYX.Editor.prototype */
	// Defines the global dom event listener 
	DOMEventListeners: new Hash(),

	// Defines the selection
	selection: [],
	
	// Defines the current zoom level
	zoomLevel:1.0,

	construct: function(config) {
		
		// initialization.
		this._eventsQueue 	= [];
		this.loadedPlugins 	= [];
		this.pluginsData 	= [];
		
		
		//meta data about the model for the signavio warehouse
		//directory, new, name, description, revision, model (the model data)
		
		this.modelMetaData = config;
		
		var model = config;
		if(config.model) {
			model = config.model;
		}
		
		this.id = model.resourceId;
        if(!this.id) {
        	this.id = model.id;
        	if(!this.id) {
        		this.id = ORYX.Editor.provideId();
        	}
        }
		

        
        // Defines if the editor should be fullscreen or not
		this.fullscreen = config.fullscreen !== false;

		//shanglihui 20111121
		/*
		if (Signavio&&Signavio.Helper&&Signavio.Helper.ShowMask instanceof Function) {
			Signavio.Helper.ShowMask(true, !this.fullscreen ? this.id : Ext.getBody());
		}
		*/
		
		// Initialize the eventlistener
		this._initEventListener();

		// Load particular stencilset
		if(ORYX.CONFIG.BACKEND_SWITCH) {
			var ssUrl = (model.stencilset.namespace||model.stencilset.url).replace("#", "%23");
        	ORYX.Core.StencilSet.loadStencilSet(ORYX.CONFIG.STENCILSET_HANDLER + ssUrl, this.id);
		} else {
			var ssUrl = model.stencilset.url;
			//dhz 20111230
			ssUrl=ORYX.CONFIG.SERVER_HANDLER_ROOT+ssUrl;
        	ORYX.Core.StencilSet.loadStencilSet(ssUrl, this.id);
		}
		
        
        //TODO load ealier and asynchronous??
        this._loadStencilSetExtensionConfig();
        
        //Load predefined StencilSetExtensions
        if(!!ORYX.CONFIG.SSEXTS){
        	ORYX.CONFIG.SSEXTS.each(function(ssext){
                this.loadSSExtension(ssext.namespace);
            }.bind(this));
        }

		// CREATES the canvas
		this._createCanvas(model.stencil ? model.stencil.id : null, model);

		// GENERATES the whole EXT.VIEWPORT
		this._generateGUI();

		// Initializing of a callback to check loading ends
		var loadPluginFinished 	= false;
		var loadContentFinished = false;
		var initFinished = function(){	
			if( !loadPluginFinished || !loadContentFinished ){ return }
			this._finishedLoading();
		}.bind(this)
		
		// disable key events when Ext modal window is active
		ORYX.Editor.makeExtModalWindowKeysave(this._getPluginFacade());
		
		// LOAD the plugins
		window.setTimeout(function(){
			this.loadPlugins();
			loadPluginFinished = true;
			initFinished();
		}.bind(this), 100);

		// LOAD the content of the current editor instance
		window.setTimeout(function(){
            this.loadSerialized(model, true); // Request the meta data as well
            this.getCanvas().update();
            
            //shanglihui 20120106 
            //dhz 2012-02-20
            //var s1 = model.properties.name + '-' + model.properties.id;
            //window.document.title = s1;
            
			loadContentFinished = true;
			initFinished();
		}.bind(this), 200);
	},
	
	_finishedLoading: function() {
		if(Ext.getCmp('oryx-loading-panel')){
			Ext.getCmp('oryx-loading-panel').hide()
		}
		
		// Do Layout for viewport
		this.layout.doLayout();
		// Generate a drop target
		new Ext.dd.DropTarget(this.getCanvas().rootNode.parentNode);
		
		// Default is no stateful
		Ext.Component.prototype.stateful = false;
		
		// Fixed the problem that the viewport can not 
		// start with collapsed panels correctly
		if (ORYX.CONFIG.PANEL_RIGHT_COLLAPSED === true){
			this.layout_regions.east.collapse();
		}
		if (ORYX.CONFIG.PANEL_LEFT_COLLAPSED === true){
			this.layout_regions.west.collapse();
		}

		// If Prism (Signavio ThinClient), force to update the view again. 
		// Sometimes the right panel was on the wrong side.
		if (String(window.navigator.userAgent).include("Firefox/3.5 Prism") &&
			"function" == typeof this.layout.fireResize){
			window.setTimeout(function(el){
				this.layout.fireResize(el.getWidth(), el.getHeight());
			}.bind(this, Ext.getBody()), 100);
		}
		
		// Raise Loaded Event
		this.handleEvents( {type:ORYX.CONFIG.EVENT_LOADED} )
		
	},
	
	_initEventListener: function(){

		// Register on Events
		
		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_KEYDOWN, this.catchKeyDownEvents.bind(this), false);
		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_KEYUP, this.catchKeyUpEvents.bind(this), false);

		// Enable Key up and down Event
		this._keydownEnabled = 	true;
		this._keyupEnabled =  	true;

		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEDOWN] = [];
		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEUP] 	= [];
		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEOVER] = [];
		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEOUT] 	= [];
		this.DOMEventListeners[ORYX.CONFIG.EVENT_SELECTION_CHANGED] = [];
		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEMOVE] = [];
				
	},
	
	/**
	 * Generate the whole viewport of the
	 * Editor and initialized the Ext-Framework
	 * 
	 */
	_generateGUI: function() {

		//TODO make the height be read from eRDF data from the canvas.
		// default, a non-fullscreen editor shall define its height by layout.setHeight(int) 
		
		// Defines the layout hight if it's NOT fullscreen
		var layoutHeight 	= ORYX.CONFIG.WINDOW_HEIGHT;
	
		var canvasParent	= this.getCanvas().rootNode.parentNode;

		/**
		 * Extend the Region implementation so that, 
		 * the clicking area can be extend to the whole collapse area and
		 * an title can now be shown.
		 *
		 */
		var oldGetCollapsedEl = Ext.layout.BorderLayout.Region.prototype.getCollapsedEl;
		Ext.layout.BorderLayout.Region.prototype.getCollapsedEl = function(){
			oldGetCollapsedEl.apply(this, arguments);
			
			if(this.collapseMode !== 'mini' && this.floatable === false && this.expandTriggerAll === true){
               this.collapsedEl.addClassOnOver("x-layout-collapsed-over");
			   this.collapsedEl.on("mouseover", this.collapsedEl.addClass.bind(this.collapsedEl, "x-layout-collapsed-over"));
               this.collapsedEl.on("click", this.onExpandClick, this);
            }
			
			
			if (this.collapseTitle){
				/* // Use CSS3 Attribute
				this.collapsedEl.createChild({
                    cls: "x-collapse-text", html: this.collapseTitle
                });*/
				
				// Use SVG to rotate text
				var svg = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.collapsedEl.dom,
				['svg', {style:"position:relative;left:"+(this.position === "west" ? 4 : 6)+"px;top:"+(this.position === "west" ? 2 : 5)+"px;"},
					['text', {transform:"rotate(90)", x:0, y:0, "stroke-width":"0px", fill:"#EEEEEE", style:"font-weight:bold;", "font-size":"11"}, this.collapseTitle]
				]);
				var text = svg.childNodes[0];
				svg.setAttribute("xmlns:svg", "http://www.w3.org/2000/svg");
				
				// Rotate the west into the other side
				if (this.position === "west" && text.getComputedTextLength instanceof Function){
					// Wait till rendered
					window.setTimeout(function(){
						var length  = text.getComputedTextLength();
						text.setAttributeNS(null, "transform", "rotate(-90, " + ((length / 2) + 7) + ", " + ((length / 2) - 3) + ")");;
					}, 1)
				}
				delete this.collapseTitle;
			}
	        return this.collapsedEl;
		}

		// DEFINITION OF THE VIEWPORT AREAS
		this.layout_regions = {
				
				// DEFINES TOP-AREA
				north	: new Ext.Panel({ //TOOO make a composite of the oryx header and addable elements (for toolbar), second one should contain margins
					region	: 'north',
					cls		: 'x-panel-editor-north',
					autoEl	: 'div',
					border	: false
				}),	
				
				// DEFINES RIGHT-AREA
				east	: new Ext.Panel({
					region	: 'east',
					layout	: 'fit',
					cls		: 'x-panel-editor-east',
					/*layout: 'accordion',
					layoutConfig: {
		               // layout-specific configs go here
						titleCollapse: true,
						animate: true,
						activeOnTop: true
	                },*/
					autoEl	: 'div',
					collapseTitle : ORYX.I18N.View.East,
					titleCollapse : true,
					border	:false,
					cmargins: {left:0, right:0},
					floatable: false,
					expandTriggerAll:true,
					collapsible	: true,
					width	: ORYX.CONFIG.PANEL_RIGHT_WIDTH || 200,
					split	: true,
					title	: "East"
				}),
				
				
				// DEFINES BOTTOM-AREA
				south	: new Ext.Panel({
					region	: 'south',
					cls		: 'x-panel-editor-south',
					autoEl	: 'div',
					border	: false
				}),
				
				
				// DEFINES LEFT-AREA
				west	: new Ext.Panel({
					region	: 'west',
					layout	: 'anchor',
					autoEl	: 'div',
					cls		: 'x-panel-editor-west',
					collapsible	: true,
					titleCollapse : true,
					collapseTitle : ORYX.I18N.View.West,
					width	: ORYX.CONFIG.PANEL_LEFT_WIDTH || 200,
					autoScroll: Ext.isIPad ? false : true,
					cmargins: {left:0, right:0},
					floatable: false,
					expandTriggerAll:true,
					split	: true,
					title	: "West"
				}),
				
				
				// DEFINES CENTER-AREA (FOR THE EDITOR)
				center	: new Ext.Panel({
					region	: 'center',
					cls		: 'x-panel-editor-center',
					autoScroll: true,
					items	: {
						layout	: "fit",
						autoHeight: true,
						el		: canvasParent
					}
				})
		}
		
		// Hide every region except the center
		for (region in this.layout_regions) {
			if ( region != "center" ) {
				//this.layout_regions[ region ].hide();
			}
		}
		
		// Config for the Ext.Viewport 
		var layout_config = {
			layout: 'border',
			items: [
				this.layout_regions.north,
				this.layout_regions.east,
				this.layout_regions.south,
				this.layout_regions.west,
				this.layout_regions.center
			]
		}

		// IF Fullscreen, use a viewport
		if (this.fullscreen) {
			this.layout = new Ext.Viewport( layout_config );
		
		// IF NOT, use a panel and render it to the given id
		} else {
			layout_config.renderTo 	= this.id;
			layout_config.height 	= layoutHeight;
			this.layout = new Ext.Panel( layout_config );
		}
		
		if (Ext.isIPad && "undefined" != typeof iScroll){
			this.getCanvas().iscroll = new iScroll(this.layout_regions.center.body.dom.firstChild, {
				touchCount: 2
			});
		}
		
		//Generates the ORYX-Header
		this._generateHeader();
		
		
		// Set the editor to the center, and refresh the size
	 	canvasParent.parentNode.setAttributeNS(null, 'align', 'center');
	 	canvasParent.setAttributeNS(null, 'align', 'left');
		this.getCanvas().setSize({
			width	: ORYX.CONFIG.CANVAS_WIDTH,
			height	: ORYX.CONFIG.CANVAS_HEIGHT
		});		
						
	},
	
	_generateHeader: function(){
		
		var getURL = function(){
			var meta = this.getModelMetaData();
			if (meta["new"]){
				 return ORYX.CONFIG.WEB_URL + "#" + meta.parent;
			} else {
				 return ORYX.CONFIG.WEB_URL + "#/model/" + meta.modelId;
			}
		}.bind(this);
		
		// Command to set the document title
		var DocumentNameChangeCommand = ORYX.Core.Command.extend({
			construct: function(editor, value, oldValue, modelMetaData){
				this.editor = editor;
				this.value = value;
				this.oldValue = oldValue;
				this.modelMetaData = modelMetaData;
			},
			execute: function(){
				this.modelMetaData.name = this.value;
				this.editor.boundEl.dom.textContent = this.value;
			}, 
			rollback: function(){
				this.modelMetaData.name = this.oldValue;
				this.editor.boundEl.dom.textContent = this.oldValue;
			}
		});
		
		/*
		 * The editor to inline-edit the document title,
		 * sets the document title to the meta infos on complete
		 */
		var documentNameEditor = new Ext.Editor(new Ext.form.TextField({
			cls: "y-header-document-name-editor",
			allowBlank: false
		}), {
			cancelOnEsc: true,
			completeOnEnter: true,
			updateEl: true,
			autoSize: "width",
			shadow: "drop",
			listeners: {
				beforecomplete : function(editor, value, oldValue) {
					if (value !== oldValue) {
						// Use custom function to set the document title
						this._getPluginFacade().executeCommands([new DocumentNameChangeCommand(editor, value, oldValue, this.getModelMetaData())]);
					}
					
					// Hide the editor
					editor.editing = false;
					editor.hide();
					
					// Cancel normal completion of editing to prevent html injection
					return false;
				}.bind(this)
			}
		});
		
		var headerPanel = new Ext.Panel({
			height		: 30,
			autoHeight	: false,
			border		: false,
			html		: "<div id='oryx_editor_header'>" +
							"<a href=\""+(getURL())+"\" target=\"_blank\">" +
								"<img src='"+ORYX.PATH+"images/oryx.small.gif' border=\"0\" />" +
							"</a>" +
						"</div>",
			listeners	: {
							bodyresize : function() {
								// On init
								this.updateDocumentNameEditor(documentNameEditor, $('header-document-name'));
							}.bind(this)
			}
		});

		var maActive 	= ORYX.MashupAPI && ORYX.MashupAPI.isUsed;
		var maKey		= maActive ? ORYX.MashupAPI.key : "";
		var maCanRun	= maActive ? ORYX.MashupAPI.canRun : false;	
		var maIsRemoteM	= maActive ? ORYX.MashupAPI.isModelRemote : true;	
		
		var maModelImage= maIsRemoteM ? "<img src='"+ORYX.PATH+"images/page_white_put.png'/>" : "";
		var maModelAuthI= maActive ? "<span class='mashupinfo'><img src='"+ORYX.PATH+"images/" +( maCanRun ? "plugin_error" : "plugin") +".png'/>" + maModelImage + "</span>" : "";
		
		
		// Callback if the user changes
		var fn = function(val){
			val = val || ORYX.Editor.Cookie.getParams();
			
			var publicText = ORYX.I18N.Oryx.notLoggedOn;
			var user = val && val.identifier && val.identifier != "public" ? decodeURI(val.identifier.gsub('"', "")).replace(/\+/g," ") : "";
			
			if( user.length <= 0 ){
				user 	= 	publicText;
			}
			
			var content = 	"<div id='oryx_editor_header'>" +
								"<a href=\""+(getURL())+"\" target=\"_blank\">" +
									"<img src='"+ORYX.PATH+"images/oryx.small.gif' border=\"0\" />" + 
								"</a>" + 
								"<span class='openid " + (publicText == user ? "not" : "") + "'>" + 
									"<span class='y-header-document-name' id='header-document-name'></span>" + 	
									(unescape(user)) + 
									maModelAuthI + 
								"</span>" + 
								"<div style='clear: both;'/>"+ 
							"</div>";
			
			if( headerPanel.body ){
				headerPanel.body.dom.innerHTML = content;
			} else {
				headerPanel.html = content;
			}
			
			this.updateDocumentNameEditor(documentNameEditor, $('header-document-name'));
			
		}.bind(this);	
		
		ORYX.Editor.Cookie.onChange(fn);
		fn(ORYX.Editor.Cookie.getParams());
		
//		if (this.getModelMetaData()["new"]){
		this.registerOnEvent(ORYX.CONFIG.EVENT_SAVED, fn.bind(this, undefined));
//		}
		
			
		// The oryx header
		this.addToRegion("north", headerPanel );
	},
	
	/**
	 * Sets the current name of the document to the target element
	 * @params {HTMLElement} element
	 */
	updateDocumentNameEditor : function(editor, element) {
		if (editor && element) {
			// Get the name of the model
			var name = (this.getModelMetaData()["name"] || ORYX.I18N.Save.newProcess || "");
			// Truncate after a predefined length
			name = name.truncate(ORYX.CONFIG.MAX_DIAGRAM_TITLE_LENGTH, "...").toString();
			// Set the text as textContent to prevent injections
			element.textContent = Signavio.Utils.unescapeHTML(name);
			// Refresh the click event listener
			element.addEventListener("click", function(event) {
				editor.startEdit(event.currentTarget, Signavio.Utils.unescapeHTML(event.currentTarget.textContent));
			}.bind(this), false);
		}
		
	},
	
	/**
	 * adds a component to the specified region
	 * 
	 * @param {String} region
	 * @param {Ext.Component} component
	 * @param {String} title, optional
	 * @return {Ext.Component} dom reference to the current region or null if specified region is unknown
	 */
	addToRegion: function(region, component, title) {
		
		if (region.toLowerCase && this.layout_regions[region.toLowerCase()]) {
			var current_region = this.layout_regions[region.toLowerCase()];

			current_region.add(component);

			/*if( (region.toLowerCase() == 'east' || region.toLowerCase() == 'west') && current_region.items.length == 2){ //!current_region.getLayout() instanceof Ext.layout.Accordion ){
				var layout = new Ext.layout.Accordion( current_region.layoutConfig );
            	current_region.setLayout( layout );
				
				var items = current_region.items.clone();
				
				current_region.items.each(function(item){ current_region.remove( item )})
				items.each(function(item){ current_region.add( item )})
				
			}	*/		

			ORYX.Log.debug("original dimensions of region %0: %1 x %2", current_region.region, current_region.width, current_region.height)

			// update dimensions of region if required.
			if  (!current_region.width && component.initialConfig && component.initialConfig.width) {
				ORYX.Log.debug("resizing width of region %0: %1", current_region.region, component.initialConfig.width)	
				current_region.setWidth(component.initialConfig.width)
			}
			if  (component.initialConfig && component.initialConfig.height) {
				ORYX.Log.debug("resizing height of region %0: %1", current_region.region, component.initialConfig.height)
				var current_height = current_region.height || 0;
				current_region.height = component.initialConfig.height + current_height;
				current_region.setHeight(component.initialConfig.height + current_height)
			}
			
			// set title if provided as parameter.
			if (typeof title == "string") {
				current_region.setTitle(title);	
			}
						
			// trigger doLayout() and show the pane
			current_region.ownerCt.doLayout();
			current_region.show();

			if(Ext.isMac)
				ORYX.Editor.resizeFix();
			
			return current_region;
		}
		
		return null;
	},
	getAvailablePlugins: function(){
		var curAvailablePlugins=ORYX.availablePlugins.clone();
		curAvailablePlugins.each(function(plugin){
			if(this.loadedPlugins.find(function(loadedPlugin){
				return loadedPlugin.type==this.name;
			}.bind(plugin))){
				plugin.engaged=true;
			}else{
				plugin.engaged=false;
			}
			}.bind(this));
		return curAvailablePlugins;
	},

	loadScript: function (url, callback){
	    var script = document.createElement("script")
	    script.type = "text/javascript";
	    if (script.readyState){  //IE
	        script.onreadystatechange = function(){
	            if (script.readyState == "loaded" || script.readyState == "complete"){
	                script.onreadystatechange = null;
	                callback();
	            }
        	};
    	} else {  //Others
	        script.onload = function(){
	            callback();
	        };
		}
	    script.src = url;
		document.getElementsByTagName("head")[0].appendChild(script);
	},
	/**
	 * activate Plugin
	 * 
	 * @param {String} name
	 * @param {Function} callback
	 * 		callback(sucess, [errorCode])
	 * 			errorCodes: NOTUSEINSTENCILSET, REQUIRESTENCILSET, NOTFOUND, YETACTIVATED
	 */
	activatePluginByName: function(name, callback, loadTry){

		var match=this.getAvailablePlugins().find(function(value){return value.name==name});
		if(match && (!match.engaged || (match.engaged==='false'))){		
				var loadedStencilSetsNamespaces = this.getStencilSets().keys();
				var facade = this._getPluginFacade();
				var newPlugin;
				var me=this;
				ORYX.Log.debug("Initializing plugin '%0'", match.name);
				
					if (!match.requires 	|| !match.requires.namespaces 	|| match.requires.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) ){
						if(!match.notUsesIn 	|| !match.notUsesIn.namespaces 	|| !match.notUsesIn.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 })){
	
					try {
						
						var className 	= eval(match.name);
							var newPlugin = new className(facade, match);
							newPlugin.type = match.name;
							
							// If there is an GUI-Plugin, they get all Plugins-Offer-Meta-Data
							if (newPlugin.registryChanged) 
								newPlugin.registryChanged(me.pluginsData);
							
							// If there have an onSelection-Method it will pushed to the Editor Event-Handler
							if (newPlugin.onSelectionChanged) 
								me.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, newPlugin.onSelectionChanged.bind(newPlugin));
							this.loadedPlugins.push(newPlugin);
							this.loadedPlugins.each(function(loaded){
								if(loaded.registryChanged)
									loaded.registryChanged(this.pluginsData);
							}.bind(me));
							callback(true);
						
					} catch(e) {
						ORYX.Log.warn("Plugin %0 is not available", match.name);
						if(!!loadTry){
							callback(false,"INITFAILED");
							return;
						}
						this.loadScript("plugins/scripts/"+match.source, this.activatePluginByName.bind(this,match.name,callback,true));
					}
					}else{
						callback(false,"NOTUSEINSTENCILSET");
						ORYX.Log.info("Plugin need a stencilset which is not loaded'", match.name);
					}
								
				} else {
					callback(false,"REQUIRESTENCILSET");
					ORYX.Log.info("Plugin need a stencilset which is not loaded'", match.name);
				}

			
			}else{
				callback(false, match?"NOTFOUND":"YETACTIVATED");
				//TODO error handling
			}
	},

	/**
	 *  Laden der Plugins
	 */
	loadPlugins: function() {
		
		// if there should be plugins but still are none, try again.
		// TODO this should wait for every plugin respectively.
		/*if (!ORYX.Plugins && ORYX.availablePlugins.length > 0) {
			window.setTimeout(this.loadPlugins.bind(this), 100);
			return;
		}*/
		
		var me = this;
		var newPlugins = [];


		var loadedStencilSetsNamespaces = this.getStencilSets().keys();

		// Available Plugins will be initalize
		var facade = this._getPluginFacade();
		
		// If there is an Array where all plugins are described, than only take those
		// (that comes from the usage of oryx with a mashup api)
		if( ORYX.MashupAPI && ORYX.MashupAPI.loadablePlugins && ORYX.MashupAPI.loadablePlugins instanceof Array ){
		
			// Get the plugins from the available plugins (those who are in the plugins.xml)
			ORYX.availablePlugins = $A(ORYX.availablePlugins).findAll(function(value){
										return ORYX.MashupAPI.loadablePlugins.include( value.name )
									})
			
			// Add those plugins to the list, which are only in the loadablePlugins list
			ORYX.MashupAPI.loadablePlugins.each(function( className ){
				if( !(ORYX.availablePlugins.find(function(val){ return val.name == className }))){
					ORYX.availablePlugins.push( {name: className } );
				}
			})
		}
		
		
		ORYX.availablePlugins.each(function(value) {
			ORYX.Log.debug("Initializing plugin '%0'", value.name);
				if( (!value.requires 	|| !value.requires.namespaces 	|| value.requires.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) ) &&
					(!value.notUsesIn 	|| !value.notUsesIn.namespaces 	|| !value.notUsesIn.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) )&&
					/*only load activated plugins or undefined */
					(value.engaged || (value.engaged===undefined)) ){

				try {
					var className 	= eval(value.name);
					if( className ){
						var plugin		= new className(facade, value);
						plugin.type		= value.name;
						newPlugins.push( plugin );
						plugin.engaged=true;
					}
				} catch(e) {
					ORYX.Log.warn("Plugin %0 is not available", value.name);
				}
							
			} else {
				ORYX.Log.info("Plugin need a stencilset which is not loaded'", value.name);
			}
			
		});

		newPlugins.each(function(value) {
			// If there is an GUI-Plugin, they get all Plugins-Offer-Meta-Data
			if(value.registryChanged)
				value.registryChanged(me.pluginsData);

			// If there have an onSelection-Method it will pushed to the Editor Event-Handler
			if(value.onSelectionChanged)
				me.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, value.onSelectionChanged.bind(value));
		});

		this.loadedPlugins = newPlugins;
		
		// Hack for the Scrollbars
		if(Ext.isMac) {
			ORYX.Editor.resizeFix();
		}
		
		this.registerPluginsOnKeyEvents();
		
		this.setSelection();
		
	},

    /**
     * Loads the stencil set extension file, defined in ORYX.CONFIG.SS_EXTENSIONS_CONFIG
     */
    _loadStencilSetExtensionConfig: function(){
        // load ss extensions
        new Ajax.Request(ORYX.CONFIG.SS_EXTENSIONS_CONFIG, {
            method: 'GET',
            asynchronous: false,
            onSuccess: (function(transport) {
                var jsonObject = Ext.decode(transport.responseText);
                this.ss_extensions_def = jsonObject;
            }).bind(this),
            onFailure: (function(transport) {
                ORYX.Log.error("Editor._loadStencilSetExtensionConfig: Loading stencil set extension configuration file failed." + transport);
            }).bind(this)
        });
    },

	/**
	 * Creates the Canvas
	 * @param {String} [stencilType] The stencil type used for creating the canvas. If not given, a stencil with myBeRoot = true from current stencil set is taken.
	 * @param {Object} [canvasConfig] Any canvas properties (like language).
	 */
	_createCanvas: function(stencilType, canvas) {
        if (stencilType) {
            // Add namespace to stencilType
            if (stencilType.search(/^http/) === -1) {
                stencilType = this.getStencilSets().values()[0].namespace() + stencilType;
            }
        }
        else {
            // Get any root stencil type
            stencilType = this.getStencilSets().values()[0].findRootStencilName();
        }
        
		// get the stencil associated with the type
		var canvasStencil = ORYX.Core.StencilSet.stencil(stencilType);
			
		if (!canvasStencil) 
			ORYX.Log.fatal("Initialisation failed, because the stencil with the type %0 is not part of one of the loaded stencil sets.", stencilType);
		
		// create all dom
		// TODO fix border, so the visible canvas has a double border and some spacing to the scrollbars
		var div = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", null, ['div']);
		// set class for custom styling
		div.addClassName("ORYX_Editor");
						
		// create the canvas
		this._canvas = new ORYX.Core.Canvas({
			width					: ORYX.CONFIG.CANVAS_WIDTH,
			height					: ORYX.CONFIG.CANVAS_HEIGHT,
			'eventHandlerCallback'	: this.handleEvents.bind(this),
			id						: this.id,
			parentNode				: div
		}, canvasStencil);
        
        if (canvas && canvas.properties) {
          // Migrate canvasConfig to an RDF-like structure
          //FIXME this isn't nice at all because we don't want rdf any longer
          var properties = [];
          for(field in canvas.properties){
            properties.push({
              prefix: 'oryx',
              name: field,
              value: canvas.properties[field],
              format: (canvas.formats ? canvas.formats[field] : [])
            });
          }
            
          this._canvas.deserialize(properties);
          
          // Deserialize language
          if (this.modelMetaData.model && this.modelMetaData.model.language){
        	  this._canvas.setLanguage(this.modelMetaData.model.language);
          }
          
          // Deserialize orientation
          if (this.modelMetaData.model && this.modelMetaData.model.orientation){
        	  this._canvas.setOrientation(this.modelMetaData.model.orientation);
          }
          
        }
				
	},

	/**
	 * Returns a per-editor singleton plugin facade.
	 * To be used in plugin initialization.
	 */
	_getPluginFacade: function() {

		// if there is no pluginfacade already created:
		if(!(this._pluginFacade))

			// create it.
			this._pluginFacade = {

				activatePluginByName:		this.activatePluginByName.bind(this),
				//deactivatePluginByName:		this.deactivatePluginByName.bind(this),
				getAvailablePlugins:	this.getAvailablePlugins.bind(this),
				offer:					this.offer.bind(this),
				getStencilSets:			this.getStencilSets.bind(this),
				getStencilSetExtensionDefinition:function(){ return Object.clone(this.ss_extensions_def||{})}.bind(this),
				getRules:				this.getRules.bind(this),
				loadStencilSet:			this.loadStencilSet.bind(this),
				createShape:			this.createShape.bind(this),
				deleteShape:			this.deleteShape.bind(this),
				getSelection:			this.getSelection.bind(this),
				setSelection:			this.setSelection.bind(this),
				updateSelection:		this.updateSelection.bind(this),
				getCanvas:				this.getCanvas.bind(this),
				
				importJSON:				this.importJSON.bind(this),
				importERDF:				this.importERDF.bind(this),
				getERDF:				this.getERDF.bind(this),
                getJSON:                this.getJSON.bind(this),
                getSerializedJSON:      this.getSerializedJSON.bind(this),
				
				executeCommands:		this.executeCommands.bind(this),
				isExecutingCommands:	this.isExecutingCommands.bind(this),
				
				registerOnEvent:		this.registerOnEvent.bind(this),
				unregisterOnEvent:		this.unregisterOnEvent.bind(this),
				raiseEvent:				this.handleEvents.bind(this),
				enableEvent:			this.enableEvent.bind(this),
				disableEvent:			this.disableEvent.bind(this),
				
				eventCoordinates:		this.eventCoordinates.bind(this),
				addToRegion:			this.addToRegion.bind(this),
				
				getModelMetaData:		this.getModelMetaData.bind(this)
			};

		// return it.
		return this._pluginFacade;
	},

	isExecutingCommands: function(){
		return !!this.commandExecuting;
	},

	/**
	 * Implementes the command pattern
	 * (The real usage of the command pattern
	 * is implemented and shown in the Plugins/undo.js)
	 *
	 * @param <Oryx.Core.Command>[] Array of commands
	 */
	executeCommands: function(commands){
		
		if (!this.commandStack){
			this.commandStack = [];
		}
		if (!this.commandStackExecuted){
			this.commandStackExecuted = [];
		}
		
		
		this.commandStack = [].concat(this.commandStack)
							  .concat(commands)
							  .compact();
		
		// Check if already executes
		if (this.commandExecuting){ return; }
		
		// Start execution
		this.commandExecuting = true;
		
		// Iterate over all commands
		while(this.commandStack.length > 0){
			var command = this.commandStack.shift();
			// and execute it
			command.execute();
			this.commandStackExecuted.push(command);
			
			// Raise event for executing commands inside the loop, because
			// new commands can occur during the execution of the last command
			// in stack
			if (this.commandStack.length == 0){
				this.handleEvents({
					type		: ORYX.CONFIG.EVENT_LAST_EXECUTE_COMMANDS,
					commands	: this.commandStackExecuted
				});
				
				// Update the canvas after all commands are executed,
				// except commands generated by layout callbacks and plugins
				// registered on ORYX.CONFIG.EVENT_LAST_EXECUTE_COMMANDS
				this.getCanvas().update();
				this.updateSelection();
			}
		}
		
		this.handleEvents({
			type		: ORYX.CONFIG.EVENT_EXECUTE_COMMANDS,
			commands	: this.commandStackExecuted
		});
		
		// Remove temporary vars
		delete this.commandStack;
		delete this.commandStackExecuted;
		delete this.commandExecuting;
		
		
		this.updateSelection();

	},
	
    /**
     * Returns JSON of underlying canvas (calls ORYX.Canvas#toJSON()).
     * @return {Object} Returns JSON representation as JSON object.
     */
    getJSON: function(){
        var canvas = this.getCanvas().toJSON();
        canvas.ssextensions = this.getStencilSets().values()[0].extensions().keys().findAll(function(sse){ return !sse.endsWith('/meta#') });
        return canvas;
    },
    
    /**
     * Serializes a call to toJSON().
     * @return {String} Returns JSON representation as string.
     */
    getSerializedJSON: function(){
        return Ext.encode(this.getJSON());
    },
	
    /**
	 * @return {String} Returns eRDF representation.
	 * @deprecated Use ORYX.Editor#getJSON instead, if possible.
	 */
	getERDF:function(){

		// Get the serialized dom
        var serializedDOM = DataManager.serializeDOM( this._getPluginFacade() );
		
		// Add xml definition if there is no
		serializedDOM = '<?xml version="1.0" encoding="utf-8"?>' +
						'<html xmlns="http://www.w3.org/1999/xhtml" ' +
						'xmlns:b3mn="http://b3mn.org/2007/b3mn" ' +
						'xmlns:ext="http://b3mn.org/2007/ext" ' +
						'xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ' +
						'xmlns:atom="http://b3mn.org/2007/atom+xhtml">' +
						'<head profile="http://purl.org/NET/erdf/profile">' +
						'<link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" />' +
						'<link rel="schema.dcTerms" href="http://purl.org/dc/terms/ " />' +
						'<link rel="schema.b3mn" href="http://b3mn.org" />' +
						'<link rel="schema.oryx" href="http://oryx-editor.org/" />' +
						'<link rel="schema.raziel" href="http://raziel.org/" />' +
						'<base href="' +
						location.href.split("?")[0] +
						'" />' +
						'</head><body>' +
						serializedDOM +
						'</body></html>';
		
		return serializedDOM;				
	},
    
	/**
	* Imports shapes in JSON as expected by {@link ORYX.Editor#loadSerialized}
	* @param {Object|String} jsonObject The (serialized) json object to be imported
	* @param {boolean } [noSelectionAfterImport=false] Set to true if no shapes should be selected after import
	* @throws {SyntaxError} If the serialized json object contains syntax errors
	*/
	importJSON: function(jsonObject, noSelectionAfterImport) {
		
        try {
            jsonObject = this.renewResourceIds(jsonObject);
        } catch(error){
            throw error;
        }     
		//check, if the imported json model can be loaded in this editor
		// (stencil set has to fit)
		if(jsonObject.stencilset.namespace && jsonObject.stencilset.namespace !== this.getCanvas().getStencil().stencilSet().namespace()) {
			Ext.Msg.alert(ORYX.I18N.JSONImport.title, String.format(ORYX.I18N.JSONImport.wrongSS, jsonObject.stencilset.namespace, this.getCanvas().getStencil().stencilSet().namespace()));
			return null;
		} else {
			var commandClass = ORYX.Core.Command.extend({
			construct: function(jsonObject, loadSerializedCB, noSelectionAfterImport, facade){
				this.jsonObject = jsonObject;
				this.noSelection = noSelectionAfterImport;
				this.facade = facade;
				this.shapes;
				this.connections = [];
				this.parents = new Hash();
				this.selection = this.facade.getSelection();
				this.loadSerialized = loadSerializedCB;
			},			
			execute: function(){
				
				if (!this.shapes) {
					// Import the shapes out of the serialization		
					this.shapes	= this.loadSerialized( this.jsonObject );		
					
					//store all connections
					this.shapes.each(function(shape) {
						
						if (shape.getDockers) {
							var dockers = shape.getDockers();
							if (dockers) {
								if (dockers.length > 0) {
									this.connections.push([dockers.first(), dockers.first().getDockedShape(), dockers.first().referencePoint]);
								}
								if (dockers.length > 1) {
									this.connections.push([dockers.last(), dockers.last().getDockedShape(), dockers.last().referencePoint]);
								}
							}
						}
						
						//store parents
						this.parents[shape.id] = shape.parent;
					}.bind(this));
				} else {
					this.shapes.each(function(shape) {
						this.parents[shape.id].add(shape);
					}.bind(this));
					
					this.connections.each(function(con) {
						con[0].setDockedShape(con[1]);
						con[0].setReferencePoint(con[2]);
						con[0].update();
					});
				}
				
				//this.parents.values().uniq().invoke("update");
				this.facade.getCanvas().update();			
					
				if(!this.noSelection)
					this.facade.setSelection(this.shapes);
				else
					this.facade.updateSelection();
					
				// call updateSize again, because during loadSerialized the edges' bounds  
				// are not yet initialized properly
				this.facade.getCanvas().updateSize();	
					
				},
				rollback: function(){
					var selection = this.facade.getSelection();
					
					this.shapes.each(function(shape) {
						selection = selection.without(shape);
						this.facade.deleteShape(shape);
					}.bind(this));
					
					/*this.parents.values().uniq().each(function(parent) {
						if(!this.shapes.member(parent))
							parent.update();
					}.bind(this));*/
					
					this.facade.getCanvas().update();
					
					this.facade.setSelection(selection);
				}
			})
			
			var command = new commandClass(jsonObject, 
											this.loadSerialized.bind(this),
											noSelectionAfterImport,
											this._getPluginFacade());
			
			this.executeCommands([command]);	
			
			return command.shapes.clone();
		}
	},
    
    /**
     * This method renew all resource Ids and according references.
     * Warning: The implementation performs a substitution on the serialized object for
     * easier implementation. This results in a low performance which is acceptable if this
     * is only used when importing models.
     * @param {Object|String} jsonObject
     * @throws {SyntaxError} If the serialized json object contains syntax errors.
     * @return {Object} The jsonObject with renewed ids.
     * @private
     */
    renewResourceIds: function(jsonObject){
        // For renewing resource ids, a serialized and object version is needed
        if(Ext.type(jsonObject) === "string"){
            try {
                var serJsonObject = jsonObject;
                jsonObject = Ext.decode(jsonObject);
            } catch(error){
                throw new SyntaxError(error.message);
            }
        } else {
            var serJsonObject = Ext.encode(jsonObject);
        }        
        
        // collect all resourceIds recursively
        var collectResourceIds = function(shapes){
            if(!shapes) return [];
            
            return shapes.map(function(shape){
                return collectResourceIds(shape.childShapes).concat(shape.resourceId);
            }).flatten();
        }
        var resourceIds = collectResourceIds(jsonObject.childShapes);
        
        // Replace each resource id by a new one
        resourceIds.each(function(oldResourceId){
            var newResourceId = ORYX.Editor.provideId();
            serJsonObject = serJsonObject.gsub('"'+oldResourceId+'"', '"'+newResourceId+'"')
        });
        
        return Ext.decode(serJsonObject);
    },
	
	/**
	 * Import erdf structure to the editor
	 *
	 */
	importERDF: function( erdfDOM ){

		var serialized = this.parseToSerializeObjects( erdfDOM );	
		
		if(serialized)
			return this.importJSON(serialized, true);
	},

	/**
	 * Parses one model (eRDF) to the serialized form (JSON)
	 * 
	 * @param {Object} oneProcessData
	 * @return {Object} The JSON form of given eRDF model, or null if it couldn't be extracted 
	 */
	parseToSerializeObjects: function( oneProcessData ){
		
		// Firefox splits a long text node into chunks of 4096 characters.
		// To prevent truncation of long property values the normalize method must be called
		if(oneProcessData.normalize) oneProcessData.normalize();
		try {
			var xsl = "";
			var source=ORYX.PATH + "lib/extract-rdf.xsl";
			new Ajax.Request(source, {
				asynchronous: false,
				method: 'get',
				onSuccess: function(transport){
					xsl = transport.responseText
				}.bind(this),
				onFailure: (function(transport){
					ORYX.Log.error("XSL load failed" + transport);
				}).bind(this)
			});
			var domParser = new DOMParser();
			var xmlObject = oneProcessData;
			var xslObject = domParser.parseFromString(xsl, "text/xml");
        	var xsltProcessor = new XSLTProcessor();
        	var xslRef = document.implementation.createDocument("", "", null);
        	xsltProcessor.importStylesheet(xslObject);
        
            var new_rdf = xsltProcessor.transformToFragment(xmlObject, document);
            var serialized_rdf = (new XMLSerializer()).serializeToString(new_rdf);
			}catch(e){
			Ext.Msg.alert("Oryx", error);
			var serialized_rdf = "";
		}
            
            // Firefox 2 to 3 problem?!
            serialized_rdf = !serialized_rdf.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf : serialized_rdf;

//        var req = new Ajax.Request(ORYX.CONFIG.ROOT_PATH+"rdf2json", {
        var req = new Ajax.Request("/p/rdf2json", {
          method: 'POST',
          asynchronous: false,
          onSuccess: function(transport) {
              Ext.decode(transport.responseText);
          },
          parameters: {
              rdf: serialized_rdf
          }
        });
        
        return Ext.decode(req.transport.responseText);
	},

    /**
     * Loads serialized model to the oryx.
     * @example
     * editor.loadSerialized({
     *    resourceId: "mymodel1",
     *    childShapes: [
     *       {
     *          stencil:{ id:"Subprocess" },
     *          outgoing:[{resourceId: 'aShape'}],
     *          target: {resourceId: 'aShape'},
     *          bounds:{ lowerRight:{ y:510, x:633 }, upperLeft:{ y:146, x:210 } },
     *          resourceId: "myshape1",
     *          childShapes:[],
     *          properties:{},
     *       }
     *    ],
     *    properties:{
     *       language: "English"
     *    },
     *    stencilset:{
     *       url:"http://localhost:8080/oryx/stencilsets/bpmn1.1/bpmn1.1.json"
     *    },
     *    stencil:{
     *       id:"BPMNDiagram"
     *    }
     * });
     * @param {Object} model Description of the model to load.
     * @param {Array} [model.ssextensions] List of stenctil set extensions.
     * @param {String} model.stencilset.url
     * @param {String} model.stencil.id 
     * @param {Array} model.childShapes
     * @param {Array} [model.properties]
     * @param {String} model.resourceId
     * @return {ORYX.Core.Shape[]} List of created shapes
     * @methodOf ORYX.Editor.prototype
     */
    loadSerialized: function(model, requestMeta){
        var canvas  = this.getCanvas();
      
        // Bugfix (cf. http://code.google.com/p/oryx-editor/issues/detail?id=240)
        // Deserialize the canvas' stencil set extensions properties first!
        this.loadSSExtensions(model.ssextensions);
		
		// Load Meta Data Extension if available
		// #Signavio
		if (requestMeta === true) {
			var metaDataExtension = this.getExtensionForMetaData();
			if (metaDataExtension) {
				this.loadSSExtension(metaDataExtension);
			}
		}
		
        var shapes = this.getCanvas().addShapeObjects(model.childShapes, this.handleEvents.bind(this));
        
        if(model.properties) {
        	for(key in model.properties) {
        		var value = model.properties[key];
				var prop = this.getCanvas().getStencil().property("oryx-"+key);
        		if (!(typeof value === "string") && (!prop || !prop.isList())) {
        			value = Ext.encode(value);
        		}
            	this.getCanvas().setProperty("oryx-" + key, value);
            }
        }
        
        
        this.getCanvas().updateSize();
		
		// Force to update the selection
		this.selection = [null];
		this.setSelection([]);
		
        return shapes;
    },
	
	/**
	 * Return the namespace of the extension which
	 * provided all the self defined meta data
	 * @return {String} Returns null if no extension is defined, otherwise the namespace
	 *
	 */
	getExtensionForMetaData: function(){
		if (!this.ss_extensions_def||!(this.ss_extensions_def.extensions instanceof Array)){
			return null;
		}
		
		var stencilsets = this.getStencilSets();
		var extension = this.ss_extensions_def.extensions.find(function(ex){
				return !!stencilsets[ex["extends"]] && ex.namespace.endsWith("/meta#");
			});
			
		return extension ? extension.namespace || null : null;		
	},
    
    /**
     * Calls ORYX.Editor.prototype.ss_extension_namespace for each element
     * @param {Array} ss_extension_namespaces An array of stencil set extension namespaces.
     */
    loadSSExtensions: function(ss_extension_namespaces){
        if(!ss_extension_namespaces) return;

        ss_extension_namespaces.each(function(ss_extension_namespace){
            this.loadSSExtension(ss_extension_namespace);
        }.bind(this));
    },
	
	/**
	* Loads a stencil set extension.
	* The stencil set extensions definiton file must already
	* be loaded when the editor is initialized.
	*/
	loadSSExtension: function(ss_extension_namespace) {				
		
		if (this.ss_extensions_def) {
			
			var stencilsets = this.getStencilSets();
			var extension = this.ss_extensions_def.extensions.find(function(ex){
								return ex.namespace === ss_extension_namespace && stencilsets[ex["extends"]];
							});
			
			if (!extension) {
				return;
			}
			
			var stencilset = stencilsets[extension["extends"]];
			
			if (!stencilset) {
				return;
			}
			
			// Check if absolute or relative url
			if ((extension["definition"]||"").startsWith("/")){
				stencilset.addExtension(extension["definition"])
			} else {
				stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + extension["definition"])
			}
			
			//stencilset.addExtension("/oryx/build/stencilsets/extensions/" + extension["definition"])
			this.getRules().initializeRules(stencilset);
			
			this._getPluginFacade().raiseEvent({
				type: ORYX.CONFIG.EVENT_STENCIL_SET_LOADED
			});
		}
		
	},

	disableEvent: function(eventType){
		if(eventType == ORYX.CONFIG.EVENT_KEYDOWN) {
			this._keydownEnabled = false;
		}
		if(eventType == ORYX.CONFIG.EVENT_KEYUP) {
			this._keyupEnabled = false;
		}
		if(this.DOMEventListeners.keys().member(eventType)) {
			var value = this.DOMEventListeners.remove(eventType);
			this.DOMEventListeners['disable_' + eventType] = value;
		}
	},

	enableEvent: function(eventType){
		if(eventType == ORYX.CONFIG.EVENT_KEYDOWN) {
			this._keydownEnabled = true;
		}
		
		if(eventType == ORYX.CONFIG.EVENT_KEYUP) {
			this._keyupEnabled = true;
		}
		
		if(this.DOMEventListeners.keys().member("disable_" + eventType)) {
			var value = this.DOMEventListeners.remove("disable_" + eventType);
			this.DOMEventListeners[eventType] = value;
		}
	},

	/**
	 *  Methods for the PluginFacade
	 */
	registerOnEvent: function(eventType, callback) {
		if(!(this.DOMEventListeners.keys().member(eventType))) {
			this.DOMEventListeners[eventType] = [];
		}
		
		// Only add callback if not already existing for eventType
		if(!this.DOMEventListeners[eventType].include(callback)) {
				this.DOMEventListeners[eventType].push(callback);
		}
	},

	unregisterOnEvent: function(eventType, callback) {
		if(this.DOMEventListeners.keys().member(eventType)) {
			this.DOMEventListeners[eventType] = this.DOMEventListeners[eventType].without(callback);
		} else {
			// Event is not supported
			// TODO: Error Handling
		}
	},

	getSelection: function() {
		return this.selection || [];
	},

	getStencilSets: function() { 
		return ORYX.Core.StencilSet.stencilSets(this.id); 
	},
	
	getRules: function() {
		return ORYX.Core.StencilSet.rules(this.id);
	},
	
	loadStencilSet: function(source) {
		try {
			ORYX.Core.StencilSet.loadStencilSet(source, this.id);
			this.handleEvents({type:ORYX.CONFIG.EVENT_STENCIL_SET_LOADED});
		} catch (e) {
			ORYX.Log.warn("Requesting stencil set file failed. (" + e + ")");
		}
	},

	offer: function(pluginData) {
		if(!this.pluginsData.member(pluginData)){
			this.pluginsData.push(pluginData);
		}
	},
	
	/**
	 * It creates an new event or adds the callback, if already existing,
	 * for the key combination that the plugin passes in keyCodes attribute
	 * of the offer method.
	 * 
	 * The new key down event fits the schema:
	 * 		key.event[.metactrl][.alt][.shift].'thekeyCode'
	 */
	registerPluginsOnKeyEvents: function() {
		this.pluginsData.each(function(pluginData) {
			
			if(pluginData.keyCodes) {
				
				pluginData.keyCodes.each(function(keyComb) {
					var eventName = "key.event";
					
					/* Include key action */
					eventName += '.' + keyComb.keyAction;
					
					if(keyComb.metaKeys) {
						/* Register on ctrl or apple meta key as meta key */
						if(keyComb.metaKeys.
							indexOf(ORYX.CONFIG.META_KEY_META_CTRL) > -1) {
								eventName += "." + ORYX.CONFIG.META_KEY_META_CTRL;
						}
							
						/* Register on alt key as meta key */
						if(keyComb.metaKeys.
							indexOf(ORYX.CONFIG.META_KEY_ALT) > -1) {
								eventName += '.' + ORYX.CONFIG.META_KEY_ALT;
						}
						
						/* Register on shift key as meta key */
						if(keyComb.metaKeys.
							indexOf(ORYX.CONFIG.META_KEY_SHIFT) > -1) {
								eventName += '.' + ORYX.CONFIG.META_KEY_SHIFT;
						}		
					}
					
					/* Register on the actual key */
					if(keyComb.keyCode)	{
						eventName += '.' + keyComb.keyCode;
					}
					
					/* Register the event */
					ORYX.Log.debug("Register Plugin on Key Event: %0", eventName);
					if (pluginData.toggle === true && pluginData.buttonInstance) {
						this.registerOnEvent(eventName, function(){
							pluginData.buttonInstance.toggle(!pluginData.buttonInstance.pressed); // Toggle 
							pluginData.functionality.call(pluginData, pluginData.buttonInstance, pluginData.buttonInstance.pressed); // Call function
						});
					} else {
						this.registerOnEvent(eventName, pluginData.functionality)
					}
				
				}.bind(this));
			}
		}.bind(this));
	},
	
	isEqual: function(a,b){
		return a === b || (a.length === b.length && a.all(function(r){ return b.include(r) }))
	},
	
	isDirty: function(a){
		return a.any(function(shape){ return shape.isPropertyChanged() })
	},

	setSelection: function(elements, subSelectionElement, force) {
		
		if (!elements) { elements = []; }
		if (!(elements instanceof Array)) { elements = [elements]; }
		
		elements = elements.findAll(function(n){ return n && n instanceof ORYX.Core.Shape });
		
		if (elements[0] instanceof ORYX.Core.Canvas) {
			elements = [];
		}
		
		if (!force && this.isEqual(this.selection, elements) && !this.isDirty(elements)){
			return;
		}
		
		this.selection = elements;
		this._subSelection = subSelectionElement;
		
		this.handleEvents({type:ORYX.CONFIG.EVENT_SELECTION_CHANGED, elements:elements, subSelection: subSelectionElement, force: !!force})
	},
	
	updateSelection: function() {
		this.setSelection(this.selection, this._subSelection, true);
		/*var s = this.selection;
		this.setSelection();
		this.setSelection(s);*/
	},

	getCanvas: function() {
		return this._canvas;
	},
	

	/**
	*	option = {
	*		type: string,
	*		position: {x:int, y:int},
	*		connectingType:	uiObj-Class
	*		connectedShape: uiObj
	*		draggin: bool
	*		namespace: url
	*       parent: ORYX.Core.AbstractShape
	*		template: a template shape that the newly created inherits properties from.
	*		}
	*/
	createShape: function(option) {

		if(option && option.serialize && option.serialize instanceof Array){
		
			var type = option.serialize.find(function(obj){return (obj.prefix+"-"+obj.name) == "oryx-type"});
			var stencil = ORYX.Core.StencilSet.stencil(type.value);
		
			if(stencil.type() == 'node'){
				var newShapeObject = new ORYX.Core.Node({'eventHandlerCallback':this.handleEvents.bind(this)}, stencil);	
			} else {
				var newShapeObject = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, stencil);	
			}
		
			this.getCanvas().add(newShapeObject);
			newShapeObject.deserialize(option.serialize);
		
			return newShapeObject;
		}

		// If there is no argument, throw an exception
		if(!option || !option.type || !option.namespace) { throw "To create a new shape you have to give an argument with type and namespace";}
		
		var canvas = this.getCanvas();
		var newShapeObject;

		// Get the shape type
		var shapetype = option.type;

		// Get the stencil set
		var sset = ORYX.Core.StencilSet.stencilSet(option.namespace);

		// Create an New Shape, dependents on an Edge or a Node
		if(sset.stencil(shapetype).type() == "node") {
			newShapeObject = new ORYX.Core.Node({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(shapetype))
		} else {
			newShapeObject = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(shapetype))
		}
		
		// when there is a template, inherit the properties.
		if(option.template) {

			newShapeObject._jsonStencil.properties = option.template._jsonStencil.properties;
			newShapeObject.postProcessProperties();
		}

		// Add to the canvas
		if(option.parent && newShapeObject instanceof ORYX.Core.Node) {
			option.parent.add(newShapeObject);
		} else {
			canvas.add(newShapeObject);
		}
		
		
		// Set the position
		var point = option.position ? option.position : {x:100, y:200};
	
		
		var con;
		// If there is create a shape and in the argument there is given an ConnectingType and is instance of an edge
		if(option.connectingType && option.connectedShape && !(newShapeObject instanceof ORYX.Core.Edge)) {

			// there will be create a new Edge
			con = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(option.connectingType));
			
			// And both endings dockers will be referenced to the both shapes
			con.dockers.first().setDockedShape(option.connectedShape);
			
			var magnet = option.connectedShape.getDefaultMagnet()
			var cPoint = magnet ? magnet.bounds.center() : option.connectedShape.bounds.midPoint();
			con.dockers.first().setReferencePoint( cPoint );
			con.dockers.last().setDockedShape(newShapeObject);
			con.dockers.last().setReferencePoint(newShapeObject.getDefaultMagnet().bounds.center());		
			
			// The Edge will be added to the canvas and be updated
			canvas.add(con);	
			//连线时也触发创建图形的事件，解决不计算连线ID的问题
			this.handleEvents({
				type: SMARTDOT.CONFIG.EVENT_AFTER_CREATE_SHAPE,
				shape: newShapeObject
			});
			//con.update();
			
		} 
		
		// Move the new Shape to the position
		if(newShapeObject instanceof ORYX.Core.Edge && option.connectedShape) {

			newShapeObject.dockers.first().setDockedShape(option.connectedShape);
			
			if( option.connectedShape instanceof ORYX.Core.Node ){
				newShapeObject.dockers.first().setReferencePoint(option.connectedShape.getDefaultMagnet().bounds.center());					
				newShapeObject.dockers.last().bounds.centerMoveTo(point);			
			} else {
				newShapeObject.dockers.first().setReferencePoint(option.connectedShape.bounds.midPoint());								
			}

		} else {
			
			var b = newShapeObject.bounds;
			if( newShapeObject instanceof ORYX.Core.Node && newShapeObject.dockers.length == 1){
				b = newShapeObject.dockers.first().bounds;
			}
			
			if (newShapeObject instanceof ORYX.Core.Edge){
				b.extend({x:0, y:1});
				point.x -= 8;
				point.y -= 8;
			}
			
			b.centerMoveTo(point);
			
			var upL = b.upperLeft();
			b.moveBy( -Math.min(upL.x, 0) , -Math.min(upL.y, 0) );
			
			var lwR = b.lowerRight();
			b.moveBy( -Math.max(lwR.x-canvas.bounds.width(), 0) , -Math.max(lwR.y-canvas.bounds.height(), 0) );
			
		}
		
		// Update the shape
		if (newShapeObject instanceof ORYX.Core.Edge) {
			newShapeObject._update(false);
		}
		
		// And refresh the selection
		if(!(newShapeObject instanceof ORYX.Core.Edge)&&!(option.dontUpdateSelection)) {
			this.setSelection([newShapeObject]);
		}
		
		if(con && con.alignDockers) {
			con.alignDockers();
		} 
		if(newShapeObject.alignDockers) {
			newShapeObject.alignDockers();
		}
		//触发创建图形的事件 shanglihui 20111123
		this.handleEvents({
					type: SMARTDOT.CONFIG.EVENT_AFTER_CREATE_SHAPE,
					shape: newShapeObject
					});		

		return newShapeObject;
	},
	
	deleteShape: function(shape) {
		
		if (!shape || !shape.parent){ return }
		
		//remove shape from parent
		// this also removes it from DOM
		shape.parent.remove(shape);
		
		//delete references to outgoing edges
		shape.getOutgoingShapes().each(function(os) {
			var docker = os.getDockers().first();
			if(docker && docker.getDockedShape() == shape) {
				docker.setDockedShape(undefined);
			}
		});
		
		//delete references to incoming edges
		shape.getIncomingShapes().each(function(is) {
			var docker = is.getDockers().last();
			if(docker && docker.getDockedShape() == shape) {
				docker.setDockedShape(undefined);
			}
		});
		
		//delete references of the shape's dockers
		shape.getDockers().each(function(docker) {
			docker.setDockedShape(undefined);
		});
	},
	
	/**
	 * Returns an object with meta data about the model.
	 * Like name, description, ...
	 * 
	 * Empty object with the current backend.
	 * 
	 * @return {Object} Meta data about the model
	 */
	getModelMetaData: function() {
		return this.modelMetaData;
	},

	/* Event-Handler Methods */
	
	/**
	* Helper method to execute an event immediately. The event is not
	* scheduled in the _eventsQueue. Needed to handle Layout-Callbacks.
	*/
	_executeEventImmediately: function(eventObj) {
		if(this.DOMEventListeners.keys().member(eventObj.event.type)) {
			this.DOMEventListeners[eventObj.event.type].each((function(value) {
				value(eventObj.event, eventObj.arg);		
			}).bind(this));
		}
	},

	_executeEvents: function() {
		this._queueRunning = true;
		while(this._eventsQueue.length > 0) {
			var val = this._eventsQueue.shift();
			this._executeEventImmediately(val);
		}
		this._queueRunning = false;
	},
	
	/**
	 * Leitet die Events an die Editor-Spezifischen Event-Methoden weiter
	 * @param {Object} event Event , welches gefeuert wurde
	 * @param {Object} uiObj Target-UiObj
	 */
	handleEvents: function(event, uiObj) {
		
		ORYX.Log.trace("Dispatching event type %0 on %1", event.type, uiObj);

		switch(event.type) {
			case ORYX.CONFIG.EVENT_MOUSEDOWN:
				this._handleMouseDown(event, uiObj);
				break;
			case ORYX.CONFIG.EVENT_MOUSEMOVE:
				this._handleMouseMove(event, uiObj);
				break;
			case ORYX.CONFIG.EVENT_MOUSEUP:
				this._handleMouseUp(event, uiObj);
				break;
			case ORYX.CONFIG.EVENT_MOUSEOVER:
				this._handleMouseHover(event, uiObj);
				break;
			case ORYX.CONFIG.EVENT_MOUSEOUT:
				this._handleMouseOut(event, uiObj);
				break;
		}
		/* Force execution if necessary. Used while handle Layout-Callbacks. */
		if(event.forceExecution) {
			this._executeEventImmediately({event: event, arg: uiObj});
		} else {
			this._eventsQueue.push({event: event, arg: uiObj});
		}
		
		if(!this._queueRunning) {
			this._executeEvents();
		}
		
		// TODO: Make this return whether no listener returned false.
		// So that, when one considers bubbling undesireable, it won't happen.
		return false;
	},

	isValidEvent: function(e){
		try {
			var isInput = ["INPUT", "TEXTAREA"].include(e.target.tagName.toUpperCase());
			var gridHasFocus = e.target.className.include("x-grid3-focus") && !e.target.className.include("x-grid3-focus-canvas");
			return !isInput && !gridHasFocus;
		} catch(e){
			return false;
		}
	},

	catchKeyUpEvents: function(event) {
		if(!this._keyupEnabled) {
			return;
		}
		/* assure we have the current event. */
        if (!event) 
            event = window.event;
        
		// Checks if the event comes from some input field
		if (!this.isValidEvent(event)){
			return;
		}
		
		/* Create key up event type */
		var keyUpEvent = this.createKeyCombEvent(event,	ORYX.CONFIG.KEY_ACTION_UP);
		
		ORYX.Log.debug("Key Event to handle: %0", keyUpEvent);

		/* forward to dispatching. */
		this.handleEvents({type: keyUpEvent, event:event});
	},
	
	/**
	 * Catches all key down events and forward the appropriated event to 
	 * dispatching concerning to the pressed keys.
	 * 
	 * @param {Event} 
	 * 		The key down event to handle
	 */
	catchKeyDownEvents: function(event) {
		if(!this._keydownEnabled) {
			return;
		}
		/* Assure we have the current event. */
        if (!event) 
            event = window.event;
        
		/* Fixed in FF3 */
		// This is a mac-specific fix. The mozilla event object has no knowledge
		// of meta key modifier on osx, however, it is needed for certain
		// shortcuts. This fix adds the metaKey field to the event object, so
		// that all listeners that registered per Oryx plugin facade profit from
		// this. The original bug is filed in
		// https://bugzilla.mozilla.org/show_bug.cgi?id=418334
		//if (this.__currentKey == ORYX.CONFIG.KEY_CODE_META) {
		//	event.appleMetaKey = true;
		//}
		//this.__currentKey = pressedKey;
		
		// Checks if the event comes from some input field
		if (!this.isValidEvent(event)){
			return;
		}
		
		/* Create key up event type */
		var keyDownEvent = this.createKeyCombEvent(event, ORYX.CONFIG.KEY_ACTION_DOWN);
		
		ORYX.Log.debug("Key Event to handle: %0", keyDownEvent);
		
		/* Forward to dispatching. */
		this.handleEvents({type: keyDownEvent,event: event});
	},
	
	/**
	 * Creates the event type name concerning to the pressed keys.
	 * 
	 * @param {Event} keyDownEvent
	 * 		The source keyDownEvent to build up the event name
	 */
	createKeyCombEvent: function(keyEvent, keyAction) {

		/* Get the currently pressed key code. */
        var pressedKey = keyEvent.which || keyEvent.keyCode;
		//this.__currentKey = pressedKey;
		
		/* Event name */
		var eventName = "key.event";
		
		/* Key action */
		if(keyAction) {
			eventName += "." + keyAction;
		}
		
		/* Ctrl or apple meta key is pressed */
		if(keyEvent.ctrlKey || keyEvent.metaKey) {
			eventName += "." + ORYX.CONFIG.META_KEY_META_CTRL;
		}
		
		/* Alt key is pressed */
		if(keyEvent.altKey) {
			eventName += "." + ORYX.CONFIG.META_KEY_ALT;
		}
		
		/* Alt key is pressed */
		if(keyEvent.shiftKey) {
			eventName += "." + ORYX.CONFIG.META_KEY_SHIFT;
		}
		
		/* Return the composed event name */
		return  eventName + "." + pressedKey;
	},

	_handleMouseDown: function(event, uiObj) {
		
		// get canvas.
		var canvas = this.getCanvas();
		// Try to get the focus
		canvas.focus()
	
		// find the shape that is responsible for this element's id.
		var element = event.currentTarget;
		var elementController = uiObj;

		// gather information on selection.
		var currentIsSelectable = (elementController !== null) &&
			(elementController !== undefined) && (elementController.isSelectable);
		var currentIsMovable = (elementController !== null) &&
			(elementController !== undefined) && (elementController.isMovable);
		var modifierKeyPressed = event.shiftKey || event.ctrlKey;
		var noObjectsSelected = this.selection.length === 0;
		var currentIsSelected = this.selection.member(elementController);


		// Rule #1: When there is nothing selected, select the clicked object.
		if(currentIsSelectable && noObjectsSelected) {

			this.setSelection([elementController]);

			ORYX.Log.trace("Rule #1 applied for mouse down on %0", element.id);

		// Rule #3: When at least one element is selected, and there is no
		// control key pressed, and the clicked object is not selected, select
		// the clicked object.
		} else if(currentIsSelectable && !noObjectsSelected &&
			!modifierKeyPressed && !currentIsSelected) {

			this.setSelection([elementController]);

			//var objectType = elementController.readAttributes();
			//alert(objectType[0] + ": " + objectType[1]);

			ORYX.Log.trace("Rule #3 applied for mouse down on %0", element.id);

		// Rule #4: When the control key is pressed, and the current object is
		// not selected, add it to the selection.
		} else if(currentIsSelectable && modifierKeyPressed
			&& !currentIsSelected) {
				
			var newSelection = this.selection.clone();
			newSelection.push(elementController)
			this.setSelection(newSelection)

			ORYX.Log.trace("Rule #4 applied for mouse down on %0", element.id);

		// Rule #6
		} else if(currentIsSelectable && currentIsSelected &&
			modifierKeyPressed) {

			var newSelection = this.selection.clone();
			this.setSelection(newSelection.without(elementController))

			ORYX.Log.trace("Rule #6 applied for mouse down on %0", elementController.id);

		// Rule #5: When there is at least one object selected and no control
		// key pressed, we're dragging.
		/*} else if(currentIsSelectable && !noObjectsSelected
			&& !modifierKeyPressed) {

			if(this.log.isTraceEnabled())
				this.log.trace("Rule #5 applied for mouse down on "+element.id);
*/
		// Rule #2: When clicked on something that is neither
		// selectable nor movable, clear the selection, and return.
		} else if (!currentIsSelectable && !currentIsMovable) {
			
			this.setSelection([]);
			
			ORYX.Log.trace("Rule #2 applied for mouse down on %0", element.id);

			return;

		// Rule #7: When the current object is not selectable but movable,
		// it is probably a control. Leave the selection unchanged but set
		// the movedObject to the current one and enable Drag. Dockers will
		// be processed in the dragDocker plugin.
		} else if(!currentIsSelectable && currentIsMovable && !(elementController instanceof ORYX.Core.Controls.Docker)) {
			
			// TODO: If there is any moveable elements, do this in a plugin
			//ORYX.Core.UIEnableDrag(event, elementController);

			ORYX.Log.trace("Rule #7 applied for mouse down on %0", element.id);
		
		// Rule #8: When the element is selectable and is currently selected and no 
		// modifier key is pressed
		} else if(currentIsSelectable && currentIsSelected &&
			!modifierKeyPressed) {
			
			this._subSelection = this._subSelection != elementController ? elementController : undefined;
						
			this.setSelection(this.selection, this._subSelection);
			
			ORYX.Log.trace("Rule #8 applied for mouse down on %0", element.id);
		}
		
		
		// prevent event from bubbling, return.
		//Event.stop(event);
		return;
	},

	_handleMouseMove: function(event, uiObj) {
		return;
	},

	_handleMouseUp: function(event, uiObj) {
		// get canvas.
		var canvas = this.getCanvas();

		// find the shape that is responsible for this elemement's id.
		var elementController = uiObj;

		//get event position
		var evPos = this.eventCoordinates(event);

		//Event.stop(event);
	},

	_handleMouseHover: function(event, uiObj) {
		return;
	},

	_handleMouseOut: function(event, uiObj) {
		return;
	},

	/**
	 * Calculates the event coordinates to SVG document coordinates.
	 * @param {Event} event
	 * @return {SVGPoint} The event coordinates in the SVG document
	 */
	eventCoordinates: function(event) {

		var canvas = this.getCanvas();

		var svgPoint = canvas.node.ownerSVGElement.createSVGPoint();
		svgPoint.x = event.clientX;
		svgPoint.y = event.clientY;
		var matrix = canvas.node.getScreenCTM();
		
		if (Ext.isIE9){
			var sn = Ext.fly(canvas.getScrollNode().firstChild);
			matrix.e = sn.getLeft()+4;
			matrix.f = sn.getTop()+4;
		}
		
		return svgPoint.matrixTransform(matrix.inverse());
	}
};
ORYX.Editor = Clazz.extend(ORYX.Editor);

/**
 * Creates a new ORYX.Editor instance by fetching a model from given url and passing it to the constructur
 * @param {String} modelUrl The JSON URL of a model.
 * @param {Object} config Editor config passed to the constructur, merged with the response of the request to modelUrl
 */
ORYX.Editor.createByUrl = function(modelUrl, config){
    if(!config) config = {};
    
    new Ajax.Request(modelUrl, {
      method: 'GET',
      onSuccess: function(transport) {
        var editorConfig = Ext.decode(transport.responseText);
        editorConfig = Ext.applyIf(editorConfig, config);
        new ORYX.Editor(editorConfig);
      }.bind(this)
    });
}

// TODO Implement namespace awareness on attribute level.
/**
 * graft() function
 * Originally by Sean M. Burke from interglacial.com, altered for usage with
 * SVG and namespace (xmlns) support. Be sure you understand xmlns before
 * using this funtion, as it creates all grafted elements in the xmlns
 * provided by you and all element's attribures in default xmlns. If you
 * need to graft elements in a certain xmlns and wish to assign attributes
 * in both that and another xmlns, you will need to do stepwise grafting,
 * adding non-default attributes yourself or you'll have to enhance this
 * function. Latter, I would appreciate: martin?apfelfabrik.de
 * @param {Object} namespace The namespace in which
 * 					elements should be grafted.
 * @param {Object} parent The element that should contain the grafted
 * 					structure after the function returned.
 * @param {Object} t the crafting structure.
 * @param {Object} doc the document in which grafting is performed.
 */
ORYX.Editor.graft = function(namespace, parent, t, doc) {

    doc = (doc || (parent && parent.ownerDocument) || document);
    var e;
    if(t === undefined) {
        throw "Can't graft an undefined value";
    } else if(t.constructor == String) {
        e = doc.createTextNode( t );
    } else {
        for(var i = 0; i < t.length; i++) {
            if( i === 0 && t[i].constructor == String ) {
                var snared;
                snared = t[i].match( /^([a-z][a-z0-9]*)\.([^\s\.]+)$/i );
                if( snared ) {
                    e = doc.createElementNS(namespace, snared[1] );
                    e.setAttributeNS(null, 'class', snared[2] );
                    continue;
                }
                snared = t[i].match( /^([a-z][a-z0-9]*)$/i );
                if( snared ) {
                    e = doc.createElementNS(namespace, snared[1] );  // but no class
                    continue;
                }

                // Otherwise:
                e = doc.createElementNS(namespace, "span" );
                e.setAttribute(null, "class", "namelessFromLOL" );
            }

            if( t[i] === undefined ) {
                throw "Can't graft an undefined value in a list!";
            } else if( t[i].constructor == String || t[i].constructor == Array ) {
                this.graft(namespace, e, t[i], doc );
            } else if(  t[i].constructor == Number ) {
                this.graft(namespace, e, t[i].toString(), doc );
            } else if(  t[i].constructor == Object ) {
                // hash's properties => element's attributes
                for(var k in t[i]) { e.setAttributeNS(null, k, t[i][k] ); }
            } else {

			}
        }
    }
	if(parent) {
	    parent.appendChild( e );
	} else {

	}
    return e; // return the topmost created node
};

ORYX.Editor.provideId = function() {
	var res = [], hex = '0123456789ABCDEF';

	for (var i = 0; i < 36; i++) res[i] = Math.floor(Math.random()*0x10);

	res[14] = 4;
	res[19] = (res[19] & 0x3) | 0x8;

	for (var i = 0; i < 36; i++) res[i] = hex[res[i]];

	res[8] = res[13] = res[18] = res[23] = '-';

	return "oryx_" + res.join('');
};

/**
 * When working with Ext, conditionally the window needs to be resized. To do
 * so, use this class method. Resize is deferred until 100ms, and all subsequent
 * resizeBugFix calls are ignored until the initially requested resize is
 * performed.
 */
ORYX.Editor.resizeFix = function() {
	if (!ORYX.Editor._resizeFixTimeout) {
		ORYX.Editor._resizeFixTimeout = window.setTimeout(function() {
			window.resizeBy(1,1);
			window.resizeBy(-1,-1);
			ORYX.Editor._resizefixTimeout = null;
		}, 100); 
	}
};

ORYX.Editor.Cookie = {
	
	callbacks:[],
		
	onChange: function( callback, interval ){
	
		this.callbacks.push(callback);
		this.start( interval )
	
	},
	
	start: function( interval ){
		
		if( this.pe ){
			return;
		}
		
		var currentString = document.cookie;
		
		this.pe = new PeriodicalExecuter( function(){
			
			if( currentString != document.cookie ){
				currentString = document.cookie;
				this.callbacks.each(function(callback){ callback(this.getParams()) }.bind(this));
			}
			
		}.bind(this), ( interval || 10000 ) / 1000);	
	},
	
	stop: function(){

		if( this.pe ){
			this.pe.stop();
			this.pe = null;
		}
	},
		
	getParams: function(){
		var res = {};
		
		var p = document.cookie;
		p.split("; ").each(function(param){ res[param.split("=")[0]] = param.split("=")[1];});
		
		return res;
	},	
	
	toString: function(){
		return document.cookie;
	}
};

/**
 * Workaround for SAFARI/Webkit, because
 * when trying to check SVGSVGElement of instanceof there is 
 * raising an error
 * 
 */
ORYX.Editor.SVGClassElementsAreAvailable = true;
ORYX.Editor.setMissingClasses = function() {
	
	try {
		SVGElement;
	} catch(e) {
		ORYX.Editor.SVGClassElementsAreAvailable = false;
		SVGSVGElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'svg').toString();
		SVGGElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'g').toString();
		SVGPathElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'path').toString();
		SVGTextElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'text').toString();
		//SVGMarkerElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'marker').toString();
		SVGRectElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'rect').toString();
		SVGImageElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'image').toString();
		SVGCircleElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'circle').toString();
		SVGEllipseElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'ellipse').toString();
		SVGLineElement	 	= document.createElementNS('http://www.w3.org/2000/svg', 'line').toString();
		SVGPolylineElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'polyline').toString();
		SVGPolygonElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'polygon').toString();
		
	}
	
}
ORYX.Editor.checkClassType = function( classInst, classType ) {
	
	if( ORYX.Editor.SVGClassElementsAreAvailable ){
		return classInst instanceof classType
	} else {
		return classInst == classType
	}
};
ORYX.Editor.makeExtModalWindowKeysave = function(facade) {
	Ext.override(Ext.Window,{
		beforeShow : function(){
			delete this.el.lastXY;
			delete this.el.lastLT;
			if(this.x === undefined || this.y === undefined){
				var xy = this.el.getAlignToXY(this.container, 'c-c');
				var pos = this.el.translatePoints(xy[0], xy[1]);
				this.x = this.x === undefined? pos.left : this.x;
				this.y = this.y === undefined? pos.top : this.y;
			}
			this.el.setLeftTop(this.x, this.y);
	
			if(this.expandOnShow){
				this.expand(false);
			}
	
			if(this.modal){
				facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
				Ext.getBody().addClass("x-body-masked");
				this.mask.setSize(Ext.lib.Dom.getViewWidth(true), Ext.lib.Dom.getViewHeight(true));
				this.mask.show();
			}
		},
		afterHide : function(){
	        this.proxy.hide();
	        if(this.monitorResize || this.modal || this.constrain || this.constrainHeader){
	            Ext.EventManager.removeResizeListener(this.onWindowResize, this);
	        }
	        if(this.modal){
	            this.mask.hide();
	            facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
	            Ext.getBody().removeClass("x-body-masked");
	        }
	        if(this.keyMap){
	            this.keyMap.disable();
	        }
	        this.fireEvent("hide", this);
	    },
	    beforeDestroy : function(){
	    	if(this.modal)
	    		facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
	        Ext.destroy(
	            this.resizer,
	            this.dd,
	            this.proxy,
	            this.mask
	        );
	        Ext.Window.superclass.beforeDestroy.call(this);
	    }
	});
}
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}

new function(){
    
    ORYX.Core.UIEnableDrag = function(event, uiObj, option){
    
        // Only one dragging can be active
        ORYX.Core.UIDisableDrag(event);
        
        this.uiObj = uiObj;
        var upL = uiObj.bounds.upperLeft();
        
        var a = uiObj.node.getScreenCTM();
        this.faktorXY = {
            x: a.a,
            y: a.d
        };
        
        this.scrollNode = uiObj.node.ownerSVGElement.parentNode.parentNode;
        
        this.offSetPosition = {
            x: Event.pointerX(event) - (upL.x * this.faktorXY.x),
            y: Event.pointerY(event) - (upL.y * this.faktorXY.y)
        };
        
        this.offsetScroll = {
            x: this.scrollNode.scrollLeft,
            y: this.scrollNode.scrollTop
        };
        
        this.dragCallback = ORYX.Core.UIDragCallback.bind(this);
        this.disableCallback = ORYX.Core.UIDisableDrag.bind(this);
        
        this.movedCallback = option ? option.movedCallback : undefined;
        this.upCallback = option ? option.upCallback : undefined;
        
        document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);
        document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.dragCallback, false);
        
    };
    
    ORYX.Core.UIDragCallback = function(event){
    
        var position = {
            x: Event.pointerX(event) - this.offSetPosition.x,
            y: Event.pointerY(event) - this.offSetPosition.y
        }
        
        position.x -= this.offsetScroll.x - this.scrollNode.scrollLeft;
        position.y -= this.offsetScroll.y - this.scrollNode.scrollTop;
        
        position.x /= this.faktorXY.x;
        position.y /= this.faktorXY.y;
        
        this.uiObj.bounds.moveTo(position);
        //this.uiObj.update();
        
        if (this.movedCallback) 
            this.movedCallback(event);
        
        Event.stop(event);
        
    };
    
    ORYX.Core.UIDisableDrag = function(event){
        document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.dragCallback, false);
        document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);
        
        if (this.upCallback) 
            this.upCallback(event);
        
        this.upCallback = undefined;
        this.movedCallback = undefined;
        
        Event.stop(event);
    };
    
    
    
    /**
     * Implementation of a stand alone drag drop of svg nodes
     * @param {Event} event
     * @param {HTMLElement} node
     * @param {Object} option Define movedCallback and upCallback to handle special behavior
     *
     */
    ORYX.Core.SVGEnableDrag = function(event, node, option) {

        // Only one dragging can be active
        ORYX.Core.SVGDisableDrag(event);
        
        //Event.stop(event);
        
        var point = {
            x : Event.pointerX(event),
            y : Event.pointerY(event)
        }
        
        this.node = node;
        var upL;
        try {
            
            var ctm = node.getCTM();
            var bb = node.getBBox();
            var up = ORYX.Core.Math.getTranslatedPoint(bb, ctm);
            if (Math.abs(ctm.b)<1e-6&&Math.abs(ctm.c)<1e-6){
                upL = up;
            } else {
                var sctm = node.getScreenCTM()
                upL = {x:point.x-(sctm.e-ctm.e)-(bb.width/2), y:point.y-(sctm.f-ctm.f)-(bb.height/2)};
            }
            
            upL.x -= node.parentNode.getCTM().e;
            upL.y -= node.parentNode.getCTM().f;
            
        } catch(e){
            upL = node.getBBox();
        }
        var a = node.parentNode.getCTM();
        this.faktorXY = {x:a.a, y: a.d};
        this.scrollNode = node.ownerSVGElement.parentNode.parentNode;
        this.offsetScroll = {x:this.scrollNode.scrollLeft, y:this.scrollNode.scrollTop};
            
        
        this.offSetPosition =  {
            x: point.x - (upL.x),
            y: point.y - (upL.y)};
        
        this.dragCallback = ORYX.Core.SVGDragCallback.bind(this);
        this.disableCallback = ORYX.Core.SVGDisableDrag.bind(this);
    
        this.movedCallback = option ? option.movedCallback : undefined;
        this.upCallback = option ? option.upCallback : undefined;
        this.adjustPosition = (option ? option.adjustPosition : undefined) || function(e){ return e; }; 
        
        document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE,  this.dragCallback , true);
        document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);
    
    };
    
    ORYX.Core.SVGDragCallback = function(event) {

        Event.stop(event);
        
        var position = {
            x: Event.pointerX(event) - this.offSetPosition.x,
            y: Event.pointerY(event) - this.offSetPosition.y}
    
        position.x  -= this.offsetScroll.x - this.scrollNode.scrollLeft; 
        position.y  -= this.offsetScroll.y - this.scrollNode.scrollTop;
        position.x /= this.faktorXY.x;
        position.y /= this.faktorXY.y;
        
        position.x = Math.floor(position.x);
        position.y = Math.floor(position.y);
        
        position = this.adjustPosition(position, event);

        if (position === false){
            return;
        }   
        
        this.node.setAttribute("transform", ["translate(", Math.floor(position.x), ", ", Math.floor(position.y) ,")"].join(""));
    
        if(this.movedCallback)
            this.movedCallback(event, position);
        
        
        // Cache last position
        this.lastPosition = position;
    
    };
    
    ORYX.Core.SVGDisableDrag = function(event) {
        document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.dragCallback, true);
        document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);
        
        if(this.upCallback)
            this.upCallback(event, this.lastPosition);
            
        delete this.upCallback;
        delete this.movedCallback;      
        delete this.lastPosition;       
        
        //Event.stop(event);    
    };


    
}();




new function(){

    /**
     * Overwrites the getLocation method, so that the 
     * parent which might have some scrollbars adds the 
     * scroll position to the location. If the canvas was
     * scrolled, out of the shaperepositories, the shapes
     * was wrong positioned.
     * 
     * @overwrite
     */
    Ext.dd.DragDropMgr.getLocation = function(oDD) {
        if (! this.isTypeOfDD(oDD)) {
            return null;
        }
        var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;

        try {
            pos= Ext.lib.Dom.getXY(el);
        } catch (e) { }

        if (!pos) {
            return null;
        }
        
        // Decrease position by its scroll parent
        var scrollParent = Ext.get(el).parent("div{overflow=auto}");
        if (scrollParent){
            pos[0] += scrollParent.dom.scrollLeft;
            pos[1] += scrollParent.dom.scrollTop;
            
            // Use transform element of scrolling element
            var scrollEl = scrollParent.dom.firstChild;
            if (scrollEl && (scrollEl.style.MozTransform || scrollEl.style.webkitTransform)){
                try {
                    var obj = (scrollEl.style.MozTransform || scrollEl.style.webkitTransform || "").replace(/(.*translate.+?)([-0-9]+)(.*?)([-0-9]+)(.*)/i, "{x:$2, y:$4}");
                    obj = obj.startsWith("{") ? obj.evalJSON() : {};
                    if (obj && "undefined" != typeof obj.x && "undefined" != typeof obj.y){
                        pos[0] -= obj.x;
                        pos[1] -= obj.y;
                    }
                } catch(e){}
            }
        }

        x1 = pos[0];
        x2 = x1 + el.offsetWidth;
        y1 = pos[1];
        y2 = y1 + el.offsetHeight;

        t = y1 - oDD.padding[0];
        r = x2 + oDD.padding[1];
        b = y2 + oDD.padding[2];
        l = x1 - oDD.padding[3];
        
        return new Ext.lib.Region( t, r, b, l );
    };

    
    /**
     * Implementation of a special drag handler
     * 
     * @class
     */
    ORYX.Core.DragZone = function(el, facade){
        this.facade = facade;
        ORYX.Core.DragZone.superclass.constructor.call(this, el, {shadow: !Ext.isMac});
        
        // Init snap to grid
        this.snap = new ORYX.Core.SnapToGrid(facade);
        // Init selected rect
        this.rectangle = new ORYX.Core.SelectedRect(this.facade.getCanvas().getSvgContainer(), {"stroke-opacity":0.5});
        
        // Show grid line if enabled
        if (ORYX.CONFIG.SHOW_GRIDLINE) {
            this.vLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_VERTICAL);
            this.hLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_HORIZONTAL);
        }
        
    };

    ORYX.Core.DragZone.HIGHLIGHT_ATTACH = "shaperepositoy.attach";
    ORYX.Core.DragZone.HIGHLIGHT_ADD = "shaperepositoy.add";
    ORYX.Core.DragZone.HIGHLIGHT_CONNECTBETWEEN = "shaperepositoy.connect";
    ORYX.Core.DragZone.OVERLAY_POOLDOCKING = "poollanecreation.overlay";
    
    Ext.extend(ORYX.Core.DragZone, Ext.dd.DragZone, {
        
        validBoundaries: ["node", "edge"],
        
        afterDragDrop: function(){  /* Can be overwritten */},
        afterDragOver: function(){  /* Can be overwritten */},
        afterDragEnter: function(){ /* Can be overwritten */},
        afterValidDrop: function(){ /* Can be overwritten */},
        
        canAttach: function(shapes, stencil){
            return this.facade.getRules().canConnect({
                                        sourceShape     : shapes[0],
                                        edgeStencil     : stencil,
                                        targetStencil   : stencil
                                    }); 
        },

        canContain: function(shapes, stencil){
            return this.facade.getRules().canContain({
                                        containingShape     : shapes[0], 
                                        containedStencil    : stencil
                                    }); 
        },
        
        canConnectBetween: function(shapes, stencil){
            return this.facade.getRules().canConnect({                                              // Source to Stencil
                                                    sourceShape     : shapes[0].getSource(),
                                                    edgeShape       : shapes[0],
                                                    targetStencil   : stencil
                                                }) &&   
                                                this.facade.getRules().canConnect({                 // Stencil to Target
                                                    sourceStencil   : stencil,
                                                    edgeShape       : shapes[0],
                                                    targetShape     : shapes[0].getTarget()
                                                }) && 
                                                this.facade.getRules().canContain({
                                                    containingShape     : shapes[1], 
                                                    containedStencil    : stencil
                                                }); 
        },
        
        canConnect: function(){
            return undefined;
        },

    
        onInitDrag: function(){
            this.bounds = this.getBounds() || false;
            
            if (this.bounds){
                // Set snap parameters
                this.snap.setScale(this.getScale());
                this.snap.setReferenceBounds(this.bounds);          
                this.snap.setReferenceShapes();
                
                // Get shape to consider for snapping
                if (this.snapTimer)
                    window.clearTimeout(this.snapTimer)
                
                this.snapTimer = window.setTimeout(function(){
                    this.snap.setReferenceShapes(this.getSnapReferencedShapes(), true);
                }.bind(this), 1);
                    
            }
            
            delete this.cachedTarget;
            delete this._canAttach; delete this._canContain;
            delete this._canConnectBetween; delete this._canConnect;
            delete this._lastOverElement; delete this._lastOverElements;
            delete this.isDragOver;         
            this.initIntervalDragOver = true;
            
            return ORYX.Core.DragZone.superclass.onInitDrag.apply(this, arguments);
        },
        
        onDrag: function(evt){
            
            if (this.rectangle){
                // Scroll the rectangle into the view
                this.rectangle.scrollIntoView(evt, this.onDrag.bind(this), this.initIntervalDragOver);
            }
            
            if (!this.rectangle||!this.bounds||this.rectangle.hidden){ 
                return;
            }
            
            
            var position = this.getNormalizedXY(evt);
            var modifierKeyPressed = evt.altKey || evt.ctrlKey;
            if (!modifierKeyPressed)
                position = this.snapPosition(position);
            var scale = this.getScale();
            this.bounds.moveTo(position.x/scale,position.y/scale);
             
            if (this._lastOverElement) {
                this.rectangle.resize(this.bounds);
            }
        },
        
        // private (@overwrite)
        onDragOver : function(e, id){
            var target = this.cachedTarget || Ext.dd.DragDropMgr.getDDById(id);
            if(this.beforeDragOver(target, e, id) !== false){
                
                this.isDragOver = true;
                window.setTimeout(function(){ delete this.initIntervalDragOver;}.bind(this), 1000)
                
                if (this._canAttach || this._canContain || this._canConnectBetween || this._canConnect){
                    this.setAllowed();
                } else {
                    this.setNotAllowed();
                }
                this.updateHighlight(e);
    
                if(this.afterDragOver){
                    this.afterDragOver(target, e, id);
                }
            }
        },
        
        
        hide: function(){
            
            this.rectangle.hide();
            this.highlightShape();
            
            if (this.vLine)
                this.vLine.hide();
            if (this.hLine)
                this.hLine.hide();
        },
        
        show: function(){
            this.rectangle.show();
        },
        
                
        /**
         * Set the proxy to an allowed state
         *
         */
        setAllowed: function(){
            var pr = this.getProxy();
            pr.setStatus(pr.dropAllowed);
            pr.sync();
        },

        /**
         * Set the proxy to an invalid state
         *
         */
        setNotAllowed: function(){
            var pr = this.getProxy();
            pr.setStatus(pr.dropNotAllowed);
            pr.sync();
        },
        
        /**
         * Returns the stencil which 
         * gets dragged currently
         * @return {ORYX.Core.Stencil}
         */
        getDraggedStencil: function(target){
            var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);
            var stencilSet = this.facade.getStencilSets()[option.namespace];
            return stencilSet.stencil(option.type);
        },
        
        
        highlightShape: function(id, element, style, color, coords){
            
            if (id !== undefined){
                // Show Highlight
                this.facade.raiseEvent({
                    type        : ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,
                    highlightId : id,
                    elements    : [element],
                    style       : style,
                    color       : color,
                    coords      : coords
                });
            }

            
            // Hide others
            [ORYX.Core.DragZone.HIGHLIGHT_ATTACH, ORYX.Core.DragZone.HIGHLIGHT_ADD, ORYX.Core.DragZone.HIGHLIGHT_CONNECTBETWEEN, ORYX.Core.DragZone.OVERLAY_POOLDOCKING].each(function(cId){
                if (cId !== id){
                    this.facade.raiseEvent({
                        type        : ORYX.CONFIG.EVENT_POOLDOCKING_HIDE,
                        highlightId : cId    
                    });
                    
                    this.facade.raiseEvent({
                        type        : ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
                        highlightId : cId
                    });
                }
            }.bind(this));
            
                        
        },
        
        updateHighlight: function(evt){
            
            // IF OVER CANVAS
            if (this._lastOverElement&&this._lastOverElement instanceof ORYX.Core.Canvas){
                this.highlightShape();
            
            // IF ATTACH
            } else if (this._canAttach === true && this._lastOverElement){
                this.highlightShape(
                        ORYX.Core.DragZone.HIGHLIGHT_ATTACH,
                        this._lastOverElement,
                        ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE,
                        ORYX.CONFIG.SELECTION_VALID_COLOR
                    );
            
            // IF ADD OR CONNECT OR CONNECT BETWEEN
            //XXX Drag Lanes?
            } else if(this._canContain !== undefined || this._canConnectBetween !== undefined  || this._canConnect !== undefined && this._lastOverElement){
                this.highlightShape(
                        ORYX.Core.DragZone.HIGHLIGHT_ADD,
                        this._lastOverElement,
                        undefined,
                        this._canContain || this._canConnectBetween || this._canConnect ? ORYX.CONFIG.SELECTION_VALID_COLOR : ORYX.CONFIG.SELECTION_INVALID_COLOR);     
            } else {
                this.highlightShape();
            }
        },
        
        setOptions: function(options){
            Ext.apply(Ext.dd.Registry.getHandle(this.DDM.currentTarget), options);
        },
        
        getOptions: function(){
            return Ext.dd.Registry.getHandle(this.DDM.currentTarget);
        },
        
        updateOptions: function(options, event){
            
            // Can...
            options.canContain          = !!this._canContain;
            options.canAttach           = !!this._canAttach;
            options.canConnectBetween   = !!this._canConnectBetween;
            options.canConnect          = !!this._canConnect;
            
            // Update position
            var pos;
            try {
                pos = this.bounds.center(); 
            } catch(e){
                pos = this.getNormalizedXY(event);
            }
                        
            // Add parent
            if (this._canContain&&!this._canAttach&&!this._canConnectBetween&&this._lastOverElement){
                options.parent = this._lastOverElement;
            } else {
                delete options.parent;
            }

            // Add connect between
            if (this._canConnectBetween&&!this._canAttach&&this._lastOverElement){
                options.parent = this.getCandidatesAtPosition(pos)[1];
                var seg = this._lastOverElement.findSegment(pos);
                if (seg){
                    pos = ORYX.Core.Math.getPointOfIntersectionPointLine(seg.fromDocker.bounds.center(), seg.toDocker.bounds.center(), pos);
                }
            }
                        
            // Update offset
            if (options.parent){
                // Correct position of parent
                var parentAbs = options.parent.absoluteXY();
                pos.x -= parentAbs.x; pos.y -= parentAbs.y;
            }

            // If connect
            if (this._canConnect){
                options.parent = this._lastOverElement;
            }
                
            // Set position
            options.position = pos
            
            return options;
        },
        
        // private
        beforeDragDrop: function(){ },
        
        // private
        beforeDragEnter: function(){
            if (!this.rectangle||!this.bounds){
                return;
            }
            this.show()
        },
        
        // private
        beforeDragOut: function(){
            // Remove last selected element
            delete this._lastOverElement;
            delete this.isDragOver;
            this.initIntervalDragOver = true;
            
            if (!this.rectangle||!this.bounds){
                return;
            }
            this.hide();
        },

        getCandidatesAtPosition: function(coord){

            var shapes = this.facade.getCanvas().getAbstractShapesAtPosition( coord ), self = this;
            
            return shapes.reverse().findAll(function(candidate) {
                            return (candidate instanceof ORYX.Core.Canvas 
                                    || candidate instanceof ORYX.Core.Node
                                    || candidate instanceof ORYX.Core.Edge)
                                    && self.facade.getRules().isContainable(candidate);
                        });
        },
                
        // private
        beforeDragOver: function(target, event){
        
            var coord = this.facade.eventCoordinates(event.browserEvent);
    
            // Get the upper element    
            var parentCandidates = this.getCandidatesAtPosition(coord);
                
            if(parentCandidates.length === 0) {
                return;
            }   
                
            // Get the current stencil
            var stencil = this.getDraggedStencil(target);
                        
            // If the stencil is not containable, use only canvas
            if (!this.facade.getRules().isContainable(stencil)){
                parentCandidates = [parentCandidates.last()];
            }
            
            // Get candidate
            var parentCandidate = parentCandidates.first();
            
            if (parentCandidate !== this._lastOverElement || this._lastOverElements.length !== parentCandidates.length || this._lastOverElements.any(function(s){ return !parentCandidates.include(s) })){
                delete this._canAttach;
                delete this._canContain;
                delete this._canConnectBetween;
                delete this._canConnect;
                this._lastOverElement = parentCandidate;
                this._lastOverElements = parentCandidates;
            
            } else if(parentCandidate === this._lastOverElement && (stencil.type() === "edge" || this._canAttach === false)){
                return;
            }
            
            if (!parentCandidate){
                this.updateHighlight();
                this.setNotAllowed();
                return;
            }
    
            // Node
            if(stencil.type() === "node") {
                
                /** 
                 * Check Attachments
                 */
                if (parentCandidate instanceof ORYX.Core.Node && parentCandidate.isPointOverOffset(coord.x, coord.y) && this._canAttach === undefined) {
                    this._canAttach = this.canAttach(parentCandidates, stencil);
                    delete this._canContain;        
                }
                
                /** 
                 * Check Containment
                 */
                if (this._canContain === undefined && (!this._canAttach || (parentCandidate instanceof ORYX.Core.Node && !parentCandidate.isPointOverOffset(coord.x, coord.y)))) {
                    this._canContain = this.canContain(parentCandidates, stencil);
                    delete this._canAttach;
                }
                
                
                /** 
                 * Check Connect between (if candidate is an edge)
                 */
                if (parentCandidate instanceof ORYX.Core.Edge && this._canConnectBetween === undefined && this._canContain !== true && this._canAttach !== true) {
                    this._canConnectBetween = this.canConnectBetween(parentCandidates, stencil);
                }
    
            // Edge
            } else { 
                
                /** 
                 * Check Connect
                 */
                if (this._canConnect === undefined) {
                    this._canConnect = this.canConnect(parentCandidates, stencil);
                }
                
                if (this._canConnect === undefined){
                    this._canContain = true;
                    this._lastOverElement = this.facade.getCanvas();
                }
            }
        },
        
        // private (@overwrite)
        onDragDrop : function(e, id){
            
            var target = this.cachedTarget || Ext.dd.DragDropMgr.getDDById(id);
            this.cachedTarget = false;
            this.proxy.hide();
            
            var option = this.updateOptions(Ext.dd.Registry.getHandle(target.DDM.currentTarget), e);
            option = Object.clone(option);
            
            if(this.beforeDragDrop(target, e, id) !== false){
                if(target.isNotifyTarget){
                    if(this.getProxy().dropStatus === this.getProxy().dropAllowed && this._lastOverElement){ // valid drop?
                        this.onValidDrop(option, this._lastOverElement, e);
                    }else{
                        this.hide();
                        this.onInvalidDrop(target, e, id);
                    }
                }else{
                    this.onValidDrop(target, e, id);
                }
                
                if(this.afterDragDrop){
                    this.afterDragDrop(target, e, id);
                }
            }
            
            delete this.cachedTarget;
            delete this._canAttach; delete this._canContain;
            delete this._canConnectBetween; delete this._canConnect;
            delete this._lastOverElement; delete this._lastOverElements;
        },
        
        onValidDrop : function(option, shape, event){
            this.hideProxy();
            if(this.afterValidDrop){
                window.setTimeout(function(){
                    this.afterValidDrop.apply(this, arguments);         
                    this.hide();
                }.bind(this, option, shape, event), 1);
            }
        },
        
        // private (@overwrite)
        afterRepair: function(){
            this.dragging = false;
        },
            
        /**
         *
         * @return {Array} Shapes which should be considered for snapping
         */ 
        getSnapReferencedShapes: function(){
                
            return this.facade.getCanvas().getChildShapes(true);
            
        },
        
        /**
         *
         * @return {Object} Returns a x/y coordinate normalized to the canvas
         */
        getNormalizedXY: function(evt){
            
            var xy = evt.getXY();
            var pos = {x: xy[0], y: xy[1]};
    
            var a = this.facade.getCanvas().node.getScreenCTM();
            
            if (Ext.isIE9){
                var sn = Ext.fly(this.facade.getCanvas().getScrollNode().firstChild);
                a.e = sn.getLeft()+4;
                a.f = sn.getTop()+4;
            }
            
            // Correcting the UpperLeft-Offset
            pos.x -= a.e; pos.y -= a.f;
            // Correcting the Zoom-Faktor
            //pos.x /= a.a; pos.y /= a.d;
            
            var scale = this.getScale();
            
            var mid = this.bounds ? this.bounds.midPoint() : {x:0, y:0};
            
            // Set that the position is not lower than zero
            pos.x = Math.max( mid.x*scale , pos.x );
            pos.y = Math.max( mid.y*scale , pos.y );
    
            // Set that the position is not bigger than the canvas
            var c = this.facade.getCanvas();
            pos.x = Math.min( (c.bounds.width() - mid.x)*scale,     pos.x);
            pos.y = Math.min( (c.bounds.height() - mid.y)*scale,    pos.y);


            return pos;
        },
        
        snapPosition: function(pos){
    
            var scale = this.getScale();
            
            // Adjust by midpoint
            var mid = this.bounds.midPoint();
            pos.x -= mid.x*scale; pos.y -= mid.y*scale;
            
            var hor, ver;
            var onHor = function(x){hor = x}.bind(this);
            var onVer = function(y){ver = y}.bind(this);
            pos = this.snap.adjustPoint(pos, onHor, onVer);
            
            if (this.hLine&&this.vLine){
                if (hor === undefined){ this.hLine.hide() } else { this.hLine.update(hor) }
                if (ver === undefined){ this.vLine.hide() } else { this.vLine.update(ver) }
            }
        
            return pos;

        },
        
        /**
         * Return the scale factor of the canvas
         * @return {int}
         */
        getScale: function(){
            try {
                return this.facade.getCanvas().node.transform.baseVal.getItem(0).matrix.a;
            } catch(e) {
                return 1;
            }
        },
    
        /**
         * Return the bounds of a new shape
         * @return {ORYX.Core.Bounds}
         */
        getBounds: function(){

            var option = Ext.dd.Registry.getHandle(this.DDM.currentTarget);
            var stencil = this.facade.getStencilSets()[option.namespace].stencil(option.type);
            
            if (!this.validBoundaries.include(stencil.type())){
                return;
            }
            
            return new ORYX.Core.Node({}, stencil).bounds.clone();
        }

    });
    
    var SIZESNAPGROUPS = new Hash();
    SIZESNAPGROUPS["http://b3mn.org/stencilset/bpmn2.0#"] = [
        ["Task", "CollapsedSubprocess", "Subprocess", "CollapsedEventSubprocess", "EventSubprocess"],
        ["Pool", "VerticalPool", "CollapsedPool", "CollapsedVerticalPool"],
        ["Lane", "VerticalLane"],
        ["Group"],
        ["DataObject"]
    ];
    SIZESNAPGROUPS["http://b3mn.org/stencilset/bpmn2.0choreography#"] = [
        ["ChoreographyTask", "ChoreographySubprocessCollapsed", "ChoreographySubprocessExpanded"],
        ["ChoreographyParticipant"],
        ["Group"]
    ];
    SIZESNAPGROUPS["http://www.signavio.com/stencilsets/processmap#"] = [
        ["Process", "ProcessCollapsed"],
        ["TextNote"],
        ["Group"]
    ];
    SIZESNAPGROUPS["http://b3mn.org/stencilset/epc#"] = [
        ["Event", "Function", "ProcessInterface"],
        ["Organization", "Position", "Data", "System"],
        ["TextNote"]
    ];
    SIZESNAPGROUPS["http://www.signavio.com/stencilsets/organigram#"] = [
        ["TextNote"]
    ];
    
    /**
     * Implementation of some helper methods
     * for snap to grid. Mainly to adjust a point
     * to the currently related shapes.
     * @class ORYX.Core.SnapToGrid
     * 
     */
    ORYX.Core.SnapToGrid = Clazz.extend({
    
        construct: function(facade){
            this.points = [];
            this.scale = 1;
            this.bounds = undefined;
            this.facade = facade;
            this.ulThres = 6;
            this.cThres     = 16;
            this.lrThres = 6;
        },
        
        setReferenceShapes: function(shapes, dontExcludeSelection, forceExecution){
            
            if (this.timer)
                window.clearTimeout(this.timer);
                
            this.points = [];
            this.widths = new Hash();
            this.heights = new Hash();
            
            if (!(shapes instanceof Array) || shapes.length == 0){
                return;
            }
            
            var selection = this.facade ? this.facade.getSelection() : [];
            
            
            // define callback set the referencing shapes
            var setClb = function(){
                
                var includeInSnapping = function(shape) { 
                    if(selection.size()!=1) return false;
                    if(!shape.isResizable) return false;
                    var ssg = SIZESNAPGROUPS[shape.getStencil().namespace()]; // quick fix (should be rewritten soon) 
                    if(!ssg) return true;
                    return ssg.any(function(g) {
                        return g.include(shape.getStencil().idWithoutNs()) && g.include(selection[0].getStencil().idWithoutNs());
                    }) || ssg.all(function(g) {
                        return !g.include(shape.getStencil().idWithoutNs()) && !g.include(selection[0].getStencil().idWithoutNs());
                    });
                }
                
                var minDistW = new Hash();
                var minDistH = new Hash();
                // For all shapes
                shapes.each((function(value) {
                    if(!(value instanceof ORYX.Core.Edge)) {
                        var ul      = value.absoluteXY();
                        var width   = value.bounds.width();
                        var height  = value.bounds.height();
                        
                        if(!selection.include(value) || dontExcludeSelection) { 
                            // Add the upperLeft, center and lowerRight - Point to the distancePoints
                            this.points.push({
                                ul: {
                                    x: ul.x,
                                    y: ul.y
                                },
                                c: {
                                    x: ul.x + Math.round(width / 2),
                                    y: ul.y + Math.round(height / 2)
                                },
                                lr: {
                                    x: ul.x + width,
                                    y: ul.y + height
                                }
                            });
                        }
                        
                        // only store sizes of shapes from the same stencilset group
                        if(!selection.include(value) && includeInSnapping(value)) {
                            var dist = ORYX.Core.Math.getDistancePointToPoint(value.absoluteCenterXY(), selection[0].absoluteCenterXY());
                            if ("undefined" == typeof minDistW[width] || dist < minDistW[width]) {
                                minDistW[width] = dist;
                                this.widths[width] = [value];
                            }
                            if ("undefined" == typeof minDistH[height] || dist < minDistH[height]) {
                                minDistH[height] = dist;
                                this.heights[height] = [value];
                            }
                        }   
                        
                    }
                }).bind(this));
                
            };
            
            
            // execute immediately or asynchronous
            if(!forceExecution) {
                this.timer = window.setTimeout(setClb.bind(this), 1);
            } else {
                var clb = setClb.bind(this);
                clb();
            }
        },
        
        setReferenceBounds: function(bounds){
            this.bounds = bounds || undefined;
        },
    
        setScale: function(scale){
            this.scale = scale || 1;
        },
            
        adjustPoint: function(point, adjustedYClb, adjustedXClb){
            
            // Get the current Bounds
            var bounds = this.bounds;
            if (!bounds){
                return;
            }
            
            var ulThres = this.ulThres;
            var cThres  = this.cThres;
            var lrThres = this.lrThres;
    
            var scale = this.scale;
            
            var ul  = { x: (point.x/scale), y: (point.y/scale)};
            var c   = { x: (point.x/scale) + (bounds.width()/2), y: (point.y/scale) + (bounds.height()/2)};
            var lr  = { x: (point.x/scale) + (bounds.width()), y: (point.y/scale) + (bounds.height())};
    
            var offsetX, offsetY;
            var gridX, gridY;
            
            // For each distant point
            this.points.each(function(value) {
                var x, y, gx, gy;
                if (Math.abs(value.c.x-c.x) < cThres){
                    x = value.c.x-c.x;
                    gx = value.c.x;
                }/* else if (Math.abs(value.ul.x-ul.x) < ulThres){
                    x = value.ul.x-ul.x;
                    gx = value.ul.x;
                } else if (Math.abs(value.lr.x-lr.x) < lrThres){
                    x = value.lr.x-lr.x;
                    gx = value.lr.x;
                } */
                
    
                if (Math.abs(value.c.y-c.y) < cThres){
                    y = value.c.y-c.y;
                    gy = value.c.y;
                }/* else if (Math.abs(value.ul.y-ul.y) < ulThres){
                    y = value.ul.y-ul.y;
                    gy = value.ul.y;
                } else if (Math.abs(value.lr.y-lr.y) < lrThres){
                    y = value.lr.y-lr.y;
                    gy = value.lr.y;
                } */
    
                if (x !== undefined) {
                    offsetX = offsetX === undefined ? x : (Math.abs(x) < Math.abs(offsetX) ? x : offsetX);
                    if (offsetX === x)
                        gridX = gx;
                }
    
                if (y !== undefined) {
                    offsetY = offsetY === undefined ? y : (Math.abs(y) < Math.abs(offsetY) ? y : offsetY);
                    if (offsetY === y)
                        gridY = gy;
                }
            });

            if (offsetX !== undefined) {
                ul.x += offsetX;    
                ul.x *= scale;
                if (gridX!==undefined&&adjustedXClb instanceof Function)
                    adjustedXClb(gridX);
            } else {
                ul.x = (point.x - (point.x % (ORYX.CONFIG.GRID_DISTANCE/2)));
            }
            
            if (offsetY !== undefined) {    
                ul.y += offsetY;
                ul.y *= scale;
                /*if (this.hLine&&gridY)
                    this.hLine.update(gridY);*/
                if (gridY!==undefined&&adjustedYClb instanceof Function)
                    adjustedYClb(gridY);
            } else {
                ul.y = (point.y - (point.y % (ORYX.CONFIG.GRID_DISTANCE/2)));
            }
            
            return ul;
        },
        
        adjustBounds: function(bounds, orientation, aspectRatio, adjustedWidthClb, adjustedHeightClb, startBounds, widing){
            bounds = bounds.clone();
            
            var wThres = 12;
            var hThres = 12;
            var pThres = 12;
    
            var scale = this.scale;
    
            var offsetX, offsetY;
            var snapPointX, snapPointY;
            
            // For each width
            this.widths.each(function(pair) {
    
                var x, gx;
                if (Math.abs(bounds.width()-pair.key) < wThres){
                    x = pair.key-bounds.width();
                }
    
                if (x !== undefined) {
                    offsetX = offsetX === undefined ? x : (Math.abs(x) < Math.abs(offsetX) ? x : offsetX);
                }
    
            });
            
            // For each height
            this.heights.each(function(pair) {
    
                var y;
                if (Math.abs(bounds.height()-pair.key) < hThres){
                    y = pair.key-bounds.height();
                }
    
                if (y !== undefined) {
                    offsetY = offsetY === undefined ? y : (Math.abs(y) < Math.abs(offsetY) ? y : offsetY);
                }
    
            });

            var excludedSelf = false;
            
            // For each snap point corresponding to resize direction
            var p = (orientation=="northwest") ? bounds.upperLeft() : bounds.lowerRight();
            
            var startPoint = {
                ul: {
                    x: startBounds.upperLeft().x,
                    y: startBounds.upperLeft().y
                },
                c: {
                    x: startBounds.center().x,
                    y: startBounds.center().y
                },
                lr: {
                    x: startBounds.lowerRight().x,
                    y: startBounds.lowerRight().y
                }
            };
            this.points.concat([startPoint]).each(function(value) {

                var x, y, gx, gy;
                var vp = (orientation=="northwest") ? value.ul : value.lr;
                
                var showSnapLine = true;
                // don't show snap lines when snapping back to the old size
                if(value.ul.x==startBounds.upperLeft().x && value.ul.y==startBounds.upperLeft().y 
                                && value.lr.x==startBounds.lowerRight().x && value.lr.y==startBounds.lowerRight().y) {
                    if(!excludedSelf) {
                        excludedSelf = true;
                        showSnapLine = false;
                    }
                }
                
                if (Math.abs(vp.x-p.x) < pThres){
                    x = (orientation=="northwest") ? (p.x-vp.x) : (vp.x-p.x);
                    gx = vp.x;
                }
                
                if (Math.abs(vp.y-p.y) < pThres){
                    y = (orientation=="northwest") ? (p.y-vp.y) : (vp.y-p.y);
                    gy = vp.y;
                }
                
                if (x !== undefined) {
                    if(widing) x = 2*x;
                    offsetX = offsetX === undefined ? x : (Math.abs(x) <= Math.abs(offsetX) ? x : offsetX);
                    if (offsetX==x && showSnapLine)
                        snapPointX = gx;
                }
                
                if (y !== undefined) {
                    if(widing) y = 2*y;
                    offsetY = offsetY === undefined ? y : (Math.abs(y) <= Math.abs(offsetY) ? y : offsetY);
                    if (offsetY==y && showSnapLine)
                        snapPointY = gy;
                }

            });
            
            var exWidthClb, exHeightClb;
            var similarShapesW, similarShapesH;
            
            if(aspectRatio) { // snap, but keep aspect ratio
                var arX, arY;

                if(offsetX!==undefined && offsetY!==undefined) {
                    if(offsetY<offsetX) {
                        arX = (this.orientation==="northwest") ? -(aspectRatio * (bounds.height()-offsetY) - bounds.width()) : (aspectRatio * (bounds.height()+offsetY) - bounds.width());
                        arY = offsetY;
                    } else {
                        arX = offsetX;
                        arY = (this.orientation==="northwest") ? -((bounds.width()-offsetX) / aspectRatio - bounds.height()) : ((bounds.width()+offsetX) / aspectRatio - bounds.height());
                    }
                    exWidthClb = true;
                    exHeightClb = true;
                } else if(offsetX!==undefined && offsetY===undefined && snapPointX) {
                    arX = offsetX;
                    arY = (this.orientation==="northwest") ? -((bounds.width()-offsetX) / aspectRatio - bounds.height()) : ((bounds.width()+offsetX) / aspectRatio - bounds.height());
                    exWidthClb = true;
                } else if(offsetX===undefined && offsetY!==undefined && snapPointY) {
                    arX = (this.orientation==="northwest") ? -(aspectRatio * (bounds.height()-offsetY) - bounds.width()) : (aspectRatio * (bounds.height()+offsetY) - bounds.width());
                    arY = offsetY;
                    exHeightClb = true;
                } else {//if(offsetX===undefined && offsetY===undefined) {
                    /*offsetX = -(bounds.width() % (ORYX.CONFIG.GRID_DISTANCE/2));
                    if(this.orientation==="northwest") offsetX = -offsetX;
                    arX = offsetX;
                    arY = (this.orientation==="northwest") ? -((bounds.width()-offsetX) / aspectRatio - bounds.height()) : ((bounds.width()+offsetX) / aspectRatio - bounds.height());
                    */
                    arX = 0; arY = 0;
                }
        
                bounds.extend({x:arX, y:arY});
                if(widing && orientation=="southeast") bounds.moveBy({x:-(arX/2), y:-(arY/2)});
                else if(widing && orientation=="northwest") bounds.moveBy({x:-(arX/2), y:-(arY/2)});
                else if(orientation=="northwest") bounds.moveBy({x:-arX, y:-arY});
                                
                if(this.widths.keys().include(bounds.width()))
                    similarShapesW = this.widths[bounds.width()];
                
                if(this.heights.keys().include(bounds.height()))
                    similarShapesH = this.heights[bounds.height()];
                
            } else { // default snapping
                
                if (offsetX !== undefined) {
                    bounds.extend({x:offsetX, y:0});
                    if(widing && orientation=="southeast") bounds.moveBy({x:-(offsetX/2), y:0});
                    else if(widing && orientation=="northwest") bounds.moveBy({x:-(offsetX/2), y:0});
                    else if(orientation=="northwest") bounds.moveBy({x:-offsetX, y:0});

                    if(this.widths.keys().include(bounds.width()))
                        similarShapesW = this.widths[bounds.width()];
                    exWidthClb = true;
                } /*else {
                    offsetX = -(bounds.width() % (ORYX.CONFIG.GRID_DISTANCE/2));
                    if(this.orientation==="northwest") offsetX = -offsetX;
                    bounds.extend({x:offsetX, y:0});
                    if(orientation=="northwest") bounds.moveBy({x:-offsetX, y:0});
                }*/

                if (offsetY !== undefined) {
                    bounds.extend({x:0, y:offsetY});
                    if(widing && orientation=="southeast") bounds.moveBy({x:0, y:-(offsetY/2)});
                    else if(widing && orientation=="northwest") bounds.moveBy({x:0, y:-(offsetY/2)});
                    else if(orientation=="northwest") bounds.moveBy({x:0, y:-offsetY});
                    if(this.heights.keys().include(bounds.height()))
                        similarShapesH = this.heights[bounds.height()];
                    exHeightClb = true;     
                } /*else {
                    offsetY = -(bounds.height() % (ORYX.CONFIG.GRID_DISTANCE/2));
                    if(this.orientation==="northwest") offsetY = -offsetY;
                    bounds.extend({x:0, y:offsetY});
                    if(orientation=="northwest") bounds.moveBy({x:0, y:-offsetY});
                }*/

            }

            // execute callbacks
            if(exWidthClb && (adjustedWidthClb instanceof Function)) 
                adjustedWidthClb(bounds, similarShapesW, snapPointX);
            if(exHeightClb && (adjustedHeightClb instanceof Function))
                adjustedHeightClb(bounds, similarShapesH, snapPointY);
                
            return bounds;
        }
        
    });
    
}();

new function(){
    
    // Global timer, to prevent
    // that multiple times this get called
    var timer;
    
    /**
     * Implementation of a selection rectangle
     * Mainly to show current selection or drag area
     * @class
     * 
     */
    ORYX.Core.SelectedRect = Clazz.extend({
    
        construct: function(parentId, options) {
    
            this.parentId = parentId;
    
            this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", $(parentId),
                        ['g']);
    
            this.dashedArea = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,
                ['rect', Ext.apply({x: 0, y: 0,
                    'fill'              : 'none',
                    'stroke'            : '#777777', 
                    'stroke-width'      : 1, 
                    'stroke-dasharray'  : '3,3',
                    'shape-rendering'   : 'crispEdges',
                    'pointer-events'    : 'none'}, options ||{})]);
    
            this.hide();
            
            this.extNode = Ext.get(this.node);
            this.scrollElement = Ext.get(this.node).parent(".x-panel-body");
    
        
            document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, function(){
                window.clearTimeout(timer);
            }, true);
        },
    
        hide: function() {
            this.node.setAttributeNS(null, 'display', 'none');
            this.hidden = true;
        },
    
        show: function() {
            this.node.setAttributeNS(null, 'display', '');
            this.hidden = false;
            this.dashedArea.setAttributeNS(null, 'stroke-width', Math.max(0.2, (1/this.getScale()) || 1));
        },
        
        getScale: function(){
            return this.node.getScreenCTM().a || 1;
        },
    
        resize: function(bounds) {
            var upL = bounds.upperLeft();
    
            var padding = ORYX.CONFIG.SELECTED_AREA_PADDING;
            
            if (Ext.isGecko && Number(ORYX.Utils.getBrowserVersion()) >= 4){
                upL.x += 1; upL.y += 1;
            }
            
            this.dashedArea.setAttributeNS(null, 'width', (bounds.width() + 2*padding) + 1);
            this.dashedArea.setAttributeNS(null, 'height', (bounds.height() + 2*padding) + 1);
            this.node.setAttributeNS(null, 'transform', "translate("+ (upL.x - padding - 1) +", "+ (upL.y - padding - 1) +")");
        },
        
        getScrollerBounds: function(){
            var r = this.scrollElement.getRegion();
            var b = new ORYX.Core.Bounds(r.left, r.top, r.right, r.bottom);
            return b;
        },
        
        getPosition: function(event){
            event = event.browserEvent || event;
            return {x: Event.pointerX(event), y: Event.pointerY(event)};
        },
        
        scrollIntoView: function(event, fn, dontScrollToLeft){
            //window.clearTimeout(this.timer);
            //this.timer = window.setTimeout(function(){
                
                // Width of the scrollbar
                var scrollbarWidth = 22;
                var scroll  = this.scrollElement.dom;
                
                // Get the scrolling bounds and position
                var sb = this.getScrollerBounds();
                var pos = this.getPosition(event);
                // Remove timeout
                window.clearTimeout(timer);
                
                // Adjust the size
                sb.widen(-5);
                sb.extend({
                    x: scroll.offsetHeight !== scroll.scrollHeight ? -scrollbarWidth : 0,
                    y: scroll.offsetWidth !== scroll.scrollWidth ? -scrollbarWidth : 0
                })
                
                // If inside the canvas
                if (sb.isIncluded(pos)){
                    return;
                }
                
                
                // Get some scrolling values
                var sLeft   = scroll.scrollLeft;
                var sTop    = scroll.scrollTop;
                var sHeight = scroll.offsetHeight;
                var sWidth  = scroll.offsetWidth;
                var scrollTop = sTop, scrollLeft = sLeft;
                
                // Remove scroll width/height
                sHeight     -= (scroll.offsetHeight !== scroll.scrollHeight ? scrollbarWidth : 0);
                sWidth      -= (scroll.offsetWidth !== scroll.scrollWidth ? scrollbarWidth : 0);
                
                var scrollStep = 5;
                        
                // Left 
                if (pos.x < sb.a.x && !dontScrollToLeft) {
                    scrollLeft -= scrollStep * Math.max(1, Math.min(((sb.a.x-pos.x)/50)+1, 3));
                // Right
                } else if (pos.x > sb.b.x){
                    scrollLeft += scrollStep * Math.max(1, Math.min(((pos.x-sb.b.x)/50)+1, 3));
                }
                
                
                // Top  
                if (pos.y < sb.a.y) {
                    scrollTop -= scrollStep * Math.max(1, Math.min(((sb.a.y-pos.y)/50)+1, 3));
                // Bottom
                } else if (pos.y > sb.b.y){
                    scrollTop += scrollStep * Math.max(1, Math.min(((pos.y-sb.b.y)/50)+1, 3));
                }
                
                
                // Adjust correct scrolling
                scrollTop = Math.min(scroll.scrollHeight - sHeight - 5, Math.max(0, scrollTop));
                scrollLeft = Math.min(scroll.scrollWidth - sWidth - 5, Math.max(0, scrollLeft));
                
                var oldScroll = {scrollTop: scroll.scrollTop, scrollLeft: scroll.scrollLeft};
                if (Ext.isIPad && (scroll.style.MozTransform || scroll.style.webkitTransform)){
                    try {
                        var obj = (scroll.style.MozTransform || scroll.style.webkitTransform || "").replace(/(.*translate.+?)([-0-9\.]+)(.*?)([-0-9\.]+)(.*)/i, "{x:$2, y:$4}");
                        obj = obj.startsWith("{") ? obj.evalJSON() : {};
                        if (obj && "undefined" != typeof obj.x && "undefined" != typeof obj.y){
                            oldScroll.scrollLeft = obj.x;
                            oldScroll.scrollTop = obj.y;
                        }
                    } catch(e){}
                }
                
                // If there are new values, scroll and update
                if (oldScroll.scrollTop !== scrollTop || oldScroll.scrollLeft !== scrollLeft){
                    
                    if (Ext.isIPad){
                        scroll.style.webkitTransform = "translate("
                            + scrollLeft
                            + "px, "
                            + scrollTop
                            + "px)";
                    } else {
                        scroll.scrollTop    = scrollTop;
                        scroll.scrollLeft   = scrollLeft;
                    }
                    
                    // Update the scroll box
                    timer = window.setTimeout(function(){
                        if (fn instanceof Function){
                            //fn(event)
                        }
                        this.scrollIntoView(event, fn, dontScrollToLeft);
                    }.bind(this), 10);  
                }               

            //}.bind(this), 100);
        },
        
        /**
         * Raises an mouse move event to update the view
         * @param {Event}
         *
         */
        refreshView: function(event){
            
            if (!event || false){ return }
            
            try {
                event = event.browserEvent || event;
                
                // FF, Webkit
                if (document.createEvent) {
                    var evt = document.createEvent('MouseEvents');
                    evt.initMouseEvent(event.type, true, true, window, 0, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, 0, null);
                    return (event.target || document.documentElement).dispatchEvent(evt);
                }
            } catch(e){}
        }
    
    }); 

}();


new function(){ 
    
    /**
     * Implementation of gridlines
     * Horizontal or vertical are available
     * 
     * @class ORYX.Plugins.GridLine
     * 
     */
    ORYX.Core.GridLine = Clazz.extend({
        
        construct: function(parentId, direction) {
    
            if (ORYX.Core.GridLine.DIR_HORIZONTAL !== direction && ORYX.Core.GridLine.DIR_VERTICAL !== direction) {
                direction = ORYX.Plugins.GridLine.DIR_HORIZONTAL
            }
            
        
            this.parent = $(parentId);
            this.direction = direction;
            this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parent,
                        ['g']);
    
            this.line = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,
                ['path', {
                    'fill'              : 'none',
                    'stroke'            : 'silver', 
                    'stroke-width'      : 1, 
                    'stroke-dasharray'  : '5,5',
                    'shape-rendering'   : 'crispEdges',
                    'pointer-events'    : 'none'}]);
    
            this.hide();
    
        },
    
        hide: function() {
            this.node.setAttributeNS(null, 'display', 'none');
        },
    
        show: function() {
            this.node.setAttributeNS(null, 'display', '');
            this.line.setAttributeNS(null, 'stroke-width', Math.max(1, (1/this.getScale()) || 1));
        },
    
        getScale: function(){
            try {
                return this.node.getScreenCTM().a || 1;
            } catch(e) {
                return 1;
            }
        },
        
        update: function(pos) {
            
            if (this.direction === ORYX.Core.GridLine.DIR_HORIZONTAL) {
                var y = pos instanceof Object ? pos.y : pos; 
                var cWidth = this.parent.parentNode.parentNode.width.baseVal.value/this.getScale();
                this.line.setAttributeNS(null, 'd', 'M 0 '+y+ ' L '+cWidth+' '+y);
            } else {
                var x = pos instanceof Object ? pos.x : pos; 
                var cHeight = this.parent.parentNode.parentNode.height.baseVal.value/this.getScale();
                this.line.setAttributeNS(null, 'd', 'M'+x+ ' 0 L '+x+' '+cHeight);
            }
            
            this.show();
        }
    
    
    });
    
    /**
     * Some statics
     */
    ORYX.Core.GridLine.DIR_HORIZONTAL = "hor";
    ORYX.Core.GridLine.DIR_VERTICAL = "ver";    
    var LOCAL = {};
    LOCAL.def = null;
    
    /**
     * Implementation of size guides
     * Horizontal or vertical are available
     * 
     * @class ORYX.Plugins.SizeGuide
     * 
     */
    ORYX.Core.SizeGuide = Clazz.extend({
        
        construct: function(parentId, direction) {
    
            if (ORYX.Core.SizeGuide.DIR_HORIZONTAL !== direction && ORYX.Core.SizeGuide.DIR_VERTICAL !== direction) {
                direction = ORYX.Core.SizeGuide.DIR_HORIZONTAL
            }
        
            this.parent = $(parentId);
            this.direction = direction;
            this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parent,
                        ['g']);

            if(!LOCAL.def) {
                // create markers, if not already created
                LOCAL.def = [
                    ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parent.ownerSVGElement.firstChild,
                        ['marker', {
                            'id'            : 'sizeGuide-start',
                            'refX'          : 0,
                            'refY'          : 5,
                            'markerUnits'   : 'userSpaceOnUse',
                            'markerWidth'   : 6,
                            'markerHeight'  : 20,
                            'orient'        : 'auto'
                        },  ['path', {
                                'd'         : 'M 6 2 L 1 5 L 6 8 M 0 0 L 0 20',
                                'fill'      : 'none',
                                'stroke'    : 'silver'
                            }]
                        ]),
                    ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parent.ownerSVGElement.firstChild,
                        ['marker',     {
                            'id'            : 'sizeGuide-end',
                            'refX'          : 6,
                            'refY'          : 5,
                            'markerUnits'   : 'userSpaceOnUse',
                            'markerWidth'   : 6,
                            'markerHeight'  : 20,
                            'orient'        : 'auto'
                        },  ['path', {
                                'd'         : 'M 0 2 L 5 5 L 0 8 M 6 0 L 6 20',
                                'fill'      : 'none',
                                'stroke'    : 'silver'
                            }]
                        ])
                    ];
            }
    
            this.line = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,
                ['path', {
                    'fill'              : 'none',
                    'stroke'            : 'silver', 
                    'stroke-dasharray'  : '5,5',
                    'shape-rendering'   : 'geometricPrecision',
                    'pointer-events'    : 'none',
                    'marker-start'      : 'url(#sizeGuide-start)',
                    'marker-end'        : 'url(#sizeGuide-end)'}]);
    
            this.hide();
    
        },
    
        hide: function() {
            if (!this.hidden) {
                this.node.setAttributeNS(null, 'display', 'none');
                this.hidden = true;
            }
        },
    
        show: function() {
            if (this.hidden) {
                this.node.setAttributeNS(null, 'display', '');
                this.line.setAttributeNS(null, 'stroke-width', Math.max(1, (1 / this.getScale()) || 1));
                delete this.hidden;
            }
        },
    
        getScale: function(){
            try {
                return this.node.getScreenCTM().a || 1;
            } catch(e) {
                return 1;
            }
        },
        
        update: function(bounds) {
            var ul = bounds.upperLeft();
            var lr = bounds.lowerRight();
            
            offset = 20;
            
            if (this.direction === ORYX.Core.SizeGuide.DIR_HORIZONTAL) {
                var y = 0; // pos instanceof Object ? pos.y : pos; 
                //var cWidth = this.parent.parentNode.parentNode.width.baseVal.value/this.getScale();
                //var cWidth = length;
                
                this.line.setAttributeNS(null, 'd', 'M '+ul.x+' '+(ul.y-offset)+ ' L '+lr.x+' '+(ul.y-offset));
            } else {
                var x = 0; // pos instanceof Object ? pos.x : pos; 
                //var cHeight = this.parent.parentNode.parentNode.height.baseVal.value/this.getScale();
            //  var cHeight = length;
                this.line.setAttributeNS(null, 'd', 'M'+(lr.x+offset)+ ' '+ul.y+' L '+(lr.x+offset)+' '+lr.y);
            }

            this.show();
        }
    
    
    });
    
    /**
     * Some statics
     */
    ORYX.Core.SizeGuide.DIR_HORIZONTAL = "hor";
    ORYX.Core.SizeGuide.DIR_VERTICAL = "ver";
    

    /**
     * Implementation of a command which
     * add all children from the same parent to it.
     * 
     * @param {facade} facade
     * @param {ORYX.Core.Shape} shape
     * @param {boolean} alsoRemove Indicated if also the childs have to be removed from the shape which are outside or not
     */
    ORYX.Core.EnsureChildCommand = ORYX.Core.Command.extend({
        
            construct: function(facade, shapes, alsoRemove){
                this.shapes     = shapes instanceof Array ? shapes : [shapes];
                this.facade     = facade;
                this.alsoRemove = alsoRemove === true;
                this.changes;
            },          
            execute: function(){
                
                if (!ORYX.CONFIG.CONTAIN_AUTOMATICALY){ return; }
                
                if (this.changes){
                    this.exectueAgain();
                    return;
                }
                
                // Get all children (all elements from the canvas and all children of the shapes parent)
                var children = [].concat(this.facade.getCanvas().getChildNodes());
                this.shapes.each(function(shape){
                    if (!(shape.parent instanceof ORYX.Core.Canvas)){
                        children = children.concat(shape.parent.getChildNodes());
                    }
                });
                children = children.uniq().findAll(function(shape){
                                return shape.getDockers().length === 0 || !shape.getDockers()[0].getDockedShape()
                            });
                
                
                var shapes = [];
                this.shapes.each(function(shape){
                    // Get the most top element 
                    // which is not the canvas
                    var mostTopShape = shape;
                    while(mostTopShape&&!(mostTopShape.parent instanceof ORYX.Core.Canvas)){
                        mostTopShape = mostTopShape.parent;
                    }
                    
                    // The shapes which might be one of the parent
                    // could be all shapes from the most top, or the shape themselves
                    if (mostTopShape&&!shapes.include(mostTopShape)){
                        var ch = mostTopShape.getChildNodes(true).reverse();
                        ch = ch.findAll(function(child){
                            return this.facade.getRules().isContainer(child)
                        }.bind(this))
                        shapes = shapes.concat(shape, mostTopShape, ch);
                    }
                }.bind(this));
                shapes = shapes.uniq();
                
                // Cache the absolute bounds 
                var sBounds = {};
                this.changes = $H({});
                
                /**
                 * If also removing is wished
                 */
                if (this.alsoRemove){
                    shapes.each(function(shape){
                        // Cache the absolute bounds
                        if (!sBounds[shape.getId()]){
                            sBounds[shape.getId()] = shape.absoluteBounds();
                        }
                        var bounds = sBounds[shape.getId()];
                        var childs = shape.getChildNodes();
                        
                        childs.each(function(child){
                            if (child.getDockers().length === 1 && child.getDockers()[0].getDockedShape()){
                                return;
                            }
                            var ul = child.absoluteXY();
                            var lr = {x:ul.x+child.bounds.width(), y:ul.y+child.bounds.height()};
                            if (!bounds.isIncluded(ul, 2)&&!bounds.isIncluded(lr, 2)){
                                var parent = this.getContainerParent(shape.parent, child);
                                if (parent){
                                    this.add(parent, child, sBounds[parent.getId()] || parent.absoluteBounds());
                                    children.push(child); // Add to childs to consider
                                }
                            }
                        }.bind(this))
                    }.bind(this))
                }
                
                // For every considered shape
                children.each(function(child){
                    
                    // Get position
                    var ul = child.absoluteXY();
                    var lr = {x:ul.x+child.bounds.width(), y:ul.y+child.bounds.height()};
                    
                    // Iterate over all possible parent shapes          
                    shapes.any(function(parent){
                        // Check if parent is child
                        var c = child;
                        while(c && !(c instanceof ORYX.Core.Canvas)){
                            if (c === parent){ return false; }
                            c = c.parent;
                        }
                        
                        // Check if child is parent
                        var c = parent;
                        while(c && !(c instanceof ORYX.Core.Canvas)){
                            if (c === child){ return false; }
                            c = c.parent;
                        }
                        
                        // Cache the absolute bounds
                        if (!sBounds[parent.getId()]){
                            sBounds[parent.getId()] = parent.absoluteBounds();
                        }
                        var bounds = sBounds[parent.getId()];
                        
                        // Check if the child is within the parent
                        if (bounds.isIncluded(ul, -2) && bounds.isIncluded(lr, -2)){
                            
                            // Check if the child can be contained in the parent
                            if (this.facade.getRules().canContain({containingShape:parent,containedShape:child})){
                                this.add(parent, child, bounds);
                                return true;
                            }
                        }
                        return false;
                    }.bind(this));
                }.bind(this));
                
                this.facade.getCanvas().update();
            },
            
            add: function(parent, child, bounds){
                // If all TRUE, adds it
                var cUl = child.absoluteXY();
                var pUl = bounds ? bounds.upperLeft() : {x:0,y:0};
                var pos = {x:cUl.x-pUl.x, y:cUl.y-pUl.y};
                var oldParent = this.changes[child.getId()] ? this.changes[child.getId()].oldParent : child.parent;
                var oldPosition = this.changes[child.getId()] ? this.changes[child.getId()].oldPosition : child.bounds.upperLeft();
                
                // Cache changes for rollback
                this.changes[child.getId()] = {
                                            shape       : child,
                                            oldParent   : oldParent,
                                            oldPosition : oldPosition,
                                            newParent   : parent,
                                            newPosition : bounds ? pos : oldPosition
                                        }
                
                parent.add(child);
                if (bounds){
                    child.bounds.moveTo(pos);       
                }
                
                child.getOutgoingNodes(function(node){
                    this.add(parent, node);
                }.bind(this))
            },
            
            getContainerParent: function(parent, shape){
                while(parent && !this.facade.getRules().canContain({containingShape:parent,containedShape:shape})){
                    parent = parent.parent;
                }
                return parent;
            },
            
            exectueAgain: function(){
                // Iterate over all changes and rollback
                this.changes.each(function(pair){
                    var parent = pair.value.newParent;
                    var shape = pair.value.shape;
                    parent.add(shape);
                    shape.bounds.moveTo(pair.value.newPosition);
                }.bind(this))

                //this.facade.getCanvas().update();
            },
            
            rollback: function(){
                
                if (!ORYX.CONFIG.CONTAIN_AUTOMATICALY){ return; }
                
                // Iterate over all changes and rollback
                this.changes.each(function(pair){
                    var parent = pair.value.oldParent;
                    var shape = pair.value.shape;
                    parent.add(shape);
                    shape.bounds.moveTo(pair.value.oldPosition);
                }.bind(this))

                //this.facade.getCanvas().update();
            }
        });
    
    /**
     * Implements a command to move docker by an offset.
     * 
     * @class ORYX.Core.MoveDockersCommand
     * @param {Object} object An object with the docker id as key and docker and offset as object value
     * 
     */ 
    ORYX.Core.MoveDockersCommand = ORYX.Core.Command.extend({
        construct: function(dockers){
            this.dockers    = $H(dockers);
            this.edges      = $H({});
        },
        execute: function(){
            if (this.changes) {
                this.executeAgain();
                return;
            } else {
                this.changes = $H({});
            }
            
            this.dockers.values().each(function(docker){
                var edge = docker.docker.parent;
                if (!edge){ return }
                
                if (!this.changes[edge.getId()]) {
                    this.changes[edge.getId()] = {
                        edge                : edge,
                        oldDockerPositions  : edge.dockers.map(function(r){ return r.bounds.center() })
                    }
                }
                docker.docker.bounds.moveBy(docker.offset);
                this.edges[edge.getId()] = edge;
                docker.docker.update();
            }.bind(this));
            this.edges.each(function(edge){
                this.updateEdge(edge.value);
                if (this.changes[edge.value.getId()])
                    this.changes[edge.value.getId()].dockerPositions = edge.value.dockers.map(function(r){ return r.bounds.center() })
            }.bind(this));
        },
        updateEdge: function(edge){
            edge._update(true);
            [edge.getOutgoingShapes(), edge.getIncomingShapes()].flatten().invoke("_update", [true])
        },
        executeAgain: function(){
            this.changes.values().each(function(change){
                // Reset the dockers
                //this.removeAllDocker(change.edge);
                change.dockerPositions.each(function(pos, i){   
                    if (i==0||i==change.dockerPositions.length-1){ return }                 
                    //var docker = change.edge.createDocker(undefined, pos);
                    change.edge.dockers[i].bounds.centerMoveTo(pos);
                    change.edge.dockers[i].update();
                }.bind(this));
                this.updateEdge(change.edge);
            }.bind(this));
        },
        rollback: function(){
            this.changes.values().each(function(change){
                // Reset the dockers
                //this.removeAllDocker(change.edge);
                change.oldDockerPositions.each(function(pos, i){    
                    if (i==0||i==change.oldDockerPositions.length-1){ return }                  
                    //var docker = change.edge.createDocker(undefined, pos);
                    change.edge.dockers[i].bounds.centerMoveTo(pos);
                    change.edge.dockers[i].update();
                }.bind(this));
                this.updateEdge(change.edge);
            }.bind(this));
        },
        removeAllDocker: function(edge){
            edge.dockers.slice(1, edge.dockers.length-1).each(function(docker){
                edge.removeDocker(docker);
            });
        }
    });
    
    /**
     * Implements a command to create a shape regarding its option
     * 
     * @class ORYX.Core.CreateShapeCommand
     * @param {Object} option
     * @param {ORYX.Core.Shape} shape
     * @param {Object} position
     * @param {ORYX.Core.Plugin} plugin
     * 
     */ 
    ORYX.Core.CreateShapeCommand = ORYX.Core.Command.extend({
        construct: function(option, shape, position, plugin){
            this.option = option;
            this.position = position;
            this.element = shape;
            this.plugin = plugin;
            this.facade = plugin.facade;
            this.selection = this.facade.getSelection();
            this.adjustChild;
            this.shape;
            this.parent;
        },          
        execute: function(){            
            if (!this.shape) {
                this.shape  = this.facade.createShape(this.option);
                this.parent = this.shape.parent;
            } else if (this.parent){
                this.parent.add(this.shape);
            }
            
            var option = this.option;
            
            /**
             * DO ATTACH
             */ 
            if( option.canAttach &&  this.element instanceof ORYX.Core.Node && this.shape.dockers.length > 0){
                // Get first docker
                var docker = this.shape.dockers[0];
                // Add to the same parent
                if( this.element.parent instanceof ORYX.Core.Node ) {
                    this.element.parent.add( this.shape );
                }
                // Set docker position                          
                docker.bounds.centerMoveTo( this.position );
                docker.setDockedShape( this.element );
            }

            /**
             * DO Connect
             */ 
            if( option.canConnectBetween &&  this.element instanceof ORYX.Core.Edge){
                var from    = this.element.getSource();
                var to      = this.element.getTarget();
                var edge;
                if (this.edge) {
                    edge = this.edge;
                    this.facade.getCanvas().add(this.edge);
                } else {
                    edge = this.facade.createShape({
                        namespace   : this.element.getStencil().namespace(),
                        type        : this.element.getStencil().id()
                    });
                }
                
                var layoutingRequired = false, absBounds = this.shape.absoluteBounds();
                this.element.getDockers().each(function(docker) {
                    var point = docker.getAbsoluteReferencePoint() || docker.bounds.center();
                    if(absBounds.isIncluded(point)) {
                        layoutingRequired = true;
                        throw $break;
                    }
                }.bind(this));
                
                var mid = {x:this.shape.bounds.width()/2,y:this.shape.bounds.height()/2};
                if (this.shape.getDefaultMagnet()){
                    mid = this.shape.getDefaultMagnet().bounds.center();
                }
                var refTo = this.element.getDockers().last().referencePoint;
                
                var segment = this.element.findSegment(this.shape.absoluteCenterXY());
                var dockers = this.element.dockers.slice(this.element.dockers.indexOf(segment.toDocker), this.element.dockers.length-1);
                
                this.element.getDockers().last().setDockedShape(this.shape);
                this.element.getDockers().last().setReferencePoint(mid);
                
                edge.getDockers().first().setDockedShape(this.shape);
                edge.getDockers().first().setReferencePoint(mid);
                edge.getDockers().last().setDockedShape(to);
                edge.getDockers().last().setReferencePoint(refTo);
                
                this.dockerPosition = this.element.getDockers().map(function(docker){ return docker.bounds.center() });
                
                // Remove dockers from the old shape
                var count = 0;
                dockers.each(function(docker){
                    this.element.removeDocker(docker);
                    if(!layoutingRequired && !this.edge) edge.createDocker(1+count, docker.bounds.center());
                    count++;
                }.bind(this));
                
                if(layoutingRequired) {
                    // Layout edges
                    this.plugin.doLayout(this.element);
                    this.plugin.doLayout(edge);
                }
                
                this.edge = edge;
                
            }
                            
            // Update
            this.facade.setSelection([this.shape]);             
            this.facade.getCanvas().update();
            
            // Set the parents correctly
            if (!this.adjustChild){
                this.adjustChild = new ORYX.Core.EnsureChildCommand(this.facade, this.shape);
            }
            this.adjustChild.execute();
            
            // Update
            this.facade.updateSelection();      
        },
        
        rollback: function(){
            // Rollback adjustment of childs
            this.adjustChild.rollback();
            
            // Delete shape
            this.facade.deleteShape(this.shape);
            
            if (this.edge){
                
                // Reset the dockers
                this.removeAllDocker(this.element);
                this.dockerPosition.each(function(pos, i){  
                    if (i==0||i==this.dockerPosition.length-1){ return }                    
                    var docker = this.element.createDocker(undefined, pos);
                    docker.bounds.centerMoveTo(pos);
                }.bind(this));
                
                // Reset the last docker
                this.element.getDockers().last().setDockedShape(this.edge.getTarget());
                this.element.getDockers().last().setReferencePoint(this.edge.dockers.last().referencePoint);
                
                // Remove the new edge
                this.facade.deleteShape(this.edge);
                
            }

            //this.facade.setSelection([]);
            //this.facade.getCanvas().update();
            this.facade.setSelection(this.selection.without(this.shape));
            
        },
        
        removeAllDocker: function(edge){
            edge.dockers.slice(1, edge.dockers.length-1).each(function(docker){
                edge.removeDocker(docker);
            })
        }
    });
        
    
}();
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 * @namespace The ORYX.Core Namespace
 * @name ORYX.Core
 */
if("undefined" == typeof ORYX) {var ORYX = {};}
if("undefined" == typeof ORYX.Core) {ORYX.Core = {};}

new function(){
	/**
	 * @class ORYX.Core.Shape
	 * Base class for Shapes.
	 * @extends ORYX.Core.AbstractShape
	 */
	ORYX.Core.Shape = ORYX.Core.AbstractShape.extend({
	/** @lends ORYX.Core.Shape# */
		
		/**
		 * 
		 * @param {Options} options
		 * @param {Stencil} stencil
		 */
		construct: function(options, stencil) {
			// call base class constructor
			arguments.callee.$.construct.apply(this, arguments);
			
			this.dockers = [];
			this.magnets = [];
			
			this._defaultMagnet;
			
			this.incoming = [];
			this.outgoing = [];
			
			this.nodes = [];
			
			this._dockerChangedCallback = this._dockerChanged.bind(this);
			
			//Hash map for all labels. Labels are not treated as children of shapes.
			this._labels = new Hash();
			
			// create SVG node
			this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg",
				null,
				['g', {id:"svg-" + this.resourceId},
					['g', {"class": "stencils"},
						['g', {"class": "me"}],
						['g', {"class": "children"}],
						['g', {"class": "edge"}]
					],
					['g', {"class": "controls"},
						['g', {"class": "dockers"}],
						['g', {"class": "magnets"}]				
					]
				]);
			
			this.fillButStroke = {
					"http://b3mn.org/stencilset/bpmn2.0#Task" : ["sendTaskpath", "sendTaskpath2"],
					"http://b3mn.org/stencilset/epc#Mail" : ["atText"],
					"http://b3mn.org/stencilset/bpmn2.0#IntermediateMessageEventThrowing" : ["path1", "path2"],
					"http://b3mn.org/stencilset/bpmn2.0#EndMessageEvent" : ["path1", "path2"]
			};
			
			this.strokeAndFill = {
				//BPMN
					"http://b3mn.org/stencilset/bpmn2.0#Task" : ["userTaskcircle"],
					"http://b3mn.org/stencilset/bpmn2.0#Subprocess" : ["adhocpath"],
					"http://b3mn.org/stencilset/bpmn2.0#EventSubprocess" : ["adhocpath"],
					"http://b3mn.org/stencilset/bpmn2.0#CollapsedSubprocess" : ["adhocpath"],
					"http://b3mn.org/stencilset/bpmn2.0#CollapsedEventSubprocess" : ["adhocpath"],
					
					"http://b3mn.org/stencilset/bpmn2.0#IntermediateSignalEventThrowing" : ["signalThrowing"],
					"http://b3mn.org/stencilset/bpmn2.0#IntermediateCompensationEventThrowing" : ["poly1", "poly2"],
					"http://b3mn.org/stencilset/bpmn2.0#IntermediateEscalationEventThrowing" : ["path9"],
					"http://b3mn.org/stencilset/bpmn2.0#IntermediateMultipleEventThrowing" : ["middlePolygonThrowing"],
					"http://b3mn.org/stencilset/bpmn2.0#IntermediateLinkEventThrowing" : ["poly1"],
					
					"http://b3mn.org/stencilset/bpmn2.0#EndCompensationEvent" : ["poly1", "poly2"],
					"http://b3mn.org/stencilset/bpmn2.0#EndCancelEvent" : ["path1"],
					"http://b3mn.org/stencilset/bpmn2.0#EndMultipleEvent" : ["middlepolygon"],
					"http://b3mn.org/stencilset/bpmn2.0#EndErrorEvent" : ["errorPolygon"],
					"http://b3mn.org/stencilset/bpmn2.0#EndEscalationEvent" : ["path9"],
					"http://b3mn.org/stencilset/bpmn2.0#EndSignalEvent" : ["signalThrowing"],
					"http://b3mn.org/stencilset/bpmn2.0#EndTerminateEvent" : ["circle1"],
					
					"http://b3mn.org/stencilset/bpmn2.0#processparticipant" : ["path1", "path2", "circle1"],
					
					"http://b3mn.org/stencilset/bpmn2.0#Exclusive_Databased_Gateway" : ["crosspath", "crosspath2"],
					
					"http://b3mn.org/stencilset/bpmn2.0#SequenceFlow" : ["arrowhead"],
			
					"http://b3mn.org/stencilset/bpmn2.0#DataObject" : ["output"],

				//Conversation
					"http://b3mn.org/stencilset/bpmn2.0conversation#SequenceFlow" : ["arrowhead"],					
					
				//Choreography
					"http://b3mn.org/stencilset/bpmn2.0choreography#IntermediateEscalationEventThrowing" : ["path9"],
					"http://b3mn.org/stencilset/bpmn2.0choreography#IntermediateLinkEventThrowing" : ["poly1"],
					
					"http://b3mn.org/stencilset/bpmn2.0choreography#EndTerminateEvent" : ["circle1"],
					
					"http://b3mn.org/stencilset/bpmn2.0choreography#Exclusive_Databased_Gateway" : ["crosspath", "crosspath2"],
					
					"http://b3mn.org/stencilset/bpmn2.0choreography#SequenceFlow" : ["arrowhead"],
			
				//EPC
					"http://b3mn.org/stencilset/epc#Fax" : ["opening"]
			};
		},
		
		/**
		 * Returns the html element the svg of this shape is contained
		 * @returns {HTMLElement}
		 */
		getMeContainer: function() {
			return this.node.childNodes[0].childNodes[0];
		},
		
		/**
		 * Returns the html element where all children are included
		 * @returns {HTMLElement}
		 */
		getChildContainer: function() {
			return this.node.childNodes[0].childNodes[1];
		},
		
		/**
		 * Returns the html element where all edges are contained
		 * @returns {HTMLElement}
		 */
		getEdgeContainer: function() {
			return this.node.childNodes[0].childNodes[2];
		},
	
		/**
		 * If changed flag is set, refresh method is called.
		 */
		update: function() {
			//if(this.isChanged) {
				//this.layout();
			//}
		},
		
		/**
		 * !!!Not called from any sub class!!!
		 */
		_update: function() {
	
		},
		
		/**
		 * Calls the super class refresh method
		 * and updates the svg elements that are referenced by a property.
		 */
		refresh: function() {
			//call base class refresh method
			arguments.callee.$.refresh.apply(this, arguments);
			
			if(this.node.ownerDocument) {
				
				// Return the element by its id
				var getElement = function(id){
					return this.node.ownerDocument.getElementById(id) || Ext.fly(this.node).child("[id="+id+"]", true);
				}.bind(this);
				
				// Return the element by its class name
				var getElements = function(className){
					return [].concat($A(this.node.ownerDocument.getElementsByTagNameNS('http://www.w3.org/2000/svg', className)), $A(this.node.getElementsByTagNameNS('http://www.w3.org/2000/svg', className))).compact();
				}.bind(this);
				
				// Get the id of the stencil
				var stencilId = this.getStencil().id();
				
				//adjust SVG to properties' values
				var me = this;
				this.propertiesChanged.each((function(propChanged) {
					if(propChanged.value) {
						var prop = this.properties[propChanged.key];
						var property = this.getStencil().property(propChanged.key);
						this.propertiesChanged[propChanged.key] = false;
						
						// Check if the property has the correct language
						if (property.language() && property.language() !== me.getCanvas().getLanguage()){
							return;
						}
	
						//handle choice properties
						if(property.type() == ORYX.CONFIG.TYPE_CHOICE) {
							//iterate all references to SVG elements
							property.refToView().each((function(ref) {
								//if property is referencing a label, update the label
								if(ref !== "") {
									var label = this._labels[this.id + ref];
									if (label && property.item(prop)) {
										label.text(property.item(prop).title());
									}
								}
							}).bind(this));
							
							//if the choice's items are referencing SVG elements
							// show the selected and hide all other referenced SVG
							// elements
							var refreshedSvgElements = new Hash();
							property.items().each((function(item) {
								item.refToView().each((function(itemRef) {
									if(itemRef == "") { return; }
									
									var svgElem;
	//								if (this instanceof ORYX.Core.Node){
	//									svgElem = this.getSVGShape(this.id + itemRef);
	//									if (svgElem){
	//										svgElem[prop == item.value() ? "show" : "hide"]();
	//										return;
	//									}
	//								}
									
									svgElem = getElement(this.id + itemRef)
									
									if(!svgElem) { return; }
									
									/* Do not refresh the same svg element multiple times */
									if(!refreshedSvgElements[svgElem.id] || prop == item.value()) {
										if (Ext.isOpera){
											svgElem.setAttributeNS(null, 'visibility', ((prop == item.value()) ? 'visible' : 'hidden'));
										}
										svgElem.setAttributeNS(null, 'display', ((prop == item.value()) ? 'inherit' : 'none'));
										
										refreshedSvgElements[svgElem.id] = svgElem;
									}
									
									// Reload the href if there is an image-tag
									if(ORYX.Editor.checkClassType(svgElem, SVGImageElement)) {
										svgElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', svgElem.getAttributeNS('http://www.w3.org/1999/xlink', 'href'));
									}
								}).bind(this));
							}).bind(this));
							
						} else { //handle properties that are not of type choice
							//iterate all references to SVG elements
							property.refToView().each((function(ref) {
								//if the property does not reference an SVG element,
								// do nothing
	
								if(ref === "") { return; }
			
								var refId = this.id + ref;
	
								//get the SVG element
								var svgElem = getElement(refId);
	
								var containsNotInDOM = false;
								try {
									containsInDOM = this.node.parentNode && !(svgElem.ownerSVGElement);
								} catch(e){ 
									containsInDOM = false; 
								}
								
								//if the SVG element can not be found
								if(!svgElem || containsInDOM) { 
									//if the referenced SVG element is a SVGAElement, it cannot
									// be found with getElementById (Firefox bug).
									// this is a work around
									if(property.type() === ORYX.CONFIG.TYPE_URL || property.type() === ORYX.CONFIG.TYPE_DIAGRAM_LINK) {
										var svgElems = getElements("a");
										
										svgElem = $A(svgElems).find(function(elem) {
											return elem.getAttributeNS(null, 'id') === refId;
										});
										
										if(!svgElem) { return; } 
									} else {
										//this.propertiesChanged[propChanged.key] = true;
										return;
									}					
								}
								
								if (property.complexAttributeToView()) {
									var label = this._labels[refId];
									if (label) {
										try {
									    	propJson = prop.evalJSON();
									    	var value = propJson[property.complexAttributeToView()]
									    	label.text( ("undefined" === typeof value) ? prop : value);
									    } catch (e) {
									    	label.text(prop);
									    }
									}
									
								} else {
	
									switch (property.type()) {
										case ORYX.CONFIG.TYPE_BOOLEAN:	
											
											if (typeof prop == "string")
												prop = prop === "true";
		
											if (Ext.isOpera){
												svgElem.setAttributeNS(null, 'visibility', (!(prop === property.inverseBoolean()) ? 'visible' : 'hidden'));
											}
											svgElem.setAttributeNS(null, 'display', (!(prop === property.inverseBoolean())) ? 'inherit' : 'none');
											
											break;
										case ORYX.CONFIG.TYPE_COLOR:
											if(property.fill()) {
												if (svgElem.tagName.toLowerCase() === "stop"){
													if (prop){
														
														if (property.lightness() &&  property.lightness() !== 1){
															prop = ORYX.Utils.adjustLightness(prop, property.lightness());
														}
														
														svgElem.setAttributeNS(null, "stop-color", prop);
													
														// Adjust stop color of the others
														if (svgElem.parentNode.tagName.toLowerCase() === "radialgradient"){
															ORYX.Utils.adjustGradient(svgElem.parentNode, svgElem);
														}
													}
													
													// If there is no value, set opaque
													if (svgElem.parentNode.tagName.toLowerCase() === "radialgradient"){
														$A(svgElem.parentNode.getElementsByTagName('stop')).each(function(stop){
															stop.setAttributeNS(null, "stop-opacity", prop ? stop.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'default-stop-opacity') || 1 : 0);
														}.bind(this));
													}

													// Toggle pointer-events of the container node if fill is set/unset
													var cont = this.getMeContainer().childNodes[0];
													if (cont && cont.nodeType == 1){
														if (prop && String(cont.getAttributeNS(null, "pointer-events")).toLowerCase() == "stroke"){
															cont.setAttributeNS(null, "pointer-events", "all");
														} else if (!prop && String(cont.getAttributeNS(null, "pointer-events")).toLowerCase() == "all"){
															cont.setAttributeNS(null, "pointer-events", "stroke");
														}
													}
													
												} else {
													svgElem.setAttributeNS(null, 'fill', prop || "none");
													// Determine if the current svgElem is not a marker and the default fill color is not white, set the new fill color
													// If the current svg element is not a marker but a path, don't set the background color
//													if ((svgElem.parentNode.nodeName !== "marker" && svgElem.nodeName !== "path") ||
//														svgElem.parentNode.nodeName === "marker" && svgElem.getAttributeNS(null, 'fill') !== "white") {
//															svgElem.setAttributeNS(null, 'fill', prop || "none");
//													}
												}
											}
											if(property.stroke()) {
												// Set only the fill color instead of the border color
												if (this.fillButStroke[stencilId] && this.fillButStroke[stencilId].include(ref)) {
													svgElem.setAttributeNS(null, "fill", prop || "none");
												} else {
													svgElem.setAttributeNS(null, 'stroke', prop);

													// Set both border color and fill color
													if (this.strokeAndFill[stencilId] && this.strokeAndFill[stencilId].include(ref)) {
														svgElem.setAttributeNS(null, "fill", prop || "none");
													}
												}
												
											}
											break;
										case ORYX.CONFIG.TYPE_STRING:
											var label = this._labels[refId];
											if (label) {
												
												/** Multi-language:
												 * Lookup if there is a value in another language
												 * when the current language has no value.
												 */
												if (ORYX.CONFIG.MULTI_LANGUAGES_ENABLED && property.language() && property.value() == (prop||"")){
													var value = prop, 
														oprop = property.origin(),
														// Find the value in another language
														language = $H(ORYX.CONFIG.MULTI_LANGUAGES||{}).keys().find(function(lang){
															var key = oprop.prefix() + "-" + oprop.id() + (lang == ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT ? "" : "_" + lang );
															if ((this.properties[key]||"") != oprop.value()){
																value = this.properties[key]||"";
																return true;
															}
															return false;
														}.bind(this));
													// Set the value if its different
													if (language && value !== prop){
														value += " ("+(Signavio.I18N.Multilanguage[String(language).toUpperCase()+"_Short"]||language)+")";
														label.text(value);
														label.css = "x-label-invalid";
														break;
													}
												}
												
												label.text(prop);
												label.css = "";
											}
											break;
										case ORYX.CONFIG.TYPE_INTEGER:
											var label = this._labels[refId];
											if (label) {
												label.text(prop);
											}
											break;
										case ORYX.CONFIG.TYPE_FLOAT:
											if(property.fillOpacity()) {
												svgElem.setAttributeNS(null, 'fill-opacity', prop);
											} 
											if(property.strokeOpacity()) {
												svgElem.setAttributeNS(null, 'stroke-opacity', prop);
											}
											if(!property.fillOpacity() && !property.strokeOpacity()) {
												var label = this._labels[refId];
												if (label) {
													label.text(prop);
												}
											}
											break;
										case ORYX.CONFIG.TYPE_URL:
										case ORYX.CONFIG.TYPE_DIAGRAM_LINK:
											//TODO what is the dafault path?
											var hrefAttr = svgElem.getAttributeNodeNS('http://www.w3.org/1999/xlink', 'xlink:href');
											if(hrefAttr) {
												hrefAttr.textContent = prop;
											} else {
												svgElem.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', prop);
											}	
											break;
									}
								}
							}).bind(this));
							
							
						}
						
					}
				}).bind(this));
				
				//update labels
				this._labels.values().each(function(label) {
					label.update();
				});
			}
		},
		
		layout: function() {
			//this.getStencil().layout(this)
			var layoutEvents = this.getStencil().layout()
			if (layoutEvents) {
				layoutEvents.each(function(event) {
					
					// setup additional attributes
					event.shape = this;
					event.forceExecution = true;
					
					// do layouting
					this._delegateEvent(event);
				}.bind(this))
				
			}
		},
		
		/**
		 * Returns an array of Label objects.
		 */
		getLabels: function() {
			return this._labels.values();
		},
		
		/**
		 * Returns the label for a given ref
		 * @return {ORYX.Core.Label} Returns null if there is no label
		 */
		getLabel: function(ref){
			if (!ref){
				return null;
			}
			return (this._labels.find(function(o){
					return o.key.endsWith(ref);
				})||{}).value || null;
		},
		
		/**
		 * Hides all related labels
		 * 
		 */
		hideLabels: function(){
			this.getLabels().invoke("hide");
		},
	
		/**
		 * Shows all related labels
		 * 
		 */
		showLabels: function(){
			var labels = this.getLabels();
			labels.invoke("show");
			labels.each(function(label) {
					label.update();
			});
		},
		
		setOpacity: function(value, animate){
			
			// 0.0 <= value <= 1.0
			value = Math.max(Math.min((typeof value == "number" ? value : 1.0), 1.0), 0.0);
					
			//if (animate !== true){
				if (value !== 1.0){
					value = String(value);
					this.node.setAttributeNS(null, "fill-opacity", value);
					this.node.setAttributeNS(null, "stroke-opacity", value);
				} else {
					this.node.removeAttributeNS(null, "fill-opacity");
					this.node.removeAttributeNS(null, "stroke-opacity");
				}
			/*} else {
				var args = {opacity:{to:value}};
				if (!this.isVisible){
					this.show();
				}
				if (this.currentAnim){
					this.currentAnim.stop();
				}
				
				this.currentAnim = Ext.lib.Anim.run(this.node, args, 0.4, "easeOut", function(){
				    if (args.opacity.to === 0.0){
				        this.hide();
				    } else if (args.opacity.to === 1.0){
						this.node.removeAttributeNS(null, "style");
					}
					delete this.currentAnim;
				}, this)
			}*/
	
			
	
		},
		
		/**
		 * Returns an array of dockers of this object.
		 */
		getDockers: function() {
			return this.dockers;
		},
		
		getMagnets: function() {
			return this.magnets;
		},
		
		getDefaultMagnet: function() {
			if(this._defaultMagnet) {
				return this._defaultMagnet;
			} else if (this.magnets.length > 0) {
				return this.magnets[0];
			} else {
				return undefined;
			}
		},
	
		getParentShape: function() {
			return this.parent;
		},
		
		getIncomingShapes: function(iterator) {
			if(iterator) {
				this.incoming.each(iterator);
			}
			return this.incoming;
		},
		
		getIncomingNodes: function(iterator) {
	        return this.incoming.select(function(incoming){
	            var isNode = (incoming instanceof ORYX.Core.Node);
	            if(isNode && iterator) iterator(incoming);
	            return isNode;
	        });
	    },
		
		
		getOutgoingShapes: function(iterator) {
			if(iterator) {
				this.outgoing.each(iterator);
			}
			return this.outgoing;
		},
	    
	    getOutgoingNodes: function(iterator) {
	        return this.outgoing.select(function(out){
	            var isNode = (out instanceof ORYX.Core.Node);
	            if(isNode && iterator) iterator(out);
	            return isNode;
	        });
	    },
		
		getAllDockedShapes: function(iterator) {
			var result = this.incoming.concat(this.outgoing);
			if(iterator) {
				result.each(iterator);
			}
			return result
		},
	
		/**
		 * Returns the canvas, which is the 
		 * global parent of all shapes
		 * @return {ORYX.Core.Canvas}
		 */
		getCanvas: function() {
			if ("undefined" != typeof this.canvas){
				return this.canvas;
			} 
			if(this.parent instanceof ORYX.Core.Canvas) {
				this.canvas = this.parent;
			} else if(this.parent instanceof ORYX.Core.Shape) {
				this.canvas = this.parent.getCanvas();
			} else {
				this.canvas = null;
			}
			return this.canvas;
		},
		
		/**
		 * 
		 * @param {Object} deep
		 * @param {Object} iterator
		 */
		getChildNodes: function(deep, iterator) {
			if(!deep && !iterator) {
				return this.nodes.clone();
			} else {
				var result = [];
				this.nodes.each(function(uiObject) {
					if(!uiObject.isVisible){return}
					if(iterator) {
						iterator(uiObject);
					}
					result.push(uiObject);
					
					if(deep && uiObject instanceof ORYX.Core.Shape) {
						result = result.concat(uiObject.getChildNodes(deep, iterator));
					}
				});
		
				return result;
			}
		},
		
		/**
		 * Overrides the UIObject.add method. Adds uiObject to the correct sub node.
		 * @param {UIObject} uiObject
		 * @param {Number} index
		 */
		add: function(uiObject, index, silent) {
			//parameter has to be an UIObject, but
			// must not be an Edge.
			if(uiObject instanceof ORYX.Core.UIObject 
				&& !(uiObject instanceof ORYX.Core.Edge)) {
				
				if (!(this.children.member(uiObject))) {
					//if uiObject is child of another parent, remove it from that parent.
					if(uiObject.parent) {
						uiObject.parent.remove(uiObject, true);
					}
	
					//add uiObject to this Shape
					if(index != undefined)
						this.children.splice(index, 0, uiObject);
					else
						this.children.push(uiObject);
	
					//set parent reference
					uiObject.parent = this;
	
					//add uiObject.node to this.node depending on the type of uiObject
					var parent;
					if(uiObject instanceof ORYX.Core.Node) {
						parent = this.node.childNodes[0].childNodes[1];
						
						//add uiObject to the nodes
						if(index != undefined)
							this.nodes.splice(index, 0, uiObject);
						else
							this.nodes.push(uiObject);
						
					} else if(uiObject instanceof ORYX.Core.Controls.Control) {
						var ctrls = this.node.childNodes[1];
						if(uiObject instanceof ORYX.Core.Controls.Docker) {
							parent = ctrls.childNodes[0];
							if (this.dockers.length >= 2){
								this.dockers.splice(index!==undefined?Math.min(index, this.dockers.length-1):this.dockers.length-1, 0, uiObject);
							} else {
								this.dockers.push(uiObject);
							}
						} else if(uiObject instanceof ORYX.Core.Controls.Magnet) {
							parent = ctrls.childNodes[1];
							this.magnets.push(uiObject);
						} else {
							parent = ctrls;
						}
					} else {	//UIObject
						parent = this.node;
					}
	
					if (!(uiObject instanceof ORYX.Core.Shape)){
						if(index != undefined && index < parent.childNodes.length) {
							uiObject.node = parent.insertBefore(uiObject.node, parent.childNodes[index]);
						} else {
							uiObject.node = parent.appendChild(uiObject.node);	
						}
					}
					this._changed();
					//uiObject.bounds.registerCallback(this._changedCallback);
					
					
					if (uiObject instanceof ORYX.Core.Shape && this.eventHandlerCallback && silent !== true){
						this.eventHandlerCallback({type:ORYX.CONFIG.EVENT_SHAPEADDED,shape:uiObject});
					}	
				} else {
					ORYX.Log.warn("add: ORYX.Core.UIObject is already a child of this object.");
				}
			} else {
				ORYX.Log.warn("add: Parameter is not of type ORYX.Core.UIObject.");
			}
		},
	
		/**
		 * Overrides the UIObject.remove method. Removes uiObject.
		 * @param {UIObject} uiObject
		 */
		remove: function(uiObject, silent) {
			//if uiObject is a child of this object, remove it.
			if (this.children.member(uiObject)) {
				//remove uiObject from children
				var parent = uiObject.parent;
	
				this.children = this.children.without(uiObject);
	
				//delete parent reference of uiObject
				uiObject.parent = undefined;
	
				//delete uiObject.node from this.node
				if(uiObject instanceof ORYX.Core.Shape) {
					if(uiObject instanceof ORYX.Core.Edge) {
						uiObject.removeMarkers();
	
						if ($A(this.node.childNodes[0].childNodes[2].childNodes).include(uiObject.node))
							uiObject.node = this.node.childNodes[0].childNodes[2].removeChild(uiObject.node);
					} else {
						if ($A(this.node.childNodes[0].childNodes[1].childNodes).include(uiObject.node))
							uiObject.node = this.node.childNodes[0].childNodes[1].removeChild(uiObject.node);
						this.nodes = this.nodes.without(uiObject);
					}
				} else if(uiObject instanceof ORYX.Core.Controls.Control) {
					if (uiObject instanceof ORYX.Core.Controls.Docker) {
						if ($A(this.node.childNodes[1].childNodes[0].childNodes).include(uiObject.node))
							uiObject.node = this.node.childNodes[1].childNodes[0].removeChild(uiObject.node);
						this.dockers = this.dockers.without(uiObject);
					} else if (uiObject instanceof ORYX.Core.Controls.Magnet) {
						if ($A(this.node.childNodes[1].childNodes[1].childNodes).include(uiObject.node))
							uiObject.node = this.node.childNodes[1].childNodes[1].removeChild(uiObject.node);
						this.magnets = this.magnets.without(uiObject);
					} else {
						if ($A(this.node.childNodes[1].childNodes).include(uiObject.node))
							uiObject.node = this.node.childNodes[1].removeChild(uiObject.node);
					}
				}
	
				if(this.eventHandlerCallback && silent !== true)
					this.eventHandlerCallback({type: ORYX.CONFIG.EVENT_SHAPEREMOVED, shape: uiObject, parent: parent});
				
				this._changed();
				//uiObject.bounds.unregisterCallback(this._changedCallback);
			} else {
	
				ORYX.Log.warn("remove: ORYX.Core.UIObject is not a child of this object.");
			}
		},
		
		/**
		 * Calculate the Border Intersection Point between two points
		 * @param {PointA}
		 * @param {PointB}
		 */
		getIntersectionPoint: function() {
				
			var pointAX, pointAY, pointBX, pointBY;
			
			// Get the the two Points	
			switch(arguments.length) {
				case 2:
					pointAX = arguments[0].x;
					pointAY = arguments[0].y;
					pointBX = arguments[1].x;
					pointBY = arguments[1].y;
					break;
				case 4:
					pointAX = arguments[0];
					pointAY = arguments[1];
					pointBX = arguments[2];
					pointBY = arguments[3];
					break;
				default:
					throw "getIntersectionPoints needs two or four arguments";
			}
			
			
			
			// Defined an include and exclude point
			var includePointX, includePointY, excludePointX, excludePointY;
	
			var bounds = this.absoluteBounds();
			
			if(this.isPointIncluded(pointAX, pointAY, bounds)){
				includePointX = pointAX;
				includePointY = pointAY;
			} else {
				excludePointX = pointAX;
				excludePointY = pointAY;
			}
	
			if(this.isPointIncluded(pointBX, pointBY, bounds)){
				includePointX = pointBX;
				includePointY = pointBY;
			} else {
				excludePointX = pointBX;
				excludePointY = pointBY;
			}
					
			// If there is no inclue or exclude Shape, than return
			if(!includePointX || !includePointY || !excludePointX || !excludePointY) {
				return undefined;
			}
	
			var midPointX = 0;
			var midPointY = 0;		
			
			var refPointX, refPointY;
			
			var minDifferent = 1;
			// Get the UpperLeft and LowerRight
			//var ul = bounds.upperLeft();
			//var lr = bounds.lowerRight();
			
			// Optimzation: Lookup if the intersection point
			// of the border and the line is include of the
			// shape. If so, this is also the intersection
			// point of the shape the line.
			var intersection = ORYX.Core.Math.getIntersectionPointOfRect(excludePointX, excludePointY,  // Line A
									includePointX, includePointY, 										// Line B
									bounds.upperLeft().x, bounds.upperLeft().y, 						// Rect A
									bounds.lowerRight().x, bounds.lowerRight().y );						// Rect B
									
			if (intersection && this.isPointIncluded(intersection.x, intersection.y, bounds)){
				return intersection;
			}				
			
			
			var i = 0;
			
			while(true) {
				// Calculate the midpoint of the current to points	
				var midPointX = Math.min(includePointX, excludePointX) + ((Math.max(includePointX, excludePointX) - Math.min(includePointX, excludePointX)) / 2.0);
				var midPointY = Math.min(includePointY, excludePointY) + ((Math.max(includePointY, excludePointY) - Math.min(includePointY, excludePointY)) / 2.0);
				
				
				// Set the new midpoint by the means of the include of the bounds
				if(this.isPointIncluded(midPointX, midPointY, bounds)){
					includePointX = midPointX;
					includePointY = midPointY;
				} else {
					excludePointX = midPointX;
					excludePointY = midPointY;
				}			
				
				// Calc the length of the line
				var length = Math.sqrt(Math.pow(includePointX - excludePointX, 2) + Math.pow(includePointY - excludePointY, 2));
				// Calc a point one step from the include point
				refPointX = includePointX + ((excludePointX - includePointX) / length);
				refPointY = includePointY + ((excludePointY - includePointY) / length);
						
				
				// If the reference point not in the bounds, break
				if(!this.isPointIncluded(refPointX, refPointY, bounds)) {
					break;
				}
				
				// Stop looking if the length is smaller than 1
				if (Math.abs(length) < 1){
					break;
				}
								
				
			}
	
			// Return the last includepoint
			return {x:refPointX , y:refPointY};
		},
	
	   
	    
	    /**
	     * Calculate if the point is inside the Shape
	     * @param {PointX}
	     * @param {PointY} 
	     */
	    isPointIncluded: function(){
			return  false;
		},
	
		/**
		 * Returns TRUE if the given node
		 * is a child node of the shapes node
		 * @param {Element} node
		 * @return {Boolean}
		 *
		 */
		containsNode: function(node){
			var me = this.node.firstChild.firstChild;
			while(node){
				if (node == me){
					return true;
				}
				node = node.parentNode;
			}
			return false;
		},
	    
	    /**
	     * Calculate if the point is over an special offset area
	     * @param {Point}
	     * @returns
	     */
	    isPointOverOffset: function(){
			return  this.isPointIncluded.apply( this , arguments );
		},
		
		/**
		 * Returns the overlapping Area within this and the passed shape
		 * @param {ORYX.Core.Shape} foreignShape
		 * @returns {ORYX.Core.Bounds || Boolean} The overlapping area or
		 *   false if no overlapping area exists
		 */
		getOverlap : function(foreignShape) {
			var shape = this;
			
			var shapeUL = shape.absoluteBounds().upperLeft();
			var shapeLR = shape.absoluteBounds().lowerRight();
			var foreignShapeUL = foreignShape.absoluteBounds().upperLeft();
			var foreignShapeLR = foreignShape.absoluteBounds().lowerRight();
	
			var xOverlap = Math.min(shapeLR.x, foreignShapeLR.x) - Math.max(shapeUL.x, foreignShapeUL.x);
			var yOverlap = Math.min(shapeLR.y, foreignShapeLR.y) - Math.max(shapeUL.y, foreignShapeUL.y);
			
			if (xOverlap > 0 || yOverlap > 0) {
				var ul = {
					x: Math.max(shapeUL.x, foreignShapeUL.x),
					y: Math.min(shapeLR.y, foreignShapeLR.y)
				};
				var lr = {
					x: Math.min(shapeLR.x, foreignShapeLR.x),
					y: Math.max(shapeUL.y, foreignShapeUL.y)
				};
				
				return new ORYX.Core.Bounds(ul, lr);
			} else {
				return false;
			}
		},
		
		_dockerChanged: function() {
	
		},
			
		/**
		 * Create a Docker for this Edge
		 * @param index
		 * @param position
		 * @returns {ORYX.Core.Controls.Docker}
		 */
		createDocker: function(index, position) {
			var docker = new ORYX.Core.Controls.Docker({eventHandlerCallback: this.eventHandlerCallback});
			docker.bounds.registerCallback(this._dockerChangedCallback);
			if(position) {
				docker.bounds.centerMoveTo(position);
			}
			this.add(docker, index);
			
			return docker;
		},
	
		/**
		 * Get the serialized object
		 * return Array with hash-entrees (prefix, name, value)
		 * Following values will given:
		 * 		Bounds
		 * 		Outgoing Shapes
		 * 		Parent
		 */
		serialize: function() {
			var serializedObject = arguments.callee.$.serialize.apply(this);
	
			// Add the bounds
			serializedObject.push({name: 'bounds', prefix:'oryx', value: this.bounds.serializeForERDF(), type: 'literal'});
	
			// Add the outgoing shapes
			this.getOutgoingShapes().each((function(followingShape){
				serializedObject.push({name: 'outgoing', prefix:'raziel', value: '#'+ERDF.__stripHashes(followingShape.resourceId), type: 'resource'});			
			}).bind(this));
	
			// Add the parent shape, if the parent not the canvas
			//if(this.parent instanceof ORYX.Core.Shape){
				serializedObject.push({name: 'parent', prefix:'raziel', value: '#'+ERDF.__stripHashes(this.parent.resourceId), type: 'resource'});	
			//}			
			
			return serializedObject;
		},
			
		/**
		 * 
		 * @param serialize
		 * @param json
		 */	
		deserialize: function(serialize, json){
			arguments.callee.$.deserialize.apply(this, arguments);
			
			// Set the Bounds
			var bounds = serialize.find(function(ser){ return 'oryx-bounds' === (ser.prefix+"-"+ser.name); });
			if (bounds) {
				var b = bounds.value.replace(/,/g, " ").split(" ").without("");
				if (this instanceof ORYX.Core.Edge) {
					if (!this.dockers.first().isChanged)
						this.dockers.first().bounds.centerMoveTo(parseFloat(b[0]), parseFloat(b[1]));
					if (!this.dockers.last().isChanged)
						this.dockers.last().bounds.centerMoveTo(parseFloat(b[2]), parseFloat(b[3]));
				} else {
					this.bounds.set(parseFloat(b[0]), parseFloat(b[1]), parseFloat(b[2]), parseFloat(b[3]));
				}
			}
			
			if (json && json.labels instanceof Array){
				json.labels.each(function(slabel){
					var label = this.getLabel(slabel.ref);
					if (label){
						label.deserialize(slabel, this);
					}
				}.bind(this));
			}
		},
		
		/**
		 * 
		 * @returns
		 */
		toJSON: function(){
			var json = arguments.callee.$.toJSON.apply(this, arguments);
			
			var labels = [], id = this.id;
			this._labels.each(function(obj){
				var slabel = obj.value.serialize();
				if (slabel){
					slabel.ref = obj.key.replace(id, '');
					labels.push(slabel);
				}
			});
			
			if (labels.length > 0){
				json.labels = labels;
			}
			return json;
		},
	
			
		/**
		 * Private methods.
		 */
	
		/**
		 * Child classes have to overwrite this method for initializing a loaded
		 * SVG representation.
		 * @param {SVGDocument} svgDocument
		 */
		_init: function(svgDocument) {
			//adjust ids
			this._adjustIds(svgDocument, 0);
		},
	
		_adjustIds: function(element, idIndex) {
			if(element instanceof Element) {
				var eid = element.getAttributeNS(null, 'id');
				if(eid && eid !== "") {
					element.setAttributeNS(null, 'id', this.id + eid);
				} else {
					element.setAttributeNS(null, 'id', this.id + "_" + this.id + "_" + idIndex);
					idIndex++;
				}
				
				// Replace URL in fill attribute
				var fill = element.getAttributeNS(null, 'fill');
				if (fill&&fill.include("url(#")){
					fill = fill.replace(/url\(#/g, 'url(#'+this.id);
					element.setAttributeNS(null, 'fill', fill);
				}
				// shanglihui 20120112 支持滤镜特性
				var filter = element.getAttributeNS(null, 'filter');
				if (filter&&filter.include("url(#")){
					filter = filter.replace(/url\(#/g, 'url(#'+this.id);
					element.setAttributeNS(null, 'filter', filter);
				}
				
				if(element.hasChildNodes()) {
					for(var i = 0; i < element.childNodes.length; i++) {
						idIndex = this._adjustIds(element.childNodes[i], idIndex);
					}
				}
			}
			return idIndex;
		},
	
		toString: function() { return "ORYX.Core.Shape " + this.getId(); }
	});
}();
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.Controls) {ORYX.Core.Controls = {};}


/**
 * @classDescription Abstract base class for all Controls.
 */
ORYX.Core.Controls.Control = ORYX.Core.UIObject.extend({
	
	toString: function() { return "Control " + this.id; }
 });/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/


/**
 * Init namespaces
 * @namespace The ORYX.Core.Controls Namespace
 * @name ORYX.Core.Controls
 */
if("undefined" == typeof ORYX) {var ORYX = {};}
if("undefined" == typeof ORYX.Core) {ORYX.Core = {};}
if("undefined" == typeof ORYX.Core.Controls) {ORYX.Core.Controls = {};}

new function(){
	/**
	 * @class ORYX.Core.Controls.Docker
	 * Represents a movable docker that can be bound to a shape. Dockers are used
	 * for positioning shape objects.
	 * @extends ORYX.Core.Controls.Control
	 * 
	 * TODO absoluteXY und absoluteCenterXY von einem Docker liefern falsche Werte!!!
	 */
	ORYX.Core.Controls.Docker = ORYX.Core.Controls.Control.extend({
	/** @lends ORYX.Core.Controls.Docker# */
		/**
		 * Constructor
		 * @constructor
		 */
		construct: function() {
			arguments.callee.$.construct.apply(this, arguments);
			
			var size = Ext.isIPad ? 12 : 8;
			
			this.isMovable = true;						// Enables movability
			this.bounds.set(0, 0, size*2, size*2);		// Set the bounds
			this.referencePoint = undefined;			// Refrenzpoint 
			this._dockedShapeBounds = undefined;		
			this._dockedShape = undefined;
			this._oldRefPoint1 = undefined;
			this._oldRefPoint2 = undefined;
			
			//this.anchors = [];
			this.anchorLeft;
			this.anchorRight;
			this.anchorTop;
			this.anchorBottom;
	
			this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg",
				null,
				['g']);
	
			// The DockerNode reprasentation
			this._dockerNode = ORYX.Editor.graft("http://www.w3.org/2000/svg",
				this.node,
				['g', {"pointer-events":"all"},
						['circle', {cx:size, cy:size, r:size, stroke:"none", fill:"none"}],
						['circle', {cx:size, cy:size, r:size-5, stroke:"black", fill:"red", "stroke-width":"1", "fill-opacity": Ext.isIPad ? 0.5 : 1, "stroke-opacity": Ext.isIPad ? 0.5 : 1}]
					]);
				
			// The ReferenzNode reprasentation	
			this._referencePointNode = ORYX.Editor.graft("http://www.w3.org/2000/svg",
				this.node,	
				['g', {"pointer-events":"none"},
					['circle', {cx: this.bounds.upperLeft().x, cy: this.bounds.upperLeft().y, r: 3, fill:"red", "fill-opacity":0.4, style:Ext.isIPad ? "visibility:hidden;" : ""}]]);
	
			// Hide the Docker
			this.hide();
			
			//Add to the EventHandler
			this.addEventHandlers(this._dockerNode);
	
			// Buffer the Update Callback for un-/register on Event-Handler 
			this._updateCallback = this._changed.bind(this);
		},
		
		update: function() {
			// If there have an DockedShape	
			if(this._dockedShape) {
				if(this._dockedShapeBounds && this._dockedShape instanceof ORYX.Core.Node) {
					// Calc the delta of width and height of the lastBounds and the current Bounds
					var dswidth = this._dockedShapeBounds.width();
					var dsheight = this._dockedShapeBounds.height();
					if(!dswidth)
						dswidth = 1;
					if(!dsheight)
						dsheight = 1;	
					var widthDelta = 	this._dockedShape.bounds.width() 	/ dswidth;
					var heightDelta = 	this._dockedShape.bounds.height() 	/ dsheight;
					
					// If there is an different
					if(widthDelta !== 1.0 || heightDelta !== 1.0) {
						// Set the delta
						this.referencePoint.x *= widthDelta;
						this.referencePoint.y *= heightDelta;
					}
		
					// Clone these bounds
					this._dockedShapeBounds = this._dockedShape.bounds.clone();				
				}
				
				// Get the first and the last Docker of the parent Shape
				var dockerIndex = this.parent.dockers.indexOf(this);
				var dock1 = this;
				var dock2 = this.parent.dockers.length > 1 ? 
								(dockerIndex === 0?							// If there is the first element
								 	this.parent.dockers[dockerIndex + 1]:	// then take the next docker
									this.parent.dockers[dockerIndex - 1]):  // if not, then take the docker before
								undefined;
				
				// Calculate the first absolute Refenzpoint 
				var absoluteReferenzPoint1 = dock1.getDockedShape() 
					&& !dock1._connectsEdgeOnEdge() ? 
						dock1.getAbsoluteReferencePoint() : 
						dock1.bounds.center();
	
				// Calculate the last absolute Refenzpoint 
				var absoluteReferenzPoint2 = dock2 && dock2.getDockedShape() 
						&& !dock2._connectsEdgeOnEdge() ? 
					dock2.getAbsoluteReferencePoint() : 
					dock2 ? 
						dock2.bounds.center() :
						undefined;
	
				// If there is no last absolute Referenzpoint		
				if(!absoluteReferenzPoint2) {
					// Calculate from the middle of the DockedShape
					var center = this._dockedShape.absoluteCenterXY();
					var minDimension = this._dockedShape.bounds.width() * this._dockedShape.bounds.height(); 
					absoluteReferenzPoint2 = {
						x: absoluteReferenzPoint1.x + (center.x - absoluteReferenzPoint1.x) * -minDimension,
						y: absoluteReferenzPoint1.y + (center.y - absoluteReferenzPoint1.y) * -minDimension
					};
				}
				
				var newPoint = undefined;
				
				/*if (!this._oldRefPoint1 || !this._oldRefPoint2 ||
					absoluteReferenzPoint1.x !== this._oldRefPoint1.x ||
					absoluteReferenzPoint1.y !== this._oldRefPoint1.y ||
					absoluteReferenzPoint2.x !== this._oldRefPoint2.x ||
					absoluteReferenzPoint2.y !== this._oldRefPoint2.y) {*/
					
					// Get the new point for the Docker, calucalted by the intersection point of the Shape and the two points
					newPoint = this._dockedShape.getIntersectionPoint(absoluteReferenzPoint1, absoluteReferenzPoint2);
					
					// If there is new point, take the referencepoint as the new point
					if(!newPoint) {
						newPoint = this.getAbsoluteReferencePoint();
					}
					
					if(this.parent && this.parent.parent) {
						var grandParentPos = this.parent.parent.absoluteXY();
						newPoint.x -= grandParentPos.x;
						newPoint.y -= grandParentPos.y;
					}
					
					// Set the bounds to the new point
					this.bounds.centerMoveTo(newPoint);
				
					this._oldRefPoint1 = absoluteReferenzPoint1;
					this._oldRefPoint2 = absoluteReferenzPoint2;
				} 
				/*else {
					newPoint = this.bounds.center();
				}*/
				
				
		//	}
			
			// Call the super class
			arguments.callee.$.update.apply(this, arguments);
		},
	
		/**
		 * Calls the super class refresh method and updates the view of the docker.
		 */
		refresh: function() {
			arguments.callee.$.refresh.apply(this, arguments);
			
			// Refresh the dockers node
			var p = this.bounds.upperLeft();
			this._dockerNode.setAttributeNS(null, 'transform','translate(' + p.x + ', ' + p.y + ')');
			
			// Refresh the referencepoints node
			p = Object.clone(this.referencePoint);
			
			if(p && this._dockedShape){
				var upL;
				if(this.parent instanceof ORYX.Core.Edge) {
					upL = this._dockedShape.absoluteXY();
				} else {
					upL = this._dockedShape.bounds.upperLeft();
				}
				p.x += upL.x;
				p.y += upL.y;
			} else {
				p = this.bounds.center();
			}			
	
			this._referencePointNode.setAttributeNS(null, 'transform','translate(' + p.x + ', ' + p.y + ')');
		},
	
		/**
		 * Set the reference point
		 * @param {Object} point
		 */	
		setReferencePoint: function(point) {
			// Set the referencepoint
			if(this.referencePoint !== point &&
				(!this.referencePoint || 
				!point ||
				this.referencePoint.x !== point.x || 
				this.referencePoint.y !== point.y)) {
				
				// Make sure that the reference point is inside the shape
				var dockedShape = this.getDockedShape();
				if (dockedShape) {
					point.x = Math.max(0, Math.min(dockedShape.bounds.width(), point.x));
					point.y = Math.max(0, Math.min(dockedShape.bounds.height(), point.y));
				}
				this.referencePoint = point;
				this._changed();			
			}
	
			
			// Update directly, because the referencepoint has no influence of the bounds
			//this.refresh();
		},
		
		/**
		 * Get the absolute referencepoint
		 */
		getAbsoluteReferencePoint: function() {
			if(!this.referencePoint || !this._dockedShape) {
				return undefined;
			} else {
				var absUL = this._dockedShape.absoluteXY();
				return {
							x: this.referencePoint.x + absUL.x,
							y: this.referencePoint.y + absUL.y
						};
			}
		},	
		
		/**
		 * Set the docked Shape from the docker
		 * @param {Object} shape
		 */
		setDockedShape: function(shape) {
	
			// If there is an old docked Shape
			if(this._dockedShape) {
				this._dockedShape.bounds.unregisterCallback(this._updateCallback);
				
				// Delete the Shapes from the incoming and outgoing array
				// If this Docker the incoming of the Shape
				if(this === this.parent.dockers.first()) {
					
					this.parent.incoming = this.parent.incoming.without(this._dockedShape);
					this._dockedShape.outgoing = this._dockedShape.outgoing.without(this.parent);
				
				// If this Docker the outgoing of the Shape	
				} else if (this === this.parent.dockers.last()){
		
					this.parent.outgoing = this.parent.outgoing.without(this._dockedShape);
					this._dockedShape.incoming = this._dockedShape.incoming.without(this.parent);
								
				}
				
			}
	
			
			// Set the new Shape
			this._dockedShape = shape;
			this._dockedShapeBounds = undefined;
			var referencePoint = undefined;
			
			// If there is an Shape, register the updateCallback if there are changes in the shape bounds
			if(this._dockedShape) {
				
				// Add the Shapes to the incoming and outgoing array
				// If this Docker the incoming of the Shape
				if(this === this.parent.dockers.first()) {
					
					this.parent.incoming.push(shape);
					shape.outgoing.push(this.parent);
				
				// If this Docker the outgoing of the Shape	
				} else if (this === this.parent.dockers.last()){
		
					this.parent.outgoing.push(shape);
					shape.incoming.push(this.parent);
								
				}
				
				// Get the bounds and set the new referencepoint
				var bounds = this.bounds;
				var absUL = shape.absoluteXY();
				
				/*if(shape.parent){
					var b = shape.parent.bounds.upperLeft();
					absUL.x -= b.x;
					absUL.y -= b.y;
				}*/
				
				referencePoint = {
					x: bounds.center().x - absUL.x,
					y: bounds.center().y - absUL.y
				};
							
				this._dockedShapeBounds = this._dockedShape.bounds.clone();
				
				this._dockedShape.bounds.registerCallback(this._updateCallback);
				
				// Set the color of the docker as docked
				this.setDockerColor(ORYX.CONFIG.DOCKER_DOCKED_COLOR);				
			} else {
				// Set the color of the docker as undocked
				this.setDockerColor(ORYX.CONFIG.DOCKER_UNDOCKED_COLOR);
			}
	
			// Set the referencepoint
			this.setReferencePoint(referencePoint);
			this._changed();
			//this.update();
		},
		
		/**
		 * Get the docked Shape
		 * @returns {ORYX.Core.Shape}
		 */
		getDockedShape: function() {
			return this._dockedShape;
		},
	
		/**
		 * Returns TRUE if the docker has a docked shape
		 * @returns {Boolean}
		 */
		isDocked: function() {
			return !!this._dockedShape;
		},
			
		/**
		 * Set the Color of the Docker
		 * @param {Object} color
		 */
		setDockerColor: function(color) {
			this._dockerNode.lastChild.setAttributeNS(null, "fill", color);
		},
		/**
		 * 
		 * @param prevent
		 */
		preventHiding: function(prevent){
			this._preventHiding = Math.max(0, (this._preventHiding||0) + (prevent ? 1 : -1));
		},
		
		/**
		 * Hides this UIObject and all its children.
		 * @returns {Boolean}
		 */
		hide: function() {
			if (this._preventHiding){
				return false;
			}
			
			// Hide docker and reference point
			this.node.setAttributeNS(null, 'visibility', 'hidden');
			this._referencePointNode.setAttributeNS(null, 'visibility', 'hidden');
			
			this.children.each(function(uiObj) {
				uiObj.hide();	
			});				
		},
		
		/**
		 * Enables visibility of this UIObject and all its children.
		 */
		show: function() {
			// Show docker
			this.node.setAttributeNS(null, 'visibility', 'visible');
			
			// Hide reference point if the connected shape is an edge
			if (this.getDockedShape() instanceof ORYX.Core.Edge){
				this._referencePointNode.setAttributeNS(null, 'visibility', 'hidden');
			} else {
				this._referencePointNode.setAttributeNS(null, 'visibility', 'visible');
			}
			
			this.children.each(function(uiObj) {
				uiObj.show();	
			});		
		},
		
		absoluteBounds : function(){
			return this.bounds.clone();
		},
		
		/**
		 * Checks if this docker connects two edges.
		 */
		_connectsEdgeOnEdge: function() {
			return (this.parent instanceof ORYX.Core.Edge 
					&& this.getDockedShape() instanceof ORYX.Core.Edge);
		},
 		
		/**
		 * @returns {String}
		 */
		toString: function() { return "Docker " + this.id; }
		
	});
}();
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.Controls) {ORYX.Core.Controls = {};}


/**
 * @classDescription Represents a magnet that is part of another shape and can
 * be attached to dockers. Magnets are used for linking edge objects
 * to other Shape objects.
 * @extends {Control}
 */
ORYX.Core.Controls.Magnet = ORYX.Core.Controls.Control.extend({
		
	/**
	 * Constructor
	 */
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);
		
		//this.anchors = [];
		this.anchorLeft;
		this.anchorRight;
		this.anchorTop;
		this.anchorBottom;
		
		this.bounds.set(0, 0, 16, 16);
		
		//graft magnet's root node into owner's control group.
		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg",
			null,
			['g', {"pointer-events":"all"},
					['circle', {cx:"8", cy:"8", r:"4", stroke:"none", fill:"red", "fill-opacity":"0.3"}]
				]);
			
		this.hide();
	},
	
	update: function() {
		arguments.callee.$.update.apply(this, arguments);
		
		//this.isChanged = true;
	},
	
	_update: function() {		
		arguments.callee.$.update.apply(this, arguments);
		
		//this.isChanged = true;
	},
	
	refresh: function() {
		arguments.callee.$.refresh.apply(this, arguments);

		var p = this.bounds.upperLeft();
		/*if(this.parent) {
			var parentPos = this.parent.bounds.upperLeft();
			p.x += parentPos.x;
			p.y += parentPos.y;
		}*/
		
		this.node.setAttributeNS(null, 'transform','translate(' + p.x + ', ' + p.y + ')');
	},
	
	show: function() {
		//this.refresh();
		arguments.callee.$.show.apply(this, arguments);
	},
	
	toString: function() {
		return "Magnet " + this.id;
	}
});

/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if (!ORYX) {
    var ORYX = {};
}
if (!ORYX.Core) {
    ORYX.Core = {};
}

/**
 * @classDescription Abstract base class for all Nodes.
 * @extends ORYX.Core.Shape
 */
ORYX.Core.Node = {

    /**
     * Constructor
     * @param options {Object} A container for arguments.
     * @param stencil {Stencil}
     */
    construct: function(options, stencil){
        arguments.callee.$.construct.apply(this, arguments);
        
        this.isSelectable = true;
        this.isMovable = true;
		this._dockerUpdated = false;
        
        this._oldBounds = new ORYX.Core.Bounds(); //init bounds with undefined values
        this._svgShapes = []; //array of all SVGShape objects of
        // SVG representation
        
        //TODO vielleicht in shape verschieben?
        this.minimumSize = undefined; // {width:..., height:...}
        this.maximumSize = undefined;
        
        //TODO vielleicht in shape oder uiobject verschieben?
        // vielleicht sogar isResizable ersetzen?
        this.isHorizontallyResizable = false;
        this.isVerticallyResizable = false;
        
        this.dataId = undefined;
        
        this._init(this._stencil.view());
    },
        
    /**
     * This method checks whether the shape is resized correctly and calls the
     * super class update method.
     */
    _update: function(){
		
		this.dockers.invoke("update");
		if (this.isChanged) {

			var bounds = this.bounds;
            var oldBounds = this._oldBounds;
						
			if (this.isResized) {
			
				var widthDelta = bounds.width() / oldBounds.width();
				var heightDelta = bounds.height() / oldBounds.height();
				
				//iterate over all relevant svg elements and resize them
				this._svgShapes.each(function(svgShape){
					//adjust width
					if (svgShape.isHorizontallyResizable) {
						svgShape.width = svgShape.oldWidth * widthDelta;
					}
					//adjust height
					if (svgShape.isVerticallyResizable) {
						svgShape.height = svgShape.oldHeight * heightDelta;
					}
					
					//check, if anchors are set
					var anchorOffset;
					var leftIncluded = svgShape.anchorLeft;
					var rightIncluded = svgShape.anchorRight;
					
					if (rightIncluded) {
						anchorOffset = oldBounds.width() - (svgShape.oldX + svgShape.oldWidth);
						if (leftIncluded) {
							svgShape.width = bounds.width() - svgShape.x - anchorOffset;
						}
						else {
							svgShape.x = bounds.width() - (anchorOffset + svgShape.width);
						}
					}
					else 
						if (!leftIncluded) {
							svgShape.x = widthDelta * svgShape.oldX;
							if (!svgShape.isHorizontallyResizable) {
								svgShape.x = svgShape.x + svgShape.width * widthDelta / 2 - svgShape.width / 2;
							}
						}
					
					var topIncluded = svgShape.anchorTop;
					var bottomIncluded = svgShape.anchorBottom;
					
					if (bottomIncluded) {
						anchorOffset = oldBounds.height() - (svgShape.oldY + svgShape.oldHeight);
						if (topIncluded) {
							svgShape.height = bounds.height() - svgShape.y - anchorOffset;
						}
						else {
							// Hack for choreography task layouting
							if (!svgShape._isYLocked) {
								svgShape.y = bounds.height() - (anchorOffset + svgShape.height);
							}
						}
					}
					else 
						if (!topIncluded) {
							svgShape.y = heightDelta * svgShape.oldY;
							if (!svgShape.isVerticallyResizable) {
								svgShape.y = svgShape.y + svgShape.height * heightDelta / 2 - svgShape.height / 2;
							}
						}
				});
				
				//check, if the current bounds is unallowed horizontally or vertically resized
				var p = {
					x: 0,
					y: 0
				};
				if (!this.isHorizontallyResizable && bounds.width() !== oldBounds.width()) {
					p.x = oldBounds.width() - bounds.width();
				}
				if (!this.isVerticallyResizable && bounds.height() !== oldBounds.height()) {
					p.y = oldBounds.height() - bounds.height();
				}
				if (p.x !== 0 || p.y !== 0) {
					bounds.extend(p);
				}
				
				//check, if the current bounds are between maximum and minimum bounds
				p = {
					x: 0,
					y: 0
				};
				var widthDifference, heightDifference;
				if (this.minimumSize) {
				
					ORYX.Log.debug("Shape (%0)'s min size: (%1x%2)", this, this.minimumSize.width, this.minimumSize.height);
					widthDifference = this.minimumSize.width - bounds.width();
					if (widthDifference > 0) {
						p.x += widthDifference;
					}
					heightDifference = this.minimumSize.height - bounds.height();
					if (heightDifference > 0) {
						p.y += heightDifference;
					}
				}
				if (this.maximumSize) {
				
					ORYX.Log.debug("Shape (%0)'s max size: (%1x%2)", this, this.maximumSize.width, this.maximumSize.height);
					widthDifference = bounds.width() - this.maximumSize.width;
					if (widthDifference > 0) {
						p.x -= widthDifference;
					}
					heightDifference = bounds.height() - this.maximumSize.height;
					if (heightDifference > 0) {
						p.y -= heightDifference;
					}
				}
				if (p.x !== 0 || p.y !== 0) {
					bounds.extend(p);
				}
				
				//update magnets
				
				var widthDelta = bounds.width() / oldBounds.width();
				var heightDelta = bounds.height() / oldBounds.height();
				
				var leftIncluded, rightIncluded, topIncluded, bottomIncluded, center, newX, newY;
				
				this.magnets.each(function(magnet){
					leftIncluded = magnet.anchorLeft;
					rightIncluded = magnet.anchorRight;
					topIncluded = magnet.anchorTop;
					bottomIncluded = magnet.anchorBottom;
					
					center = magnet.bounds.center();
					
					if (leftIncluded) {
						newX = center.x;
					}
					else 
						if (rightIncluded) {
							newX = bounds.width() - (oldBounds.width() - center.x)
						}
						else {
							newX = center.x * widthDelta;
						}
					
					if (topIncluded) {
						newY = center.y;
					}
					else 
						if (bottomIncluded) {
							newY = bounds.height() - (oldBounds.height() - center.y);
						}
						else {
							newY = center.y * heightDelta;
						}
					
					if (center.x !== newX || center.y !== newY) {
						magnet.bounds.centerMoveTo(newX, newY);
					}
				});
				
				// Set new position of labels
				this.getLabels().each(function(label){
					
					// If the flag is set, 
					// don't update again.
					if (label.updated){
						delete label.updated;
						return;
					}
					
					// Set the position depending on its anchor
					if (!label.isAnchorLeft()) {
						if (label.isAnchorRight()) {
							label.setX(bounds.width() - (oldBounds.width() - label.oldX))
						} else {
							label.setX((label.position?label.position.x:label.x) * widthDelta);
						}
					}
					if (!label.isAnchorTop()) {
						if (label.isAnchorBottom()) {
							label.setY(bounds.height() - (oldBounds.height() - label.oldY));
						} else {
							label.setY((label.position?label.position.y:label.y) * heightDelta);
						}
					}
					
					// If there is a position,
					// set the origin position as well
					if (label.position){
						if (!label.isOriginAnchorLeft()) {
							if (label.isOriginAnchorRight()) {
								label.setOriginX(bounds.width() - (oldBounds.width() - label.oldX))
							} else {
								label.setOriginX(label.x * widthDelta);
							}
						}
						if (!label.isOriginAnchorTop()) {
							if (label.isOriginAnchorBottom()) {
								label.setOriginY(bounds.height() - (oldBounds.height() - label.oldY));
							} else {
								label.setOriginY(label.y * heightDelta);
							}
						}
					}
				});
				
				//update docker
				var docker = this.dockers[0];
				if (docker) {
					docker.bounds.unregisterCallback(this._dockerChangedCallback);
					if (!this._dockerUpdated) {
						docker.bounds.centerMoveTo(this.bounds.center());
						this._dockerUpdated = false;
					}
					
					docker.update();
					docker.bounds.registerCallback(this._dockerChangedCallback);
				}
				this.isResized = false;
			}
            
            this.refresh();
			
			this.isChanged = false;
			
			this._oldBounds = this.bounds.clone();
        }
		
		this.children.each(function(value) {
			if(!(value instanceof ORYX.Core.Controls.Docker)) {
				value._update();
			}
		});
		
		if (this.dockers.length > 0&&!this.dockers.first().getDockedShape()) {
			this.dockers.each(function(docker){
				docker.bounds.centerMoveTo(this.bounds.center())
			}.bind(this));
		}
		
		// Append parent to its parent
		if (this.parent && !this.node.parentNode){
			var index = this.parent.nodes.indexOf(this);
			var parent = this.parent.getChildContainer();
			if(index < parent.childNodes.length)
				parent.insertBefore(this.node, parent.childNodes[index]);
			else
				parent.appendChild(this.node);
		}
		
		
		//if(index != undefined && index < parent.childNodes.length)
		//	uiObject.node = parent.insertBefore(uiObject.node, parent.childNodes[index]);
		//else
		//	uiObject.node = parent.appendChild(uiObject.node);
		
		
		
		/*this.incoming.each((function(edge) {
			if(!(this.dockers[0] && this.dockers[0].getDockedShape() instanceof ORYX.Core.Node))
				edge._update(true);
		}).bind(this));
		
		this.outgoing.each((function(edge) {
			if(!(this.dockers[0] && this.dockers[0].getDockedShape() instanceof ORYX.Core.Node))
				edge._update(true);
		}).bind(this)); */
    },
    
    /**
     * This method repositions and resizes the SVG representation
     * of the shape.
     */
    refresh: function(){
        arguments.callee.$.refresh.apply(this, arguments);
        
        /** Movement */
        var x = this.bounds.upperLeft().x;
        var y = this.bounds.upperLeft().y;
        
        //set translation in transform attribute
        /*var attributeTransform = document.createAttributeNS(ORYX.CONFIG.NAMESPACE_SVG, "transform");
        attributeTransform.nodeValue = "translate(" + x + ", " + y + ")";
        this.node.firstChild.setAttributeNode(attributeTransform);*/
		// Move owner element
		this.node.firstChild.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")");
		// Move magnets
		this.node.childNodes[1].childNodes[1].setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")");
        
        /** Resize */
        
        //iterate over all relevant svg elements and update them
        this._svgShapes.each(function(svgShape){
            svgShape.update();
        });
    },
    
    _dockerChanged: function(){
		var docker = this.dockers[0];
        
        //set the bounds of the the association
        this.bounds.centerMoveTo(docker.bounds.center());
        
		this._dockerUpdated = true;
        //this._update(true);
    },
    
    /**
     * This method traverses a tree of SVGElements and returns
     * all SVGShape objects. For each basic shape or path element
     * a SVGShape object is initialized.
     *
     * @param svgNode {SVGElement}
     * @return {Array} Array of SVGShape objects
     */
    _initSVGShapes: function(svgNode, parent){
        var svgShapes = [], svgShape;
        try {
            svgShape = new ORYX.Core.SVG.SVGShape(svgNode, parent);
            svgShapes.push(svgShape);
        } 
        catch (e) {
            //do nothing
        }
        
        if (svgNode.hasChildNodes()) {
            for (var i = 0; i < svgNode.childNodes.length; i++) {
                svgShapes = svgShapes.concat(this._initSVGShapes(svgNode.childNodes[i], svgShape));
            }
        }
        
        return svgShapes;
    },
    
    /**
     * Calculate if the point is inside the Shape
     * @param {PointX}
     * @param {PointY} 
     * @param {absoluteBounds} optional: for performance
     */
    isPointIncluded: function(pointX, pointY, absoluteBounds){
        // If there is an arguments with the absoluteBounds
        var absBounds = absoluteBounds && absoluteBounds instanceof ORYX.Core.Bounds ? absoluteBounds : this.absoluteBounds();
        
        if (!absBounds.isIncluded(pointX, pointY)) {
			return false;
		} else {
			
		}
			
        
        //point = Object.clone(point);
        var ul = absBounds.upperLeft();
        var x = pointX - ul.x;
        var y = pointY - ul.y;		
	
		var i=0;
		do {
			var isPointIncluded = this._svgShapes[i++].isPointIncluded( x, y );
		} while( !isPointIncluded && i < this._svgShapes.length)
		
		return isPointIncluded;

        /*return this._svgShapes.any(function(svgShape){
            return svgShape.isPointIncluded(point);
        });*/
    },
 
    
    /**
     * Calculate if the point is over an special offset area
     * @param {Point}
     */
    isPointOverOffset: function( pointX, pointY ){       
		var isOverEl = arguments.callee.$.isPointOverOffset.apply( this , arguments );
		
		if (isOverEl) {
						
	        // If there is an arguments with the absoluteBounds
	        var absBounds = this.absoluteBounds();
	        absBounds.widen( - ORYX.CONFIG.BORDER_OFFSET );
			
	        if ( !absBounds.isIncluded( pointX, pointY )) {
	            return true;
	        }		
		}
		
		return false;
		
	},
	   
    serialize: function(){
        var result = arguments.callee.$.serialize.apply(this);
        
        // Add the docker's bounds
        // nodes only have at most one docker!
        this.dockers.each((function(docker){
			if (docker.getDockedShape()) {
				var center = docker.referencePoint;
				center = center ? center : docker.bounds.center();
				result.push({
					name: 'docker',
					prefix: 'oryx',
					value: $H(center).values().join(','),
					type: 'literal'
				});
			}
        }).bind(this));
        
        // Get the spezific serialized object from the stencil
        try {
            //result = this.getStencil().serialize(this, result);

			var serializeEvent = this.getStencil().serialize();
			
			/*
			 * call serialize callback by reference, result should be found
			 * in serializeEvent.result
			 */
			if(serializeEvent.type) {
				serializeEvent.shape = this;
				serializeEvent.data = result;
				serializeEvent.result = undefined;
				serializeEvent.forceExecution = true;
				
				this._delegateEvent(serializeEvent);
				
				if(serializeEvent.result) {
					result = serializeEvent.result;
				}
			}
        } 
        catch (e) {
        }
        return result;
    },
    
    deserialize: function(data){
    	arguments.callee.$.deserialize.apply(this, arguments);
		
	    try {
            //data = this.getStencil().deserialize(this, data);

			var deserializeEvent = this.getStencil().deserialize();
			
			/*
			 * call serialize callback by reference, result should be found
			 * in serializeEventInfo.result
			 */
			if(deserializeEvent.type) {
				deserializeEvent.shape = this;
				deserializeEvent.data = data;
				deserializeEvent.result = undefined;
				deserializeEvent.forceExecution = true;
				
				this._delegateEvent(deserializeEvent);
				if(deserializeEvent.result) {
					data = deserializeEvent.result;
				}
			}
        } 
        catch (e) {
        }
		
		// Set the outgoing shapes
		var outgoing = data.findAll(function(ser){ return (ser.prefix+"-"+ser.name) == 'raziel-outgoing'});
		outgoing.each((function(obj){
			// TODO: Look at Canvas
			if(!this.parent) {return};
								
			// Set outgoing Shape
			var next = this.getCanvas().getChildShapeByResourceId(obj.value);
																	
			if(next){
				if(next instanceof ORYX.Core.Edge) {
					//Set the first docker of the next shape
					var refPoint = next.dockers.first().referencePoint || next.dockers.first().bounds.center();
					var refPointCopy = { 
						x: refPoint.x,
						y: refPoint.y
					};
					next.dockers.first().setDockedShape(this);
					next.dockers.first().setReferencePoint(refPointCopy);
				} else if(next.dockers.length > 0) { //next is a node and next has a docker
					next.dockers.first().setDockedShape(this);
					//next.dockers.first().setReferencePoint({x: this.bounds.width() / 2.0, y: this.bounds.height() / 2.0});
				}
			}	
			
		}).bind(this));
        
        if (this.dockers.length === 1) {
            var dockerPos;
            dockerPos = data.find(function(entry){
                return (entry.prefix + "-" + entry.name === "oryx-dockers");
            });
            
            if (dockerPos) {
                var points = dockerPos.value.replace(/,/g, " ").split(" ").without("").without("#");
				if (points.length === 2 && this.dockers[0].getDockedShape()) {
                    this.dockers[0].setReferencePoint({
                        x: parseFloat(points[0]),
                        y: parseFloat(points[1])
                    });
                }
                else {
                    this.dockers[0].bounds.centerMoveTo(parseFloat(points[0]), parseFloat(points[1]));
                }
            }
        }
    },
    
    /**
     * This method excepts the SVGDoucment that is the SVG representation
     * of this shape.
     * The bounds of the shape are calculated, the SVG representation's upper left point
     * is moved to 0,0 and it the method sets if this shape is resizable.
     *
     * @param {SVGDocument} svgDocument
     */
    _init: function(svgDocument){
        arguments.callee.$._init.apply(this, arguments);
		
        var svgNode = svgDocument.getElementsByTagName("g")[0]; //outer most g node
        // set all required attributes
        var attributeTitle = svgDocument.ownerDocument.createAttributeNS(null, "title");
        attributeTitle.nodeValue = this.getStencil().title();
        svgNode.setAttributeNode(attributeTitle);
        
        var attributeId = svgDocument.ownerDocument.createAttributeNS(null, "id");
        attributeId.nodeValue = this.id;
        svgNode.setAttributeNode(attributeId);
        
        // 
        var stencilTargetNode = this.node.childNodes[0].childNodes[0]; //<g class=me>"

        
        /**set minimum and maximum size*/
        var minSizeAttr = svgNode.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "minimumSize");
        if (minSizeAttr) {
            minSizeAttr = minSizeAttr.replace("/,/g", " ");
            var minSizeValues = minSizeAttr.split(" ");
            minSizeValues = minSizeValues.without("");
            
            if (minSizeValues.length > 1) {
                this.minimumSize = {
                    width: parseFloat(minSizeValues[0]),
                    height: parseFloat(minSizeValues[1])
                };
            }
            else {
                //set minimumSize to (1,1), so that width and height of the stencil can never be (0,0)
                this.minimumSize = {
                    width: 1,
                    height: 1
                };
            }
        }
        
        var maxSizeAttr = svgNode.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "maximumSize");
        if (maxSizeAttr) {
            maxSizeAttr = maxSizeAttr.replace("/,/g", " ");
            var maxSizeValues = maxSizeAttr.split(" ");
            maxSizeValues = maxSizeValues.without("");
            
            if (maxSizeValues.length > 1) {
                this.maximumSize = {
                    width: parseFloat(maxSizeValues[0]),
                    height: parseFloat(maxSizeValues[1])
                };
            }
        }
        
        if (this.minimumSize && this.maximumSize &&
        (this.minimumSize.width > this.maximumSize.width ||
        this.minimumSize.height > this.maximumSize.height)) {
        
            //TODO wird verschluckt!!!
            throw this + ": Minimum Size must be greater than maxiumSize.";
        }
        
        /**get current bounds and adjust it to upperLeft == (0,0)*/
        //initialize all SVGShape objects
        this._svgShapes = this._initSVGShapes(svgNode);
        
        //get upperLeft and lowerRight of stencil
        var upperLeft = {
            x: undefined,
            y: undefined
        };
        var lowerRight = {
            x: undefined,
            y: undefined
        };
        var me = this;
        this._svgShapes.each(function(svgShape){
            upperLeft.x = (upperLeft.x !== undefined) ? Math.min(upperLeft.x, svgShape.x) : svgShape.x;
            upperLeft.y = (upperLeft.y !== undefined) ? Math.min(upperLeft.y, svgShape.y) : svgShape.y;
            lowerRight.x = (lowerRight.x !== undefined) ? Math.max(lowerRight.x, svgShape.x + svgShape.width) : svgShape.x + svgShape.width;
            lowerRight.y = (lowerRight.y !== undefined) ? Math.max(lowerRight.y, svgShape.y + svgShape.height) : svgShape.y + svgShape.height;
            
            /** set if resizing is enabled */
            //TODO isResizable durch die beiden anderen booleans ersetzen?
            if (svgShape.isHorizontallyResizable) {
                me.isHorizontallyResizable = true;
                me.isResizable = true;
            }
            if (svgShape.isVerticallyResizable) {
                me.isVerticallyResizable = true;
                me.isResizable = true;
            }
            if (svgShape.anchorTop && svgShape.anchorBottom) {
                me.isVerticallyResizable = true;
                me.isResizable = true;
            }
            if (svgShape.anchorLeft && svgShape.anchorRight) {
                me.isHorizontallyResizable = true;
                me.isResizable = true;
            }
        });
        
        //move all SVGShapes by -upperLeft
        this._svgShapes.each(function(svgShape){
            svgShape.x -= upperLeft.x;
            svgShape.y -= upperLeft.y;
            svgShape.update();
        });
        
        //set bounds of shape
        //the offsets are also needed for positioning the magnets and the docker
        var offsetX = upperLeft.x;
        var offsetY = upperLeft.y;
        
        lowerRight.x -= offsetX;
        lowerRight.y -= offsetY;
        upperLeft.x = 0;
        upperLeft.y = 0;
        
        //prevent that width or height of initial bounds is 0
        if (lowerRight.x === 0) {
            lowerRight.x = 1;
        }
        if (lowerRight.y === 0) {
            lowerRight.y = 1;
        }
        
        this._oldBounds.set(upperLeft, lowerRight);
        this.bounds.set(upperLeft, lowerRight);
        
        /**initialize magnets */
        
        var magnets = svgDocument.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_ORYX, "magnets");
        
        if (magnets && magnets.length > 0) {
        
            magnets = $A(magnets[0].getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_ORYX, "magnet"));
            
            var me = this;
            magnets.each(function(magnetElem){
                var magnet = new ORYX.Core.Controls.Magnet({
                    eventHandlerCallback: me.eventHandlerCallback
                });
                var cx = parseFloat(magnetElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "cx"));
                var cy = parseFloat(magnetElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "cy"));
                magnet.bounds.centerMoveTo({
                    x: cx - offsetX,
                    y: cy - offsetY
                });
                
                //get anchors
                var anchors = magnetElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "anchors");
                if (anchors) {
                    anchors = anchors.replace("/,/g", " ");
                    anchors = anchors.split(" ").without("");
                    for(var i = 0; i < anchors.length; i++) {
						switch(anchors[i].toLowerCase()) {
							case "left":
								magnet.anchorLeft = true;
								break;
							case "right":
								magnet.anchorRight = true;
								break;
							case "top":
								magnet.anchorTop = true;
								break;
							case "bottom":
								magnet.anchorBottom = true;
								break;
						}
					}
                }
                
                me.add(magnet);
                
                //check, if magnet is default magnet
                if (!this._defaultMagnet) {
                    var defaultAttr = magnetElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "default");
                    if (defaultAttr && defaultAttr.toLowerCase() === "yes") {
                        me._defaultMagnet = magnet;
                    }
                }
            });
        }
        else {
            // Add a Magnet in the Center of Shape			
            var magnet = new ORYX.Core.Controls.Magnet();
            magnet.bounds.centerMoveTo(this.bounds.width() / 2, this.bounds.height() / 2);
            this.add(magnet);
        }
        
        /**initialize docker */
        var dockerElem = svgDocument.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_ORYX, "docker");
        
        if (dockerElem && dockerElem.length > 0) {
            dockerElem = dockerElem[0];
            var docker = this.createDocker();
            var cx = parseFloat(dockerElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "cx"));
            var cy = parseFloat(dockerElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "cy"));
            docker.bounds.centerMoveTo({
                x: cx - offsetX,
                y: cy - offsetY
            });
            
            //get anchors
            var anchors = dockerElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "anchors");
            if (anchors) {
                anchors = anchors.replace("/,/g", " ");
                anchors = anchors.split(" ").without("");
                
				for(var i = 0; i < anchors.length; i++) {
					switch(anchors[i].toLowerCase()) {
						case "left":
							docker.anchorLeft = true;
							break;
						case "right":
							docker.anchorRight = true;
							break;
						case "top":
							docker.anchorTop = true;
							break;
						case "bottom":
							docker.anchorBottom = true;
							break;
					}
				}
            }
        }
        
        /**initialize labels*/
        var textElems = svgNode.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'text');
        $A(textElems).each((function(textElem){
            var label = new ORYX.Core.SVG.Label({
                textElement: textElem,
				shapeId: this.id,
				richtext: true
            });
            label.x -= offsetX;
            label.y -= offsetY;
            this._labels[label.id] = label;
			
			label.registerOnChange(this.layout.bind(this));
			
        }).bind(this));
        
        // Add to its parent
        stencilTargetNode.appendChild(svgNode);        
        // Add to the EventHandler
        this.addEventHandlers(stencilTargetNode);
    },
	
	/**
	 * Override the Method, that a docker is not shown
	 *
	 */
	createDocker: function() {
		var docker = new ORYX.Core.Controls.Docker({eventHandlerCallback: this.eventHandlerCallback});
		docker.bounds.registerCallback(this._dockerChangedCallback);
		
		this.dockers.push( docker );
		docker.parent = this;
		docker.bounds.registerCallback(this._changedCallback);		
		
		return docker;
	},	
	
	/**
	 * @param {String|Element} The id or the element of the svg shape
	 * @return {SVGShape}
	 */
	getSVGShape: function(node){
		return this._svgShapes.find(function(sshape){
			return sshape === node || sshape.node === node || sshape.id.endsWith(String(node));
		})
	},
	
    toString: function(){
        return this._stencil.title() + " " + this.id
    }
};
ORYX.Core.Node = ORYX.Core.Shape.extend(ORYX.Core.Node);
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
NAMESPACE_SVG = "http://www.w3.org/2000/svg";
NAMESPACE_ORYX = "http://www.b3mn.org/oryx";


/**
 * Init namespaces
 */
if (!ORYX) {
    var ORYX = {};
}
if (!ORYX.Core) {
    ORYX.Core = {};
}


/**
 * @classDescription Abstract base class for all connections.
 * @extends {ORYX.Core.Shape}
 * @param options {Object}
 *
 * TODO da die verschiebung der Edge nicht ueber eine
 *  translation gemacht wird, die sich auch auf alle kind UIObjects auswirkt,
 *  muessen die kinder hier beim verschieben speziell betrachtet werden.
 *  Das sollte ueberarbeitet werden.
 *
 */
ORYX.Core.Edge = {
    /**
     * Constructor
     * @param {Object} options
     * @param {Stencil} stencil
     */
    construct: function(options, stencil){
        arguments.callee.$.construct.apply(this, arguments);
        
        this.isMovable = true;
        this.isSelectable = true;
		
		this._dockerUpdated = false;
        
        this._markers = new Hash(); //a hash map of SVGMarker objects where keys are the marker ids
        this._paths = [];
        this._interactionPaths = [];
        this._shadowPaths = [];
        this._dockersByPath = new Hash();
        this._markersByPath = new Hash();
		
		/* Data structures to store positioning information of attached child nodes */ 
		this.attachedNodePositionData = new Hash();
        
        //TODO was muss hier initial erzeugt werden?
        var stencilNode = this.node.childNodes[0].childNodes[0];
        stencilNode = ORYX.Editor.graft("http://www.w3.org/2000/svg", stencilNode, ['g', {
            "pointer-events": "painted"
        }]);
        
        //Add to the EventHandler
        this.addEventHandlers(stencilNode.parentNode);
        
        
        this._oldBounds = this.bounds.clone();
        
        //load stencil
        this._init(this._stencil.view());
        
        if (stencil instanceof Array) {
            this.deserialize(stencil);
        }
        
    },
    
    _update: function(force){
		if(this._dockerUpdated || this.isChanged || force) {
			
			this.dockers.invoke("update");
			
	        if (false && (this.bounds.width() === 0 || this.bounds.height() === 0)) {
				var width = this.bounds.width();
				var height = this.bounds.height();
	            this.bounds.extend({
	                x: width === 0 ? 2 : 0,
	                y: height === 0 ? 2 : 0
	            });
	            this.bounds.moveBy({
	                x: width === 0 ? -1 : 0,
	                y: height === 0 ? -1 : 0
	            });
            
	        }
	        
	        // TODO: Bounds muss abhaengig des Eltern-Shapes gesetzt werden
	        var upL = this.bounds.upperLeft();
	        var oldUpL = this._oldBounds.upperLeft();
	        var oldWidth = this._oldBounds.width() === 0 ? this.bounds.width() : this._oldBounds.width();
	        var oldHeight = this._oldBounds.height() === 0 ? this.bounds.height() : this._oldBounds.height();
	        var diffX = upL.x - oldUpL.x;
	        var diffY = upL.y - oldUpL.y;
	        var diffWidth = (this.bounds.width() / oldWidth) || 1;
	        var diffHeight = (this.bounds.height() / oldHeight) || 1;
	        
	        this.dockers.each((function(docker){
	            // Unregister on BoundsChangedCallback
	            docker.bounds.unregisterCallback(this._dockerChangedCallback);
	            
	            // If there is any changes at the edge and is there is not an DockersUpdate
	            // set the new bounds to the docker
	            if (!this._dockerUpdated) {
	                docker.bounds.moveBy(diffX, diffY);
	                
	                if (diffWidth !== 1 || diffHeight !== 1) {
	                    var relX = docker.bounds.upperLeft().x - upL.x;
	                    var relY = docker.bounds.upperLeft().y - upL.y;
	                    
	                    docker.bounds.moveTo(upL.x + relX * diffWidth, upL.y + relY * diffHeight);
	                }
	            }
	            // Do Docker update and register on DockersBoundChange
	            docker.update();
	            docker.bounds.registerCallback(this._dockerChangedCallback);
	            
	        }).bind(this));
	        
	        if (this._dockerUpdated) {
	            var a = this.dockers.first().bounds.center();
	            var b = this.dockers.first().bounds.center();
	            
	            this.dockers.each((function(docker){
	                var center = docker.bounds.center();
	                a.x = Math.min(a.x, center.x);
	                a.y = Math.min(a.y, center.y);
	                b.x = Math.max(b.x, center.x);
	                b.y = Math.max(b.y, center.y);
	            }).bind(this));
	            
	            //set the bounds of the the association
	            this.bounds.set(Object.clone(a), Object.clone(b));
	        }
			
			upL = this.bounds.upperLeft(); oldUpL = this._oldBounds.upperLeft();
			diffWidth = (this.bounds.width() / (oldWidth||this.bounds.width())); diffHeight = (this.bounds.height() / (oldHeight||this.bounds.height())); 
	        diffX = upL.x - oldUpL.x; diffY = upL.y - oldUpL.y;
					
			//reposition labels
			this.getLabels().each(function(label) {
				
				if (label.getReferencePoint()){
					var ref = label.getReferencePoint();
					var from = ref.segment.from, to = ref.segment.to;
					if (!from || !from.parent || !to || !to.parent) {
						return;
					}
					
					var fromPosition = from.bounds.center(), toPosition = to.bounds.center();

					if (fromPosition.x === ref.segment.fromPosition.x && fromPosition.y === ref.segment.fromPosition.y &&
						toPosition.x === ref.segment.toPosition.x && toPosition.y === ref.segment.toPosition.y && !ref.dirty){
						return;
					}
					
					if (!this.parent.initializingShapes) {
						var oldDistance = ORYX.Core.Math.getDistanceBetweenTwoPoints(ref.segment.fromPosition, ref.segment.toPosition, ref.intersection);
						var newIntersection = ORYX.Core.Math.getPointBetweenTwoPoints(fromPosition, toPosition, isNaN(oldDistance) ? 0.5 : oldDistance);
						
						/**
						 * Set position
						 */
						// Get the orthogonal identity vector of the current segment
						var oiv = ORYX.Core.Math.getOrthogonalIdentityVector(fromPosition, toPosition);
						var isHor = Math.abs(oiv.y)===1, isVer = Math.abs(oiv.x)===1;
						oiv.x *= ref.distance; oiv.y *= ref.distance; 				// vector * distance
						oiv.x += newIntersection.x; oiv.y += newIntersection.y; 	// vector + the intersection point				
						var mx = isHor && ref.orientation && (ref.iorientation||ref.orientation).endsWith("r") ? -label.getWidth() : 0;		
						var my = isVer && ref.orientation && (ref.iorientation||ref.orientation).startsWith("l") ? -label.getHeight()+2 : 0;
						label.setX(oiv.x+mx); label.setY(oiv.y+my);
						
						// Update the reference point
						this.updateReferencePointOfLabel(label, newIntersection, from, to);
					} else {
						var oiv = ORYX.Core.Math.getOrthogonalIdentityVector(fromPosition, toPosition);
						oiv.x *= ref.distance; oiv.y *= ref.distance; // vector * distance
						oiv.x += ref.intersection.x; oiv.y += ref.intersection.y; // vector + the intersection point		
						label.setX(oiv.x); label.setY(oiv.y);
						ref.segment.fromPosition = fromPosition; ref.segment.toPosition = toPosition;		
					}
					
					return;	
				}
				
				// Update label position if no reference point is set
				if (label.position && !this.parent.initializingShapes){
					var x = label.position.x + (diffX * (diffWidth||1));
					if (x > this.bounds.lowerRight().x){
						x += this.bounds.width()-(this.bounds.width()/(diffWidth||1));
					}
					
					var y = label.position.y + (diffY * (diffHeight||1));
					if (y > this.bounds.lowerRight().y){
						y += this.bounds.height()-(this.bounds.height()/(diffHeight||1));
					}
					label.setX(x);label.setY(y);
					return;
				}
				
				switch (label.getEdgePosition()) {
					case "starttop":
						var angle = this._getAngle(this.dockers[0], this.dockers[1]);
						var pos = this.dockers.first().bounds.center();
						
						if (angle <= 90 || angle > 270) {
							label.horizontalAlign("left");
							label.verticalAlign("bottom");
							label.x = pos.x + label.getOffsetTop();
							label.y = pos.y - label.getOffsetTop();
							label.rotate(360 - angle, pos);
						} else {
							label.horizontalAlign("right");
							label.verticalAlign("bottom");
							label.x = pos.x - label.getOffsetTop();
							label.y = pos.y - label.getOffsetTop();
							label.rotate(180 - angle, pos);
						}
						
						break;

					case "startmiddle":
						var angle = this._getAngle(this.dockers[0], this.dockers[1]);
						var pos = this.dockers.first().bounds.center();
						
						if (angle <= 90 || angle > 270) {
							label.horizontalAlign("left");
							label.verticalAlign("bottom");
							label.x = pos.x + 2;
							label.y = pos.y + 4;
							label.rotate(360 - angle, pos);
						} else {
							label.horizontalAlign("right");
							label.verticalAlign("bottom");
							label.x = pos.x + 1;
							label.y = pos.y + 4;
							label.rotate(180 - angle, pos);
						}
						
						break;
												
					case "startbottom":
						var angle = this._getAngle(this.dockers[0], this.dockers[1]);
						var pos = this.dockers.first().bounds.center();
						
						if (angle <= 90 || angle > 270) {
							label.horizontalAlign("left");
							label.verticalAlign("top");
							label.x = pos.x + label.getOffsetBottom();
							label.y = pos.y + label.getOffsetBottom();
							label.rotate(360 - angle, pos);
						} else {
							label.horizontalAlign("right");
							label.verticalAlign("top");
							label.x = pos.x - label.getOffsetBottom();
							label.y = pos.y + label.getOffsetBottom();
							label.rotate(180 - angle, pos);
						}
						
						break;
					case "midtop":
						var numOfDockers = this.dockers.length;
						if(numOfDockers%2 == 0) {
							var angle = this._getAngle(this.dockers[numOfDockers/2-1], this.dockers[numOfDockers/2])
							var pos1 = this.dockers[numOfDockers/2-1].bounds.center();
							var pos2 = this.dockers[numOfDockers/2].bounds.center();
							var pos = {x:(pos1.x + pos2.x)/2.0, y:(pos1.y+pos2.y)/2.0};
							
							label.horizontalAlign("center");
							label.verticalAlign("bottom");
							label.x = pos.x;
							label.y = pos.y - label.getOffsetTop();
								
							if (angle <= 90 || angle > 270) {
								label.rotate(360 - angle, pos);
							} else {
								label.rotate(180 - angle, pos);
							}
						} else {
							var index = parseInt(numOfDockers/2);
							var angle = this._getAngle(this.dockers[index], this.dockers[index+1])
							var pos = this.dockers[index].bounds.center();
							
							if (angle <= 90 || angle > 270) {
								label.horizontalAlign("left");
								label.verticalAlign("bottom");
								label.x = pos.x + label.getOffsetTop();
								label.y = pos.y - label.getOffsetTop();
								label.rotate(360 - angle, pos);
							} else {
								label.horizontalAlign("right");
								label.verticalAlign("bottom");
								label.x = pos.x - label.getOffsetTop();
								label.y = pos.y - label.getOffsetTop();
								label.rotate(180 - angle, pos);
							}
						}
						
						break;
					case "midbottom":
						var numOfDockers = this.dockers.length;
						if(numOfDockers%2 == 0) {
							var angle = this._getAngle(this.dockers[numOfDockers/2-1], this.dockers[numOfDockers/2])
							var pos1 = this.dockers[numOfDockers/2-1].bounds.center();
							var pos2 = this.dockers[numOfDockers/2].bounds.center();
							var pos = {x:(pos1.x + pos2.x)/2.0, y:(pos1.y+pos2.y)/2.0};
							
							label.horizontalAlign("center");
							label.verticalAlign("top");
							label.x = pos.x;
							label.y = pos.y + label.getOffsetTop();
							
							if (angle <= 90 || angle > 270) {
								label.rotate(360 - angle, pos);
							} else {
								label.rotate(180 - angle, pos);
							}
						} else {
							var index = parseInt(numOfDockers/2);
							var angle = this._getAngle(this.dockers[index], this.dockers[index+1])
							var pos = this.dockers[index].bounds.center();
							
							if (angle <= 90 || angle > 270) {
								label.horizontalAlign("left");
								label.verticalAlign("top");
								label.x = pos.x + label.getOffsetBottom();
								label.y = pos.y + label.getOffsetBottom();
								label.rotate(360 - angle, pos);
							} else {
								label.horizontalAlign("right");
								label.verticalAlign("top");
								label.x = pos.x - label.getOffsetBottom();
								label.y = pos.y + label.getOffsetBottom();
								label.rotate(180 - angle, pos);
							}
						}
						
						break;
					case "endtop":
						var length = this.dockers.length;
						var angle = this._getAngle(this.dockers[length-2], this.dockers[length-1]);
						var pos = this.dockers.last().bounds.center();
						
						if (angle <= 90 || angle > 270) {
							label.horizontalAlign("right");
							label.verticalAlign("bottom");
							label.x = pos.x - label.getOffsetTop();
							label.y = pos.y - label.getOffsetTop();
							label.rotate(360 - angle, pos);
						} else {
							label.horizontalAlign("left");
							label.verticalAlign("bottom");
							label.x = pos.x + label.getOffsetTop();
							label.y = pos.y - label.getOffsetTop();
							label.rotate(180 - angle, pos);
						}
						
						break;
					case "endbottom":
						var length = this.dockers.length;
						var angle = this._getAngle(this.dockers[length-2], this.dockers[length-1]);
						var pos = this.dockers.last().bounds.center();
						
						if (angle <= 90 || angle > 270) {
							label.horizontalAlign("right");
							label.verticalAlign("top");
							label.x = pos.x - label.getOffsetBottom();
							label.y = pos.y + label.getOffsetBottom();
							label.rotate(360 - angle, pos);
						} else {
							label.horizontalAlign("left");
							label.verticalAlign("top");
							label.x = pos.x + label.getOffsetBottom();
							label.y = pos.y + label.getOffsetBottom();
							label.rotate(180 - angle, pos);
						}
						
						break;
				}
			}.bind(this));
			
			this.children.each(function(value) {
				if(value instanceof ORYX.Core.Node) {
					this.calculatePositionOfAttachedChildNode.call(this, value);
				}
			}.bind(this));
			
			this.refreshAttachedNodes();
			this.refresh();
			
			this.isChanged = false;
			this._dockerUpdated = false;
			
			this._oldBounds = this.bounds.clone();
        }
		
		if (this.parent && !this.node.parentNode){
			this.parent.getEdgeContainer().appendChild(this.node);
		}
    },
	
	/**
	 *  Moves a point to the upperLeft of a node's bounds.
	 *  
	 *  @param {point} point
	 *  	The point to move
	 *  @param {ORYX.Core.Bounds} bounds
	 *  	The Bounds of the related noe
	 */
	movePointToUpperLeftOfNode: function(point, bounds) {
		point.x -= bounds.width()/2;
		point.y -= bounds.height()/2;
	},
	
	/**
	 * Refreshes the visual representation of edge's attached nodes.
	 */	
	refreshAttachedNodes: function() {
		this.attachedNodePositionData.values().each(function(nodeData) {
			var startPoint = nodeData.segment.docker1.bounds.center();
			var endPoint = nodeData.segment.docker2.bounds.center();
			this.relativizePoint(startPoint);
			this.relativizePoint(endPoint);
			
			var newNodePosition = new Object();
			
			/* Calculate new x-coordinate */
			newNodePosition.x = startPoint.x 
								+ nodeData.relativDistanceFromDocker1
									* (endPoint.x - startPoint.x);
			
			/* Calculate new y-coordinate */
			newNodePosition.y = startPoint.y 
								+ nodeData.relativDistanceFromDocker1
									* (endPoint.y - startPoint.y);
			
			/* Convert new position to the upper left of the node */
			this.movePointToUpperLeftOfNode(newNodePosition, nodeData.node.bounds);
			
			/* Move node to its new position */
			nodeData.node.bounds.moveTo(newNodePosition);
			nodeData.node._update();					
			
		}.bind(this));
	},
	
	/**
	 * Calculates the position of an edge's child node. The node is placed on 
	 * the path of the edge.
	 * 
	 * @param {node}
	 * 		The node to calculate the new position
	 * @return {Point}
	 * 		The calculated upper left point of the node's shape.
	 */
	calculatePositionOfAttachedChildNode: function(node) {
		/* Initialize position */
		var position = new Object();
		position.x = 0;
		position.y = 0;
		
		/* Case: Node was just added */
		if(!this.attachedNodePositionData[node.getId()]) {
			this.attachedNodePositionData[node.getId()] = new Object();
			this.attachedNodePositionData[node.getId()]
					.relativDistanceFromDocker1 = 0;
			this.attachedNodePositionData[node.getId()].node = node;
			this.attachedNodePositionData[node.getId()].segment = new Object();
			this.findEdgeSegmentForNode(node);
		}else if(node.isChanged) {
			this.findEdgeSegmentForNode(node);
		}
		
		
		
	},
	
	/**
	 * Finds the appropriate edge segement for a node.
	 * The segment is choosen, which has the smallest distance to the node.
	 * 
	 * @param {ORYX.Core.Node} node
	 * 		The concerning node
	 */
	findEdgeSegmentForNode: function(node) {
		var length = this.dockers.length;
		var smallestDistance = undefined;
		
		for(i=1;i<length;i++) {
			var lineP1 = this.dockers[i-1].bounds.center();
			var lineP2 = this.dockers[i].bounds.center();
			this.relativizePoint(lineP1);
			this.relativizePoint(lineP2);
			
			var nodeCenterPoint = node.bounds.center();
			var distance = ORYX.Core.Math.distancePointLinie(
															lineP1,
															lineP2, 
															nodeCenterPoint, 
															true);
			
			if((distance || distance == 0) && ((!smallestDistance && smallestDistance != 0) 
						|| distance < smallestDistance)) {
				
				smallestDistance = distance;
				
				this.attachedNodePositionData[node.getId()].segment.docker1 = 
													this.dockers[i-1];
				this.attachedNodePositionData[node.getId()].segment.docker2 = 
													this.dockers[i];
	
			}
			
			/* Either the distance does not match the segment or the distance
			 * between docker1 and docker2 is 0
			 * 
			 * In this case choose the nearest docker as attaching point.
			 * 
			 */
			if(!distance && !smallestDistance && smallestDistance != 0) {
				(ORYX.Core.Math.getDistancePointToPoint(nodeCenterPoint, lineP1)
					< ORYX.Core.Math.getDistancePointToPoint(nodeCenterPoint, lineP2)) ?
					this.attachedNodePositionData[node.getId()].relativDistanceFromDocker1 = 0 :
					this.attachedNodePositionData[node.getId()].relativDistanceFromDocker1 = 1;
				this.attachedNodePositionData[node.getId()].segment.docker1 = 
													this.dockers[i-1];
				this.attachedNodePositionData[node.getId()].segment.docker2 = 
													this.dockers[i];
			}
		}
		
		/* Calculate position on edge segment for the node */
		if(smallestDistance || smallestDistance == 0) {
			this.attachedNodePositionData[node.getId()].relativDistanceFromDocker1 =
			this.getLineParameterForPosition(
					this.attachedNodePositionData[node.getId()].segment.docker1,
					this.attachedNodePositionData[node.getId()].segment.docker2,
					node);
		}
	},
	
	
	/**
	 *
	 * @param {ORYX.Core.Node|Object} node or position
	 * @return {Object} An object with the following attribute: {ORYX.Core.Docker} fromDocker, {ORYX.Core.Docker} toDocker, {X/Y} position, {int} distance
	 */
 	findSegment: function(node){
		
		var length = this.dockers.length;
		var result;
		
		var nodeCenterPoint = node instanceof ORYX.Core.UIObject ? node.bounds.center() : node;
			
		for (i = 1; i < length; i++) {
			var lineP1 = this.dockers[i - 1].bounds.center();
			var lineP2 = this.dockers[i].bounds.center();
			
			var distance = ORYX.Core.Math.distancePointLinie(lineP1, lineP2, nodeCenterPoint, true);
			
			if (typeof distance == "number" && (result === undefined || distance < result.distance)) {
				result = {
					distance: distance,
					fromDocker: this.dockers[i - 1],
					toDocker: this.dockers[i]
				};
				
			}
		}
		
		return result;
	},
	
	/**
	 * Returns the value of the scalar to determine the position of the node on 
	 * line defined by docker1 and docker2.
	 * 
	 * @param {point} docker1
	 * 		The docker that defines the start of the line segment
	 * @param {point} docker2
	 * 		The docker that defines the end of the line segment
	 * @param {ORYX.Core.Node} node
	 * 		The concerning node
	 * 
	 * @return {float} positionParameter
	 * 		The scalar value to determine the position on the line
	 */
	getLineParameterForPosition: function(docker1, docker2, node) {
		var dockerPoint1 = docker1.bounds.center();
		var dockerPoint2 = docker2.bounds.center();
		this.relativizePoint(dockerPoint1);
		this.relativizePoint(dockerPoint2);
		
		var intersectionPoint = ORYX.Core.Math.getPointOfIntersectionPointLine(
									dockerPoint1,
									dockerPoint2,
									node.bounds.center(), true);
		if(!intersectionPoint) {
			return 0;
		}
		
		var relativeDistance = 
			ORYX.Core.Math.getDistancePointToPoint(intersectionPoint, dockerPoint1) /
			ORYX.Core.Math.getDistancePointToPoint(dockerPoint1, dockerPoint2);
		
		return relativeDistance;
	},
	/**
	 * Makes point relative to the upper left of the edge's bound.
	 * 
	 * @param {point} point
	 * 		The point to relativize
	 */
	relativizePoint: function(point) {
		point.x -= this.bounds.upperLeft().x;
		point.y -= this.bounds.upperLeft().y;		
	},
	
	/**
	 * Move the first and last docker and calls the refresh method.
	 * Attention: This does not calculates intersection point between the
	 * edge and the bounded nodes. This only works if only the nodes are
	 * moves.
	 *
	 */
	optimizedUpdate: function(){
		
		var updateDocker = function(docker){
			if (!docker._dockedShape || !docker._dockedShapeBounds)
				return;
			var off = {
			    x: docker._dockedShape.bounds.a.x - docker._dockedShapeBounds.a.x,
			    y: docker._dockedShape.bounds.a.y - docker._dockedShapeBounds.a.y
			};
			docker.bounds.moveBy(off);
			docker._dockedShapeBounds.moveBy(off);
		}
		
		updateDocker(this.dockers.first());
		updateDocker(this.dockers.last());
		
		this.refresh();
	},
    
    refresh: function(){
        //call base class refresh method
        arguments.callee.$.refresh.apply(this, arguments);
        
        //TODO consider points for marker mids
        this._paths.each((function(path, index){
			var lastPoint = undefined;
            var dockers = this._dockersByPath.values()[0];
            var c = undefined;
			var d = undefined;
            if (lastPoint) {
                d = "M" + lastPoint.x + " " + lastPoint.y;
            }
            else {
                c = dockers[0].bounds.center();
                lastPoint = c;
                
                d = "M" + c.x + " " + c.y;
            }
            
            for (var i = 1; i < dockers.length; i++) {
                // for each docker, draw a line to the center
                c = dockers[i].bounds.center();
                d = d + "L" + c.x + " " + c.y + " ";
                lastPoint = c;
            }
            
            path.setAttributeNS(null, "d", d);
            this._interactionPaths[index].setAttributeNS(null, "d", d);
            
            var shadowPath = this._shadowPaths[index];
            if (shadowPath) {
            	shadowPath.setAttributeNS(null, "d", d);
            }
            
    		/*
    		 * Force the browser to remove and add the SVG-path to the DOM
    		 * to solve a rendering bug in IE 10 & 11.
    		 * 
    		 * see: http://stackoverflow.com/questions/15693178/svg-line-markers-not-updating-when-line-moves-in-ie10
    		 */ 
    		if (Ext.isIE10 || Ext.isIE11) {
    			path.parentNode.insertBefore(path, path);
    			if (shadowPath) {
    				shadowPath.parentNode.insertBefore(shadowPath, shadowPath);
    			}
    		}
            
        }).bind(this));
		
		
		/* move child shapes of an edge */
		if(this.getChildNodes().length > 0) {
	        var x = this.bounds.upperLeft().x;
	        var y = this.bounds.upperLeft().y;
	        
			this.node.firstChild.childNodes[1].setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")");
		}	
    },
    
    /**
     * Calculate the Border Intersection Point between two points
     * @param {PointA}
     * @param {PointB}
     */
    getIntersectionPoint: function(){
    
        var length = Math.floor(this.dockers.length / 2)
        
        return ORYX.Core.Math.midPoint(this.dockers[length - 1].bounds.center(), this.dockers[length].bounds.center())
    },
    
	/**
     * Returns TRUE if the bounds is over the edge
     * @param {Bounds}
     *
     */
    isBoundsIncluded: function(bounds){
		var dockers = this.dockers, size = dockers.length;
		return dockers.any(function(docker, i){
			if (i == size-1){ return false; }
			var a = docker.bounds.center();
			var b = dockers[i+1].bounds.center();
			
			return ORYX.Core.Math.isRectOverLine(a.x, a.y, b.x, b.y, bounds.a.x, bounds.a.y, bounds.b.x, bounds.b.y);
		});
	},
    
    /**
     * Calculate if the point is inside the Shape
     * @param {PointX}
     * @param {PointY} 
     */
    isPointIncluded: function(pointX, pointY){
    
        var isbetweenAB = this.absoluteBounds().isIncluded(pointX, pointY, 
												ORYX.CONFIG.OFFSET_EDGE_BOUNDS);
        
		var isPointIncluded = undefined;
		
        if (isbetweenAB && this.dockers.length > 0) {
		
			var i = 0;
			var point1, point2;
			
			
			do {
			
				point1 = this.dockers[i].bounds.center();
				point2 = this.dockers[++i].bounds.center();
				
				isPointIncluded = ORYX.Core.Math.isPointInLine(pointX, pointY, 
											point1.x, point1.y, 
											point2.x, point2.y, 
											ORYX.CONFIG.OFFSET_EDGE_BOUNDS);
				
			} while (!isPointIncluded && i < this.dockers.length - 1)
			
		}
		
		return isPointIncluded;

    },
  
    
    /**
     * Calculate if the point is over an special offset area
     * @param {Point}
     */
    isPointOverOffset: function(){
		return  false
	},
	
	/**
	 * Returns TRUE if the given node
	 * is a child node of the shapes node
	 * @param {Element} node
	 * @return {Boolean}
	 *
	 */
	containsNode: function(node){
		if (this._paths.include(node) || 
       		this._interactionPaths.include(node) ||
       		this._shadowPaths.include(node)){
			return true;		
		}	
		return false;
	},
	
	/**
	* Returns the angle of the line between two dockers
	* (0 - 359.99999999)
	*/
	_getAngle: function(docker1, docker2) {
		var p1 = docker1 instanceof ORYX.Core.Controls.Docker ? docker1.absoluteCenterXY() : docker1;
		var p2 = docker2 instanceof ORYX.Core.Controls.Docker ? docker2.absoluteCenterXY() : docker2;
		
		return ORYX.Core.Math.getAngle(p1, p2);
	},
	    
    alignDockers: function(){
        this._update(true);
        
        var firstPoint = this.dockers.first().bounds.center();
        var lastPoint = this.dockers.last().bounds.center();
        
        var deltaX = lastPoint.x - firstPoint.x;
        var deltaY = lastPoint.y - firstPoint.y;
        
        var numOfDockers = this.dockers.length - 1;
        
        this.dockers.each((function(docker, index){
            var part = index / numOfDockers;
            docker.bounds.unregisterCallback(this._dockerChangedCallback);
            docker.bounds.moveTo(firstPoint.x + part * deltaX, firstPoint.y + part * deltaY);
            docker.bounds.registerCallback(this._dockerChangedCallback);
        }).bind(this));
        
        this._dockerChanged();
    },
    
	add: function(shape){
        arguments.callee.$.add.apply(this, arguments);
		
		// If the new shape is a Docker which is not contained
		if (shape instanceof ORYX.Core.Controls.Docker && this.dockers.include(shape)){
			// Add it to the dockers list ordered by paths		
			var pathArray = this._dockersByPath.values()[0];
			if (pathArray) {
				pathArray.splice(this.dockers.indexOf(shape), 0, shape);
			}
			
			/* Perform necessary adjustments on the edge's child shapes */
			this.handleChildShapesAfterAddDocker(shape);
		}
	},
	
	/**
	 * Performs nessary adjustments on the edge's child shapes.
	 * 
	 * @param {ORYX.Core.Controls.Docker} docker
	 * 		The added docker
	 */
	handleChildShapesAfterAddDocker: function(docker) {
		/* Ensure type of Docker */
		if(!docker instanceof ORYX.Core.Controls.Docker) {return undefined;}
		
		var index = this.dockers.indexOf(docker);
		if(!(0 < index && index < this.dockers.length - 1)) {
		/* Exception: Expect added docker between first and last node of the edge */
			return undefined;
		} 
			
		/* Get child nodes concerning the segment of the new docker */
		var startDocker = this.dockers[index-1];
		var endDocker = this.dockers[index+1];
		
		/* Adjust the position of edge's child nodes */
		var segmentElements = 
			this.getAttachedNodePositionDataForSegment(startDocker, endDocker);
		
		var lengthSegmentPart1 = ORYX.Core.Math.getDistancePointToPoint(
										startDocker.bounds.center(),
										docker.bounds.center());
		var lengthSegmentPart2 = ORYX.Core.Math.getDistancePointToPoint(
										endDocker.bounds.center(),
										docker.bounds.center());
										
		if(!(lengthSegmentPart1 + lengthSegmentPart2)) {return;}
		
		var relativDockerPosition = lengthSegmentPart1 / (lengthSegmentPart1 + lengthSegmentPart2);
			
		segmentElements.each(function(nodePositionData) {
			/* Assign child node to the new segment */
			if(nodePositionData.value.relativDistanceFromDocker1 < relativDockerPosition) {
				/* Case: before added Docker */
				nodePositionData.value.segment.docker2 = docker;
				nodePositionData.value.relativDistanceFromDocker1 = 
					nodePositionData.value.relativDistanceFromDocker1 / relativDockerPosition;
			} else {
				/* Case: after added Docker */
				nodePositionData.value.segment.docker1 = docker;
				var newFullDistance = 1 - relativDockerPosition;
				var relativPartOfSegment = 
							nodePositionData.value.relativDistanceFromDocker1
							- relativDockerPosition;
				
				nodePositionData.value.relativDistanceFromDocker1 = 
										relativPartOfSegment / newFullDistance;
				
			}
		})
		
		
		// Update all labels reference points
		this.getLabels().each(function(label){

			var ref = label.getReferencePoint();
			if (!ref || !ref.intersection) {
				return;
			}
			var index = this.dockers.indexOf(docker);
			if (index >= ref.segment.fromIndex && index <= ref.segment.toIndex){
				
				var segment = this.findSegment(ref.intersection);
				if (!segment){ 
					// Choose whether the first of the last segment
					segment.fromDocker = ref.segment.fromIndex >= (this.dockers.length/2) ? this.dockers[0] : this.dockers[this.dockers.length-2]; 
					segment.toDocker = this.dockers[this.dockers.indexOf(from)+1]; // The next one if the to docker
				}
				
				var fromPosition = segment.fromDocker.bounds.center(), toPosition = segment.toDocker.bounds.center();
			
				var intersection = ORYX.Core.Math.getPointOfIntersectionPointLine(
										fromPosition, 		// P1 - Center of the first docker
										toPosition, 		// P2 - Center of the second docker
										ref.intersection, 	// P3 - Center of the label
										true);
				//var oldDistance = ORYX.Core.Math.getDistanceBetweenTwoPoints(ref.segment.fromPosition, ref.segment.toPosition, ref.intersection);
				//intersection = ORYX.Core.Math.getPointBetweenTwoPoints(fromPosition, toPosition, isNaN(oldDistance) ? 0.5 : (lengthOld*oldDistance)/lengthNew);
					
				// Update the reference point
				this.updateReferencePointOfLabel(label, intersection, segment.fromDocker, segment.toDocker, true);
			}
		}.bind(this));
		
		/* Update attached nodes visual representation */
		this.refreshAttachedNodes();
	},
	
	/**
	 *	Returns elements from {@link attachedNodePositiondata} that match the
	 *  segement defined by startDocker and endDocker.
	 *  
	 *  @param {ORYX.Core.Controls.Docker} startDocker
	 *  	The docker defining the begin of the segment.
	 *  @param {ORYX.Core.Controls.Docker} endDocker
	 *  	The docker defining the begin of the segment.
	 *  
	 *  @return {Hash} attachedNodePositionData
	 *  	Child elements matching the segment
	 */
	getAttachedNodePositionDataForSegment: function(startDocker, endDocker) {
		/* Ensure that the segment is defined correctly */
		if(!((startDocker instanceof ORYX.Core.Controls.Docker) 
			&& (endDocker instanceof ORYX.Core.Controls.Docker))) {
				return [];
			}
			
		/* Get elements of the segment */
		var elementsOfSegment = 
			this.attachedNodePositionData.findAll(function(nodePositionData) {
				return nodePositionData.value.segment.docker1 === startDocker &&
						nodePositionData.value.segment.docker2 === endDocker;
			});
		
		/* Return a Hash in each case */
		if(!elementsOfSegment) {return [];}
		
		return elementsOfSegment;
	},
	
	/**
	 * Removes an edge's child shape
	 */
	remove: function(shape) {
		arguments.callee.$.remove.apply(this, arguments);
		
		if(this.attachedNodePositionData[shape.getId()]) {
			delete this.attachedNodePositionData[shape.getId()];
		}
		
		/* Adjust child shapes if neccessary */
		if(shape instanceof ORYX.Core.Controls.Docker) {
			// Remove it to the dockers list ordered by paths			
			var pathArray = this._dockersByPath[this._paths[0].id];
			if (pathArray && pathArray.include(shape)) {
				this._dockersByPath[this._paths[0].id] = pathArray.without(shape);
			}
			this.handleChildShapesAfterRemoveDocker(shape);
		}
	},
	
	updateReferencePointOfLabel: function(label, intersection, from, to, dirty){
		if (!label.getReferencePoint() || !label.isVisible || !intersection) {
			return;
		}
		
		var ref = label.getReferencePoint();
		
		//
		if (ref.orientation && ref.orientation !== "ce"){
			var angle = this._getAngle(from, to);
			if (ref.distance >= 0){
				if(angle == 0){
					label.horizontalAlign("left");//ref.orientation == "lr" ? "right" : "left");
					label.verticalAlign("bottom");
				} else if (angle > 0 && angle < 90){
					label.horizontalAlign("right");
					label.verticalAlign("bottom");
				} else if (angle == 90){
					label.horizontalAlign("right");
					label.verticalAlign("top");//ref.orientation == "lr" ? "bottom" : "top");
				} else if (angle > 90 && angle < 180){
					label.horizontalAlign("right");
					label.verticalAlign("top");
				} else if (angle == 180){
					label.horizontalAlign("left");//ref.orientation == "ur" ? "right" : "left");
					label.verticalAlign("top");
				} else if (angle > 180 && angle < 270){
					label.horizontalAlign("left");
					label.verticalAlign("top");				
				} else if (angle == 270){
					label.horizontalAlign("left");
					label.verticalAlign("top");//ref.orientation == "ll" ? "bottom" : "top");
				} else if (angle > 270 && angle <= 360){
					label.horizontalAlign("left");
					label.verticalAlign("bottom");
				}
			} else {
				if(angle == 0){
					label.horizontalAlign("left");//ref.orientation == "ur" ? "right" : "left");
					label.verticalAlign("top");
				} else if (angle > 0 && angle < 90){
					label.horizontalAlign("left");
					label.verticalAlign("top");
				} else if (angle == 90){
					label.horizontalAlign("left");
					label.verticalAlign("top");//ref.orientation == "ll" ? "bottom" : "top");
				} else if (angle > 90 && angle < 180){
					label.horizontalAlign("left");
					label.verticalAlign("bottom");
				} else if (angle == 180){
					label.horizontalAlign("left");//ref.orientation == "lr" ? "right" : "left");
					label.verticalAlign("bottom");
				} else if (angle > 180 && angle < 270){
					label.horizontalAlign("right");
					label.verticalAlign("bottom");
				} else if (angle == 270){
					label.horizontalAlign("right");
					label.verticalAlign("top");//ref.orientation == "lr" ? "bottom" : "top");
				} else if (angle > 270 && angle <= 360){
					label.horizontalAlign("right");
					label.verticalAlign("top");
				}			
			}
			ref.iorientation = ref.iorientation || ref.orientation;
			ref.orientation = (label.verticalAlign()=="top"?"u":"l") + (label.horizontalAlign()=="left"?"l":"r");
		}
	
		label.setReferencePoint(Ext.apply({},{
				intersection: intersection,
				segment: {
					from: from,
					fromIndex: this.dockers.indexOf(from),
					fromPosition: from.bounds.center(),
					to: to,
					toIndex: this.dockers.indexOf(to),
					toPosition: to.bounds.center()
				},
				dirty: dirty || false
			},ref))
	},
	/**
	 * 	Adjusts the child shapes of an edges after a docker was removed.
	 * 	
	 *  @param{ORYX.Core.Controls.Docker} docker
	 *  	The removed docker.
	 */
	handleChildShapesAfterRemoveDocker: function(docker) {
		/* Ensure docker type */
		if(!(docker instanceof ORYX.Core.Controls.Docker)) {return;}
		
		this.attachedNodePositionData.each(function(nodePositionData) {
			if(nodePositionData.value.segment.docker1 === docker) {
				/* The new start of the segment is the predecessor of docker2. */
				var index = this.dockers.indexOf(nodePositionData.value.segment.docker2);
				if(index == -1) {return;}
				nodePositionData.value.segment.docker1 = this.dockers[index - 1];
			} 
			else if(nodePositionData.value.segment.docker2 === docker) {
				/* The new end of the segment is the successor of docker1. */
				var index = this.dockers.indexOf(nodePositionData.value.segment.docker1);
				if(index == -1) {return;}
				nodePositionData.value.segment.docker2 = this.dockers[index + 1];
			}
		}.bind(this));
		
		// Update all labels reference points
		this.getLabels().each(function(label){

			var ref = label.getReferencePoint();
			if (!ref || !ref.intersection) {
				return;
			}
			var from = ref.segment.from;
			var to = ref.segment.to;
			
			if (from !== docker && to !== docker){ 
				return; 
			}
			
			var segment = this.findSegment(ref.intersection);
			if (segment){ 
				from = segment.fromDocker;
				to = segment.toDocker;
			} else {
				from = from === docker ? this.dockers[this.dockers.indexOf(to)-1] : from;
				to = this.dockers[this.dockers.indexOf(from)+1];
			}

			var intersection = ORYX.Core.Math.getPointOfIntersectionPointLine(from.bounds.center(), to.bounds.center(), ref.intersection, true);			
			// Update the reference point
			this.updateReferencePointOfLabel(label, intersection, from, to, true);
		}.bind(this));
		
		/* Update attached nodes visual representation */
		this.refreshAttachedNodes();
	},
	
	/**
     *@deprecated Use the .createDocker() Method and set the point via the bounds
     */
    addDocker: function(position, exDocker){
        var lastDocker;
		var result;
        this._dockersByPath.any((function(pair){
            return pair.value.any((function(docker, index){
                if (!lastDocker) {
                    lastDocker = docker;
                    return false;
                }
                else {
                    var point1 = lastDocker.bounds.center();
                    var point2 = docker.bounds.center();
                    
                    if (ORYX.Core.Math.isPointInLine(position.x, position.y, point1.x, point1.y, point2.x, point2.y, 10)) {
                        var path = this._paths.find(function(path){
                            return path.id === pair.key;
                        });
                        if (path) {
                            var allowAttr = path.getAttributeNS(NAMESPACE_ORYX, 'allowDockers');
                            if (allowAttr && allowAttr.toLowerCase() === "no") {
                                return true;
                            }
                        }
                        var newDocker = (exDocker) ? exDocker : this.createDocker(this.dockers.indexOf(lastDocker) + 1, position);
						newDocker.bounds.centerMoveTo(position);
                        if(exDocker)
							this.add(newDocker, this.dockers.indexOf(lastDocker) + 1);
                        // Remove new Docker from 'to add' dockers
						//pair.value = pair.value.without(newDocker);
						//pair.value.splice(this.dockers.indexOf(lastDocker) + 1, 0, newDocker);
						// Remove the Docker from the Docker list and add the Docker to the new position
                        //this.dockers = this.dockers.without(newDocker);
                        //this.dockers.splice(this.dockers.indexOf(lastDocker) + 1, 0, newDocker);
                        //this._update(true);
						result = newDocker;
                        return true;
                    }
                    else {
                        lastDocker = docker;
                        return false;
                    }
                }
            }).bind(this));
        }).bind(this));
		return result;
    },
    
    removeDocker: function(docker){
        if (this.dockers.length > 2 && !(this.dockers.first() === docker)) {
            this._dockersByPath.any((function(pair){
                if (pair.value.member(docker)) {
                    if (docker === pair.value.last()) {
                        return true;
                    }
                    else {
                        this.remove(docker);
                        this._dockersByPath[pair.key] = pair.value.without(docker);
                        this.isChanged = true;
                        this._dockerChanged();
                        return true;
                    }
                }
                return false;
            }).bind(this));
        }
    },
	
	/**
	 * Removes all dockers from the edge which are on 
	 * the line between two dockers and those who are obsolete created inside a docked shape
	 * @return {Object} Removed dockers in an indicied array 
	 * (key is the removed position of the docker, value is docker themselve)
	 */
	removeUnusedDockers:function(){
		var marked = $H({});
		
		this.dockers.each(function(docker, i){
			if (i==0||i==this.dockers.length-1){ return }
			var previous = this.dockers[i-1];
			
			/* Do not consider already removed dockers */
			if(marked.values().indexOf(previous) != -1 && this.dockers[i-2]) {
				previous = this.dockers[i-2];
			}
			var next = this.dockers[i+1];
			
			var cp = previous.getDockedShape() && previous.referencePoint ? previous.getAbsoluteReferencePoint() : previous.bounds.center();
			var cn = next.getDockedShape() && next.referencePoint ? next.getAbsoluteReferencePoint() : next.bounds.center();
			var cd = docker.bounds.center();
			
			if (ORYX.Core.Math.distancePointLinie(cp, cn, cd, false) <= 1){
				marked[i] = docker;
			}
			
		}.bind(this))

//		var s1 = this.dockers[0].isDocked() ? this.dockers[0].getDockedShape() : undefined;
//		if (s1) {
//			if (s1.isPointIncluded(this.dockers[0].bounds.center().x, this.dockers[0].bounds.center().y) &&
//			    s1.isPointIncluded(this.dockers[1].bounds.center().x, this.dockers[1].bounds.center().y)) {
//				marked[1] = this.dockers[1];
//				var ref = {
//					x:this.dockers[1].bounds.center().x - s1.bounds.upperLeft().x,
//					y:this.dockers[1].bounds.center().y - s1.bounds.upperLeft().y
//				};
//				this.dockers[0].setReferencePoint(ref);
//			}
//		}
//		
//		var s2 = this.dockers[this.dockers.length - 1].isDocked() ? this.dockers[this.dockers.length - 1].getDockedShape() : undefined;
//		if (s2) {
//			if (s2.isPointIncluded(this.dockers[this.dockers.length - 1].bounds.center().x, this.dockers[this.dockers.length - 1].bounds.center().y) &&
//		    	s2.isPointIncluded(this.dockers[this.dockers.length - 2].bounds.center().x, this.dockers[this.dockers.length - 2].bounds.center().y)) {
//				marked[this.dockers.length - 2] = this.dockers[this.dockers.length - 2];
//				var ref = {
//					x:this.dockers[this.dockers.length - 2].bounds.center().x - s2.bounds.upperLeft().x,
//					y:this.dockers[this.dockers.length - 2].bounds.center().y - s2.bounds.upperLeft().y
//				};
//				this.dockers[this.dockers.length - 1].setReferencePoint(ref);
//			}
//		}
		
		marked.each(function(docker){
			this.remove(docker.value);
		}.bind(this))
		
		if (marked.values().length > 0){
			this._update(true);
		}
		
		return marked;
	},
    
    /**
     * Initializes the Edge after loading the SVG representation of the edge.
     * @param {SVGDocument} svgDocument
     */
    _init: function(svgDocument){
        arguments.callee.$._init.apply(this, arguments);
        
        var minPointX, minPointY, maxPointX, maxPointY;
        
        // Check if richtext is enabled
        var isRichtext = ORYX.Utils.buildIsRichtextForLabel(this.getStencil());

        //init markers
        var defs = svgDocument.getElementsByTagNameNS(NAMESPACE_SVG, "defs");
        if (defs.length > 0) {
            defs = defs[0];
            var markerElements = $A(defs.getElementsByTagNameNS(NAMESPACE_SVG, "marker"));
            var marker;
            var me = this;
            markerElements.each(function(markerElement){
                try {
                    marker = new ORYX.Core.SVG.SVGMarker(markerElement.cloneNode(true));
                    me._markers[marker.id] = marker;
                    var textElements = $A(marker.element.getElementsByTagNameNS(NAMESPACE_SVG, "text"));
                    var label;
                    textElements.each(function(textElement){
                        label = new ORYX.Core.SVG.Label({
                            textElement: textElement,
							shapeId: this.id,
							richtext: isRichtext(textElem)
                        });
                        me._labels[label.id] = label;
                    });
                } 
                catch (e) {
                }
            });
        }
        
        
        var gs = svgDocument.getElementsByTagNameNS(NAMESPACE_SVG, "g");
        if (gs.length <= 0) {
            throw "Edge: No g element found.";
        }
        var g = gs[0];
        
        
        g.setAttributeNS(null, "id", null);
        
        var isFirst = true;
        
        $A(g.childNodes).each((function(path, index){
            if (ORYX.Editor.checkClassType(path, SVGPathElement)) {
                path = path.cloneNode(false);
                
                /*
                 * Fix for SVG path markers shining through overlay windows (like save dialog) in IE9.
                 * See:
                 * http://stackoverflow.com/questions/18837012/svg-markers-showing-through-overlaid-content-ie9#
                 */
                if (Ext.isIE9) {
                    path.setAttributeNS(null, "opacity", Signavio.CONFIG.IE9_PATH_OPACITY_FIX_VALUE);
                }
                
                var originalPathId = path.getAttributeNS(null, "id") || '';
                
                var pathId = (originalPathId)?originalPathId:this.id + "_" + index;
                path.setAttributeNS(null, "id", pathId);
                this._paths.push(path);
                
                //check, if markers are set and update the id
                var markersByThisPath = [];
                var markerUrl = path.getAttributeNS(null, "marker-start");
                
                if (markerUrl && markerUrl !== "") {
                    markerUrl = markerUrl.strip();
                    markerUrl = markerUrl.replace(/^url\(.*#(.*?)["'\)].*/, '$1');
                    var markerStartId = this.id.concat(markerUrl);
                    path.setAttributeNS(null, "marker-start", "url(#" + markerStartId + ")");
                    
                    markersByThisPath.push(this._markers[markerStartId]);
                }
                
                markerUrl = path.getAttributeNS(null, "marker-mid");
                
                if (markerUrl && markerUrl !== "") {
                    markerUrl = markerUrl.strip();
                    markerUrl = markerUrl.replace(/^url\(.*#(.*?)["'\)].*/, '$1');
                    var markerMidId = this.id.concat(markerUrl);
                    path.setAttributeNS(null, "marker-mid", "url(#" + markerMidId + ")");
                    
                    markersByThisPath.push(this._markers[markerMidId]);
                }
                
                markerUrl = path.getAttributeNS(null, "marker-end");
                
                if (markerUrl && markerUrl !== "") {
                    markerUrl = markerUrl.strip();
                    markerUrl = markerUrl.replace(/^url\(.*#(.*?)["'\)].*/, '$1');
                    var markerEndId = this.id.concat(markerUrl);
                    path.setAttributeNS(null, "marker-end", "url(#" + markerEndId + ")");
                    
                    markersByThisPath.push(this._markers[markerEndId]);
                }
                
                this._markersByPath[pathId] = markersByThisPath;
                
                //init dockers
                var parser = new PathParser();
                var handler = new ORYX.Core.SVG.PointsPathHandler();
                parser.setHandler(handler);
                parser.parsePath(path);
                
                if (handler.points.length < 4) {
                    throw "Edge: Path has to have two or more points specified.";
                }
                
                this._dockersByPath[pathId] = [];
                
				for (var i = 0; i < handler.points.length; i += 2) {
					//handler.points.each((function(point, pIndex){
					var x = handler.points[i];
					var y = handler.points[i+1];
					if (isFirst) {
						var docker = new ORYX.Core.Controls.Docker({
							eventHandlerCallback: this.eventHandlerCallback
						});
						docker.bounds.centerMoveTo(x,y);
						docker.bounds.registerCallback(this._dockerChangedCallback);
						this.add(docker, this.dockers.length);
						
						//this._dockersByPath[pathId].push(docker);
						
						//calculate minPoint and maxPoint
						if (minPointX) {
							minPointX = Math.min(x, minPointX);
							minPointY = Math.min(y, minPointY);
						}
						else {
							minPointX = x;
							minPointY = y;
						}
						
						if (maxPointX) {
							maxPointX = Math.max(x, maxPointX);
							maxPointY = Math.max(y, maxPointY);
						}
						else {
							maxPointX = x;
							maxPointY = y;
						}
					}
					//}).bind(this));
				}
                isFirst = false;
            }
        }).bind(this));
        
        this.bounds.set(minPointX, minPointY, maxPointX, maxPointY);
        
        if (false&&(this.bounds.width() === 0 || this.bounds.height() === 0)) {
			var width = this.bounds.width();
			var height = this.bounds.height();
			
            this.bounds.extend({
                x: width === 0 ? 2 : 0,
                y: height === 0 ? 2 : 0
            });
            
            this.bounds.moveBy({
                x: width === 0 ? -1 : 0,
                y: height === 0 ? -1 : 0
            });
            
        }
        
        this._oldBounds = this.bounds.clone();
        
        //add paths to this.node
        this._paths.reverse();
        var paths = [];
        this._paths.each((function(path){
            paths.push(this.node.childNodes[0].childNodes[0].childNodes[0].appendChild(path));
        }).bind(this));
        
        this._paths = paths;
        
        this._paths.each((function(path){
    		var pathParent = this.node.childNodes[0].childNodes[0].childNodes[0];

        	// Only insert a shadow if the path is not dashed.
        	if (ORYX.CONFIG.EDGE_SHADOWS_ENABLED && !path.getAttributeNS(null, "stroke-dasharray")) {
        		var shadowPath = this._buildShadowPathForPath(path, svgDocument, defs);
        		
            	// Insert the shadow as the first child so that it is rendered at the very bottom.
            	this._shadowPaths.push(pathParent.insertBefore(shadowPath, pathParent.firstChild));
        	}
        	
        	var iPath = this._buildInteractionPathForPath(path, svgDocument);
            this._interactionPaths.push(pathParent.appendChild(iPath));
            
        }).bind(this));
        
        this._paths.reverse();
        this._interactionPaths.reverse();
        this._shadowPaths.reverse();
		
		/**initialize labels*/
        var textElems = svgDocument.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'text');
        
		$A(textElems).each((function(textElem){
            var label = new ORYX.Core.SVG.Label({
                textElement: textElem,
				shapeId: this.id,
				richtext: isRichtext(textElem)
            });
            this.node.childNodes[0].childNodes[0].appendChild(label.node);
            this._labels[label.id] = label;
			
			label.registerOnChange(this.layout.bind(this));
        }).bind(this)); 
		
        
        this.propertiesChanged.each(function(pair){
            pair.value = true;
        });
		
        //this._update(true);
    },
    
    _buildShadowPathForPath: function(path, svgDocument, defs) {
    	// Init a shadow path that is a clone of the original path, just with different styling.
    	var shadowPath = path.cloneNode(false);
    	var shadowPathID = shadowPath.getAttributeNS(null, "id")||"";
    	shadowPath.setAttributeNS(null, "id", (shadowPathID + Signavio.CONFIG.SVG_SHADOW_ID_SUFFIX));
    	shadowPath.setAttributeNS(null, "stroke-width", 5);
    	shadowPath.setAttributeNS(null, "stroke-opacity", 0.7);
    	shadowPath.setAttributeNS(null, "stroke-linecap", "butt");
    	shadowPath.setAttributeNS(null, "stroke", "white");
    	
    	// Creates a pattern like this:  ##__###############...
    	//shadowPath.setAttributeNS(null, "stroke-dasharray", "2 2 10000");
    	
    	// The offset means we omit the first two #'s, leading to __###############...
    	// This is nice because we now have a 2 pixel "margin" where the white shadow is missing.
    	// Without this, the edge shadow would overlap its docked shape's border by some pixels. 
    	//shadowPath.setAttributeNS(null, "stroke-dashoffset", "2");
    	
    	// Init shadow for markers: a clone of each marker with different styling.
    	var pathId = path.getAttributeNS(null, "id");
    	
    	var pathStartMarker = path.getAttributeNS(null, "marker-start");
    	var pathMidMarker = path.getAttributeNS(null, "marker-mid");
    	var pathEndMarker = path.getAttributeNS(null, "marker-end");
    	
    	var markers = this._markersByPath[pathId];
    	if (markers) {
        	markers.each(function(marker) {
        		if (marker && marker.element && marker.element.childNodes) {
        			var markerNodes = marker.element.childNodes;
        			var i;        			
        			var shadowMarkerElement = marker.element.cloneNode(false);
        			
        	    	shadowMarkerElement.setAttributeNS(null, "id", marker.id + Signavio.CONFIG.SVG_SHADOW_ID_SUFFIX);
        	    	
        	    	// Override the dasharray, otherwise it is inherited from the shadow path.
        	    	//shadowMarkerElement.setAttributeNS(null, "stroke-dasharray", "0");
        	    	
        	    	// Depending on which marker we are dealing with, set the matching marker shadow.
        			if (pathStartMarker && pathStartMarker.indexOf(marker.id) >= 0) {
        				shadowPath.setAttributeNS(null, "marker-start", "url(#" + marker.id + Signavio.CONFIG.SVG_SHADOW_ID_SUFFIX + ")");
        			} else if (pathMidMarker && pathMidMarker.indexOf(marker.id) >= 0) {
        				shadowPath.setAttributeNS(null, "marker-mid", "url(#" + marker.id + Signavio.CONFIG.SVG_SHADOW_ID_SUFFIX + ")");
        			} else if (pathEndMarker && pathEndMarker.indexOf(marker.id) >= 0) {
        				shadowPath.setAttributeNS(null, "marker-end", "url(#" + marker.id + Signavio.CONFIG.SVG_SHADOW_ID_SUFFIX + ")");
        			}
        			
        			for (i = 0; i < markerNodes.length; i++) {
                		var markerPath = markerNodes[i];
                		if (markerPath.nodeType !== markerPath.ELEMENT_NODE) {
                			// There is whitespace inside marker elements which can show up as text nodes here...
                			continue;
                		}
                		var markerPathID = markerPath.getAttributeNS(null, "id");

                		var markerShadow = markerPath.cloneNode(false);
                		markerShadow.setAttributeNS(null, "id", (markerPathID + Signavio.CONFIG.SVG_SHADOW_ID_SUFFIX));
                		markerShadow.setAttributeNS(null, "stroke-width", 5);
                		markerShadow.setAttributeNS(null, "stroke-opacity", 0.7);
                		markerShadow.setAttributeNS(null, "stroke-linecap", "butt");
                		markerShadow.setAttributeNS(null, "stroke", "white");
                		
                		shadowMarkerElement.appendChild(markerShadow);
                		defs.appendChild(shadowMarkerElement);
                		
            	    	var marker = new ORYX.Core.SVG.SVGMarker(shadowMarkerElement.cloneNode(true));
                        this._markers[marker.id] = marker;
        			}
        		}
        	}.bind(this));
    	}
    	
    	return shadowPath;
    },
    
    _buildInteractionPathForPath: function(path, svgDocument) {
        //init interaction path
        var iPath = path.cloneNode(false);
		iPath.setAttributeNS(null, "id", (iPath.getAttributeNS(null, "id")||"") + "_z");
        iPath.setAttributeNS(null, "stroke-width", ORYX.CONFIG.OFFSET_EDGE_BOUNDS * 2);
        iPath.setAttributeNS(null, "visibility", "hidden");
        iPath.setAttributeNS(null, "stroke-dasharray", null);
        iPath.setAttributeNS(null, "stroke", "black");
        iPath.setAttributeNS(null, "fill", "none");
		iPath.setAttributeNS(null, "title", this.getStencil().title());
		
        /* In SVG elements, the tooltip needs to be set in a separate <title> element,
         * the "title" attribute of the <g> element is ignored in all browsers except Firefox.
         * We keep the attribute only in to be safe in case it is used somewhere else. 
         * The tooltip should come from the <title> element now.
         */
        var titleElement = svgDocument.ownerDocument.createElementNS(ORYX.CONFIG.NAMESPACE_SVG, 'title');
        titleElement.textContent = this.getStencil().title();
        iPath.appendChild(titleElement);
        
        return iPath;
    },
    
    /**
     * Adds all necessary markers of this Edge to the SVG document.
     * Has to be called, while this.node is part of DOM.
     */
    addMarkers: function(defs){
        this._markers.each(function(marker){
            if (!defs.ownerDocument.getElementById(marker.value.id)) {
                marker.value.element = defs.appendChild(marker.value.element);
            }
        });
    },
    
    /**
     * Removes all necessary markers of this Edge from the SVG document.
     * Has to be called, while this.node is part of DOM.
     */
    removeMarkers: function(){
        var svgElement = this.node.ownerSVGElement;
        if (svgElement) {
            var defs = svgElement.getElementsByTagNameNS(NAMESPACE_SVG, "defs");
            if (defs.length > 0) {
                defs = defs[0];
                this._markers.each(function(marker){
                    var foundMarker = defs.ownerDocument.getElementById(marker.value.id);
                    if (foundMarker) {
                        marker.value.element = defs.removeChild(marker.value.element);
                    }
                });
            }
        }
    },
    
    /**
     * Calls when a docker has changed
     */
    _dockerChanged: function(){
    
        //this._update(true);
		this._dockerUpdated = true;
        
    },
    
    serialize: function(){
        var result = arguments.callee.$.serialize.apply(this);
        
        //add dockers triple
        var value = "";
        this._dockersByPath.each((function(pair){
            pair.value.each(function(docker){
                var position = docker.getDockedShape() && docker.referencePoint ? docker.referencePoint : docker.bounds.center();
                value = value.concat(position.x + " " + position.y + " ");
            });
            
            value += " # ";
        }).bind(this));
        result.push({
            name: 'dockers',
            prefix: 'oryx',
            value: value,
            type: 'literal'
        });
        
        //add parent triple dependant on the dockedShapes
        //TODO change this when canvas becomes a resource
/*        var source = this.dockers.first().getDockedShape();
        var target = this.dockers.last().getDockedShape();
        var sharedParent;
        if (source && target) {
            //get shared parent
            while (source.parent) {
                source = source.parent;
                if (source instanceof ORYX.Core.Canvas) {
                    sharedParent = source;
                    break;
                }
                else {
                    var targetParent = target.parent;
                    var found;
                    while (targetParent) {
                        if (source === targetParent) {
                            sharedParent = source;
                            found = true;
                            break;
                        }
                        else {
                            targetParent = targetParent.parent;
                        }
                    }
                    if (found) {
                        break;
                    }
                }
            }
        }
        else 
            if (source) {
                sharedParent = source.parent;
            }
            else 
                if (target) {
                    sharedParent = target.parent;
                }
*/        
        //if (sharedParent) {
/*            result.push({
                name: 'parent',
                prefix: 'raziel',
                //value: '#' + ERDF.__stripHashes(sharedParent.resourceId),
                value: '#' + ERDF.__stripHashes(this.getCanvas().resourceId),
                type: 'resource'
            });*/
        //}
		
		//serialize target and source
		var lastDocker = this.dockers.last();
		
		var target = lastDocker.getDockedShape();
		
		if(target) {
			result.push({
				name: 'target',
				prefix: 'raziel',
				value: '#' + ERDF.__stripHashes(target.resourceId),
				type: 'resource'
			});
		}
        
        try {
            //result = this.getStencil().serialize(this, result);
			var serializeEvent = this.getStencil().serialize();
			
			/*
			 * call serialize callback by reference, result should be found
			 * in serializeEvent.result
			 */
			if(serializeEvent.type) {
				serializeEvent.shape = this;
				serializeEvent.data = result;
				serializeEvent.result = undefined;
				serializeEvent.forceExecution = true;
				
				this._delegateEvent(serializeEvent);
				
				if(serializeEvent.result) {
					result = serializeEvent.result;
				}
			}
        } 
        catch (e) {
        }
        return result;
    },
    
    deserialize: function(data){
        try {
            //data = this.getStencil().deserialize(this, data);
			
			var deserializeEvent = this.getStencil().deserialize();
			
			/*
			 * call serialize callback by reference, result should be found
			 * in serializeEventInfo.result
			 */
			if(deserializeEvent.type) {
				deserializeEvent.shape = this;
				deserializeEvent.data = data;
				deserializeEvent.result = undefined;
				deserializeEvent.forceExecution = true;
				
				this._delegateEvent(deserializeEvent);
				if(deserializeEvent.result) {
					data = deserializeEvent.result;
				}
			}
        } 
        catch (e) {
        }
        
		// Set the outgoing shapes
		var target = data.find(function(ser) {return (ser.prefix+"-"+ser.name) == 'raziel-target'});
		var targetShape;
		if(target) {
			targetShape = this.getCanvas().getChildShapeByResourceId(target.value);
		}
		
		var outgoing = data.findAll(function(ser){ return (ser.prefix+"-"+ser.name) == 'raziel-outgoing'});
		outgoing.each((function(obj){
			// TODO: Look at Canvas
			if(!this.parent) {return};
								
			// Set outgoing Shape
			var next = this.getCanvas().getChildShapeByResourceId(obj.value);
															
			if(next){
				if(next == targetShape) {
					// If this is an edge, set the last docker to the next shape
					this.dockers.last().setDockedShape(next);
					this.dockers.last().setReferencePoint({x: next.bounds.width() / 2.0, y: next.bounds.height() / 2.0});
				} else if(next instanceof ORYX.Core.Edge) {
					//Set the first docker of the next shape
					next.dockers.first().setDockedShape(this);
					//next.dockers.first().setReferencePoint({x: this.bounds.width() / 2.0, y: this.bounds.height() / 2.0});
				} /*else if(next.dockers.length > 0) { //next is a node and next has a docker
					next.dockers.first().setDockedShape(this);
					next.dockers.first().setReferencePoint({x: this.bounds.width() / 2.0, y: this.bounds.height() / 2.0});
				}*/
			}	
			
		}).bind(this));
		
        
        var oryxDockers = data.find(function(obj){
            return (obj.prefix === "oryx" &&
            obj.name === "dockers");
        });
		
        if (oryxDockers) {
            var dataByPath = oryxDockers.value.split("#").without("").without(" ");
            
            dataByPath.each((function(data, index){
                var values = data.replace(/,/g, " ").split(" ").without("");
                
                //for each docker two values must be defined
                if (values.length % 2 === 0) {
                    var path = this._paths[index];
                    
                    if (path) {
                        if (index === 0) {
                            while (this._dockersByPath[path.id].length > 2) {
                                this.removeDocker(this._dockersByPath[path.id][1]);
                            }
                        }
                        else {
                            while (this._dockersByPath[path.id].length > 1) {
                                this.removeDocker(this._dockersByPath[path.id][0]);
                            }
                        }
                        
                        var dockersByPath = this._dockersByPath[path.id];
                        
                        if (index === 0) {
                            // Set position of first docker
                            var x = parseFloat(values.shift());
                            var y = parseFloat(values.shift());
							
							// Check value						
							x = x || x === 0.0 ? x : 10.0;
							y = y || y === 0.0 ? y : 10.0;
                            
                            if (dockersByPath.first().getDockedShape()) {
                                dockersByPath.first().setReferencePoint({
                                    x: x,
                                    y: y
                                });
                            }
                            else {
                                dockersByPath.first().bounds.centerMoveTo(x, y);
                            }
                        }
                        
                        // Set position of last docker
                        y = parseFloat(values.pop());
                        x = parseFloat(values.pop());
						
						// Check value	
						x = x || x === 0.0 ? x : 10.0;
						y = y || y === 0.0 ? y : 10.0;
                        
                        if (dockersByPath.last().getDockedShape()) {
                            dockersByPath.last().setReferencePoint({
                                x: x,
                                y: y
                            });
                        } else {
                            dockersByPath.last().bounds.centerMoveTo(x, y);
                        }
                        
                        //add additional dockers
                        for (var i = 0; i < values.length; i++) {
                            x = parseFloat(values[i]);
                            y = parseFloat(values[++i]);
                            
                            var newDocker = this.createDocker();
                            newDocker.bounds.centerMoveTo(x, y);
                            
                            //this.dockers = this.dockers.without(newDocker);
                            //this.dockers.splice(this.dockers.indexOf(dockersByPath.last()), 0, newDocker);
                            //dockersByPath.splice(this.dockers.indexOf(dockersByPath.last()), 0, newDocker);
						}
                    }
                }
            }).bind(this));
        } else {
            this.alignDockers();
        }
		
        arguments.callee.$.deserialize.apply(this, arguments);
		
		this._changed();
    },
    
    toString: function(){
        return this.getStencil().title() + " " + this.id;
    },
    
    /**
     * @return {ORYX.Core.Shape} Returns last docked shape or null.
     */
    getTarget: function(){
        return this.dockers.last() ? this.dockers.last().getDockedShape() : null;
    },
	
	/**
	 * @return {ORYX.Core.Shape} Returns the first docked shape or null
	 */
	getSource: function() {
		return this.dockers.first() ? this.dockers.first().getDockedShape() : null;
	},
	
	/**
	 * Checks whether the edge is at least docked to one shape.
	 * 
	 * @return {boolean} True if edge is docked
	 */
	isDocked: function() {
		var isDocked = false;
		this.dockers.each(function(docker) {
			if(docker.isDocked()) {
				isDocked = true;
				throw $break;
			}
		});
		return isDocked;
	},
    
    /**
     * Calls {@link ORYX.Core.AbstractShape#toJSON} and add a some stencil set information.
     */
    toJSON: function() {
        var json = arguments.callee.$.toJSON.apply(this, arguments);
        
        if(this.getTarget()) {
            json.target = {
                resourceId: this.getTarget().resourceId
            };
        }
        
        return json;
    }
};
ORYX.Core.Edge = ORYX.Core.Shape.extend(ORYX.Core.Edge);
/**
 * Copyright (c) 2008
 * Willi Tscheschner
 * 
 **/

/**
 * Namespace
 * @namespace Namespace for ORYX Plugins
 * @name ORYX.Plugins
 */
if("undefined" == typeof ORYX){ var ORYX = {}; }
if("undefined" == typeof ORYX.Plugins){ ORYX.Plugins = {}; }

new function(){
	/**
	   This abstract plugin class can be used to build plugins on.
	   It provides some more basic functionality like registering events (on*-handlers)...
	   @example
	    ORYX.Plugins.MyPlugin = ORYX.Plugins.AbstractPlugin.extend({
	        construct: function() {
	            // Call super class constructor
	            arguments.callee.$.construct.apply(this, arguments);
	            
	            [...]
	        },
	        [...]
	    });
	   @class ORYX.Plugins.AbstractPlugin
	   @extends Clazz
	   @author Willi Tscheschner
	*/
	ORYX.Plugins.AbstractPlugin = Clazz.extend({
	    /** @lends ORYX.Plugins.AbstractPlugin# */
		/** 
	     * The facade which offer editor-specific functionality
	     * @type Facade
	     * @memberOf ORYX.Plugins.AbstractPlugin#
	     */
		facade: null,
		
		/**
		 * @constructor
		 * @param {Facade} facade
		 */
		construct: function( facade ){
			this.facade = facade;
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.onLoaded.bind(this));
		},
	        
	    /**
	       Overwrite to handle load event. TODO: Document params!!!
	       @methodOf ORYX.Plugins.AbstractPlugin#
	    */
		onLoaded: function(){},
		
	    /**
	       Overwrite to handle selection changed event. TODO: Document params!!!
	       @methodOf ORYX.Plugins.AbstractPlugin#
	    */
		onSelectionChanged: function(){},
		
	    /**
	       Show overlay on given shape.
	       @methodOf ORYX.Plugins.AbstractPlugin#
	       @example
	       showOverlay(
	           myShape,
	           { stroke: "green" },
	           ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
	               "title": "Click the element to execute it!",
	               "stroke-width": 2.0,
	               "stroke": "black",
	               "d": "M0,-5 L5,0 L0,5 Z",
	               "line-captions": "round"
	           }])
	       )
	       @param {ORYX.Core.Shape[]} shapes One shape or array of shapes the overlay should be put on
	       @param {ORYX.XXX.Attributes} attributes some attributes...
	       @param {ORYX.svg.node} svgNode The svg node which should be used as overlay
	       @param {String} [svgNode="NW"] The svg node position where the overlay should be placed
	    */
		showOverlay: function(shapes, attributes, svgNode, svgNodePosition ){
			
			if( !(shapes instanceof Array) ){
				shapes = [shapes];
			}
			
			// Define Shapes
			shapes = shapes.map(function(shape){
				var el = shape;
				if( typeof shape == "string" ){
					el = this.facade.getCanvas().getChildShapeByResourceId( shape );
					el = el || this.facade.getCanvas().getChildById( shape, true );
				}
				return el;
			}.bind(this)).compact();
			
			// Define unified id
			if( !this.overlayID ){
				this.overlayID = this.type + ORYX.Editor.provideId();
			}
			
			this.facade.raiseEvent({
				type		: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
				id			: this.overlayID,
				shapes		: shapes,
				attributes 	: attributes,
				node		: svgNode,
				nodePosition: svgNodePosition || "NW"
			});
			
		},
		
	    /**
	       Hide current overlay.
	       @methodOf ORYX.Plugins.AbstractPlugin.prototype
	    */
		hideOverlay: function(){
			this.facade.raiseEvent({
				type	: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
				id		: this.overlayID
			});		
		},
		
		/**
	       Does a transformation with the given xslt stylesheet.
	       @methodOf ORYX.Plugins.AbstractPlugin.prototype
	       @param {String} data The data (e.g. eRDF) which should be transformed
	       @param {String} stylesheet URL of a stylesheet which should be used for transforming data.
	    */
		doTransform: function( data, stylesheet ) {		
			
			if( !stylesheet || !data ){
				return "";
			}
	
	        var parser 		= new DOMParser();
	        var parsedData 	= parser.parseFromString(data, "text/xml");
			source=stylesheet;
			new Ajax.Request(source, {
				asynchronous: false,
				method: 'get',
				onSuccess: function(transport){
					xsl = transport.responseText;
				}.bind(this),
				onFailure: (function(transport){
					ORYX.Log.error("XSL load failed" + transport);
				}).bind(this)
			});
	        var xsltProcessor = new XSLTProcessor();
			var domParser = new DOMParser();
			var xslObject = domParser.parseFromString(xsl, "text/xml");
	        xsltProcessor.importStylesheet(xslObject);
	        
	        try {
	        	
	            var newData 		= xsltProcessor.transformToFragment(parsedData, document);
	            var serializedData 	= (new XMLSerializer()).serializeToString(newData);
	            
	           	/* Firefox 2 to 3 problem?! */
	            serializedData = !serializedData.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serializedData : serializedData;
	            
	            return serializedData;
	            
	        }catch (error) {
	            return -1;
	        }
	        
		},
		
		/**
		 * Opens a new window that shows the given XML content.
		 * @methodOf ORYX.Plugins.AbstractPlugin.prototype
		 * @param {Object} content The XML content to be shown.
		 * @example
		 * openDownloadWindow( "my.xml", "<exampleXML />" );
		 */
		openXMLWindow: function(content) {
			var win = window.open(
			   'data:application/xml,' + encodeURIComponent(
			     content
			   ),
			   '_blank', "resizable=yes,width=600,height=600,toolbar=0,scrollbars=yes"
			);
		},
		
	    /**
	     * Opens a download window for downloading the given content.
	     * @methodOf ORYX.Plugins.AbstractPlugin.prototype
	     * @param {String} filename The content's file name
	     * @param {String} content The content to download
	     */
		openDownloadWindow: function(filename, content) {
			var win = window.open("");
			if (win != null) {
				win.document.open();
				win.document.write("<html><body>");
				var submitForm = win.document.createElement("form");
				win.document.body.appendChild(submitForm);
				
				var createHiddenElement = function(name, value) {
					var newElement = document.createElement("input");
					newElement.name=name;
					newElement.type="hidden";
					newElement.value = value;
					return newElement;
				};
				
				submitForm.appendChild( createHiddenElement("download", content) );
				submitForm.appendChild( createHiddenElement("file", filename) );
				
				// Append security parameter
				$H(Ext.Ajax.getSecurityParameter()).each(function(hash){
						if (hash.value instanceof Array) {
							hash.value.each(function(val){
								submitForm.appendChild( createHiddenElement(hash.key, val) );
							})
						} else {
							submitForm.appendChild( createHiddenElement(hash.key, hash.value) );
						}
					});
				
				submitForm.method = "POST";
				win.document.write("</body></html>");
				win.document.close();
				submitForm.action= ORYX.CONFIG.SERVER_DOWNLOAD_HANDLER;
				submitForm.submit();
			}		
		},
	    
	    /**
	     * Serializes DOM.
	     * @methodOf ORYX.Plugins.AbstractPlugin.prototype
	     * @type {String} Serialized DOM
	     */
	    getSerializedDOM: function(){
	        // Force to set all resource IDs
	        var serializedDOM = DataManager.serializeDOM( this.facade );
	
	        //add namespaces
	        serializedDOM = '<?xml version="1.0" encoding="utf-8"?>' +
	        '<html xmlns="http://www.w3.org/1999/xhtml" ' +
	        'xmlns:b3mn="http://b3mn.org/2007/b3mn" ' +
	        'xmlns:ext="http://b3mn.org/2007/ext" ' +
	        'xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ' +
	        'xmlns:atom="http://b3mn.org/2007/atom+xhtml">' +
	        '<head profile="http://purl.org/NET/erdf/profile">' +
	        '<link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" />' +
	        '<link rel="schema.dcTerms" href="http://purl.org/dc/terms/ " />' +
	        '<link rel="schema.b3mn" href="http://b3mn.org" />' +
	        '<link rel="schema.oryx" href="http://oryx-editor.org/" />' +
	        '<link rel="schema.raziel" href="http://raziel.org/" />' +
	        '<base href="' +
	        location.href.split("?")[0] +
	        '" />' +
	        '</head><body>' +
	        serializedDOM +
	        '</body></html>';
	        
	        return serializedDOM;
	    },
	    
	    /**
	     * Sets the editor in read only mode: Edges/ dockers cannot be moved anymore,
	     * shapes cannot be selected anymore.
	     * @methodOf ORYX.Plugins.AbstractPlugin#
	     * @see ORYX.Plugins.AbstractPlugin#disableReadOnlyMode
	     */
	    enableReadOnlyMode: function(){
	        //Edges cannot be moved anymore
	        this.facade.disableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
	        
	        // Stop the user from editing the diagram while the plugin is active
	        this._stopSelectionChange = function(){
	            if(this.facade.getSelection().length > 0) {
	                this.facade.setSelection([]);
	            }
	        };
	        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this._stopSelectionChange.bind(this));
	    },
	    /**
	     * Disables read only mode, see @see
	     * @methodOf ORYX.Plugins.AbstractPlugin#
	     * @see ORYX.Plugins.AbstractPlugin#enableReadOnlyMode
	     */
	    disableReadOnlyMode: function(){
	        // Edges can be moved now again
	        this.facade.enableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
	        
	        if (this._stopSelectionChange) {
	            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this._stopSelectionChange.bind(this));
	            this._stopSelectionChange = undefined;
	        }
	    },
	    
	    /**
	     * Extracts RDF from DOM.
	     * @methodOf ORYX.Plugins.AbstractPlugin.prototype
	     * @type {String} Extracted RFD. Null if there are transformation errors.
	     */
	    getRDFFromDOM: function(){
	        //convert to RDF
			try {
				var xsl = "";
				source=ORYX.PATH + "lib/extract-rdf.xsl";
				new Ajax.Request(source, {
					asynchronous: false,
					method: 'get',
					onSuccess: function(transport){
						xsl = transport.responseText;
					}.bind(this),
					onFailure: (function(transport){
						ORYX.Log.error("XSL load failed" + transport);
					}).bind(this)
				});
				/*
				 var parser = new DOMParser();
				 var parsedDOM = parser.parseFromString(this.getSerializedDOM(), "text/xml");
				 var xsltPath = ORYX.PATH + "lib/extract-rdf.xsl";
				 var xsltProcessor = new XSLTProcessor();
				 var xslRef = document.implementation.createDocument("", "", null);
				 xslRef.async = false;
				 xslRef.load(xsltPath);
				 xsltProcessor.importStylesheet(xslRef);
				 try {
				 var rdf = xsltProcessor.transformToDocument(parsedDOM);
				 return (new XMLSerializer()).serializeToString(rdf);
				 } catch (error) {
				 Ext.Msg.alert("Oryx", error);
				 return null;
				 }*/
				var domParser = new DOMParser();
				var xmlObject = domParser.parseFromString(this.getSerializedDOM(), "text/xml");
				var xslObject = domParser.parseFromString(xsl, "text/xml");
				var xsltProcessor = new XSLTProcessor();
				xsltProcessor.importStylesheet(xslObject);
				var result = xsltProcessor.transformToFragment(xmlObject, document);
				
				var serializer = new XMLSerializer();
				
				return serializer.serializeToString(result);
			}catch(e){
				Ext.Msg.alert("Oryx", error);
				return "";
			}
	
			
	    },
	    
	    /**
	     * Checks if a certain stencil set is loaded right now.
		 * @param stencilSetExtensionNamespace
	     * @returns {Boolean}
	     */
		isStencilSetExtensionLoaded: function(stencilSetExtensionNamespace) {
			return this.facade.getStencilSets().values().any(
				function(ss){ 
					return ss.extensions().keys().any(
						function(extensionKey) {
							return extensionKey == stencilSetExtensionNamespace;
						}.bind(this)
					);
				}.bind(this)
			);
		},
		
		/**
		 * Raises an event so that registered layouters does
		 * have the posiblility to layout the given shapes 
		 * For further reading, have a look into the AbstractLayouter
		 * class
		 * @param {Object} shapes
		 */
		doLayout: function(shapes){
			// Raises a do layout event
			this.facade.raiseEvent({
				type		: ORYX.CONFIG.EVENT_LAYOUT,
				shapes		: shapes
			});
		},
		
		
		/**
		 * Does a primitive layouting with the incoming/outgoing 
		 * edges (set the dockers to the right position) and if 
		 * necessary, it will be called the real layouting 
		 * @param {ORYX.Core.Node} node
		 * @param {Array} edges 
		 * @param {Object} offset
		 */
		layoutEdges : function(node, allEdges, offset){		
	
			if (!this.facade.isExecutingCommands() || allEdges.length === 0){ return; }		
	
			var Command = ORYX.Core.Command.extend({
				
				/**
				 * @field
				 * @type {Number} The size of small shapes to determine how to layout the messageflows
				 */
				smallShapeSize	: 200,
				
				/**
				 * @field
				 * @type {Boolean[String side][]} Flag to determine if a side needs to be layouted 
				 */
				allInside		: [],
				
				/**
				 * @field
				 * @type {Boolean} Flag to determine if the relative Position between the connected nodes changed
				 */
				positionChanged : false,
				
				/**
				 * @field
				 * @type {ORYX.Core.Edge[String id][]} The order of the edges determined by the edge's id
				 */
				oldOrder		: {},
				
				/**
				 * @field
				 * @type {ORYX.Core.Docker[]} Dockers which were removed due to be included in a docked shape
				 */
				removedDockers 	: [],
				
				/**
				 * @constructs
				 * @param {ORYX.Core.Edge[]} edges All docked edges
				 * @param {ORYX.Core.Node} node The dragged node
				 * @param {Object} offset Contains the movement information
				 * @param {Object} plugin Contains the layout callback 
				 */
				construct: function(edges, node, offset, plugin){
					this.edges = edges;
					this.node = node;
					this.plugin = plugin;
					this.offset = offset;		
					
					// Get the new absolute center
					var center = node.absoluteXY();
					this.ulo = {x: center.x - offset.x, y:center.y - offset.y};
					
					// The absolute bounds of the node
					this.nodeBounds = this.node.absoluteBounds();

					// The previous position of the node
					this.oldBounds = this.nodeBounds.clone();
					var r = {x:(this.nodeBounds.upperLeft().x)-this.offset.x,
							 y:(this.nodeBounds.upperLeft().y)-this.offset.y };
					this.oldBounds.set(r, {x:r.x+(this.nodeBounds.width()/(this.offset.xs||1)),
					    y:r.y+(this.nodeBounds.height()/(this.offset.ys||1))
					});
					
				},
				execute: function(){
					
					if (this.changes){
						this.executeAgain();
						return;
					} else {
						this.changes = [];
						this.edges.each(function(edge){
							this.changes.push({
								edge: edge,
								oldDockerPositions: edge.dockers.map(function(r){ return r.isDocked()?r.referencePoint : r.bounds.center(); })
							});
						}.bind(this));
					}
					
					/**
					 * PREPARE ALL MESSAGEFLOWS FOR LAYOUTING (REMOVE INCLUDED DOCKERS, DETERMINE THE ORDER):
					 */
					this.edges.each(function(edge) {
						if (edge.getStencil().keepState()) {
							this.prepareEdgeForLayout(edge);							
						}
					}.bind(this));
					
					
					/**
					 * LAYOUT ALL DOCKED EDGES:
					 */
					this.edges.each(function(edge, edgeIndex){
						//variable to set to reduce updates
						
						// If it's not a messageflow, do the old layouting
						if (edge.getStencil().keepState() == false) {
							if (this.offset.xs || this.offset.ys) {
								this.plugin.doLayout(edge);
								return;
							} else {
								this.layoutOldStyle(edge);
								return;
							}
						}
						
						var needLayout = false;
						
						// Get the data object.
						var data = this.getDataObject(edge, edgeIndex);
						if (!data){ return; }
						var threshold = 12;
						
						// Check if the overlap and the docked edge share the same side.
						var wrongOverlap = this.nodeBounds.getSide(data.foreignBounds.center()) !== data.side;
						var wasAligned = this.wasAligned(data.first, data.second);
						
						
						/**
						 * IF OVERLAP EXISTS, CHECK IF THE EDGE SHOULD BE MOVED INSIDE IT:
						 */
						// If an overlap exists and it is on the right side and it is wide enough for the edges
						if (data.overlap && !wrongOverlap && data.overlap.width() > threshold &&
							edge.dockers.length <= 3 &&
							// And not all edges are inside the overlap
							(this.allInside[data.newSide] === false ||
							 !this.allEdgesInside(
									 this.node,
									 (this.isSmallShapeInvolved(data) ?
											 this.nodeBounds :
											 this.oldBounds
									 ),
									 this.getRelevantEdges(this.node, this.oldBounds, data.side, data.edge), data.side)
							 )
							) {
								// Move the edge into the overlap
								this.moveToOverlap(data, edge.dockers.length, true, true, wasAligned);
						}
					
						/**
						 *  IF NO OVERLAP EXISTS, CHECK IF THE EDGE SHOULD BE MOVED:
						 */
						/*
						 * Handle edges with 2 dockers:
						 * If they're inside the overlapping area, just
						 * leave them where they are, if not they're skew
						 * and are layouted the old way.
						 */
						else if (edge.dockers.length === 2) {
							if (this.isSmallShapeInvolved(data) && data.overlap && data.overlap.width() > threshold) {
								this.moveToOverlap(data, edge.dockers.length, true);
							} else {
								needLayout = this.moveEdge(data, edge.dockers.length);
							}
						} 

						/* If the docked edge has
						 * three dockers:
						 */
						else if (edge.dockers.length === 3) {
							/*
							 * If an edge has 3 bendPoints and is
							 * inside of the overlapping area, one of the
							 * bendPoints must be inside of one of the
							 * docked shapes. 
							 */ 
							if (data.overlap  && !wrongOverlap && data.overlap.width() > threshold && this.isInsideOverlap(data)) {
								this.removedDockers = this.removedDockers.concat(this.removeAllDocker(edge));
								/*
								 * If a small Shape aka Task involved, realign
								 * the edges according to their number on the
								 * shared side, if not, just move the edge.
								 */
								if (this.isSmallShapeInvolved(data)) {
									this.moveToOverlap(data, edge.dockers.length, true);
								} else {
									needLayout = this.moveEdge(data, edge.dockers.length);
								}
							}
							/* 
							 * If not, try to keep all bendPoints where
							 * they are and avoid too much layouting. 
							 */ 
							else {
								var updatedData = this.layoutOldStyle(edge, data);
								if (updatedData) {
									data = updatedData;
									data.edge._update(true);
								}
								/*
								 * If it happens that bendPoints are inside of
								 * one of the shapes after moving, remove them
								 * and adjust the edge.
								 */
								if (this.isBendPointIncluded(edge)) {
									// Remove docker
									var removedDockers = this.removeAllDocker(edge);
									this.removedDockers = this.removedDockers.concat(removedDockers);
									// Set the position of the last or first 
									// docker to the one of the removed one
									if (removedDockers.length == 1){
										var rdocker = removedDockers.first();
										var ab = edge.dockers.first().getDockedShape().absoluteBounds();
										if (edge.dockers.first().getDockedShape() && 
											ab.isIncluded(rdocker.bounds.center())){
											var db = rdocker.bounds.clone();
											db.moveBy(-ab.a.x, -ab.a.y);
											edge.dockers.first().setReferencePoint(db.center());
										} else if (edge.dockers.last().getDockedShape()){
											var bb = edge.dockers.last().getDockedShape().absoluteBounds();
											var db = rdocker.bounds.clone();
											db.moveBy(-bb.a.x, -bb.a.y);
											edge.dockers.last().setReferencePoint(db.center());											
										}
									}
								}
//								if (this.isSmallShapeInvolved(data)) {
//									this.moveToOverlap(data, length, true);
//								} else 
								if (!this.isAligned(data.first, data.second) && wasAligned){
									needLayout = this.moveEdge(data, edge.dockers.length);
								}
							}
						}
						/* If the edge has more than 3 dockers, determine
						 * if there is an overlapping area, if so, move
						 * the docked segment, if not, layout the old way.
						 */
						else if (edge.dockers.length > 3) {
//							if (this.isSmallShapeInvolved(data) && data.overlap && !wrongOverlap) {
//								this.moveToOverlap(data, edge.dockers.length, true, true);
//							} else if (data.overlap  && !wrongOverlap && this.isInsideOverlap(data, true)) {
//								needLayout = this.moveEdge(data, edge.dockers.length);
//							} else {
								this.layoutOldStyle(edge, data);
//							}
						}
					
						//Update the edge
						edge._update(true);
						
						edge.removeUnusedDockers();

						// Recalculate docker bounds to check if they are aligned:
						var first = data.first;
						var second = data.edge.dockers[(first === data.edge.dockers[0] ? 1 : data.edge.dockers.length - 2)];
						
						// Check if the docked segment is aligned, a bend point is included or the need to layout came up anywhere before.
						if (this.isBendPointIncluded(edge) ||
							needLayout === true ||
							(
							 !this.isAligned(first, second) &&
							 wasAligned
							)) {
								this.plugin.doLayout(edge);
								return;
						}
					}.bind(this));
	
					
					/**
					 * REPOSITION OVERLAYING EDGES
					 */
					var threshold = 12;

					var sidesToManage = this.getSidesToManage(threshold);
					
					// Realign all edges on the given side
					var etr;
					var dockers;
					
					sidesToManage.each(function(side) {
						etr = [];
						var edgesFromSide = this.edges.findAll(function(edge) {
							var first = (edge.dockers[0].getDockedShape() === this.node ?
									edge.dockers[0]:
									edge.dockers[edge.dockers.length - 1]
							);
							// True if docked to the given side
							return this.node.absoluteBounds().getSide(first.bounds.center()) === side;
						}.bind(this));
						
						edgesFromSide.each(function(edge, edgeIndex) {
							var data = this.getDataObject(edge, edgeIndex);
							if (data && data.overlap && 
								(["top", "bottom"].include(side) && data.overlap.width() ||
								 ["left" ,"right"].include(side) && data.overlap.height() ) < threshold*(edgesFromSide.length+1)) {
								if(!etr.include(edge)) {
									etr.push(edge);
								}
							}	
						}.bind(this));
						
						if (etr.length > 0) {
							this.handleSmallOverlap(etr, threshold);
						} else {
							this.redistributeEdges(side, threshold);	
						}
					}.bind(this));
					
					// Save the docker positions for undo/redo
					this.edges.each(function(edge, i){
						this.changes[i].dockerPositions = edge.dockers.map(function(r){ return r.isDocked()? r.referencePoint : r.bounds.center(); });
					}.bind(this));
					
				},
				
				/**
				 * Returns all sides that need to be reordered
				 * @param {Number} threshold The minimal distance between two edges or towards the shape's boundaries
				 * @returns {String[]} sidesToManage The sides which need to be reordered
				 */
				getSidesToManage : function(threshold) {
					
					var dockers = [];
					var sidesToManage = [];
					
					// Get all to this.node docked dockers
					this.edges.each(function(edge) {
						dockers.push(edge.dockers[0].getDockedShape() === this.node ? edge.dockers[0] :
																					  edge.dockers[edge.dockers.length - 1]);
					}.bind(this)); 
					// Check if 2 or more dockers have the same coordinates, if so, collect the edge
					dockers.each(function(activeDocker){ 
						// The side of the active docker
						var side = this.nodeBounds.getSide(activeDocker.bounds.center());
						// Check if the active docker is to close to the node's borderes
						if (activeDocker.parent.getStencil().keepState() &&
							(["top", "bottom"].include(side) && (Math.abs(activeDocker.bounds.center().x - this.nodeBounds.upperLeft().x) < threshold || Math.abs(activeDocker.bounds.center().x - this.nodeBounds.lowerRight().x) < threshold) || 
							 ["left", "right"].include(side) && (Math.abs(activeDocker.bounds.center().y - this.nodeBounds.upperLeft().y) < threshold || Math.abs(activeDocker.bounds.center().y - this.nodeBounds.lowerRight().y) < threshold)) &&
							!sidesToManage.include(side)) {
							sidesToManage.push(side);
						} else {
							dockers.each(function(docker) {
						        // Check if there are overlaying edges or the dragged node is small and the side has more than one docker
								if (docker !== activeDocker && 
							        	// If it's a message flow
							        	docker.parent.getStencil().keepState() && (
							        		(
							        			// If the docked side of the dragged node is small
									        	(["top", "bottom"].include(side) && this.nodeBounds.width() < this.smallShapeSize ||
									        	 ["left", "right"].include(side) && this.nodeBounds.height() < this.smallShapeSize) &&
									        	// And there are more than one edge docked to the small side
									        	this.nodeBounds.getSide(docker.bounds.center()) === side
								        	) || (
							        			// If two or more edges are overlaying 
									        	Math.abs(docker.bounds.center().x - activeDocker.bounds.center().x) < threshold &&
									            Math.abs(docker.bounds.center().y - activeDocker.bounds.center().y) < threshold
								        	)
								        ) &&
								        // And if the side is not yet remarked for maintenance 
							        	!sidesToManage.include(side)		
						        	) {
						        		// Remark the side for maintenance
						        		sidesToManage.push(side);
					            }
						    }.bind(this));	
						}
					}.bind(this));
					return sidesToManage;
				},
				
				/**
				 * 
				 * @param etr
				 * @param threshold
				 */
				handleSmallOverlap : function(etr, threshold) {
					var length = etr.length;
					// If there's only one edge, layout it.
					if (length === 1) {
						this.plugin.doLayout(etr[0]);
					}
					// If there's more than one edge, reposition them before calling the layout.
					else {
						//The data object
						var data = this.getDataObject(etr[0], 0);
						if (!data){ return; }
						//Sort the relevant edges
						etr = this.getRelevantEdges(data.node, this.nodeBounds, data.newSide, etr[0], true);
						//The most left edge
						var firstEdge = etr.first();
						//The most right edge
						var lastEdge = etr.last();
						
						// Get the relative position between the two shapes
						var leftShape = ["top", "bottom"].include(data.newSide) ? 
											this.nodeBounds.center().x < data.foreignBounds.center().x ?
													data.node :
													data.foreignNode									:
											this.nodeBounds.center().y < data.foreignBounds.center().y ?
													data.node :
													data.foreignNode;
						
						var rightShape = (leftShape === data.node ? data.foreignNode : data.node);
						
						// 
						var firstDocker = firstEdge.dockers[0].getDockedShape() === leftShape ? firstEdge.dockers.first() : firstEdge.dockers.last();
						var lastDocker = lastEdge.dockers[0].getDockedShape() === rightShape ? lastEdge.dockers.first() : lastEdge.dockers.last();
						
						var xOverlap = this.xOverlap(data);
						var yOverlap = this.yOverlap(data);
						
						var alt = firstDocker.referencePoint;
						firstDocker.setReferencePoint({
						    x : xOverlap > 0 ? (alt.x - threshold*3) : firstDocker.referencePoint.x,
						    y : yOverlap > 0 ? (alt.y - threshold*3) : firstDocker.referencePoint.y
						});
						var alt2 = lastDocker.referencePoint;
						lastDocker.setReferencePoint({
						    x : xOverlap > 0 ? (alt2.x + threshold*3) : lastDocker.referencePoint.x,
						    y : yOverlap > 0 ? (alt2.y + threshold*3) : lastDocker.referencePoint.y
						});
						firstEdge.addDocker(firstEdge.bounds.center());
						lastEdge.addDocker(lastEdge.bounds.center());

						firstEdge.dockers[1].bounds.centerMoveTo({
							x : firstEdge.dockers[0].getAbsoluteReferencePoint().x,
							y : (firstEdge.dockers[2].isDocked() ?
									firstEdge.dockers[2].getAbsoluteReferencePoint().y :
									firstEdge.dockers[2].bounds.center().y)
						});
						
						if (leftShape.absoluteBounds().isIncluded(firstEdge.dockers[1].bounds.center())) {
							firstEdge.dockers[1].bounds.centerMoveTo({
								x:(firstEdge.dockers[2].isDocked() ?
									firstEdge.dockers[2].getAbsoluteReferencePoint().x :
									firstEdge.dockers[2].bounds.center().x),
								y:firstEdge.dockers[0].getAbsoluteReferencePoint().y
							});
						}
						
						lastEdge.dockers[1].bounds.centerMoveTo({
							x : (lastEdge.dockers[2].isDocked() ?
									lastEdge.dockers[2].getAbsoluteReferencePoint().x :
									lastEdge.dockers[2].bounds.center().x),
							y : lastEdge.dockers[0].getAbsoluteReferencePoint().y
						});
						
						if (rightShape.absoluteBounds().isIncluded(lastEdge.dockers[1].bounds.center())) {
							lastEdge.dockers[1].bounds.centerMoveTo({
								x : lastEdge.dockers[0].getAbsoluteReferencePoint().x,
								y : (lastEdge.dockers[2].isDocked() ?
										lastEdge.dockers[2].getAbsoluteReferencePoint().y :
										lastEdge.dockers[2].bounds.center().y)
							});
						}
					}
				},
				
				/**
				 * 
				 * @param {ORYX.Core.Edge} edge
				 * @returns {String} side
				 */
				prepareEdgeForLayout : function(edge) {
					var first, second, last, foreignNode;
					var side;
					var length = edge.dockers.length;
					
					if (edge.dockers[0].getDockedShape() === this.node){
						first = edge.dockers[0];
						second = edge.dockers[1];
						last = edge.dockers[length - 1];
					} else if (edge.dockers[length - 1].getDockedShape() === this.node) {
						first = edge.dockers[length - 1];
						second = edge.dockers[length - 2];
						last = edge.dockers[0];
					}

					// The other node the edge is docked to
					var foreignNode = last.getDockedShape();
					// If the edge is only docked on one side, skip
					if (!foreignNode || this.node === foreignNode) {
						return;
					}
					
					// The absolute Bounds of the foreign node
					var foreignBounds = foreignNode.absoluteBounds();
					
					// If at least one node contains all dockers, skip
					if (edge.dockers.all(function(d) {
							return this.nodeBounds.isIncluded(d.bounds.center()) ||
								   foreignBounds.isIncluded(d.bounds.center());
						}.bind(this))) {
						return;
					}
					
					
					if (this.offset.xs || this.offset.ys) {
						var ref = first.referencePoint;
						var absRef = first.getAbsoluteReferencePoint();
						// Reset the edge if the node was resized by moving either the second node to align the first docker
						// Or move the first docker as long as it stays inside the bounds, but only if the docked segment was
						// aligned.
						first.setReferencePoint({
					        x : (!(this.offset.xs && ref.x/this.offset.xs > this.nodeBounds.width()) ? 
					        		ref.x/(this.offset.xs||1) :
				        			ref.x),
					        y : (!(this.offset.ys && ref.y/this.offset.ys > this.nodeBounds.height()) ?
					        		ref.y/(this.offset.ys||1) :
				        			ref.y)
					    });
			    		
						second.bounds.centerMoveTo({
				    		x : (this.offset.xs && ref.x/this.offset.xs > this.nodeBounds.width() ?
				    				absRef.x :
				    				second.bounds.center().x),
				    		y : (this.offset.ys && ref.y/this.offset.ys > this.nodeBounds.height() ?
				    				absRef.y :
				    				second.bounds.center().y)
				    	});
						edge._update(true);
					}
					
					// Get the overlapping area
					var overlap = this.node.getOverlap(foreignNode);
					
					// Wide the nodeBounds and the foreignBounds to include really close docker positions
					var wNodeBounds = this.nodeBounds.clone();
					var wForeignBounds = foreignBounds.clone();
					wNodeBounds.widen(1);
					wForeignBounds.widen(1);
					
					
					/**
					 * DOCKER COUNT = 3 AND ALL DOCKERS ARE INCLUDED:
					 */
					if (edge.dockers.length === 3 && edge.dockers.all(function(d){
						 d = d.bounds.center();
						 return (overlap?overlap.isIncluded(d):false) ||
						 		wNodeBounds.isIncluded(d) ||
								wForeignBounds.isIncluded(d);
					 })) {
						
						// Get the docked side
						side = this.nodeBounds.getSide(last.bounds.center());

						// Remove the contained docker
						this.removedDockers = this.getDockersToRemove(edge);
						this.removedDockers.each(function(d) {
							edge.remove(d);
						});
						
						// Move the reference Point of the first docker to the position of the removed docker
						if (this.removedDockers.length > 0) {
							// Move the first Docker to the position of the removed Docker
							var d = this.removedDockers.first().bounds.center();
							first.setReferencePoint({
								x : d.x - this.nodeBounds.upperLeft().x,
							    y : d.y - this.nodeBounds.upperLeft().y
							});
							last.setReferencePoint({
								x : ["top", "bottom"].include(side) ? first.getAbsoluteReferencePoint().x - foreignBounds.upperLeft().x : last.referencePoint.x,
								y : ["top", "bottom"].include(side) ? last.referencePoint.y : first.getAbsoluteReferencePoint().y - foreignBounds.upperLeft().y
							});
							edge._update(true);
						}

						// Get the order of the edges on the relevant side
						this.oldOrder[edge.id] = this.getRelevantEdges(this.node, this.oldBounds, side, edge);
						
						// Check if all edges are inside the bounds
						if (this.allEdgesInside(this.node, this.nodeBounds, this.oldOrder[edge.id], side)) {
							this.allInside[side] = true;
						} else {
							this.allInside[side] = false;
						}
						return side;

					/**
					 * DOCKER COUNT =/= 3
					 */
					} else {
						// Dockercount >= 3
						
						this.removedDockers = this.getDockersToRemove(edge);
						this.removedDockers.each(function(d){
							edge.remove(d);
						});
						// Check if the former second docker was removed and if the edge was aligned, if so, restore the alignment
						if (this.removedDockers.include(second)) {
							
							// The last removed docker
							var d = this.removedDockers.first().bounds.center();
							
							// Move the first Docker to the position of the last docker
							first.setReferencePoint({
							    x : d.x - this.nodeBounds.upperLeft().x,
							    y : d.y - this.nodeBounds.upperLeft().y
							});
							
							// Save the old second docker
							var oldSecond = Object.clone(second);
							// Get the new second docker
							second = (edge.dockers[0] === first ? edge.dockers[1] : edge.dockers[edge.dockers.length - 2]);
							
							// Get the side of the new second docker
							var newSide = this.nodeBounds.getSide(second.bounds.center());
							
							// Align the second docker
							var absRef = first.getAbsoluteReferencePoint();
							// If the docked segment was aligned, align it again
							if (this.wasAligned(first, oldSecond)) {
								second.bounds.centerMoveTo({
									x : (["left","right"].include(newSide) ? second.bounds.center().x : absRef.x),
								    y : (["left","right"].include(newSide) ? absRef.y : second.bounds.center().y)
								});	
							}
						}
						if (edge.dockers.length >= 3) {
							side = this.oldBounds.getSide(second.bounds.center());
						}
						// Dockercount === 2
						else {
							side = this.nodeBounds.getSide(last.bounds.center());
						}
						var minW = Math.min(this.nodeBounds.width(), foreignBounds.width());
						var maxW = Math.max(this.nodeBounds.width(), foreignBounds.width());
						var minH = Math.min(this.nodeBounds.height(), foreignBounds.height());
						var maxH = Math.max(this.nodeBounds.height(), foreignBounds.height());
						
						var xOverlap = Math.min(this.nodeBounds.lowerRight().x, foreignBounds.lowerRight().x) - Math.max(this.nodeBounds.upperLeft().x, foreignBounds.upperLeft().x);
						var yOverlap = Math.min(this.nodeBounds.lowerRight().y, foreignBounds.lowerRight().y) - Math.max(this.nodeBounds.upperLeft().y, foreignBounds.upperLeft().y);
						
						// Get the order of the docked edges
						this.oldOrder[edge.id] = this.getRelevantEdges(this.node, this.oldBounds, side, edge);
						// Check if all edges are inside the node's boundaries
						if (this.allEdgesInside(this.node, this.nodeBounds, this.oldOrder[edge.id], side)) {
							this.allInside[side] = true;
						} else {
							this.allInside[side] = false;
						}
						
						// Get relative position between the two nodes
						var oldPosition = this.oldBounds.getSide(foreignBounds.center());
						var newPosition = this.nodeBounds.getSide(foreignBounds.center());
						if (oldPosition !== newPosition) {
							this.positionChanged = true;
						}
						
						return side;
					}
				},

				/**
				 * Align the bounds if the center is 
				 * the same than the old center
				 * @params {Object} bounds
				 * @params {Object} bounds2
				 */
				align: function(bounds, refDocker){
					var abRef = refDocker.getAbsoluteReferencePoint() || refDocker.bounds.center();
					
					var xdif = bounds.center().x-abRef.x;
					var ydif = bounds.center().y-abRef.y;
					if (Math.abs(-Math.abs(xdif) + Math.abs(this.offset.x)) < 3 && this.offset.xs === undefined){
						bounds.moveBy({x:-xdif, y:0});
					}
					if (Math.abs(-Math.abs(ydif) + Math.abs(this.offset.y)) < 3 && this.offset.ys === undefined){
						bounds.moveBy({y:-ydif, x:0});
					}
					
					if (this.offset.xs !== undefined || this.offset.ys !== undefined){
						var absPXY = refDocker.getDockedShape().absoluteXY();
						xdif = bounds.center().x-(absPXY.x+((abRef.x-absPXY.x)/this.offset.xs));
						ydif = bounds.center().y-(absPXY.y+((abRef.y-absPXY.y)/this.offset.ys));
						
						if (Math.abs(-Math.abs(xdif) + Math.abs(this.offset.x)) < 3){
							bounds.moveBy({x:-(bounds.center().x-abRef.x), y:0});
						}
						
						if (Math.abs(-Math.abs(ydif) + Math.abs(this.offset.y)) < 3){
							bounds.moveBy({y:-(bounds.center().y-abRef.y), x:0});
						}
					}
				},
				
				/**
				 * 
				 * @param data
				 * @returns {Boolean}
				 */
				isAligned : function(first, second) {
					return Math.abs(first.bounds.center().x - second.bounds.center().x) < 1 ||
						   Math.abs(first.bounds.center().y - second.bounds.center().y) < 1;
				},
				
				/**
				 * Checks if the two given dockers were aligned before the node was moved.
				 * @param {ORYX.Core.Docker} first
				 * @param {ORYX.Core.Docker} second
				 * @returns {Boolean}
				 */
				wasAligned : function(first, second) {
					var absRef = first.getAbsoluteReferencePoint();
					return (Math.abs((absRef.x - this.offset.x) - second.bounds.center().x) < 5 ||
							Math.abs((absRef.y - this.offset.y) - second.bounds.center().y) < 5); 
				},
				
				/**
				 * 
				 * @param referencePoint
				 * @param bounds
				 * @param side
				 * @returns
				 */
				containsReference : function(referencePoint, bounds, side) {
					switch (side) {
						case "top" 			: return bounds.isIncluded({x: referencePoint.x, y: bounds.center().y});
						case "bottom"		: return bounds.isIncluded({x: referencePoint.x, y: bounds.center().y});
						case "left"			: return bounds.isIncluded({x: bounds.center().x, y: referencePoint.y});
						case "right"		: return bounds.isIncluded({x: bounds.center().x, y: referencePoint.y});
					}
				},
				
				/**
				 * Returns the size of the overlapping area on the x-axis.
				 * @param {Object} data The data Object
				 * @returns {Number} The width of the overlapping area
				 */
				xOverlap : function(data) {
					return Math.min(data.nodeLR.x, data.foreignLR.x) - Math.max(data.nodeUL.x, data.foreignUL.x);
				},
				
				/**
				 * Returns the size of the overlapping area on the y-axis.
				 * @param {Object} data The data object
				 * @return {Number} The height of the overlapping area
				 */
				yOverlap : function(data) {
					return Math.min(data.nodeLR.y, data.foreignLR.y) - Math.max(data.nodeUL.y, data.foreignUL.y);
				},
				
				/**
				 * Checks if the active edge is inside the overlapping area.
				 * If isSegment == true, only the docked segment is checked.
				 * @param data
				 * @param {Boolean} isSegment
				 * @returns {Boolean}
				 */
				isInsideOverlap : function(data, isSegment) {
					return !isSegment && data.edge.dockers.all(function(d){
											 d = d.bounds.center();
											 return (data.overlap?data.overlap.isIncluded(d):false) ||
													this.nodeBounds.isIncluded(d) ||
													data.foreignBounds.isIncluded(d);
										 }.bind(this)) ||
						   isSegment && data.edge.dockers.length > 3 && 
						   data.overlap.isIncluded(data.secCenter);
				},
				
				/**
				 * Checks if the side of the segment is kind of small, like from a shape.
				 * @param data
				 * @returns {Boolean}
				 */
				isSmallShapeInvolved : function(data) {
					if (["top", "bottom"].include(this.nodeBounds.getSide(data.first)) && (this.nodeBounds.width() < this.smallShapeSize || data.foreignBounds.width() < this.smallShapeSize) ||
						["left", "right"].include(this.nodeBounds.getSide(data.first)) && (this.nodeBounds.height() < this.smallShapeSize || data.foreignBounds.height() < this.smallShapeSize)) {
						return true;
					} else return false;
				},
				
				/**
				 * Returns true if there are bend points which overlay the shape
				 * @param {ORYX.Core.Edge} edge
				 * @returns {Boolean}
				 */
				isBendPointIncluded: function(edge, includeArrowHeads){
					// Get absolute bounds
					var ab = edge.dockers.first().getDockedShape();
					var bb = edge.dockers.last().getDockedShape();
					
					if (ab) {
						ab = ab.absoluteBounds();
						if (includeArrowHeads) {
							ab.widen(5);
						}
					}
					
					if (bb) {
						bb = bb.absoluteBounds();
						if (includeArrowHeads) {
							bb.widen(20); // Wide with 20 because of the arrow from the edge
						}
					}
					
					return edge.dockers
							.any(function(docker, i){ 
								var c = docker.bounds.center();
										// Dont count first and last
								return 	i != 0 && i != edge.dockers.length-1 && 
										// Check if the point is included to the absolute bounds
										((ab && ab.isIncluded(c)) || (bb && bb.isIncluded(c)));
							});
				},
				/**
				 * Returns unnecessary dockers to remove.
				 * @param edge
				 * @returns
				 */
				getDockersToRemove : function(edge) {
					var ab = edge.dockers.first().getDockedShape();
					var bb = edge.dockers.last().getDockedShape();
					
					if (ab) {
						ab = ab.absoluteBounds();
						ab.widen(5);
					}
					
					if (bb) {
						bb = bb.absoluteBounds();
//						bb.widen(20); // Wide with 20 because of the arrow from the edge
					}
					
					var dockers = edge.dockers.findAll(function(docker, i){ 
						var c = docker.bounds.center();
								// Dont count first and last
						return 	i != 0 && i != edge.dockers.length-1 && 
								// Check if the point is included to the absolute bounds
								((ab && ab.isIncluded(c)) || (bb && bb.isIncluded(c)));
					});
					// If the first docker is docked to the moved node, return in normal order
					if (ab === this.node) {
						return dockers;
					}
					// If the last docker is docked to the moved node, reverse the order of the dockers to remove
					return dockers._reverse();
				},
				
				/**
				 * Moves the active edge and determines if calling the doLayout is necessary.
				 * IF MOVING THE EDGE BREAKS THE ORDER, REALIGN THE AFFECTED EDGES.
				 * 
				 * @param {Object} data The data object 
				 * @param {Number} dockerCount The count of the dockers of the active edge
				 * @return {Boolean} needLayout
				 */
				moveEdge : function(data, dockerCount){
					var needLayout = false;

					if (dockerCount === 3) {
						var oldSide = this.oldBounds.getSide(data.second.bounds.center());
						var newSide = this.nodeBounds.getSide(data.last.bounds.center());
					} else {
						var oldSide = this.oldBounds.getSide(data.second.bounds.center());
						var newSide = this.nodeBounds.getSide(data.second.bounds.center());
					}
					
					if (dockerCount === 3 && this.containsReference(data.absLastRef, this.nodeBounds, newSide)) {
						data.first.setReferencePoint({
						    x: (["top", "bottom"].include(newSide) ? (data.absLastRef.x - data.nodeUL.x) / (this.offset.xs||1) : data.firstRef.x / (this.offset.xs||1)),
						    y: (["top", "bottom"].include(newSide) ? data.firstRef.y / (this.offset.ys||1) : (data.absLastRef.y - data.nodeUL.y) / (this.offset.ys||1))
						});
					} else if (oldSide === newSide) {
						if (this.containsReference((dockerCount > 3 ? data.secCenter : data.absLastRef), this.nodeBounds, newSide)) {
							data.first.setReferencePoint({
								x: data.firstRef.x / (["top", "bottom"].include(data.side) ? (this.offset.xs||1):1) - (data.orientation != "horizontal" ? this.offset.x : 0),
								y: data.firstRef.y / (["left", "right"].include(data.side) ? (this.offset.ys||1):1) - (data.orientation != "vertical" ? this.offset.y : 0 )
							});
						} else if (dockerCount === 2 && this.containsReference(data.absFirstRef, data.foreignBounds, newSide)) {
							data.last.setReferencePoint({
								x: data.lastRef.x / (["top", "bottom"].include(data.side) ? (this.offset.xs||1):1) + (data.orientation != "horizontal" ? this.offset.x : 0),
								y: data.lastRef.y / (["left", "right"].include(data.side) ? (this.offset.ys||1):1) + (data.orientation != "vertical" ? this.offset.y : 0)
							});
						} else {
							needLayout = true;
						}
					} else {
						this.layoutOldStyle(data.edge, data);
					}
					return needLayout;
				},
				
				/**
				 * Moves the active edge into the overlapping area.
				 * @param {Object} data The data Object
				 * @param {Number} dockerCount
				 * @param {Boolean} force
				 */
				moveToOverlap : function(data, dockerCount, force, realignAll, wasAligned) {
					if (data.edge.dockers[0].getDockedShape() === this.node) {
		    	    	data.second = data.edge.dockers[1];
		    	    } else {
		    	    	data.second = data.edge.dockers[data.edge.dockers.length - 2];
		    	    }
					var oldSide = this.oldBounds.getSide(data.second.bounds.center());
					var newSide = this.nodeBounds.getSide(data.second.bounds.center());
					
					if (!realignAll) {
						oldSide = this.nodeBounds.getSide(data.second.bounds.center());
					}
					
					// Get all relevant edges
					var relevantEdges = this.getRelevantEdges(
											this.node,
											this.nodeBounds,
											oldSide,
											data.edge,
											true
									);
					// Sort the relevant edges with the old order
					if (this.oldOrder[data.edge.id])
						relevantEdges = relevantEdges.sortBy(function(edge){ return this.oldOrder[data.edge.id].indexOf(edge); }.bind(this));
					
					var index = relevantEdges.indexOf(data.edge);
					
					var xOverlap = this.xOverlap(data);
					var yOverlap = this.yOverlap(data);
					
					// If an overlap exists but it is on the wrong side of the dragged node:
					var wrongOverlap = this.nodeBounds.getSide(data.foreignBounds.center()) !== oldSide;
					
					// If not all edges are inside the shape's bounds, do an equal distribution
					if (this.positionChanged || (["top", "bottom"].include(oldSide) ? xOverlap > 12 : yOverlap > 12) &&
						(this.removedDockers.length > 0 || dockerCount <= 3)) {
						
						// Reposition the first docker
						data.first.setReferencePoint({
							x : xOverlap > 0 && (force || data.orientation != "horizontal") ?
								(data.overlap.upperLeft().x - data.nodeUL.x) + (index + 1) / (relevantEdges.length + 1) * data.overlap.width() :
								data.firstRef.x,
							y : yOverlap > 0 && (force || data.orientation != "vertical") ?
								(data.overlap.upperLeft().y - data.nodeUL.y) + (index + 1) / (relevantEdges.length + 1) * data.overlap.height() :
								data.firstRef.y
						});
						// Get the absolute reference point of the just positioned docker
						var absRef = data.first.getAbsoluteReferencePoint();
						// Reposition the second docker according to the absolute bounds of the first reference point
						if (data.second.isDocked()) {
							// If it's docked, move the reference point
							data.second.setReferencePoint({
								x : xOverlap > 0 && (force || data.orientation != "horizontal") ?
									absRef.x - data.foreignUL.x :
									data.lastRef.x,
								y : yOverlap > 0 && (force || data.orientation != "vertical") ?
									absRef.y - data.foreignUL.y :
									data.lastRef.y
							});
						} else {
							// If it's not docked, move the docker itself
							data.second.bounds.centerMoveTo({
								x : (["left","right"].include(oldSide) ? data.second.bounds.center().x : data.first.getAbsoluteReferencePoint().x),
							    y : (["left","right"].include(oldSide) ? data.first.getAbsoluteReferencePoint().y : data.second.bounds.center().y)
							});
						}
					} else if (!this.isAligned((data.edge.dockers[0].getDockedShape() === this.node ? data.edge.dockers[0] : data.edge.dockers[data.edge.dockers.length - 1]),
											   (data.edge.dockers[0].getDockedShape() === this.node ? data.edge.dockers[1] : data.edge.dockers[data.edge.dockers.length - 2])) &&
							   (this.removedDockers.length > 0)) {
									if (data.second.isDocked()) {
										data.second.setReferencePoint({
											x : (["top","bottom"].include(data.foreignBounds.getSide(data.second.bounds.center())) ? data.first.getAbsoluteReferencePoint().x - data.foreignUL.x : data.lastRef.x),
											y : (["left","right"].include(data.foreignBounds.getSide(data.second.bounds.center())) ? data.first.getAbsoluteReferencePoint().y - data.foreignUL.y : data.lastRef.y)
										});
									} else if (wasAligned || this.removedDockers.length > 0) {
										data.second.bounds.centerMoveTo({
											x : (["left","right"].include(oldSide) ? data.secCenter.x : data.first.getAbsoluteReferencePoint().x),
										    y : (["left","right"].include(oldSide) ? data.first.getAbsoluteReferencePoint().y : data.secCenter.y)
										});	
									}
					}
					
					if (this.isBendPointIncluded(data.edge) && data.edge.dockers.length > 2) {
						// Remove included bendpoints before calling self!
						this.removedDockers = this.removedDockers.concat(this.removeAllDocker(data.edge));
						if (wasAligned && !this.isAligned(data.first, data.second)) {
							this.plugin.doLayout(data.edge);
							return;
						}
					}
				},
				/**
				 * Removes all dockers except the start and the end docker of an edge
				 * @param {ORYX.Core.Edge} edge
				 */
				removeAllDocker: function(edge){
					var removedDockers = [];
					edge.dockers.slice(1, edge.dockers.length-1).each(function(docker){
						removedDockers.push(docker);
						edge.removeDocker(docker);
					});
					if (edge.dockers[0].getDockedShape() === this.node) {
						return removedDockers;
					}
					return removedDockers._reverse();
				},
				
				/**
				 * Redistributes edges on a side if it's necessary and no overlapping area exists
				 * @param {String} side The side to maintain 
				 */
				redistributeEdges : function(side, threshold) {
					// Get all relevant edges to realign.
					var relevantEdges = [];
					var sideContainsSequenceFlow = false;
					var noOrder = true;
					// Find all edges docked to the shape on the given side
					var dockers = [];
					var edgesFromSide = this.edges.findAll(function(edge) {
						var first = (edge.dockers[0].getDockedShape() === this.node ?
								edge.dockers[0]:
								edge.dockers[edge.dockers.length - 1]
						);
						dockers.push(first);
						// True if docked to the given side
						return this.node.absoluteBounds().getSide(first.bounds.center()) === side;
					}.bind(this));

					edgesFromSide.each(function(edge, edgeIndex) {
						//Get the data object.
						var data = this.getDataObject(edge, edgeIndex);
						if (!data){ return; }
						//Get the relevant edges
						var altOrder = [];
						if (noOrder) {
							altOrder = this.getRelevantEdges(
									this.node,
									this.nodeBounds,
									data.newSide,
									data.edge
							);	
						}

						// The index of the active edge
						var index = (noOrder ? altOrder.indexOf(data.edge) : edgeIndex);
						
						// If the docked segment is aligned, keep it aligned
						var alignSegment = this.isAligned(data.first, data.second);
						
						// If an overlap exists but it is on the wrong side of the dragged node:
						var wrongOverlap = this.nodeBounds.getSide(data.foreignBounds.center()) !== side;
						
						//Set the first reference Point
						data.first.setReferencePoint({
							x : ["top", "bottom"].include(data.newSide) ?
								(data.overlap && !wrongOverlap ? data.overlap.upperLeft().x - this.nodeBounds.upperLeft().x : 0) +
									(index + 1) / (edgesFromSide.length + 1) *
									(data.overlap && !wrongOverlap ? data.overlap.width() : this.nodeBounds.width()) :
								data.firstRef.x,
							y : ["left", "right"].include(data.newSide) ?
								(data.overlap && !wrongOverlap ? data.overlap.upperLeft().y - this.nodeBounds.upperLeft().y : 0) + 
									(index + 1) / (edgesFromSide.length + 1) *
									(data.overlap && !wrongOverlap ? data.overlap.height() : this.nodeBounds.height()) :
								data.firstRef.y
						});
						var absRef = data.first.getAbsoluteReferencePoint();					
						// Set the second docker; if the docked segment was aligned, align it again
						if (alignSegment) {
							if (data.second.isDocked()) {
								// Set the reference Point if docked
								data.second.setReferencePoint({
									x : ["top", "bottom"].include(data.newSide) ?
										absRef.x - data.foreignUL.x :
										data.last.referencePoint.x,
									y : ["left", "right"].include(data.newSide) ?
										absRef.y - data.foreignUL.y :
										data.last.referencePoint.y
								});
								if (!this.isAligned(data.first, data.second)) {
									this.plugin.doLayout(edge);
								}
								var foreignSide = data.foreignBounds.getSide(data.second.bounds.center());
								if (!this.containsReference(data.second.getAbsoluteReferencePoint(), data.foreignBounds, foreignSide)){
									this.plugin.doLayout(edge);
								}
							}
							// Else set the docker's bounds
							else {
								data.second.bounds.centerMoveTo({
									x : (["left","right"].include(data.newSide) ? data.second.bounds.center().x : absRef.x),
								    y : (["left","right"].include(data.newSide) ? absRef.y : data.second.bounds.center().y)
								});
							}
						}
					}.bind(this));
				},
				
				/**
				 * 
				 * @param shape
				 * @param oldBounds
				 * @param side
				 * @returns
				 */
				getRelevantEdges : function(shape, bounds, side, optionalEdge, onlySameTarget) {
					var relevantShapes = optionalEdge ? [optionalEdge.getSource(), optionalEdge.getTarget()].compact() : [];
					
					var edges = shape.getAllDockedShapes().findAll(function(edge){
						if(!(edge instanceof ORYX.Core.Edge)) {
							return false;
						}
			    	    if (edge.dockers[0].getDockedShape() === shape) {
			    	    	var second = edge.dockers[1];
			    	    } else {
			    	    	var second = edge.dockers[edge.dockers.length - 2];
			    	    }
	
			    	    /**
			    	     * Consider all edges of one side for calculating the equal distribution
			    	     */
			    	    
			    	    // Find only those edges which share the same source/target
			    	    if (onlySameTarget && !(relevantShapes.include(edge.getSource()) && relevantShapes.include(edge.getTarget()))){
			    	    	return false;
			    	    }
			    	    
						return bounds.getSide(second.bounds.center()) === side;// && edge.getStencil().keepState() == true
					}.bind(this));
					
					if (optionalEdge instanceof ORYX.Core.Edge && !edges.include(optionalEdge)) {
						edges.push(optionalEdge);
					}
					return edges
					// Sort ASC by their to this.node docked docker positions
					.sort(function(a,b) {
						if (a.dockers[0].getDockedShape() === shape) {
							var aa = a.dockers[0];
							var ab = a.dockers[1];
						} else {
							var aa = a.dockers[a.dockers.length - 1];
							var ab = a.dockers[a.dockers.length - 2];
						}
						if (b.dockers[0].getDockedShape() === shape) {
							var ba = b.dockers[0];
							var bb = b.dockers[1];
						} else {
							var ba = b.dockers[b.dockers.length - 1];
							var bb = b.dockers[b.dockers.length - 2];
						}
						aa = aa.bounds.center();
						ab = ab.bounds.center();
						ba = ba.bounds.center();
						bb = bb.bounds.center();
						
						return side === "top" || side === "bottom" ?
								Math.round(aa.x - ba.x) < 0 ?
										-1 : (Math.round(aa.x - ba.x) > 0? 1 : 0):
								Math.round(aa.y - ba.y) < 0 ?
										-1 : (Math.round(aa.y - ba.y) > 0 ? 1 : 0);
					});
				},
				
				/**
				 * Returns True if all edges of one side are inside the bounds
				 * @param {ORYX.Core.Shape} shape
				 * @param {ORYX.Core.Edge[]} edges
				 * @param {String} side
				 * @returns boolean
				 */
				allEdgesInside : function(shape, bounds, edges, side) {
					return edges.all(function(edge){
						// Get the second docker
						var second = (edge.dockers[0].getDockedShape() === shape ? 
								edge.dockers[1]:
								edge.dockers[edge.dockers.length - 2]
						);
						var secPos = (second.isDocked() ? second.getAbsoluteReferencePoint() : second.bounds.center()); 
						// the threshold
						var t = 20;
						// Check if the edge is inside the bounds - the threshold.
						if (bounds.getSide(secPos) === side) {
							return (side === "top" || side === "bottom" ? 
									secPos.x > bounds.upperLeft().x+t && secPos.x < bounds.lowerRight().x-t:
									secPos.y > bounds.upperLeft().y+t && secPos.y < bounds.lowerRight().y-t);
						}
					});
				},
				
				/**
				 * Do the old layouting
				 * @param {ORYX.Core.Edge} edge
				 */
				layoutOldStyle : function(edge, data) {
					if (edge.dockers.length === 2){
						var p1 = edge.dockers.first().getAbsoluteReferencePoint() || edge.dockers.first().bounds.center();
						var p2 = edge.dockers.last().getAbsoluteReferencePoint() || edge.dockers.first().bounds.center();
						// Find all horizontal/vertical edges
						if (Math.abs(-Math.abs(p1.x - p2.x) + Math.abs(this.offset.x)) < 2 || Math.abs(-Math.abs(p1.y - p2.y) + Math.abs(this.offset.y)) < 2){
							this.plugin.doLayout(edge);
						}
					} else if (edge.dockers.length > 2) {
//						if (!edge.getStencil().keepState()) {
							// If the edge is no messageflow
							if (edge.dockers.first().getDockedShape() === this.node) {
								var second = edge.dockers[1];
								if (this.align(second.bounds, edge.dockers.first())){ second.update(); }
					        } else if (edge.dockers.last().getDockedShape() === this.node) {
					        	var beforeLast = edge.dockers[edge.dockers.length-2];
					        	if (this.align(beforeLast.bounds, edge.dockers.last())){ beforeLast.update(); }                                                                 
					        }
					        edge._update(true);
					        edge.removeUnusedDockers();
					        if (this.isBendPointIncluded(edge, true)){
					        	this.plugin.doLayout(edge);
					        	return;
					        }
					        return data;
//						}
						// If the edge is a messageflow:
//						else {
//							var first, second, side;
//							if (data) {
//								first = data.first;
//								second = data.second;
//								side = data.newSide;
//							} else if(edge.dockers[0].getDockedShape() === this.node) {
//								first = edge.dockers[0];
//								second = edge.dockers[1];
//								side = this.nodeBounds.getSide(first.bounds.center());
//							} else {
//								first = edge.dockers[1];
//								second = edge.dockers[0];
//								side = this.nodeBounds.getSide(first.bounds.center());
//							}
//							// If the docked segment was aligned before the node was moved, align it again
//							if (this.wasAligned(first, second)) {
//								var absRef = first.getAbsoluteReferencePoint();
//								second.bounds.centerMoveTo({
//									x : ["top", "bottom"].include(side) ? absRef.x : second.bounds.center().x,
//									y : ["left", "right"].include(side) ? absRef.y : second.bounds.center().y
//								});
//							}
//							return data;
//						}
					}
				},

				/**
				 * Calculates and returns the data object
				 * @param {ORYX.Core.Edge} edge
				 * @param {Number} edgeIndex
				 * @returns {___anonymous51519_52576} the data object
				 */
				getDataObject : function(edge, edgeIndex) {
					var dockers = edge.dockers;
					var length = dockers.length;
					// The shapes
					var foreignNode;
					// The dockers
					var first, second, last;
					
					if (dockers[0].getDockedShape() === this.node){
						first = dockers[0];
						second = dockers[1];
						last = dockers[length - 1];
						foreignNode = last.getDockedShape();
					} else if (dockers[length - 1].getDockedShape() === this.node) {
						first = dockers[length - 1];
						second = dockers[length - 2];
						last = dockers[0];
						foreignNode = last.getDockedShape();
					}
					// If the edge is only docked on one side, do the old layouting
					if (!first || !foreignNode) {
						this.layoutOldStyle(edge);
						return;
					}
					
					// Get the overlapping area
					var overlap = this.node.getOverlap(foreignNode);
					
					//Shortcuts for the dockers' coordinates
					var firstBounds = first.bounds;
					var firstCenter = firstBounds.center();
					var secBounds = second.bounds;
					var secCenter = secBounds.center();
					var lastBounds = last.bounds;
					var lastCenter = lastBounds.center();
					
					//The reference Points
					var absFirstRef = first.getAbsoluteReferencePoint();
					var firstRef = first.referencePoint;
					var absLastRef = last.getAbsoluteReferencePoint();
					var lastRef = last.referencePoint;
					
					//Shortcuts for the bounds' coordinates
					var nodeUL = this.nodeBounds.upperLeft();
					var nodeLR = this.nodeBounds.lowerRight();
					var foreignBounds = foreignNode.absoluteBounds();
					var foreignUL = foreignBounds.upperLeft();
					var foreignLR = foreignBounds.lowerRight();
					
					var side = this.oldBounds.getSide(second.bounds.center());
					var newSide = this.nodeBounds.getSide(second.bounds.center());
					
					//The orientation of the docked edge segment
					var orientation = 
						foreignBounds.isIncluded({x:absFirstRef.x-this.offset.x, y:absFirstRef.y-this.offset.y}) ||
						this.nodeBounds.isIncluded({x:absLastRef.x+this.offset.x, y:absLastRef.y + this.offset.y}) ? "skew" :
						Math.round(absFirstRef.y - this.offset.y) === (second.isDocked ? Math.round(absLastRef.y) : secCenter.y) ? "horizontal" :
						Math.round(absFirstRef.x - this.offset.x) === (second.isDocked ? Math.round(absLastRef.x) : secCenter.x) ? "vertical" :
						"skew";
					
					//The data package to pass the values in an easier way
					var data = {
						//The dockers
						first			: first,
						second			: second,
						last			: last,
						//The dockers' bounds
						firstBounds		: firstBounds,
						firstCenter		: firstCenter,
						secBounds		: secBounds,
						secCenter		: secCenter,
						lastBounds		: lastBounds,
						lastCenter		: lastCenter,
						//The reference points
						absFirstRef		: absFirstRef,
						firstRef		: firstRef,
						absLastRef		: absLastRef,
						lastRef			: lastRef,
						//The docked shapes
						node			: node,
						foreignNode		: foreignNode,
						overlap			: overlap,
						//The shapes' bounds
						nodeUL		: nodeUL,
						nodeLR		: nodeLR,
						foreignBounds	: foreignBounds,
						foreignUL		: foreignUL,
						foreignLR		: foreignLR,
						//The orientation of the docked edge segment
						orientation		: orientation,
						//The edge and it's index
						edge			: edge,
						edgeIndex		: edgeIndex,
						side			: side,
						newSide			: newSide
					};
					return data;
				},
				
				executeAgain: function(){
					this.changes.each(function(change){
						// Reset the dockers
						this.removeAllDocker(change.edge);
						change.dockerPositions.each(function(pos, i){	
							if (i==0||i==change.dockerPositions.length-1){
								change.edge.dockers[i].setReferencePoint(pos);
								return;
							}					
							var docker = change.edge.createDocker(undefined, pos);
							docker.bounds.centerMoveTo(pos);
							docker.update();
						}.bind(this));
						change.edge._update(true);
					}.bind(this));
				},
				rollback: function(){					
					this.changes.each(function(change){
						// Reset the dockers
						this.removeAllDocker(change.edge);
						change.oldDockerPositions.each(function(pos, i){	
							if (i==0||i==change.oldDockerPositions.length-1){
								change.edge.dockers[i].setReferencePoint(pos);
								return;
							}					
							var docker = change.edge.createDocker(undefined, pos);
							docker.bounds.centerMoveTo(pos);
							docker.update();
						}.bind(this));
						change.edge._update(true);
					}.bind(this));
				}
			});
			this.facade.executeCommands([new Command(allEdges, node, offset, this)]);
	
		}
	});
}();
/**
 * Copyright (c) 2009
 * Willi Tscheschner
 * 
 **/

if(!ORYX){ var ORYX = {} }
if(!ORYX.Plugins){ ORYX.Plugins = {} }

/**
   This abstract plugin implements the core behaviour of layout
   
   @class ORYX.Plugins.AbstractLayouter
   @constructor Creates a new instance
   @author Willi Tscheschner
*/
ORYX.Plugins.AbstractLayouter = ORYX.Plugins.AbstractPlugin.extend({
	
	/**
	 * 'layouted' defined all types of shapes which will be layouted. 
	 * It can be one value or an array of values. The value
	 * can be a Stencil ID (as String) or an class type of either 
	 * a ORYX.Core.Node or ORYX.Core.Edge
     * @type Array|String|Object
     * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	layouted : [],
	
	/**
	 * Constructor
	 * @param {Object} facade
	 * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	construct: function( facade ){
		arguments.callee.$.construct.apply(this, arguments);
			
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAYOUT, this._initLayout.bind(this));
	},
	
	/**
	 * Proofs if this shape should be layouted or not
	 * @param {Object} shape
     * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	isIncludedInLayout: function(shape){
		if (!(this.layouted instanceof Array)){
			this.layouted = [this.layouted].compact();
		}
		
		// If there are no elements
		if (this.layouted.length <= 0) {
			// Return TRUE
			return true;
		}
		
		// Return TRUE if there is any correlation between 
		// the 'layouted' attribute and the shape themselve.
		return this.layouted.any(function(s){
			if (typeof s == "string") {
				return shape.getStencil().id().include(s);
			} else {
				return shape instanceof s;
			}
		})
	},
	
	/**
	 * Callback to start the layouting
	 * @param {Object} event Layout event
	 * @param {Object} shapes Given shapes
     * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	_initLayout: function(event){
		
		// Get the shapes
		var shapes = [event.shapes].flatten().compact();
		
		// Find all shapes which should be layouted
		var toLayout = shapes.findAll(function(shape){
			return this.isIncludedInLayout(shape) 
		}.bind(this))
		
		// If there are shapes left 
		if (toLayout.length > 0){
			// Do layout
			this.layout(toLayout);
		}
	},
	
	/**
	 * Implementation of layouting a set on shapes
	 * @param {Object} shapes Given shapes
     * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	layout: function(shapes){
		throw new Error("Layouter has to implement the layout function.")
	}
});if(!Signavio){ var Signavio = {} };
if (!Signavio.Core) { Signavio.Core = {} };
Signavio.Core.Version = "5.3.0";
		/**
 * Copyright (c) 2009
 * Willi Tscheschner
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 **/

if (!Signavio) {
	var Signavio = new Object();
}

if (!Signavio.Plugins) {
	Signavio.Plugins = new Object();
}

if (!Signavio.Plugins.Utils) {
	Signavio.Plugins.Utils = new Object();
}

if (!Signavio.Helper) {
	Signavio.Helper = new Object();
}


new function(){
	
	var mask;
	
	
	Signavio.Plugins.Utils.getFFVersion = function(){
		try {
			return Number(window.navigator.userAgent.match("Firefox.([0-9]+[\.][0-9]+)")[1]) || 0 ;
		} catch(e){
			return 0;
		}	
	}
	
	
	/**
	 * Shows an overlay of signavio
	 */
	Signavio.Helper.ShowMask = function(force, parent){
		
		if (!force && ORYX.CONFIG.PREVENT_LOADINGMASK_AT_READY === true){
			return;
		}		
		
		if (mask){
			return;
		}
		
		var s 	= "background:white;bottom:0;height:100%;left:0;position:absolute;right:0;top:0;width:100%;z-index:100000;"
		var ss 	= "left:50%;margin-left:-200px;margin-top:-90px;position:absolute;top:50%;display:none;width:391px;"
		var sversion 	= "color:#ad0f5b;padding-right:10px;font-family:tahoma,arial,san-serif;font-size:12px;";
		var stext 		= "display:block;position:relative;text-align:right;top:0;width:100%;";
		var stitle 		= "color:#ad0f5b;font-weight:bold;padding-right:10px;font-family:tahoma,arial,san-serif;font-size:12px;"
		var sloading 	= "height:16px;width:16px;margin-bottom:-4px;background: transparent url(../libs/ext-2.0.2/resources/images/default/tree/loading.gif) no-repeat center;"
		var simg 		= "padding-bottom:10px;border-bottom:1px solid #ad0f5b;";

		// Define the parent
		parent = (parent ? Ext.get(parent) : null) || Ext.getBody();
		
		if (parent !== Ext.getBody()){
			parent.setStyle("position", "relative")
		}

		mask = Ext.get(document.createElement("div"));
		parent.appendChild(mask);
		mask.dom.setAttribute("style", s);
		mask.dom.innerHTML = 	"<div class='mask-logo' style='"+ss+"'>"+
									"<div>"+
										"<img style='"+simg+"' src='"+ORYX.CONFIG.EXPLORER_PATH+"/src/img/signavio/signavio_logo.jpg' />"+
									"</div>"+
									"<span class='mask-text' style='"+stext+"'>"+
										"<span class='mask-title' style='"+stitle+"'>Editor</span>"+
										"<span class='mask-version' style='"+sversion+"'>Version "+Signavio.Core.Version+"</span>"+
										"<img style='"+sloading+"' src='"+(ORYX.CONFIG.BLANK_IMAGE||Ext.BLANK_IMAGE_URL)+"'/>"+
									"</span>" +
								"</div>";

		mask.first().show({duration:0.3});

	}
			
	// When body is loaded, show overlay		
	//shanglihui 20111121
	//alert('1');
	//Ext.onReady(Signavio.Helper.ShowMask);
	
	/**
	 * Hides the overlay
	 */
	Signavio.Helper.HideMask = function(){
		window.setTimeout(function(){
			if (mask){			
				try {
					mask.first().hide({duration:0.4, remove:true,  block:true});
					mask.hide({duration:0.3, remove:true,  block :true});
					delete mask;
				} catch(e){}
			}

		}.bind(this), 2000)
	}
			
	Signavio.Plugins.Loading = {
	
		facade: undefined,
		construct: function(facade) {
			this.facade = facade;
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, Signavio.Helper.HideMask);
			
			/**
			 * Overwrite the toJSON method in the Canvas
			 * to set the correct stencilset namespace.
			 * 
			 */
			var me = this;
			new function(){
				// Copy prototype method
				var toJSON = ORYX.Core.Canvas.prototype.toJSON;
				ORYX.Core.Canvas.prototype.toJSON = function(){
					// Call super
					var json = toJSON.call(this);
					// Check for replace stencil set namespace
					json.stencilset.namespace = me.facade.getModelMetaData().model.stencilset.namespace;
					
					return json;
				}
			}()
		}
	}
	
	Signavio.Plugins.Loading = Clazz.extend(Signavio.Plugins.Loading);

	/**
	 * Provides an uniq id
	 * @overwrite
	 * @return {String}
	 *
	 */
	ORYX.Editor.provideId = function() {
		var res = [], hex = '0123456789ABCDEF';
	
		for (var i = 0; i < 36; i++) res[i] = Math.floor(Math.random()*0x10);
	
		res[14] = 4;
		res[19] = (res[19] & 0x3) | 0x8;
	
		for (var i = 0; i < 36; i++) res[i] = hex[res[i]];
	
		res[8] = res[13] = res[18] = res[23] = '-';
	
		return "sid-" + res.join('');
	};


}();


/**
 * Ext specific extension
 * 
 * 
 * 
 */
new function(){
	
	/**
	 * Implementation of an Ext-LinkButton
	 * 
	 * 
	 */
	Ext.LinkButton = Ext.extend(Ext.BoxComponent, {

		// On Click Handler
	    click: null,
		
		// Image url 
	    image: null,
		
		// Image style (only if an image url is setted) 
	    imageStyle: null,

		toggle:false, 
		
		toggleStyle:null,

		selected:false,
		
		href:false,

		el: null, 
		
	    // private
	    onRender : function(ct, position){
					
	        if( this.el == null ){	

	            this.el = document.createElement('a');

	            if (this.tabIndex)
	            	this.el.setAttribute("tabindex", this.tabIndex)
	            
	            this.el.id = this.getId();
	            this.el.className = this.cls||"x-link-button";
				
				if( !this.disabled )
	            	this.el.href = this.href ? this.href : "#" + this.text;

	            if( !this.disabled ){
	                Element.observe( this.el, 'click', this.onClick.bind(this));
	            }
		
				if( this.image ){
					this.el.innerHTML = '<img src="' + this.image + '" title="' + this.text + '"' + ( this.imageStyle ? ' style="' + this.imageStyle + '"/>': '/>')
				} else {
					this.el.innerHTML = this.text ? Ext.util.Format.htmlEncode(this.text) : (this.html || '');	
				}

	            if(this.forId){
	                this.el.setAttribute('htmlFor', this.forId);
	            }

	        }

	        Ext.LinkButton.superclass.onRender.call(this, ct, position);

	    },
		
		onClick: function(e){
			
			if( this.disabled ){ Event.stop(e); return; }
			
			// Toggle the button
			if( this.toggle ){
				this.selected = !this.selected;
				if( this.toggleStyle ){
					this._setStyle( this.el.dom, '')
					this.el.dom.setAttribute('style','')
					if( this.selected ){
						this.el.applyStyles( this.toggleStyle )
					} else {
						this.el.applyStyles( this.initialConfig.style )
					}
				}
			}

			
			if( this.click instanceof Function )
				this.click.apply(this.click, [this, e]); 
			 
			Event.stop(e)
		},
	    
	    setText: function(t, encode){
	        this.text = t;
	        if(this.rendered){
	            this.el.dom.innerHTML = encode !== false ? Ext.util.Format.htmlEncode(t) : t;
	        }
	        return this;
	    },
		
		_setStyle: function(node, style){
			if( Ext.isIE ){
				node.style.setAttribute('cssText', style );	
			} else {
				node.setAttribute('style', style );	
			}
		}
	});

	Ext.reg('linkbutton', Ext.LinkButton);
	
}();


/**
 * Helper Methods
 * 
 */

new function(){
	
	
	Signavio.Helper.RecordReader = function(meta){
	    meta = meta || {};
	    this.rels = meta.rels || this.rels;
	    Signavio.Helper.RecordReader.superclass.constructor.call(this, meta, ['rep','href','rel']);
	};
	Ext.extend(Signavio.Helper.RecordReader, Ext.data.JsonReader, {

		rels: ["gitem"],
		
		read : function(response){
			var json = response.responseText;
			var o = eval("("+json+")");
			if(!o) {
				throw {message: "JsonReader.read: Json object not found"};
			}
			var Record = this.recordType;
			var records = [], total = 0;
			o.each(function(rec){
				if (this.rels.include(rec.rel)) {
					records.push(new Record(rec));
				} 
				if (rec.rel == "info" && rec.rep.size){
					total = rec.rep.size;
				}
			}.bind(this))
			return {
				success : true,
				records : records,
				totalRecords : total || records.length
			}
		}
	})
	
	
	
	/**
	 * Creates a new record, including 'rel', 'href', and 'rep' attributes
	 * @param {String} rel
	 * @param {String} href
	 * @param {Object} rep
	 */
	Signavio.Helper.createRecord = function(rel, href, rep){
					
		var Rec = Ext.data.Record.create(["rel", "href", "rep"]);

		var record = new Rec({
		    rel	: rel,
		    href: href,
		    rep	: rep
		});
		
		return record;
	};
	
	

	/**
	 * Returns the cookie value of the 
	 * given name. Returns null if no
	 * cookie is defined with the name.
	 * @params {String} name
	 * @return {String}
	 */
	Signavio.Helper.getCookie = function( check_name ) {
		// first we'll split this cookie up into name/value pairs
		// note: document.cookie only returns name=value, not the other components
		var a_all_cookies = document.cookie.split( ';' );
		var a_temp_cookie = '';
		var cookie_name = '';
		var cookie_value = '';
		var b_cookie_found = false; // set boolean t/f default f

		for (var i = 0; i < a_all_cookies.length; i++ ) {
			// now we'll split apart each name=value pair
			a_temp_cookie = a_all_cookies[i].split( '=' );
			
			// and trim left/right whitespace while we're at it
			cookie_name = a_temp_cookie[0].replace(/^\s+|\s+$/g, '');

			// if the extracted name matches passed check_name
			if ( cookie_name == check_name ) {
				b_cookie_found = true;
				// we need to handle case where cookie has no value but exists (no = sign, that is):
				if ( a_temp_cookie.length > 1 ) {
					cookie_value = unescape( a_temp_cookie[1].replace(/^\s+|\s+$/g, '') );
				}
				// note that in cases where cookie is initialized but no value, null is returned
				return cookie_value;
				break;
			}
			a_temp_cookie = null;
			cookie_name = '';
		}
		if ( !b_cookie_found ) {
			return null;
		}
	};
	
	
	
	/**
	 * COPIED FROM THE HELPER.JS
	 * Sorting function to sort folders and models in the correct way
	 * @param {Object} a
	 * @param {Object} b
	 * @return {int} Returns 
	 */
	Signavio.Helper.BusinessObjectSortingFunction = function(a, b) { 
	
		if (!a||!b){
			return 0;
		}
		
		/**
		 * Comparator between two strings
		 * It goes throught the string and creates groups of digits and groups of other strings.
		 * It than goes to this groups and compares the first discrepancy. For groups of digits
		 * a parseInt function get called previously.
		 * @param {string} a
		 * @param {string} b
		 * @return {number} -1,0,1
		 */
		var comparator = function(a, b){
			// Get groups of digits and none digits
			var as = a.match(/([0-9]+|[^0-9]+)/g),
				bs = b.match(/([0-9]+|[^0-9]+)/g), ca, cb;
			
			// Compare each group with each other
			while((ca = as.shift()) && (cb = bs.shift())){
				// Parse int if the group only contains digits
				if (ca.match(/^([0-9]+)$/)) ca = parseInt(ca);
				if (cb.match(/^([0-9]+)$/)) cb = parseInt(cb);
				
				// If the values are diffent
				if (ca !== cb){
					
					// If the type of the values are different...
					if (typeof ca !== typeof cb){ 
						// ...sort numbers higher than strings
						return "number" == typeof ca ? -1 : 1;
					} else {
						// ...otherway, compare each values with each other 
						return (ca < cb ? -1 : (ca > cb ? 1 : 0));
					}
				}
			}
			
			// If one group has less different values than the other, sort them higher.
			return "undefined" == typeof ca && "undefined" == typeof cb ?
						  0 
						:("undefined" == typeof ca ?
							  -1 
							:("undefined" == typeof cb ? 
									  1 
									: 0));
		};
	
		try {
			// Get the type
			var relA = a.rel.toLowerCase();
			var relB = b.rel.toLowerCase();
			
			// If there are the same type
			if (relA == relB) {

				if (relA == "dir" && a.rep.type == "public"){ return -1; }
				if (relB == "dir" && b.rep.type == "public"){ return 1;  }
				
				var tA = (a.rep.name||a.rep.title||a.rep.username||-a.rep.rev||"");
				var tB = (b.rep.name||b.rep.title||b.rep.username||-b.rep.rev||"");

				tA = "string" == typeof tA ? tA.toLowerCase().gsub("?", "a").gsub("?", "o").gsub("ü", "u").replace(/([ ][ ]*)/g, " ").trim() : tA;
				tB = "string" == typeof tB ? tB.toLowerCase().gsub("?", "a").gsub("?", "o").gsub("ü", "u").replace(/([ ][ ]*)/g, " ").trim() : tB;
								
				// Return the sorting of the name values
				if ("string" == typeof tA && "string" == typeof tB){
					return comparator(tA, tB);
				} else {
					return (tA < tB ? -1 : (tA > tB ? 1 : 0));
				}
				
			// Otherwise return the sorting of the type
			} else {
				return (relA < relB ? -1 : (relA > relB ? 1 : 0));
			}
		
		// ON Exception, do nothing
		} catch(e){
			return 0;
		}
	};
	
}();

/**
 * Copyright (c) 2009
 * Signavio GmbH
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 * @author Willi Tscheschner
 * 
 * 
 **/

if (!Signavio) { var Signavio = new Object(); }
if (!Signavio.Plugins) { Signavio.Plugins = new Object(); }


new function(){ 
	
	var GlossarySupportedStencils = {
			"http://b3mn.org/stencilset/bpmn1.1#": {
				"Task" : ["oryx-name"],"CollapsedSubprocess" : ["oryx-name"],"Subprocess" : ["oryx-name"],
				"Pool" : ["oryx-name"],"CollapsedPool" : ["oryx-name"],"Lane" : ["oryx-name"],
				"DataObject" : ["oryx-name"],"StartEvent" : ["oryx-name"],"StartMessageEvent" : ["oryx-name"],
				"StartTimerEvent" : ["oryx-name"],"StartConditionalEvent" : ["oryx-name"],"StartSignalEvent" : ["oryx-name"],
				"StartMultipleEvent" : ["oryx-name"],"IntermediateEvent" : ["oryx-name"],"IntermediateMessageEventCatching" : ["oryx-name"],
				"IntermediateMessageEventThrowing" : ["oryx-name"],"IntermediateTimerEvent" : ["oryx-name"],"IntermediateErrorEvent" : ["oryx-name"],
				"IntermediateCancelEvent" : ["oryx-name"],"IntermediateCompensationEventCatching" : ["oryx-name"],"IntermediateCompensationEventThrowing" : ["oryx-name"],
				"IntermediateConditionalEvent" : ["oryx-name"],"IntermediateSignalEventCatching" : ["oryx-name"],"IntermediateSignalEventThrowing" : ["oryx-name"],
				"IntermediateMultipleEventCatching" : ["oryx-name"],"IntermediateMultipleEventThrowing" : ["oryx-name"],"IntermediateLinkEventCatching" : ["oryx-name"],
				"IntermediateLinkEventThrowing" : ["oryx-name"],"EndEvent" : ["oryx-name"],"EndMessageEvent" : ["oryx-name"],
				"EndErrorEvent" : ["oryx-name"],"EndCancelEvent" : ["oryx-name"],"EndCompensationEvent" : ["oryx-name"],
				"EndSignalEvent" : ["oryx-name"],"EndMultipleEvent" : ["oryx-name"],"EndTerminateEvent" : ["oryx-name"],
				"SequenceFlow" : ["oryx-conditionexpression"],"MessageFlow" : ["oryx-name"],
				"Exclusive_Databased_Gateway" : ["oryx-name"],"Exclusive_Eventbased_Gateway" : ["oryx-name"],
				"AND_Gateway" : ["oryx-name"],"OR_Gateway" : ["oryx-name"],
				"Complex_Gateway" : ["oryx-name"]
			},
			"http://b3mn.org/stencilset/jbpm4#": {
				"Task" : ["oryx-name"],	"Pool" : ["oryx-name"],"Lane" : ["oryx-name"],
				"StartEvent" : ["oryx-name"],"EndEvent" : ["oryx-name"],"SequenceFlow" : ["oryx-conditionexpression"],
				"Exclusive_Databased_Gateway" : ["oryx-name"],"AND_Gateway" : ["oryx-name"]
			},
			"http://b3mn.org/stencilset/timjpdl3#": {
				"Task" : ["oryx-name"],	"Pool" : ["oryx-name"],"Lane" : ["oryx-name"],
				"StartEvent" : ["oryx-name"],"EndEvent" : ["oryx-name"],"SequenceFlow" : ["oryx-conditionexpression"],
				"Exclusive_Databased_Gateway" : ["oryx-name"],"AND_Gateway" : ["oryx-name"]
			},

			"http://b3mn.org/stencilset/bpmn2.0#": {
				"Task" : ["oryx-name"],
				"CollapsedSubprocess" : ["oryx-name"],
				"Subprocess" : ["oryx-name"],
				"CollapsedEventSubprocess" : ["oryx-name"],
				"EventSubprocess" : ["oryx-name"],
				"Exclusive_Databased_Gateway" : ["oryx-name"],
				"EventbasedGateway" : ["oryx-name"],
				"ParallelGateway" : ["oryx-name"],
				"InclusiveGateway" : ["oryx-name"],
				"ComplexGateway" : ["oryx-name"],
				"Pool" : ["oryx-name"],
				"CollapsedPool" : ["oryx-name"],
				"VerticalPool" : ["oryx-name"],
				"CollapsedVerticalPool" : ["oryx-name"],
				"processparticipant" : ["oryx-name"],
				"Lane" : ["oryx-name"],
				"VerticalLane" : ["oryx-name"],
				"DataObject" : ["oryx-name"],
				"DataStore" : ["oryx-name"],
				"Message" : ["oryx-name"],
				"StartNoneEvent" : ["oryx-name"],
				"StartMessageEvent" : ["oryx-name"],
				"StartTimerEvent" : ["oryx-name"],
				"StartEscalationEvent" : ["oryx-name"],
				"StartConditionalEvent" : ["oryx-name"],
				"StartErrorEvent" : ["oryx-name"],
				"StartCompensationEvent" : ["oryx-name"],
				"StartSignalEvent" : ["oryx-name"],
				"StartMultipleEvent" : ["oryx-name"],
				"StartParallelMultipleEvent" : ["oryx-name"],
				"IntermediateEvent" : ["oryx-name"],
				"IntermediateMessageEventCatching" : ["oryx-name"],
				"IntermediateTimerEvent" : ["oryx-name"],
				"IntermediateEscalationEvent" : ["oryx-name"],
				"IntermediateConditionalEvent" : ["oryx-name"],
				"IntermediateLinkEventCatching" : ["oryx-name"],
				"IntermediateErrorEvent" : ["oryx-name"],
				"IntermediateCancelEvent" : ["oryx-name"],
				"IntermediateCompensationEventCatching" : ["oryx-name"],
				"IntermediateSignalEventCatching" : ["oryx-name"],
				"IntermediateMultipleEventCatching" : ["oryx-name"],
				"IntermediateParallelMultipleEventCatching" : ["oryx-name"],
				"IntermediateMessageEventThrowing" : ["oryx-name"],
				"IntermediateEscalationEventThrowing" : ["oryx-name"],
				"IntermediateLinkEventThrowing" : ["oryx-name"],
				"IntermediateCompensationEventThrowing" : ["oryx-name"],
				"IntermediateSignalEventThrowing" : ["oryx-name"],
				"IntermediateMultipleEventThrowing" : ["oryx-name"],
				"EndNoneEvent" : ["oryx-name"],
				"EndMessageEvent" : ["oryx-name"],
				"EndEscalationEvent" : ["oryx-name"],
				"EndErrorEvent" : ["oryx-name"],
				"EndCancelEvent" : ["oryx-name"],
				"EndCompensationEvent" : ["oryx-name"],
				"EndSignalEvent" : ["oryx-name"],
				"EndMultipleEvent" : ["oryx-name"],
				"EndTerminateEvent" : ["oryx-name"],
				"SequenceFlow" : ["oryx-conditionexpression"],
				"MessageFlow" : ["oryx-name"],
				"ChoreographyTask" : ["oryx-name"],
				"ChoreographySubprocessCollapsed" : ["oryx-name"],
				"ChoreographySubprocessExpanded" : ["oryx-name"],
				"ChoreographyParticipant" : ["oryx-name"],
				"ITSystem" : ["oryx-name"],
				"processparticipant" : ["oryx-name"]
			},
			"http://b3mn.org/stencilset/bpmn2.0choreography#": {
				"Task" : ["oryx-name"],
				"CollapsedSubprocess" : ["oryx-name"],
				"Subprocess" : ["oryx-name"],
				"CollapsedEventSubprocess" : ["oryx-name"],
				"EventSubprocess" : ["oryx-name"],
				"Exclusive_Databased_Gateway" : ["oryx-name"],
				"EventbasedGateway" : ["oryx-name"],
				"ParallelGateway" : ["oryx-name"],
				"InclusiveGateway" : ["oryx-name"],
				"ComplexGateway" : ["oryx-name"],
				"Pool" : ["oryx-name"],
				"CollapsedPool" : ["oryx-name"],
				"processparticipant" : ["oryx-name"],
				"Lane" : ["oryx-name"],
				"DataObject" : ["oryx-name"],
				"DataStore" : ["oryx-name"],
				"Message" : ["oryx-name"],
				"StartNoneEvent" : ["oryx-name"],
				"StartMessageEvent" : ["oryx-name"],
				"StartTimerEvent" : ["oryx-name"],
				"StartEscalationEvent" : ["oryx-name"],
				"StartConditionalEvent" : ["oryx-name"],
				"StartErrorEvent" : ["oryx-name"],
				"StartCompensationEvent" : ["oryx-name"],
				"StartSignalEvent" : ["oryx-name"],
				"StartMultipleEvent" : ["oryx-name"],
				"StartParallelMultipleEvent" : ["oryx-name"],
				"IntermediateEvent" : ["oryx-name"],
				"IntermediateMessageEventCatching" : ["oryx-name"],
				"IntermediateTimerEvent" : ["oryx-name"],
				"IntermediateEscalationEvent" : ["oryx-name"],
				"IntermediateConditionalEvent" : ["oryx-name"],
				"IntermediateLinkEventCatching" : ["oryx-name"],
				"IntermediateErrorEvent" : ["oryx-name"],
				"IntermediateCancelEvent" : ["oryx-name"],
				"IntermediateCompensationEventCatching" : ["oryx-name"],
				"IntermediateSignalEventCatching" : ["oryx-name"],
				"IntermediateMultipleEventCatching" : ["oryx-name"],
				"IntermediateParallelMultipleEventCatching" : ["oryx-name"],
				"IntermediateMessageEventThrowing" : ["oryx-name"],
				"IntermediateEscalationEventThrowing" : ["oryx-name"],
				"IntermediateLinkEventThrowing" : ["oryx-name"],
				"IntermediateCompensationEventThrowing" : ["oryx-name"],
				"IntermediateSignalEventThrowing" : ["oryx-name"],
				"IntermediateMultipleEventThrowing" : ["oryx-name"],
				"EndNoneEvent" : ["oryx-name"],
				"EndMessageEvent" : ["oryx-name"],
				"EndEscalationEvent" : ["oryx-name"],
				"EndErrorEvent" : ["oryx-name"],
				"EndCancelEvent" : ["oryx-name"],
				"EndCompensationEvent" : ["oryx-name"],
				"EndSignalEvent" : ["oryx-name"],
				"EndMultipleEvent" : ["oryx-name"],
				"EndTerminateEvent" : ["oryx-name"],
				"SequenceFlow" : ["oryx-conditionexpression"],
				"MessageFlow" : ["oryx-name"],
				"ChoreographyTask" : ["oryx-name"],
				"ChoreographySubprocessCollapsed" : ["oryx-name"],
				"ChoreographySubprocessExpanded" : ["oryx-name"],
				"ChoreographyParticipant" : ["oryx-name"],
				"ITSystem" : ["oryx-name"],
				"processparticipant" : ["oryx-name"]
			},
			"http://b3mn.org/stencilset/bpmn2.0conversation#": {
				"Communication" : ["oryx-name"],
				"SubConversation" : ["oryx-name"],
				"Participant" : ["oryx-name"]
			},
			"http://www.signavio.com/stencilsets/organigram#": {
				"Manager" : ["oryx-title"],
				"freejob" : ["oryx-title"],
				"position" : ["oryx-title"],
				"HierarchicOrgUnit" : ["oryx-title"]
			},
			"http://b3mn.org/stencilset/epc#": {
				"Event" : ["oryx-title"],
				"Function" : ["oryx-title"],
				"ProcessInterface" : ["oryx-title"],
				"Organization" : ["oryx-title"],
				"Position" : ["oryx-title"],
				"Data" : ["oryx-title"],
				"System" : ["oryx-title"],
				"Entity" : ["oryx-title"],
				"Form" : ["oryx-title"],
				"Resource" : ["oryx-title"],
				"Letter" : ["oryx-title"],
				"Mail" : ["oryx-title"],
				"Phone" : ["oryx-title"],
				"Fax" : ["oryx-title"]
			}
	}
	
	var GlossarySupportedStencilsDefaults = {
			"all": {"category" : "ACTIVITY"},
			"http://b3mn.org/stencilset/bpmn1.1#Pool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn1.1#CollapsedPool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn1.1#Lane": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn1.1#DataObject": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/jbpm4#Pool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/jbpm4#Lane": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/timjpdl3#Pool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/timjpdl3#Lane": {"category" : "ORG_UNIT"},
			"http://www.signavio.com/stencilsets/organigram#Manager": {"category" : "ORG_UNIT"},
			"http://www.signavio.com/stencilsets/organigram#freejob": {"category" : "ORG_UNIT"},
			"http://www.signavio.com/stencilsets/organigram#position": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0#Pool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0#CollapsedPool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0#Lane": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0#VerticalPool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0#CollapsedVerticalPool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0#VerticalLane": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0#DataObject": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/bpmn2.0#DataStore": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/bpmn2.0#Message": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/bpmn2.0#ChoreographyParticipant": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0#ITSystem": {"category" : "IT_SYSTEM"},
			"http://b3mn.org/stencilset/bpmn2.0#processparticipant": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0choreography#Pool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0choreography#CollapsedPool": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0choreography#Lane": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0choreography#CollapsedSubprocess": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0choreography#DataObject": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/bpmn2.0choreography#DataStore": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/bpmn2.0choreography#Message": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyParticipant": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/bpmn2.0conversation#Participant": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/epc#Event": {"category" : "STATE"},
			"http://b3mn.org/stencilset/epc#Organization": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/epc#Position": {"category" : "ORG_UNIT"},
			"http://b3mn.org/stencilset/epc#System": {"category" : "IT_SYSTEM"},
			"http://b3mn.org/stencilset/epc#Data": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/epc#Entity": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/epc#Form": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/epc#Resource": {"category" : "IT_SYSTEM"},
			"http://b3mn.org/stencilset/epc#Letter": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/epc#Mail": {"category" : "DOCUMENT"},
			"http://b3mn.org/stencilset/epc#Phone": {"category" : "IT_SYSTEM"},
			"http://b3mn.org/stencilset/epc#Fax": {"category" : "DOCUMENT"}
	}
	
	/**
	 * Class for one glossary entry
	 * 
	 * @class GlossaryObject
	 * @param {Object} shape
	 * @param {Object} property
	 * @param {Object} glossaryId
	 * @param {Object} text
	 * @param {Object} isDirty
	 */
	var GlossaryObject = Clazz.extend({
		construct: function(shape, property, glossaryId, text, isDirty){
			this.shape = shape;
			this.property = property;
			this.glossary = glossaryId;
			this.text = text;
			this.isDirty = isDirty||false;
		},
		toString : function(){
			return ORYX.Utils.getInGlossarySchema(this.glossary, this.text);
		}
	})
	
	var GlossaryStore = function(facade){
		this.glossary = $H({});
		this.facade = facade;
	}
	
	GlossaryStore.prototype.generateKey = function(shape, property){
		
		if (typeof property == "string")
			return shape.resourceId + "-" + property;
		
		return shape.resourceId + "-" + property.prefix() + "-" + property.id();
	}
	
	GlossaryStore.prototype.set = function(shape, property, glossary, text, isDirty) {
		
		if(!property) {
			return;
		}
		
		var key = this.generateKey(shape, property);
		
		// IF no glossary and text
		if (!glossary && !text) {
			// Remove entry
			delete this.glossary[key];
			shape.setHiddenProperty(property.prefix()+"-"+property.id()+ORYX.CONFIG.GLOSSARY_PROPERTY_DIRTY_SUFFIX);
		} else {
			// Define the value
			var value = new GlossaryObject(shape, property, glossary, text, isDirty);
			
			// IF it has already one with the same gId, removes it
			var same = this.get(shape, property, glossary);
			if (same){
				if (this.glossary[key] instanceof Array){
					this.glossary[key] = this.glossary[key].without(same);
				} else  {
					delete this.glossary[key];
				}
			}
			
			// Check if its already there
			if (this.glossary[key]&&property.isList()) {
				// if so, adds it
				if (!(this.glossary[key] instanceof Array)){
					this.glossary[key] = [this.glossary[key]];
				}
				this.glossary[key].push(value);
			// Otherwise, sets the value
			} else {
				this.glossary[key] = value;
			}	
			
			
			shape.setHiddenProperty(property.prefix()+"-"+property.id()+ORYX.CONFIG.GLOSSARY_PROPERTY_DIRTY_SUFFIX, isDirty||false);
			
			if (shape instanceof ORYX.Core.Shape) {
				var label = shape.getLabels().find(function(label){ return property.refToView().any(function(toView){ return label.id.endsWith(toView) }); })
				if (label) {
					//add maximum text width to svg xml document as an attribute of the text tag
	           		var textWidth = label.getReferencedElementWidth();
	           		if(textWidth) {
	           			label.node.setAttribute("oryx:textWidth", textWidth);
	           		}	
				}
			}
			
		}
	}

	GlossaryStore.prototype.get = function(shape, property, glossaryId) {
		if (!shape&&!property) {
			return this.glossary.values().flatten();
		}
		
		// If no property is set, find one
		if (!property) {
			property = shape.getStencil().properties().find(function(prop){
				return this.has(shape, prop)
			}.bind(this))
		}
		
		var key = this.generateKey(shape, property);
		if (glossaryId) {
			// If ARRAY
			return this.glossary[key] instanceof Array ? 
						// TRY to find it
						this.glossary[key].find(function(prop){
							return prop.glossary === glossaryId;
						}) : 
						// IF NO ARRAY, CHECK if its it with the same id
						(this.glossary[key] && this.glossary[key].glossary === glossaryId ? 
							this.glossary[key] : 
							null);
		} else {
			return this.glossary[key];	
		}
	}
	
	GlossaryStore.prototype.has = function(shape, property, glossaryId) {
		if (property) {
			return !!this.get(shape, property, glossaryId);		
		} else {
			return shape.getStencil().properties().any(function(prop){
				return this.has(shape, prop, glossaryId)
			}.bind(this))
		}
	}
	
	
	
	/**
	 * Implements the special behavior for glossary
	 * @class 
	 * 
	 */
	Signavio.Plugins.GlossarySupport = ORYX.Plugins.AbstractPlugin.extend({
	
		facade: undefined,
	
		ICON_ADD : ORYX.CONFIG.EXPLORER_PATH+"/src/img/famfamfam/"+(Ext.isIPad?"24x24/":"")+"book_add.png",
		ICON_WARNING : ORYX.CONFIG.EXPLORER_PATH+"/src/img/famfamfam/"+(Ext.isIPad?"24x24/":"")+"book_error.png",
		ICON : ORYX.CONFIG.EXPLORER_PATH+"/src/img/famfamfam/"+(Ext.isIPad?"24x24/":"")+"book.png",
	
		/**
		 * Offers the plugin functionality:
		 * 
		 */
		construct: function(facade) {
	
			this.facade = facade;
			this.overlays = $H({});
			
			this.modifyFacade();

			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.propertyChanged.bind(this) );
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this.onSelectionChange.bind(this) );
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_GLOSSARY_SHOW, this.handleOpenInfo.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_GLOSSARY_NEW, this.handleOpenNew.bind(this));
			
			this.categories = new Ext.data.Store({
	            proxy: new Ext.data.HttpProxy({
	            	useAjax	: true,
	            	method	: "GET", 
	            	headers	: {accept:"application/json"},
	                url		: '/p/glossary?originId=' + this.facade.getModelMetaData().parent 
	            }),
	            reader: new Signavio.Helper.RecordReader({rels:["cat", "priv"]})
	        });
			this.categories.load();
			
			this.glossaryOffer = {
					target 			: ORYX.Plugins.ShapeMenuPlugin,
					functionality	: function(){
						var shape = this.facade.getSelection().first();
						if (shape){
							this.showNewWindow(shape, this.getFirstSupportedProperty(shape));	
						}
					}.bind(this),
		            icon			: this.ICON_ADD,
		            description		: Signavio.I18N.Glossary_Support.tooltipCreate,
		            align			: ORYX.CONFIG.SHAPEMENU_BOTTOM,
		            minShape		: 1,
		            maxShape		: 1,
					offset			: {x: -30}
				};
			
			this.facade.offer(this.glossaryOffer);
			
			
			/**
			 * Overwrite the toJSON method in the AbstractShape
			 * to support the glossary schema when serializing
			 * 
			 */
			var me = this;
			new function(){
				// Copy prototype method
				var toJSON = ORYX.Core.AbstractShape.prototype.toJSON;
				ORYX.Core.AbstractShape.prototype.toJSON = function(){
					// Call super
					var json = toJSON.call(this);
					// Check for glossary entry
					if (me.facade.hasGlossaryExtension && me.facade.hasGlossary(this)) {
						// If so, replace all changed glossary items
						this.getStencil().properties().each(function(prop){
							var gl = me.facade.getGlossary(this, prop);
							if (gl&&json.properties[prop.id()]) {
								if (gl instanceof Array){
									json.properties[prop.id()] = gl.map(function(r, i){ return me.facade.generateGlossaryURL(r.glossary, r.text)});
								} else {
									json.properties[prop.id()] = me.facade.generateGlossaryURL(gl.glossary, json.properties[prop.id()]);
								}
							}
						}.bind(this));
					}
					
					return json;
				};
			}();
			
			
			/**
			 * Overwrite the toJSON method in the AbstractShape
			 * to support the glossary schema when serializing
			 * 
			 */
			var me = this;
			new function(){
				// Copy prototype method
				var deserialize = ORYX.Core.AbstractShape.prototype.deserialize;
				ORYX.Core.AbstractShape.prototype.deserialize = function(){
					// Call super
					deserialize.apply(this, arguments);
					// Check for glossary entry
					if (me.facade.hasGlossaryExtension) {
						// If so, replace all changed glossary items
						this.getStencil().properties().each(function(prop){
							var name = prop.prefix()+"-"+prop.id(),
								value = this.properties[name];
							if ("string" == typeof value && me.isGlossaryEntry(value)) {
								var text = me.getGlossaryText(value),
									glossaryId = me.getGlossaryId(value);
								me.facade.setGlossary(this, prop, glossaryId, text, false);
								this.properties[name] = text;
							}
						}.bind(this));
					}
				};
			}();
			
			/**
			* Overwrite the serialize method in the AbstractShape
			* to support the glossary schema when serializing
			* 
			*/
			new function(){
				// Copy prototype method
				var serializeSuper = ORYX.Core.AbstractShape.prototype.serialize;
				
				ORYX.Core.AbstractShape.prototype.serialize = function(){
					// Temporally Apply glossary changes
					if (me.facade.hasGlossaryExtension && me.facade.hasGlossary(this)) {
						// Store old values
						var oldValues = new Hash();
						// If so, replace all changed glossary items
						this.getStencil().properties().each(function(prop){
							var gl = me.facade.getGlossary(this, prop);
							if (gl && typeof this.properties[prop.prefix() + "-" + prop.id()] !== "undefined") {
								oldValues[prop.prefix() + "-" + prop.id()] = this.properties[prop.prefix() + "-" + prop.id()];

								if (gl instanceof Array){
									this.properties[prop.prefix() + "-" + prop.id()] = gl.map(function(r, i){ return me.facade.generateGlossaryURL(r.glossary, r.text)});
								} else {
									this.properties[prop.prefix() + "-" + prop.id()] = me.facade.generateGlossaryURL(gl.glossary, this.properties[prop.prefix() + "-" + prop.id()]);
								}
							}
						}.bind(this));
					}
					
					// Call super
					var serialize = serializeSuper.call(this);
					
					// Revert temporally changes on the actual shape
					if(oldValues) {
						oldValues.keys().each(function(key){
							this.properties[key] = oldValues[key];
						}.bind(this));
					}
					
					return serialize;
				};
			}();

		},
	
		modifyFacade: function() {
			
			// Enable glossary support
			this.facade.hasGlossaryExtension = true;
			
			this.glossaryStore = new GlossaryStore(this.facade);
			
			// Add a new glossary entry
			this.facade.setGlossary = this.glossaryStore.set.bind(this.glossaryStore);
			this.facade.getGlossary = this.glossaryStore.get.bind(this.glossaryStore);
			this.facade.hasGlossary = this.glossaryStore.has.bind(this.glossaryStore);
			this.facade.generateGlossaryURL = this.getGlossaryURL.bind(this);
			this.facade.checkGlossaryIsDirty = this.checkGlossaryIsDirty.bind(this);
			this.facade.updateGlossaryUI = this.updateGlossaryUI.bind(this);
			this.facade.stencilHasGlossarySupport = this.stencilHasGlossarySupport.bind(this);
		},
		
		/**
		 * Returns true if the stencil is register as a supported stencil for glossary
		 * @param {ORYX.Core.Stencil|ORYX.Core.Shape} stencil
		 * @param {ORYX.Core.Property} property (Optional) 
		 */
		stencilHasGlossarySupport: function(stencil, property){
			if (stencil instanceof ORYX.Core.AbstractShape) {
				stencil = stencil.getStencil();
			}
			return !(	!GlossarySupportedStencils[stencil.namespace()] || 
						!GlossarySupportedStencils[stencil.namespace()][stencil.idWithoutNs()] ||
						(property && !GlossarySupportedStencils[stencil.namespace()][stencil.idWithoutNs()].include(property))
						)
		},

		
		shapeHasGlossarySupportAndIsNotEmpty: function(shape){
			if (!this.stencilHasGlossarySupport(shape)) {
				return undefined;
			}
			
			var stencil = shape.getStencil();
			var props = GlossarySupportedStencils[stencil.namespace()][stencil.idWithoutNs()];
			return props.all(function(prop){
				return !!(shape.properties[prop]||"").strip();
			});
		},
		
		getFirstSupportedProperty: function(shape){
			if (!this.stencilHasGlossarySupport(shape)) {
				return false;
			}
			
			var stencil = shape.getStencil();
			return GlossarySupportedStencils[stencil.namespace()][stencil.idWithoutNs()].first();
		},
		
		isGlossaryEntry: function(value){
			return value && !!value.match(/\glossary\:\/\/.+\/[\w\W]+\;\;/g)
		},

		/**
		 * Returns the text from the string with the schema: glossary://id/text;;
		 */
		getGlossaryText: function(value){
			return (value||"").split(";;").invoke("replace", /\glossary\:\/\/.+\//g, "").first();
		},

		/**
		 * Returns the id from the string with the schema: glossary://id/text;;
		 */
		getGlossaryId: function(value){
			return (value||"").split(";;").invoke("replace", /\glossary\:\/\//g, "").invoke("replace", /\/[\w\W]+/g, "").first();
		},
		
		/**
		 * Parse the id and the text to the schema:  glossary://id/text;;
		 */
		getGlossaryURL: function(glossary, text){
			return (new Ext.XTemplate("glossary://{id}/{text};;")).apply({id:glossary, text:text});
		},
		
		/**
		 * Checks if the value A (Value) is dirty regarding B (Title of Glossary Entry)
		 * @param {String} a
		 * @param {String} b
		 */
		checkGlossaryIsDirty: function(a, b){
			
			if (!a || !b) {
				return a != b;
			}
			
//			// Tokenize by get all words
//			var tA = a.match(/[\w]*/g).without("").invoke("toLowerCase").join("");
//			var tB = b.match(/[\w]*/g).without("").invoke("toLowerCase").join("");
//			
//			return !tA.include(tB); //!tB.all(function(t){ return tA.include(t)});
			
			// algorithm related to Java class com.signavio.platform.util.StringUtil
			var REGULAR_EXPRESSION_CHARACTERS = "([{\\^-$|]})?*+.";
			var NON_WORD_NON_WHITESPACE_CHARACTERS_REGEX = "[!\"#\\$%&'\\(\\)\\*\\+,\\-\\./:;<=>\\?@\\[\\\\\\]\\^_`\\{\\|\\}~§′]";
			var REPLACE_PREFIX_REGEX = "(^|\\s|(^|[^\\\\])\\\\[nfr\\x0B]|" + NON_WORD_NON_WHITESPACE_CHARACTERS_REGEX + ")";
			var REPLACE_IN_BETWEEN_REGEX = "(\\s|\\\\[nfr\\x0B]|-)*?";
			var REPLACE_SUFFIX_REGEX = "($|\\s|[^\\\\]\\\\[nfr\\x0B]|" + NON_WORD_NON_WHITESPACE_CHARACTERS_REGEX + ")";
			
			var regexToFind = REPLACE_PREFIX_REGEX + "(";
			b.toArray().each(function(aChar, index) {
				if(REGULAR_EXPRESSION_CHARACTERS.include(aChar)) {
					regexToFind += "\\" + aChar;
				} else if (aChar !== ' ') {
					regexToFind += aChar;
				}
				if(index < b.length - 1) {
					regexToFind += REPLACE_IN_BETWEEN_REGEX;
				}
			});
			
			regexToFind += ")" + REPLACE_SUFFIX_REGEX;
			
			return !(a.match(regexToFind));
		},
		
		updateGlossaryUI: function(elements){
			if (!(elements instanceof Array))
				elements = [elements];
			
			// Store selection
			var cs = this.currentSelection;
			this.currentSelection = elements;
			// Update the button
			this.updateButton(elements);
			// Restore current selection
			this.currentSelection = cs;
		},

		/**
		 * 
		 * @param {Object} option
		 */
		propertyChanged: function(option, node){

			if (!this.stencilHasGlossarySupport(node, option.name.replace(/_[a-z]+$/i,""))) { return; }

			var key = option.name;
			var value = option.value;
			
			if (!key) { return }


			// Check if the value has the glossary schema
			var isGlossary = this.isGlossaryEntry(value);
			// Check if the key is already in the glossary store
			var hasGlossary = this.glossaryStore.has(node, key);
			
			// 
			if (!isGlossary&&!hasGlossary) { 
				if (this.overlays["glossary.urlref_" + node.resourceId] !== undefined){
					//this.hide(node);
				}
				//return;
			}
			
			// If the value is in a glossary schema
			// ATTENTION: This went to an own plugin -> the glossaryRename.js
			if (false && isGlossary) {
				
				// Get the text
				var text 		= this.getGlossaryText(value);
				var glossaryId 	= this.getGlossaryId(value);
				var isDirty 	= !!node.hiddenProperties[key+ORYX.CONFIG.GLOSSARY_PROPERTY_DIRTY_SUFFIX];

				// Show book
				//this.show(node, glossaryId, isDirty);
				
				// If it is not in the store
				if (!hasGlossary) {

					// Adds it to the store
					this.glossaryStore.set(node, node.getStencil().property(key), glossaryId, text, isDirty)
				}
				// Set property with the correct name
				node.setProperty(key, text);
				this.facade.getCanvas().update();
				
			} else if(!isGlossary && hasGlossary) {
				// Get entry
				var entry = this.glossaryStore.get(node, key);
				if (entry && (this.overlays["glossary.urlref_" + node.resourceId]===undefined||this.overlays["glossary.urlref_" + node.resourceId]!==entry.isDirty)) {
					// Show book
					//this.show( node, entry.glossary, entry.isDirty);
				}
			}	
			

			// Show/hide add button
			this.updateButton([node]);
		},
		
		/**
		 * Callback if the selection has change
		 */
		onSelectionChange: function(option){
			
			this.currentSelection = option.elements;
			this.updateButton(option.elements)

		},
		
		/**
		 * Updates the button regarding the 
		 * use of glossary and title
		 * 
		 * @param {Object} elements
		 */
		updateButton: function(elements){
			
			// Check if there is only one shape selected which has glossary support
			if (	elements.length == 1 &&  
					(this.currentSelection||[]).include(elements[0]) &&
					this.stencilHasGlossarySupport(elements[0])) {
				
				// Enable glossary button
				delete this.glossaryOffer.isEnabled;
				// Get the property
				var shape = elements[0], oprop = this.getFirstSupportedProperty(shape), prop = oprop;
				
				// Check the glossary in any language
				if (ORYX.CONFIG.MULTI_LANGUAGES_ENABLED && shape.getStencil().property(prop) && shape.getStencil().property(prop).language()){
					var property = shape.getStencil().property(oprop).origin();
					$H(ORYX.CONFIG.MULTI_LANGUAGES||{}).keys().any(function(lang){
						var key = property.prefix() + "-" + property.id() + (lang == ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT ? "" : "_" + lang );
						if (this.glossaryStore.has(shape, key)){
							prop = key;
							return true;
						} 
						return false;
					}.bind(this));
				}
				
				// If there is one entry, show it
				if (this.glossaryStore.has(shape, prop)) {
					// Get the glossary entry
					var entry = this.glossaryStore.get(shape, prop);
					var dirty = entry.isDirty;
					var title = entry.text + " - " + Signavio.I18N.Glossary_Support[dirty ? "tooltipInfoWarning" : "tooltipInfo"];
					var icon  = dirty ? this.ICON_WARNING : this.ICON;	
					this.setGlossaryOffer(title, icon, function(){
						this.openGlossaryInfo(entry.glossary, shape);
					}.bind(this));
				} else {
					// Otherwise, show add button
					this.setGlossaryOffer(Signavio.I18N.Glossary_Support.tooltipCreate, this.ICON_ADD, function(){
						this.showNewWindow(elements[0], oprop+(this.facade.getCanvas().getLanguage()!=ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT?"_"+this.facade.getCanvas().getLanguage():""));
					}.bind(this));
				}
			} else {	
				// Hide the glossary button
				this.glossaryOffer.isEnabled = function(){
					return false;
				}
			} 
		},
		
		/**
		 * Set the icon, title and the 
		 * function of the button in the 
		 * shape menu
		 * 
		 * @param {Object} title
		 * @param {Object} icon
		 * @param {Object} fn
		 */
		setGlossaryOffer: function(title, icon, fn){
			
			if (!this.glossaryOffer||!this.glossaryOffer.button){
				return;
			}
			
			this.glossaryOffer.button.setCallback(fn);
			this.glossaryOffer.button.setDescription(title);
			this.glossaryOffer.button.setIcon(icon);
		},
	
		
		/**
		 * Event-listener to open the a 
		 * glossary item
		 *  
		 * @param {Object} option "glossary" and "shape" have to be defined
		 */
		handleOpenInfo: function(option) {
			this.openGlossaryInfo(option.glossary, option.shape);
		},
		
		handleOpenNew: function(option){
			this.showNewWindow(option.shape, option.property, option.callback, option.hasCategorySwitch);
		},
		
		
		/***********************************************************************/
		/*** BEGIN COPIED FROM THE NEW.JS from the Glossary Frontend Project ***/
		/***********************************************************************/
		
		/**
		 * Out of the params, the field where created
		 * COPIED FROM THE NEW.JS from the Glossary Frontend Project
		 * 
		 */
		extractParams: function(items){
			var o = this.getBaseParams() || {};
			
			items.each(function(item){
				if (item&&item.dataField&&(item.getValue()||item.getValue() !== item.originalValue)&&(!item.defaultValue||(item.defaultValue!==item.getValue()&&item.getValue()!==item.originalValue))){
					if (item.dataField.include(".")){
						var frag = item.dataField.split(".");
						var co = o;
						frag.slice(0,frag.length-1).each(function(fr){ if (!co[fr]){ co[fr] = {}; } co = co[fr];})
						co[frag.last()] = item.getValue();
					} else {
						o[item.dataField] = item.getValue();
					}
				}
			});
			
			return o;
		},
		
		/**
		 * 
		 * COPIED FROM THE NEW.JS from the Glossary Frontend Project
		 * 
		 */
		getBaseParams: function(){
			return {language:"en", title:"", description:"", originId: this.facade.getModelMetaData().parent};
		},
				
		/**
		 * 
		 * COPIED FROM THE NEW.JS from the Glossary Frontend Project
		 * 
		 */
		getCategoryStore: function(){
			var store = new Ext.data.SimpleStore({
		        fields	: ['label', 'value'],
		        data 	: this.categories.data.items.findAll(function(category){
		        				return category.get("rel") === "cat";
		        			})
		        			.map(function(category){	// @changed
								var type = category.get("rep").type;
								return [Signavio.I18N.Glossary_Support[type]||type||"", type||""];
							})
		    });	
			return store;
		},
		
		/**
		 * 
		 * COPIED FROM THE NEW.JS from the Glossary Frontend Project
		 * 
		 * @param {Object} store - undefined
		 * @param {Object} category
		 * @param {Object} data
		 * @param {Object} onCategoryChange
		 */
		getFieldItems: function(store, category , data, onCategoryChange, hasCategorySwitch){
			
			var items = [];
			
			// Label
			items.push(new Ext.form.Label({
				text	: (Signavio.I18N.Glossary_Support.create),	 // @changed
				style	: "display:block;margin-bottom:5px;font-size:12px;margin-left:155px;"
			}))
			
			
			// Category
			items.push(Ext.ux.form.FieldFactory.generate("MetaDataChoiceInfo", {
				dataField	: "category",
				fieldLabel	: Signavio.I18N.Glossary_Support.category,  // @changed
				displayField: "label",
				valueField	: "value",
				hideTrigger	: hasCategorySwitch === false, // @changed
				disabled	: hasCategorySwitch === false, // @changed
				value		: category,
				store		: this.getCategoryStore(),
				listeners	: {
					change	: function(t,value){
						if (onCategoryChange instanceof Function){
							onCategoryChange(value)
						}
					},
					select	: function(t,value){
						if (onCategoryChange instanceof Function){
							onCategoryChange(value.get("value"))
						}
					}
				}
			}));
			
			// Title
			items.push(Ext.ux.form.FieldFactory.generate("MetaDataGlossaryLink", {
				dataField	: "title",
				itemCls		: "x-no-margin",
				fieldLabel	: Signavio.I18N.Glossary_Support.title, // @changed
				value		: data.title || "",
				showEmptyItems 	: true,
				forceSelection	: false,
				hiddenItems		: store ? [store.id] : [],
				getSearchQuery	: function(){
					var value = " " + this.getRawValue().slice(0, this.getCursorPosition()).toLowerCase().replace(/\s+/g, " ") + " ";
					var records = items[3].records || [];
					var lastWord = records.map(function(r){ return " " + r.get("rep").title.trim().split(/\s+/g).last().toLowerCase() + " " }).uniq();
					var lastIndex = 0;
					lastWord.each(function(word){
						lastIndex = value.include(word) ? Math.max(value.indexOf(word)+word.length, lastIndex) : lastIndex;
					})
					return value.slice(lastIndex).trim();
				},
				getValue	: function(){
					return this.getRawValue();
				},
				onNewRecord	: function(record){
					items[3].onSelect(record);
					delete this.records;
				}
			}));
			
			// Glossary Links
			items.push(Ext.ux.form.FieldFactory.generate("MetaDataGlossaryLinkList", {
				dataField	: "glossaryLinks",
				hideInput	: true,
				fieldLabel	: "", // @changed
				records		: data.glossaryLinks || [],
				updateView	: function(){
					var empty = this.records.length === 0;
					this.container.parent().setDisplayed(!empty);
					items[2].container.parent()[empty ? "removeClass" : "addClass"]("x-no-margin");
				},		
				getValue: function(){
					var value = (this.records||[]).map(function(rec){ return rec.get("href") || rec.get("rep")});
					var exclude = (items[2].getValue()||"").strip();
					return value.findAll(function(v){
						return typeof v === "string" || v.title !== exclude;
					})
				}
			}));
						
			// Description
			items.push(Ext.ux.form.FieldFactory.generate("MetaDataStringInfo", {
				dataField	: "description",
				fieldLabel	: Signavio.I18N.Glossary_Support.description, // @changed
				lineWrap	: true,
				value		: data.description || ""
			}));
			
			// Attachments
			items.push(Ext.ux.form.FieldFactory.generate("MetaDataUrlList", {
				dataField	: "attachments",
				fieldLabel	: Signavio.I18N.Glossary_Support.attachments, // @changed
				lineWrap	: true,
				data		: (data.attachments || []).map(function(r){ return {url: r.get("rep").url, label:r.get("rep").label, href: r.get("href")}}),
				itemFieldTpl : new Ext.XTemplate('<ol><tpl for="."><li><a href="{[Signavio.Utils.escapeHTML(values.url)]}" target="_blank" tabindex="-1">{[Signavio.Utils.escapeHTML(values.label||values.url)]}</a> <span class="x-smaller">(<a href="#{[xindex-1]}" class="x-remove" tabindex="-1">{[(Ext.ux.getI18N("btnRemove"))]}</a>)</span></li></tpl></ol>'),
				getValue	: function(){
					var value  = Ext.ux.form.UrlLinkFieldList.prototype.getValue.call(this);
					value = value.map(function(v){
						return {url: v.url, label:v.label} // @changed
					})
					return value;
				}
				
			}));
						
			// Meta Data
			Templates.getMetaData(category).each(function(meta){ // @changed
				var metaInfo = meta.rep;
				var className = metaInfo.type + (!!metaInfo.isList ? "List" : "");
				var value = (data.metaDataValues||{})[metaInfo.id] || metaInfo.defaultValue || "";
				if (value instanceof Array){
					value = value.clone();
				} else if (value instanceof Object){
					value = Object.clone(value);
				}
				items.push(Ext.ux.form.FieldFactory.generate(className, Ext.apply({}, Ext.apply({}, {id:undefined}, metaInfo), {
					dataField	: "metaDataValues."+metaInfo.id,
					fieldLabel	: metaInfo.name,
					//emptyText	: "",
					defaultValue: metaInfo.defaultValue !== (data.metaDataValues||{})[metaInfo.id] ? (metaInfo.defaultValue || "") : "",
					value		: value
				})));
				
			});
			
			return items.clone();	
		},
		
		getCurrentCategory: function(shape){ // @changed
			return ((GlossarySupportedStencilsDefaults[shape.getStencil().id()] || GlossarySupportedStencilsDefaults.all || {}).category) || this.categories.getAt(0).get("href");  // @changed
		},
		
		createNewGlossaryEntry: function(option, finish, shape, prop){

		
			if (!option||!(option.title||"").strip()){
				// Call finish callback
				if (finish instanceof Function){
					finish(false);
				}
			 	return; 
			}
			
			// Define url
			var url = ORYX.CONFIG.SERVER_GLOSSARY_HANDLER;							   
			
			option = option || {};
			$H(option).keys().each(function(v){ option[v] = typeof option[v] == "object" ? (option[v] instanceof Array ? option[v].map(function(r){ return typeof r == "object" ? Object.toJSON(r) : r}): Object.toJSON(option[v])) :option[v]});

   			var send = function(){
   			   // Send the request to the server.
   			   new Ajax.Request(url, {
   	                method		: "POST",
   	                asynchronous: true,
   	                parameters	: option,
   	                onSuccess	: function(transport) {
   	                	// Get response
   	                	var resp = transport.responseText.evalJSON();
						
   	                	// Call finish callback
						if (finish instanceof Function){
							finish(Ext.ux.data.RecordCreator.create("gitem", resp.href, Object.clone(resp.rep)));
						} 
   	                }.bind(this), 
   	                on409: function(){
   	                	var title = Signavio.Utils.escapeHTML(option.title);
   	                	Ext.Msg.confirm(Signavio.I18N.Glossary_Support.newTitle + " '"+title+"'", new Ext.XTemplate(Signavio.I18N.Glossary_Support.newError).apply({title:title}), function(btn, text) {
		    				if(btn === "yes") {
		    					option.force = true;
		    					send();
		    				} else {
		    					// Call finish callback
								if (finish instanceof Function){
									finish(false);
								}
		    				}
		    			}.bind(this));
   	                }.bind(this),
   	                on403: function(){
   	                	Ext.Msg.alert(Signavio.I18N.Glossary_Support.noWritePerm, Signavio.I18N.Glossary_Support.noWritePermDesc);
   	                }
   	             });
   		   }.bind(this)
   		   

   		   send();
		},
		
		
		extractInfo: function(shape, prop){
			var data = {};
			if (shape&&shape.properties&&prop){
				data.title = shape.properties[prop]||"";
			}
			if (shape&&shape.category){
				data.category = shape.category;
			}
			return data;
		},
		
		/**
		 * Returns TRUE if the user has the right 
		 * to edit any glossary items.
		 * @returns {Boolean}
		 */
		hasWriteRight: function(){
			var priv = this.categories.data.items.find(function(c){ return c.get("rel") == "priv"; });
			return !priv || priv.get("rep").any(function(r){ return r.rep.privilege == "glossary.write"; });
		},
		/**
		 * Shows the panel where you can create a new glossary entry
		 * COPIED FROM THE NEW.JS from the Glossary Frontend Project
		 * 
		 */
		showNewWindow: function(shape, prop, callback, hasCategorySwitch){
			
			
			if (!this.hasWriteRight()){
				if (callback instanceof Function){
					callback(false);
				}
				Ext.Msg
					.alert(Signavio.I18N.Glossary_Support.noRightTitle, Signavio.I18N.Glossary_Support.noRightDescription)
					.setIcon(Ext.Msg.INFO)
					.getDialog().syncSize();
				return;
			}
			
						
			var onCategoryChange = function(value){
				if (w.currentCategory === value){
					return;
				}
				w.currentCategory = value;
				
				w.body.fadeOut({
					duration : 0.3,
					callback: function(){
						// Get the data
						var data = this.extractParams(w.items);
						// Get the missing records
						w.items.each(function(item){
							if (item instanceof Ext.ux.form.GlossaryField&&item.dataField&&item.records){
								data[item.dataField] = item.records;
							}
						})
						// Get new items
						var items = this.getFieldItems(store, value, data, onCategoryChange);
						// Remove all current items
						for (var i=w.items.items.length-1; i>=0; --i){ w.remove(w.items.get(i)); }
						delete w.items;
						// Remove all innerHTML
						w.body.update();
						// Add all new items
						w.add.apply(w, items);
						
						w.body.show();
						w.body.setOpacity(0.01);
						
						// Update size
						w.doLayout();
						w.updateSize();
						w.doLayout();
						
						// Show the content
						w.body.fadeIn({
							duration: 0.3
						});
					}.bind(this)
				})
				
			}.bind(this);
			
			var me = this;
			var store = undefined;
			
			// Get the data from the store
			var data = this.extractInfo(shape, prop);   // @changed
			// Get category
			var category = (data.category || this.getCurrentCategory(shape) || "").split("=").last(); // @changed
			
			// Get item
			var items = this.getFieldItems(store, category, data, onCategoryChange, hasCategorySwitch);  // @changed

			// Create Window
			var w = new Ext.Window({
				currentCategory : category,
				title	: Signavio.I18N.Glossary_Support.newTitle,  // @changed
				modal	: true,
				cls		: "x-glossary-new",
				bodyStyle: "padding:10px;position:relative;overflow-x:hidden;overflow-y:auto;",
				width	: Math.max((window.innerWidth || document.body.offsetWidth || 0) * 0.5, 450),
				height	: Math.max((window.innerHeight || document.body.offsetHeight || 0) * 0.8, 450),
				minHeight	: 450,
				minWidth	: 450,
				layout		: "form",
			   	labelWidth	: 150,
				onEsc		: function(){},
				updateSize	: function(){
					var width = this.getInnerWidth()-this.body.getPadding("lr")-this.labelWidth-25;
					this.items.items.invoke("setWidth", width);
					
					var height = this.getInnerHeight()-this.body.getPadding("tb")-20;
					// Seperate all items into Textareas and others
					var sep = this.items.items.partition(function(r){ return r instanceof Ext.form.TextArea });
					
					if (sep[0].length===0){ return }
					
					// Subtract height from others
					sep[1].each(function(r){ 
						if (!r.rendered||!r.el){return}
						var el = (r.container&&r.container!==this.body?r.container.parent():r.el)
						height -= el.getHeight()+el.getPadding("tb")+el.getMargins("tb")
					}.bind(this))
					// Set height to Textareas
					sep[0].invoke("setSize", width, Math.max(height/sep[0].length, 90))
					
					
				},
				defaults	: {
					width		: 300,
			    	labelStyle	:'text-align:right;width:150px;'
				},
				show 	: function(){
					Ext.Window.prototype.show.apply(this, arguments);
					this.updateSize();
				},
				listeners:{
					resize	: function(){
						this.updateSize();
					},
					close: function(){
						if (callback instanceof Function){
							callback(false);
						}
					}
				},
				items	: items,
				buttons	: [
				       	   {text:Signavio.I18N.Glossary_Support.createButton, handler: function(){ // @changed
						   	
								w.buttons.each(function(btn){
									btn.disable();
								});
								
								// Get the current data
								var o = me.extractParams(w.items);
								
								// Finish clb
								var finish = function(success){
										if (success){
											this.ownerCt.destroy();
											if (callback instanceof Function){
												callback(success);
											} else if (shape && prop) {
												// Get origin value and title
						   	                	var value = shape.properties[prop];
						   	                	var gTitle = success.get("rep").title;
												
												// If no value is setted
												// set the glossary title
												if (!value){
													value = gTitle;
												}
												// Set property and glossary item (in a command)
						   	                	me.setProperty(shape, prop, value, {glossary:success.get("rep").id, isDirty:me.checkGlossaryIsDirty(value, gTitle)});
											}
										} else {
											this.ownerCt.buttons.each(function(btn){
												btn.enable();
											});
										}
										
									}.bind(this);
									
								me.createNewGlossaryEntry(o, finish);  // @changed
								

				       	   }},
				       	   {text:Signavio.I18N.Glossary_Support.cancel, handler: function(){ // @changed
				       		   this.ownerCt.close();
				       	   }}
				       	   ]
				
			});
			
			w.show();
			w.syncSize();
			window.setTimeout(function(){
				w.items.get(2).focus();
			}, 10)
			
		},
		
		/*********************************************************************/
		/*** END COPIED FROM THE NEW.JS from the Glossary Frontend Project ***/
		/*********************************************************************/
		
		
		/**
		 * Opens a window which shows the glossary
		 * item. It uses the templates which are 
		 * provided at the end of this file.
		 * @param {Object} glossary
		 * @param {Object} shape
		 * 
		 */
		openGlossaryInfo: function(glossary, shape){
			
			
			shape = shape instanceof ORYX.Core.Shape ? shape : undefined;
			var w;
			
			// Get the glossary data
			new Ajax.Request("/p/glossary/"+glossary, {
                method		: 'get',
                asynchronous: true,
				requestHeaders: {"Accept":"application/json"},
				parameters	: {
					originId	: this.facade.getModelMetaData().parent	// Need to identify the correct glossary 
				},
				onSuccess	: function(transport){
						var response 	= transport.responseText.evalJSON();
						var info 		= response.find(function(r){ return r.rel == "info"});
						
						w.add(new Ext.Panel({
							border:false,
							html : new Ext.XTemplate('<div class="x-glossary-title">',
														'<img class="x-{[values.category.toLowerCase()]} x-image" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>'+
														'{[Signavio.Utils.escapeHTML(values.title||"")]} ',
														'<span>({[Signavio.I18N.Glossary_Support[values.category]||values.category]})</span>',
													'</div>').apply(info.rep)
						}))
						
						w.add(new Ext.Panel({
							border:false,
							html : Templates.GlossaryItem.apply(Templates.generateData(response))
						}))
						
						w.remove(w.items.get(0));
						
						w.doLayout();
						w.syncSize();
						w.center();
					}.bind(this),
				onFailure: function(){
					//TODO: Handle failure if shape is not given
					if (!shape){ return; }
					
					Ext.Msg.confirm(Signavio.I18N.Glossary_Support.noGlossaryEntryTitle, Signavio.I18N.Glossary_Support.noGlossaryEntryDesc, function(btn){
						if (btn=="yes"){
							var glossary = this.facade.getGlossary(shape)
							if (!glossary) { return }
							
							var pname = glossary.property.prefix()+"-"+glossary.property.id();
							var value = shape.properties[pname];
							this.setProperty(shape, pname, value);
							this.updateGlossaryUI(shape);
						}
					}.bind(this))
					
					w.close();
				}.bind(this)});
			
			
			w = new Ext.Window({
				title	: Signavio.I18N.Glossary_Support.previewTitle,
				modal	: false,
				cls		: "x-glossary-preview",
				bodyStyle: "background:white;padding:10px;max-height:"+(Math.max((window.document.height||0)-300, 200))+"px;overflow:hidden;",
				autoScroll:true,
				width	: 530,
				minHeight:200,
				minWidth: 300,
				items	: [
				     	  new Ext.Panel({
				     		  border: false,
				     		  html:"<div class='x-msg-loading'>"+Signavio.I18N.Glossary_Support.waiting+"</div>"
				     	  })
				     	   ],
				buttons	: [
				       	   shape ? new Ext.LinkButton({
				       		   style:"color:white;display:block;font-size:11px;position:relative;",
				       		   text: Signavio.I18N.Glossary_Support.removeLink,
				       		   click: function(){
									Ext.Msg.confirm(Signavio.I18N.Glossary_Support.removeTitle, Signavio.I18N.Glossary_Support.removeDesc, function(btn){
										if (btn=="yes") {
											var glossary = this.facade.getGlossary(shape)
											if (!glossary) { return }
											
											var pname = glossary.property.prefix()+"-"+glossary.property.id();
											var value = shape.properties[pname];
											this.setProperty(shape, pname, value);
											this.updateGlossaryUI(shape);
											w.close();
										}
									}.bind(this))
				       	   		}.bind(this)
				       	   }) : undefined,
				       	   new Ext.LinkButton({
				       		   style	:"color:white;display:block;font-size:11px;position:relative;",
				       		   text		: Signavio.I18N.Glossary_Support.openGlossary ,
							   url		: ORYX.CONFIG.SERVER_GLOSSARY_HANDLER+"?originId="+this.facade.getModelMetaData().parent+"#gitem="+glossary,
				       		   click	: function(){
						       		//Ext.Msg.alert(Signavio.I18N.Glossary_Support.openTitle, Signavio.I18N.Glossary_Support.openDesc, function(btn){
									//	if (btn=="ok") {
									window.open(ORYX.CONFIG.SERVER_GLOSSARY_HANDLER+"?originId="+this.facade.getModelMetaData().parent+"#gitem="+glossary);
									w.close();
										//}
									//}.bind(this)).setIcon(Ext.MessageBox.INFO)
			       	   			}.bind(this)
				       	   }),
				       	   {text:Signavio.I18N.Glossary_Support.close, handler: function(){
				       		   this.ownerCt.close();
				       	   }}
				  ].compact()
				
			});
			
			w.show();
		},
		
		setProperty: function(shape, key, value, glossary){
			// Implement the specific command for property change
			var Change = ORYX.Core.Command.extend({
				construct: function(shape, key, value, facade){
					this.selectedElements = facade.getSelection();
					this.shape		= shape;
					this.key 		= key;
					this.prop		= shape.getStencil().property(key);
					this.oldValue 	= shape.properties[key];
					this.value	 	= value;
					this.facade		= facade;
					this.glossary	= glossary;
					this.oldGlossary = this.facade.hasGlossaryExtension ? this.facade.getGlossary(shape, this.prop) : null;
				},			
				execute: function(){
					if (this.facade.hasGlossaryExtension){
						if (this.glossary){
							var id = this.glossary.glossary;
							var isDirty = !!this.glossary.isDirty;
							this.facade.setGlossary(this.shape, this.prop, id, this.value, isDirty);
						} else {
							this.facade.setGlossary(this.shape, this.prop);
						}
					}
						
					this.shape.setProperty(this.key, this.value);
					this.facade.setSelection(this.selectedElements);
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
				},
				rollback: function(){
					if (this.facade.hasGlossaryExtension){
						if (this.oldGlossary){
							var og = this.oldGlossary;
							this.facade.setGlossary(this.shape, this.prop, og.glossary, og.text, og.isDirty);
						} else {
							this.facade.setGlossary(this.shape, this.prop);
						}
					}
						
					this.shape.setProperty(this.key, this.oldValue);
					this.facade.setSelection(this.selectedElements);
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
				}
			})
			
			// Execute the command
			this.facade.executeCommands([new Change(shape, key, value, this.facade)]);
		}

	});
	
	
	
	
	
	
	var Templates = {};
	Templates.Renderer = {};
														

	Templates.ListSeparator = ", ";
	Templates.Renderer.MetaDataStringInfo 		= 	'{[Signavio.Utils.escapeHTML(values.value)]}';
	Templates.Renderer.MetaDataStringInfoList 	= 	'<ol><tpl for="values.value"><li>{[Signavio.Utils.escapeHTML(values)]}</li></tpl></ol>';

	Templates.Renderer.MetaDataBoolean			= 	'<img src="/explorer/src/img/famfamfam/check_small.png" style="background:white;opacity:0.6;" />';
	
	Templates.Renderer.MetaDataUrl 				= '<div class="x-inline">'+
																		'<img class="x-image x-attachment" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>'+
																		'<a href="{[unescape(values.url)]}" target="_blank">{[Signavio.Utils.escapeHTML((values.label||"").strip()||values.url)]}</a>' +
																	'</div>';
																	
	Templates.Renderer.MetaDataUrlList 			= 	'<tpl for="values.value">'+
																		'<div class="x-inline">'+
																			'<img class="x-image x-attachment" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>'+
																			'<a href="{[unescape(values.url)]}" target="_blank">{[Signavio.Utils.escapeHTML((values.label||"").strip()||values.url)]}</a>'+
																			'<tpl if="xindex!==xcount">'+Templates.ListSeparator+'</tpl>'+
																		'</div>'+
																	'</tpl>';
																	
	Templates.Renderer.MetaDataAttachmentList 	= 	'<tpl for="values.value">'+
																		'<div class="x-inline">'+
																			'<img class="x-image x-attachment" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>'+
																			'<a href="{[unescape(values.url)]}" target="_blank">{[Signavio.Utils.escapeHTML((values.value||"").strip()||values.url)]}</a>'+
																			'<tpl if="xindex!==xcount">'+Templates.ListSeparator+'</tpl>'+
																		'</div>'+
																	'</tpl>';
																	
	Templates.Renderer.MetaDataLinkInfoList 		= 	'<tpl for="values.value">'+
																		'<div class="x-inline">'+
																			'<img class="x-image x-attachment" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>'+
																			'<a href="{[unescape(values.url)]}" target="_blank">{[Signavio.Utils.escapeHTML((values.value||"").strip()||values.url)]}</a>'+
																			'<tpl if="xindex!==xcount">'+Templates.ListSeparator+'</tpl>'+
																		'</div>'+
																	'</tpl>';
	Templates.Renderer.MetaDataLinkModelInfoList 	= '<tpl for="values.value">'+
																		'<div class="x-inline">'+
																			'<img class="x-image x-model-link" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>'+
																			'<a href="{url}" target="_blank">{[Signavio.Utils.escapeHTML(values.value||"").strip()||values.url]}</a>'+
																			' <span>({type})</span>'+
																			'<tpl if="xindex!==xcount">'+Templates.ListSeparator+' </tpl>'+
																		'</div>'+
																	'</tpl>';

	Templates.Renderer.MetaDataGlossaryLink	 	= 	'<div class="x-inline">'+
																		'<img class="x-{[values.category.toLowerCase()]} x-image" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>'+
																		'<a href="{[ORYX.CONFIG.SERVER_GLOSSARY_PREFIX]}{id}" target="_blank" class="x-glossary-link-a">{[Signavio.Utils.escapeHTML(values.title||"").strip()||values.id]}</a>'+
																	'</div>';
														
	Templates.Renderer.MetaDataGlossaryLinkList 	= 	'<tpl for="values.value">'+
																		'<div class="x-inline">'+
																			'<img class="x-{[values.category.toLowerCase()]} x-image" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>'+
																			'<a href="{[ORYX.CONFIG.SERVER_GLOSSARY_PREFIX]}{id}" target="_blank" class="x-glossary-link-a">{[Signavio.Utils.escapeHTML(values.title||"").strip()||values.id]}</a>'+
																			'<tpl if="xindex!==xcount">'+Templates.ListSeparator+'</tpl>'+
																		'</div>'+
																	'</tpl>';
																					
																															
	Templates.GlossaryItem		 = new Ext.XTemplate(	'<table>',
																'<tpl for=".">',
																	'<tr class="x-{type} {[values.cls||""]}">',
																		'<th>',
																			'{labelName}:',
																		'</th>',
																		'<td>',
																			'<tpl if="!values.type">',
																				Templates.Renderer.MetaDataStringInfo,
																			'</tpl>',
																			$H(Templates.Renderer).keys().map(function(renderer){
																				return '<tpl if="values.type == \''+renderer+'\'">'+
																							(Templates.Renderer[renderer] || Templates.Renderer.MetaDataStringInfo) + 
																						'</tpl>';
																			}).join(""),
																		'</td>',
																	'</tr>',
																'</tpl>',
																'<tpl if="values.length===0">',
																	'<tr class="x-no-data"><td><div>{[Signavio.I18N.Glossary_Support.noData]}</div></td></tr>',
																'</tpl>',
															'</table>');
															
	
	Templates.getMetaData = function(category){
		
		if (!this.meta){
			new Ajax.Request("/p/meta", {
				method: "GET",
				asynchronous: false,
				onSuccess: function(transport){
					this.meta = (transport.responseText || "").evalJSON();
				}.bind(this)
			})
		}
		
		if (this.meta instanceof Array){
			return this.meta
				.findAll(function(meta){		// Get all meta data for this category
					return meta&&meta.rep&&meta.rep.glossaryBindings instanceof Array&&meta.rep.glossaryBindings.any(function(r){ return r&&r.category&&r.category.endsWith(category) })
				}).sortBy(function(metaData){	// Sort it by its order
					var gBinding = (metaData.rep.glossaryBindings||[]).find(function(binding){ 
							return binding.category && binding.category.endsWith(category)
						});
					return gBinding ? gBinding.order : 0;
				}) 
		} else {
			return [];
		}
		
	}	
													
	/**
	 * COPIED FROM THE GLOSSARY - listView.js
	 * Returns a set on key/value-pairs for 
	 * a specific data store
	 * @param {Object} store
	 */
	Templates.generateData = function(response){
			
			var info 		= response.find(function(r){ return r.rel == "info"});
			var attachments = response.find(function(r){ return r.rel == "att"});
			var linksRec 	= response.find(function(r){ return r.rel == "link"});
			var glossaryLinks = response.find(function(r){ return r.rel == "glossarylink"});
						
			// Remove the link to the current model and only show uniq models
			var currentModel = window.location.search.replace("?id=", "");
			var addedLinks = [];
			linksRec.rep = linksRec.rep.findAll(function(r){ 
							if (r.rep.model === currentModel||addedLinks.include(r.rep.model)){
								return false;
							} else {
								addedLinks.push(r.rep.model);
								return true;
							}
						});
									
			var data = [];
			
			// Description
			if (info&&info.rep.description)
				data.push({
					labelName: Signavio.I18N.Glossary_Support.description,
					type	: "MetaDataStringInfo",
					value	: info.rep.description
				});
				
				
			// Attachments
			if (attachments&&attachments.rep.length>0)
				data.push({
					labelName: Signavio.I18N.Glossary_Support.attachments,
					type	: "MetaDataAttachmentList",
					value	: attachments.rep.map(function(p){
									return {
										url		: p.rep.url,
										value	: p.rep.label
									}
								})
				});


			// Linked Glossary Items
			if (glossaryLinks&&glossaryLinks.rep.length>0){
				var name = info.rep.title;
				data.push({
					labelName: Signavio.I18N.Glossary_Support.linkedGlossaryItems,
					type	: "MetaDataGlossaryLinkList",
					value	: glossaryLinks.rep.map(function(p){
									return {
										id		: p.rep.id,
										title	: p.rep.title,
										category: p.rep.category
									}
								}).sort(function(a,b){
									var aWord = (a.title||"").split(/\s+/g);
									var bWord = (b.title||"").split(/\s+/g);
									// Get the index of the first and last word
									var a1 = name.indexOf(aWord.first())+1, a2 = name.indexOf(aWord.last())+1;
									var b1 = name.indexOf(bWord.first())+1, b2 = name.indexOf(bWord.last())+1;
									
									// Get the min index (except if is not a found index)
									var min = Math.min.apply(Math, [a1||null, a2||null, b1||null, b2||null].compact());
									
									// Return -1 if not found, or a has a smaller index
									if (Number.POSITIVE_INFINITY === min){
										return -1;
									} else if(min === a1 || min === a2) {
										return -1;
									} else {
										return 1;
									}
								})
				});
			}	
				
				
			// Meta Data Values
			if (info&&info.rep.metaDataValues){
				var metaValues = info.rep.metaDataValues
				
				var isEmpty = function(value){
					if(value === undefined || value === null) {
						return true;
					} else if (value instanceof Array){
						return value.length === 0;
					} else if(value instanceof Object) {
						return $H(value).keys().length === 0;
					} else if(typeof value === "string") {
						return !(value.trim());
					} else if(typeof value === "number") {
						return false;
					} else if (!value){
						return true;
					}
				}
				
				this.getMetaData(info.rep.category).each(function(meta){
					// Check if it is defined, or has a default value
					if (!isEmpty(metaValues[meta.rep.id]) || meta.rep.defaultValue){
						data.push(Ext.apply({}, typeof metaValues[meta.rep.id] == "object" ? metaValues[meta.rep.id] : {},{
							labelName: meta.rep.name,
							type	: meta.rep.type + (!!meta.rep.isList?"List":"")|| "MetaDataStringInfo",
							value	: metaValues[meta.rep.id] !== undefined ? metaValues[meta.rep.id] : meta.rep.defaultValue,
							cls		: metaValues[meta.rep.id] === undefined ? "x-default" : ""
						}));
					}
				})
			}
			
		
			// Linked Models
			if (linksRec&&linksRec.rep.length>0) {
				var consideredModel = [];
				data.push({
					labelName: Signavio.I18N.Glossary_Support.linkedModels,
					type	: "MetaDataLinkModelInfoList",
					value	: linksRec.rep.map(function(p){
									return {
										url		: ORYX.CONFIG.SERVER_PUBLISHER_HANDLER + "/" + p.rep.model,
										value	: p.rep.name,
										type	: p.rep.type
									}
								}).findAll(function(model){
									if (consideredModel.include(model.url)){
										return false;
									} else {
										consideredModel.push(model.url);
										return true;
									}
								})
				});
			}	
				
			
			// Replace all newlines with br
			data.each(function(d){
				if (typeof d.value === "string")
					d.value = d.value.gsub("\n", "<br/>");
			})
			
			return data;

		}													
	
}()

/**
 * Copyright (c) 2009
 * Signavio GmbH
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 * @author Willi Tscheschner
 * 
 * 
 **/

if (!Signavio) { var Signavio = new Object(); }
if (!Signavio.Plugins) { Signavio.Plugins = new Object(); }


new function(){ 
	
	/**
	 * Implements the special behavior for glossary
	 * @class 
	 * 
	 */
	Signavio.Plugins.GlossaryRename = ORYX.Plugins.AbstractPlugin.extend({
	
		facade: undefined,
	
		/**
		 * Offers the plugin functionality:
		 * 
		 */
		construct: function(facade) {
	
			this.facade = facade;

			this.editorInitialized = false;
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, function(){
				this.editorInitialized = true;
			}.bind(this));
			
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.propertyChanged.bind(this) );
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.onFinish.bind(this));
		},
		
		onFinish: function(){
			
			// TODO: Extreme slowly, add this as core function
		
			// Update all elements after loading
			this.facade.getCanvas().getChildShapes(true).each(function(shape){
				shape.properties.each(function(prop){
					this.propertyChanged({name:prop.key, value:prop.value}, shape, true);
				}.bind(this));
			}.bind(this));
			

			this.facade.getCanvas().update();
			
		},
		
		/**
		 * Returns true if the values is in the schema: glossary://id/text;; 
		 * @param {String} value
		 * @return {Boolean}
		 */
		isGlossaryEntry: function(value){
			return value && !!(value + "").match(/\glossary\:\/\/.+\/[\w\W]+\;\;/g);
		},

		/**
		 * Returns the text from the string with the schema: glossary://id/text;;
		 * @param {String} value
		 * @return {Boolean}
		 */
		getGlossaryText: function(value){
			return (value||"").replace(/;;$/, "").replace(/\glossary\:\/\/.+?\//g, "");
		},

		/**
		 * Returns the id from the string with the schema: glossary://id/text;;
		 * @param {String} value
		 * @return {Boolean}
		 */
		getGlossaryId: function(value){
			return (value||"").split(";;").invoke("replace", /\glossary\:\/\//g, "").invoke("replace", /\/[\w\W]+/g, "").first();
		},
		
		/**
		 * 
		 * @param {Object} option
		 */
		propertyChanged: function(option, node, noUpdate){

			var key = option.name;
			var value = option.value || "";			

			if (!key||(typeof value !== "string"&&!(value instanceof Array))) { return }
			
			var nValue;
			if (value instanceof Array){
				nValue = value.map(function(v, i){
					return this.checkProperty(v, key, node, i === 0);
				}.bind(this));
				
				if (value.length == 0 && this.facade.hasGlossaryExtension){
						this.facade.setGlossary(node, node.getStencil().property(key));
				}
			} else {
				nValue = this.checkProperty(value, key, node, true);
			}
			
			if (nValue && nValue!==value && (!(nValue instanceof Array)|| nValue.toJSON() !== value.toJSON())){

				// Set property with the correct name
				node.setProperty(key, nValue, true);
				
				if (noUpdate !== true && this.editorInitialized)
					this.facade.getCanvas().update();
			}

		},
		
		checkProperty: function(value, key, node, first){
				
			// If the value is in a glossary schema
			if (this.isGlossaryEntry(value)) {
				
				// Get the text
				var text 		= this.getGlossaryText(value);
				var glossaryId 	= this.getGlossaryId(value);
				var isDirty 	= !!node.hiddenProperties[key+ORYX.CONFIG.GLOSSARY_PROPERTY_DIRTY_SUFFIX];
				
				
				// Remove the glossary item first, so that list items can get updated
				if (this.facade.hasGlossaryExtension && first) {
					this.facade.setGlossary(node, node.getStencil().property(key));
				}

				// Show book
				//this.show(node, glossaryId, isDirty);
				
				
				// If it is not in the store
				if (this.facade.hasGlossaryExtension) {

					// Adds it to the store
					this.facade.setGlossary(node, node.getStencil().property(key), glossaryId, text, isDirty)
				} 
				
				return text;
			
			} else if(this.facade.hasGlossaryExtension && !value && this.facade.hasGlossary(node, key) && first){
				this.facade.setGlossary(node, node.getStencil().property(key));
			}
			
			return value;
			
		}

	});
	
}()/**
 * Copyright (c) 2011
 * Signavio GmbH
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 * @author Lukas Brand
 * 
 * 
 **/

 if(!Signavio) { var Signavio = {}; }
 if(!Signavio.Plugins) { Signavio.Plugins = {}; }
 
 new function() {
	 Signavio.Plugins.RichtextToolbar = ORYX.Plugins.AbstractPlugin.extend({
         
		 /**
		  * The buttons to set the richtext attributes
		  */
		 _richtextButtons : $w("fontSizeBox boldButton italicButton colorButton"),
		 _utilityButtons : $w("clearButton copyStyleButton"),
		                    
		 facade: undefined,
         
         construct: function(facade) {
             this.facade = facade;
             this.rotator = 0;
             
             /*
              * Handler for the selection change event.
              */
             this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this.handleSelectionChanged.bind(this));
             
             this.buttons = this.getRichtextButtons();
             
             // Graft the color hint boxes
             this.fontColorHint = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", undefined, this.getColorHint());
             this.borderColorHint = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", undefined, this.getColorHint());
             this.backgroundColorHint = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", undefined, this.getColorHint());
             
             this.richtextButton = {
            	// The name of the button
             	name 		: Signavio.I18N.Richtext.richtext,
             	description	: Signavio.I18N.Richtext.richtextDesc,
             	// The icon to display
             	icon 		: ORYX.CONFIG.EXPLORER_PATH + "/src/img/fugue/icons/"+(Ext.isIPad ? "32x32/":"")+"edit.png",
             	// The group of the icon
             	group		: 'richtext',
             	// The icon class
             	cls			: 'x-btn-icon',
             	// The config to pass to the Ext.ux.Toolbar.HorizontalMenu
             	menuConfig	: {
         			// The buttons to add
    				menuItems 		: $H(this.buttons).values(),
    				// The css class for the horizontal menu (aka toolbar)
    				cls				: 'y-horizontal-menu' + (Ext.isIPad ? ' y-horizontal-menu-ipad' : ''),
    				/**
    				 * @override
    				 * Function to call after selection changes
    				 */
    				
    			    enableButtons : function() {
			    		this.handleSelectionChanged();
			    	}.bind(this)
             	},
             	
             	/**
             	 * @override
             	 * Function to call on toggling
             	 * @param state
             	 */
             	toggle : function(state){
			        state = state === undefined ? !this.pressed : state;
			        
			        // Arrange classes to display custom styles of the pressed button
			        if(state != this.pressed){
			            if(state){
			                this.el.addClass("y-richtext-toolbar-button-expanded" + (Ext.isIPad ? " y-richtext-toolbar-button-expanded-ipad":""));
			                if (this.overlay) {
			                	this.overlay.show();	
			                }
			                this.pressed = true;
			                this.fireEvent("toggle", this, true);
			            }else{
			                this.el.removeClass("y-richtext-toolbar-button-expanded" + (Ext.isIPad ? " y-richtext-toolbar-button-expanded-ipad":""));
			                if (this.overlay) {
			                	this.overlay.hide();
			                }
			                this.pressed = false;
			                this.fireEvent("toggle", this, false);
			            }
			            if(this.toggleHandler){
			                this.toggleHandler.call(this.scope || this, this, state);
			            }
			        }
			        
			        if (!this.toolbar && this.pressed) {
			        	this.initToolbar(this, this.menuConfig);								
					} else if (this.toolbar && this.pressed){
						this.toolbar.show();
					} else if (this.toolbar) {
						this.toolbar.hide();
					}
			    }
             };
                  
             this.facade.offer(this.richtextButton);
             
         },
         
         /**
          * Checks the richtext and background properties of the selected shape.
          * If a label exists, enable the toolbar buttons for text formatting,
          * if it's possible to set the background color of the shape, enable this function in the toolbar.
          * If it's not possible to set richtext attributes or the background color, disable the associated functionality.
          * @param shapes
          */
         handleOneShapeSelected : function(shapes, nodes, labels, backgroundIds, borderIds) {
        	 if (!shapes) {
        		 shapes = this.facade.getSelection();
        	 }
        	 if (!nodes) {
        		 nodes = this.getNodes(shapes);	 
        	 }
        	 if (!labels) {
        		 labels = this.getLabels(shapes);	 
        	 }
    		 if (!backgroundIds) {
    			 backgroundIds = this.getBackgroundIds(shapes);	 
    		 }
    		 
    		 if (!borderIds) {
    			 borderIds = this.getBorderIds(shapes);
    		 }
    		 // Set the display text of the font size combo box to display the font size of the selected shape
    		 this.setFontSizeDisplayText(shapes, labels);
    		 // Try to set the border color hint box
    		 var borderIsSet = this.checkForBorderColorCapability(shapes, labels, borderIds);
    		 if (!borderIsSet) {
    			 this.removeBorderColorHint();
    		 }
    		 
    		 // Try to set the background color hint box
    		 var backgroundColorIsSet = this.checkForBackgroundCapability(shapes, nodes, labels, backgroundIds);
    		 if (!backgroundColorIsSet) {
    			 this.removeBackgroundColorHint();
    		 }
    		 
    		 // Try to set the font color hint box
    		 var fontColorIsSet = this.checkForRichtextCapability(shapes, nodes, labels, backgroundIds);
    		 if (!fontColorIsSet) {
    			 this.removeColorHint();
    		 }
    		 
    		 this.enableUtilityButtons();
         },
         
         /**
          * Checks if multiple shapes are selected. If more than one shape is selected, disable color hinter.
          * If no nodes are selected, disable the background color button.
          * @param {ORYX.Core.Shape[]} shapes
          */
         handleMultipleShapesSelected : function(shapes, nodes, labels, backgroundIds, borderIds) {
        	 if (!shapes) {
        		 shapes = this.facade.getSelection();
        	 }
        	 if (!nodes) {
        		 nodes = this.getNodes(shapes);	 
        	 }
        	 if (!labels) {
        		 labels = this.getLabels(shapes);	 
        	 }
    		 if (!backgroundIds) {
    			 backgroundIds = this.getBackgroundIds(shapes);	 
    		 }
    		 if (!borderIds) {
    			 borderIds = this.getBorderIds(shapes);
    		 }
    		 
    		 // Check if all selected nodes share the same border color, if so, display the color hint box
    		 var borderIsSet = this.checkForBorderColorCapability(shapes, labels, borderIds);
    		 if (!borderIsSet) {
    			 this.removeBorderColorHint();
    		 }
    		 
        	 // Check if all selected nodes share the same background color, if so, display the color hint box
    		 var backgroundIsSet = this.checkForBackgroundCapability(shapes, nodes, labels, backgroundIds);
    		 if (!backgroundIsSet) {
    			 this.removeBackgroundColorHint();
    		 }
    		 
    		 // Check if all selected shapes share the same font color, if so, display the font color hint box
    		 var fontColorIsSet = this.checkForRichtextCapability(shapes, nodes, labels, backgroundIds);
    		 if (!fontColorIsSet) {
    			 this.removeColorHint();
    		 }
    		 
    		 // Sets the values of the style buttons to default/fit the styles from the selection
    		 this.hideValuesOfStyleButtons(shapes, labels, false);	 
    		 
    		 if (nodes.length === 0) {
    			 this.disableButton('bgColorButton');	
    		 } else if (nodes.length === 1) {
    			 this.enableButton('bgColorButton');
    		 }
    		 
    		 this.enableUtilityButtons();
         },
         
         /**
          * If no node is selected, disable the button for the background color.
		  * If one node is selected but it has no background property, disable the button as well.
		  * @param {ORYX.Core.Shape[]} shapes
          * @param {ORYX.Core.Node[]} nodes
          * @param {Array} labels
          * @param {String[]} backgroundIds
          * @param {String} shapeId
          */
         checkForBackgroundCapability : function(shapes, nodes, labels, backgroundIds) {
        	 if (!shapes) {
        		 shapes = this.facade.getSelection();
        	 }
        	 if (!nodes) {
        		 nodes = this.getNodes(shapes);	 
        	 }
        	 if (!labels) {
        		 labels = this.getLabels(shapes);	 
        	 }
    		 if (!backgroundIds) {
    			 backgroundIds = this.getBackgroundIds(shapes);	 
    		 }
        	
    		 nodes = nodes.findAll(function(node) {
	    		 return node instanceof ORYX.Core.Node &&
	    		 		node.getStencil().properties().find(function(property) {
	    		 			return property.isBackgroundColor() && !property.readonly();
	    		 		});
	    	 });
    		 
    		 if (nodes.length === 0 ||
    				 nodes.length === 1 && backgroundIds[nodes[0].getId()] === undefined) {
    			 	// Disable the background color button
    			 	this.disableButton('bgColorButton');
    			 	return false;
    		 } else {
    			 var color = this.getColor(nodes[0], backgroundIds);
    			 if (nodes.length > 1 && nodes.without(nodes[0]).find(function(node) {
    				 	return color !== this.getColor(node, backgroundIds);
    			 	}.bind(this))) {
    				 	color = undefined;
    			 }
    			 // Enable the background color button
    			 this.enableButton('bgColorButton');

        		 // Display the background color hint box in case a background color is defined
    			 if (color) {
    				 // Apply the color to the background color hint box
    				 this.setColorToHintBox(this.backgroundColorHint, color);
    				 // Display the background color hint box
    				 if (!this.backgroundColorHint.parentNode) {
    					 this.showBackgroundColorHint(); 
    				 }
    				 return true;
    			 }
    			 return false;
    		 }
         },
         
         /**
          * If no node is selected, disable the button for the border color.
		  * If one node is selected but it has no border property, disable the button as well.
		  * @param {ORYX.Core.Shape[]} shapes
          * @param {Array} labels
          * @param {String[]} borderIds
          * @param {String} shapeId
          */
         checkForBorderColorCapability : function(shapes, labels, borderIds) {
        	 if (!shapes) {
        		 shapes = this.facade.getSelection();
        	 }
        	 if (!labels) {
        		 labels = this.getLabels(shapes);	 
        	 }
    		 if (!borderIds) {
    			 borderIds = this.getBorderIds(shapes);	 
    		 }
        	
    		 shapes = shapes.findAll(function(shape) {
	    		 return shape.getStencil().properties().find(function(property) {
	    		 			return property.isBorderColor() && !property.readonly();
	    		 		});
	    	 });
    		 
    		 if (shapes.length === 0 ||
    				 shapes.length === 1 && borderIds[shapes[0].getId()] === undefined) {
    			 	// Disable the background color button
    			 	this.disableButton('borderColorButton');
    			 	return false;
    		 } else {
    			 var color = this.getColor(shapes[0], borderIds);
    			 if (shapes.length > 1 && shapes.without(shapes[0]).find(function(shape) {
    				 	return color !== this.getColor(shape, borderIds);
    			 	}.bind(this))) {
    				 	color = undefined;
    			 }
    			 // Enable the background color button
    			 this.enableButton('borderColorButton');

        		 // Display the background color hint box in case a background color is defined
    			 if (color) {
    				 // Apply the color to the background color hint box
    				 this.setColorToHintBox(this.borderColorHint, color);
    				 // Display the background color hint box
    				 if (!this.borderColorHint.parentNode) {
    					 this.showBorderColorHint(); 
    				 }
    				 return true;
    			 }
    			 return false;
    		 }
         },
         
         /**
          * If no label exists which richtext attributes could be set, disable all richtext style buttons in the toolbar.
		  * @param {ORYX.Core.Shape[]} shapes
          * @param {ORYX.Core.Node[]} nodes
          * @param {Array} labels
          * @param {String[]} backgroundIds
          * @param {String} shapeId
          * @returns {Boolean} whether all selected shapes share the same font color or not
          */
         checkForRichtextCapability : function(shapes, nodes, labels, backgroundIds) {
        	 if (!shapes) {
        		 shapes = this.facade.getSelection();
        	 }
        	 if (!nodes) {
        		 nodes = this.getNodes(shapes);	 
        	 }
        	 if (!labels) {
        		 labels = this.getLabels(shapes);	 
        	 }
    		 if (!backgroundIds) {
    			 backgroundIds = this.getBackgroundIds(shapes);	 
    		 }
        	 
    		 // If no label exists, disable the richtext toolbar buttons
    		 if (labels.length === 0) {
    			 
    			 // Disables all richtext style buttons except for the background color button
    			 this.disableRichtextButtons();
    			 return false;
    		 } else {
    			 var color = labels[0].getFill();
    			 if (labels.length > 1 && labels.without(labels[0]).find(function(label) {
 				 		return color !== label.getFill();
 			 		}.bind(this))) {
 				 		color = undefined;
    			 }
    			 // Enables all richtext style buttons except for the background color button
    			 this.enableRichtextButtons();
    			 
	        	 if (color) {
	        		 // Apply the color to the font color hint box
    	        	 this.setColorToHintBox(this.fontColorHint, color);
    	        	 // Display the font color hint box
    	        	 if (!this.fontColorHint.parentNode){
    	        		 this.showColorHint();
    	        	 }
    	        	 // set the value of the toolbar buttons to display the current styling
            		 this.setValuesOfStyleButtons(shapes, labels);

    	        	 return true;
    	         }
	        	 // set the value of the toolbar buttons to display the current styling
        		 this.setValuesOfStyleButtons(shapes, labels);
        		 return false;
    		 }
         },
         
         /**
          * Enables a given Button. If the button is a color button, show the according color hinter. 
          * @param {String} button
          */
         enableButton : function(button) {
        	 if(button && this.buttons[button]) {
	        	 this.buttons[button].buttonInstance.setPreventFromEnable(false);
	        	 this.buttons[button].buttonInstance.enable();
	        	 if (button === 'colorButton') {
	        		 this.setColorToHintBox(this.fontColorHint, '');
	        		 this.showColorHint();
	        	 } else if (button === 'bgColorButton') {
	        		 this.setColorToHintBox(this.backgroundColorHint, '');
	        		 this.showBackgroundColorHint();
	        	 } else if (button === 'borderColorButton') {
	        		 this.setColorToHintBox(this.borderColorHint, '');
	        		 this.showBorderColorHint();
	        	 }
        	 }
         },
        
         /**
          * Disables a given Button. If the button is a color button, hide the according color hinter. 
          * @param {String} button
          */
         disableButton : function(button) {
        	 if (button && this.buttons[button]) {
        		 this.buttons[button].buttonInstance.setPreventFromEnable(true);
            	 this.buttons[button].buttonInstance.disable();
            	 if (button === 'colorButton') {
            		 this.removeColorHint();
            	 } else if (button === 'bgColorButton') {
            		 this.removeBackgroundColorHint();
            	 }	 
        	 }
         },
        
         
         /**
          * Disables the richtext buttons except the background color button
          */
         disableRichtextButtons : function() {
    		 this._richtextButtons.each(function(button) {
    			 this.disableButton(button);
    		 }.bind(this));
         },
         
         /**
          * Enables the richtext buttons except the background color button
          */
         enableRichtextButtons : function() {
        	 this._richtextButtons.each(function(button) {
    			 this.enableButton(button);
    		 }.bind(this));
         },

         enableUtilityButtons : function() {
        	 this._utilityButtons.each(function(button) {
        		 this.enableButton(button);
        	 }.bind(this));
         },
         
         /**
          * Collapses and resets a given combo box
          */
         resetComboBox : function(box) {
        	 if (box) {
        		 box.buttonInstance.collapse();
        		 box.buttonInstance.reset();	 
        	 }
         },
         
         /**
          * If selection exists, display color hint boxes
          * @param {ORYX.Core.Shape[]} The current selection
          */
         setValuesOfStyleButtons : function(shapes, labels) {
    		 // Get the labels
        	 if (!labels) {
        		 var labels = this.getLabels(shapes);
        	 }
    		 // If selection exists and no shape is being edited
    		 // Display the current styling by setting the toolbar buttons to the current styles
    		 this.isChanging = true;
    		 
    		 if (labels.length > 0){
//    		 this.fontBox.buttonInstance.setValue(labels[0].getFont());
    			 this.setFontSizeDisplayText(shapes, labels);
	    		 this.buttons.boldButton.buttonInstance.toggle(labels[0].getBold());
	    		 this.buttons.italicButton.buttonInstance.toggle(labels[0].getItalic());
    		 } else {
	    		 this.buttons.fontSizeBox.buttonInstance.setValue(12);
	    		 this.buttons.boldButton.buttonInstance.toggle(false);
	    		 this.buttons.italicButton.buttonInstance.toggle(false);
    		 }
    		 delete this.isChanging;
         },
         
         /**
          * If no selection exists, hide the color hint boxes, if styles are being copied, prevent the copy button from
    	  * being disabled.
    	  * @param {Boolean} resetAll If true, all style buttons are resetted to their default values. If false, only
    	  * font size and color buttons are resetted.
          */
         hideValuesOfStyleButtons : function(shapes, labels, resetAll) {
        	 // If in copy style mode, prevent the copy style button from being disabled
        	 if (this.isCopyingStyles) {
    			 this.buttons.copyStyleButton.buttonInstance.setPreventFromDisable(true);
    		 } else {
    			 this.buttons.copyStyleButton.buttonInstance.setPreventFromDisable(false);
    		 }

    		 this.isChanging = true;

    		 // Set display text of the font size combo box to either the shared font size or ' '
    		 this.setFontSizeDisplayText(shapes, labels);
			 
    		 // Reset all buttons
			 if (resetAll) {
				 this.buttons.boldButton.buttonInstance.toggle(false);
				 this.buttons.italicButton.buttonInstance.toggle(false);
    		 }
    		 delete this.isChanging;
         },
         
         /**
          * Sets the display text for the font size combo box
          * @param {ORYX.Core.Shape[]} shapes
          * @param {ORYX.Core.Label[]} labels
          */
         setFontSizeDisplayText : function(shapes, labels) {
        	 // Get the labels
        	 if (!labels) {
        		 var labels = this.getLabels(shapes);	 
        	 }
        	 var value = ' ';
        	 switch(shapes.length) {
        		 // Case: nothing selected: display nothing
        		 case 0 : 	break;
        		 // Case: one shape selected: display font size of the label
        		 case 1 :	if (labels.length > 0) {
			        			value = labels[0].getFontSize();
			        		}
        			 		break;
        		 // Else display font size if all selected shapes share the same font size or nothing if not
        		 default:	if (labels.length > 0) {
        			 			value = labels[0].getFontSize();
        			 			if (labels.without(labels[0]).find(function(label) {
            		 				return label.getFontSize() !== value;
            		 			})) {
            		 				value = ' ';
            		 			}
        		 			}
        		 			break;
        	 }
        	 // Set the new value to the font size box
        	 this.buttons.fontSizeBox.buttonInstance.setValue(value);
         },
         
         /**
          * Returns a ComboBox containing the possible font sizes to select. 
          * @returns {Ext.form.ComboBox}
          */
         getFontSizeComboBox : function() {
        	 // The store containing all possible font sizes
        	 var sizeStore = new Ext.data.SimpleStore({
        		 fields		: ['value', 'displayName'],
        		 data		: [
        		     		   ['8', 8],['9', 9],['10', 10],['11', 11],['12', 12],['14', 14],
        		     		   ['18', 18],['20', 20],['24', 24],['36', 36],['48', 48],['72', 72]
        		     		  ]
        	 });
        	 
        	 return new Ext.ux.form.ComboBox({
        		 mode			: 'local',
        		 tooltip		: Signavio.I18N.Richtext.fontSizeDesc,
    			 tooltipType	: 'title',
        		 store			: sizeStore,
        		 displayField	: 'displayName',
        		 mode			: 'local',
        		 triggerAction	: 'all',
        		 emptyText		: '12',
        		 editable		: false,
        		 disableKeyFilter: true,
        		 forceSelection : true,
        		 width			: 40,
        		 height			: 18,
        		 listWidth		: 25,
        		 iconCls		: 'no-icon',
	        	 cls			: Ext.isChrome ? 'y-richtext-combobox-chrome' : 'y-richtext-combobox',
	        	 ctCls			: (Ext.isIE9 ? 'y-richtext-combobox-ct-ie9' : 'y-richtext-combobox-ct') + ' y-richtext-toolbar-button',
        		 listeners		: {
 									"select" : function(combo, entry) {
 							    		 this.changeFont(combo, 'FontSize', entry.data.value);
 									}.bind(this)
 	        					}
        	 });
         },
         
         /**
          * Returns a ComboBox containing the possible fonts to select. 
          * @returns {Ext.form.ComboBox}
          */
         getFontComboBox: function() {
        	 // The store containing all possible fonts
         	 var fontStore = new Ext.data.SimpleStore({
	    		 fields: ['font', 'displayName'],
	    		 data : [
	    		         ['Arial', 'Arial'],
	    		         ['Courier New', 'Courier New'],
	    		         ['Helvetica', 'Helvetica'],
	    		         ['Tahoma', 'Tahoma'],
//	    		         ['Times New Roman', 'Times New Roman'],
	    		         ['Verdana', 'Verdana']
	    		        ]
	    	 });
			
			return new Ext.form.ComboBox({
		        store			: fontStore,
		        displayField	: 'displayName',
		        mode			: 'local',
	        	triggerAction	: 'all',
	        	emptyText		: Signavio.I18N.Richtext.selectFont,
	        	selectOnFocus	: true,
	        	width			: 135,
	        	listWidth		: 120,
	        	iconCls			: 'no-icon',
	        	tpl				: '<tpl for="."><div style="font-family:{font}" class="x-combo-list-item">{displayName}</div></tpl>',
	        	listeners		: {
									"select" : function(combo, entry) {
							    		 this.changeFont(combo, 'Font', entry.data.font);
									}.bind(this)
	        					}
			});
         },

         /**
          * Returns a div container for the color hint
          * @returns {Array} the raw Array to graft a new div container
          */
         getColorHint : function(){
        	 return ["div", {	
    			 "class"	: Ext.isIPad ? 'y-richtext-color-hint-ipad' : Ext.isOpera ? 'y-richtext-color-hint-opera' : 'y-richtext-color-hint'
    		 }
    		];
         },
         
         /**
          * Returns a div representing the default color
          * @param {String} color
          * @returns {Array} the raw Array to graft a new div container
          */
         getColorBox : function(color) {
        	 return ["div", {
        		 "class"	: 'y-richtext-color-box',
        		 style		: 'background: none repeat scroll 0 0 ' +color+ ';'
        	 }
        	];
         },
         
         /**
          * Hides the color hint div boxes
          */
         hideColorHints : function() {
    		 this.removeColorHint();
    		 this.removeBackgroundColorHint();
    		 this.removeBorderColorHint();
         },
         
         /**
          * Adds the color hint box to the color button
          */
         showColorHint : function() {
        	 this.buttons.colorButton.buttonInstance.el.dom.parentNode.appendChild(this.fontColorHint);
         },
        
         /**
          * Removes the color hint box from the color button
          */
         removeColorHint : function() {
        	 if (this.fontColorHint.parentNode) {
        		 this.buttons.colorButton.buttonInstance.el.dom.parentNode.removeChild(this.fontColorHint); 
        	 }
         },
         
         /**
          * Adds the color hint box to the backgroundcolor button
          */
         showBackgroundColorHint : function() {
        	 this.buttons.bgColorButton.buttonInstance.el.dom.parentNode.appendChild(this.backgroundColorHint);
         },
          /**
          * Removes the color hint box from the background color button
          */
         removeBackgroundColorHint : function() {
        	 if (this.backgroundColorHint.parentNode) {
        		 this.buttons.bgColorButton.buttonInstance.el.dom.parentNode.removeChild(this.backgroundColorHint);
        	 }
         },
         
         /**
          * Adds the color hint box to the backgroundcolor button
          */
         showBorderColorHint : function() {
        	 this.buttons.borderColorButton.buttonInstance.el.dom.parentNode.appendChild(this.borderColorHint);
         },
          /**
          * Removes the color hint box from the background color button
          */
         removeBorderColorHint : function() {
        	 if (this.borderColorHint.parentNode) {
        		 this.buttons.borderColorButton.buttonInstance.el.dom.parentNode.removeChild(this.borderColorHint);
        	 }
         },
         
         /**
          * Applies a given color to a specific color hint div container
          * @param box
          * @param {String} color
          */
         setColorToHintBox : function(box, color) {
        	 if (box && box.style && color)
        		 box.style.background = "none repeat scroll 0% 0% "+color;
         },
         
         /**
          * Changes the font of the selected shapes to the desired font
          * @param {Ext.form.ComboBox} combo The comboBox
          * @param {String} attribute The font attribute to change
          * @param {String} value The value to set
          */
	     changeFont : function(combo, attribute, value, foo, toggled) {
	    	 
	    	 if (this.isChanging){
	    		 return;
	    	 }
	    	 // Get the selected shapes
	    	 var shapes = this.facade.getSelection();
    		 // Get the labels
	    	 var labels = this.getLabels(shapes);
    		 // If selection exists and no shape is being edited
	    	 if (labels.length > 0 && shapes.length > 0 && !shapes.find(function(shape) {
	        	 return shape.editing;
	         })) {
	    		 var oldValues = {}, newValues = {};
        		 // Set the new labels
        		 labels.each(function(label) {
        			 var styles = label.getStyle();
        			 oldValues[label.id] = label['get'+attribute]();
	    			 newValues[label.id] = (['bold', 'italic'].include(value) ? toggled : value);	 
	             }.bind(this));
        		 // Execute the command
        		 this.executeStyle(shapes, labels, attribute, oldValues, newValues, true);
        	 };
        	 if (attribute === 'Fill') {
        		 this.setColorToHintBox(this.fontColorHint, value);
        	 }
	     },
	     
	     /**
	      * Returns all labels which are rendered to the shape
	      * @param {ORYX.Core.Shape[]} shapes
	      * @returns {ORYX.Core.Label[]}
	      */
	     getLabels : function(shapes) {
	    	 // Get all labels from the shapes
	    	 return shapes.map(function(shape){
	    		 var labels = shape.getLabels();
	    		 var allRefToViews = shape.getStencil().properties().invoke("refToView").flatten();
	    		 
	    		 // For performance reasons, return first label if only 
	    		 // one is defined (~90% of all shapes), otherwise return
	    		 // the first label with a property which has a 
	    		 // ref to view defined.
	    		 
	    		 // Phil G: Nice performance. Took me about an hour to figure
	    		 // out, why only the color of the first label of a shape
	    		 // changed... Thanks!
	    		 return labels.findAll(function(label) {
	    			 return allRefToViews.any(function(ref){
	    				 return label.id == shape.id+ref;
	    			 });
	    		 });
	    	 }).flatten().compact();
	     },

	     /**
	      * Returns all ids of the given shapes which are holding information about the background color.
	      * @param {ORYX.Core.Shape[]} shapes
	      * @returns {String[]} The ids.
	      */
	     getBackgroundIds : function(shapes) {
	    	// Get all labels from the shapes
	    	var ids = [];
	    	shapes.each(function(shape) {
    			var shapeId = shape.getId(), bgid; 
	    		var bg = shape.getStencil().properties().find(function(property) {
    				return property.isBackgroundColor() && !property.readonly();
    			});
	    		if (bg) {
	    			bgid = bg.id();
	    		}
	    		return ids[shapeId] = bgid;
    		});
	    	return ids;
	     },
	     
	     /**
	      * Returns all ids of the given shapes which are holding information about the border color.
	      * @param {ORYX.Core.shape[]} shapes
	      * @returns {String[]} The ids.
	      */
	     getBorderIds : function(shapes) {
	    	 var ids = [];
	    	 shapes.each(function(shape) {
	    		var shapeId = shape.getId(), bid;
	    		var b = shape.getStencil().properties().find(function(property) {
	    			return property.isBorderColor() && !property.readonly();
	    		});
	    		if (b) {
	    			bid = b.id();
	    		}
	    		return ids[shapeId] = bid;
	    	 });
	    	 return ids;
	     },
	     
	     /**
	      * Returns the texts of the given Labels
	      * @param {ORYX.Core.Label} labels
	      * @returns {Object}
	      */
	     getTexts : function(labels) {
	    	 var texts = {};
	    	 labels.each(function(label) {
	    		texts[label.id] = label.text(); 
	    	 });
	    	 return texts;
	     },
	     
	     /**
	      * Returns all shapes which are instances of ORYX.Core.Node (filters all edges)
	      * @param {ORYX.Core.Shape[]} shapes
	      * @returns (ORYX.Core.Node[]) The nodes
	      */
	     getNodes : function(shapes) {
	    	 return shapes.findAll(function(shape) {
	    		return shape instanceof ORYX.Core.Node; 
	    	 });
	 	 },
	     
	 	 /**
	 	  * Function to call after changing a style of a shape/label to provide undo/redo functionality
	 	  * @param {ORYX.Core.Shape[]} shapes The shapes that were changed
	 	  * @param {ORYX.Core.Label[]} labels The labels that were changed
	 	  * @param {String} attribute The attribute which were changed
	 	  * @param {String[][]} oldValues The old values
	 	  * @param {String[][]} newValues The new values
	 	  * @param {Boolean} force Set true to force updating the label
	 	  * @param {Object[shapeId]} shapeChangeIds The keys of the changed properties of the according shapes  
	 	  * @param {Boolean} shapeChanges Set true to ensure shapechanges are handled
	 	  */
	 	 executeStyle : function(shapes, labels, attribute, oldValues, newValues, force, shapeChangeIds, shapeChanges) {
	    	 if (oldValues !== newValues) {
	    		 var facade = this.facade;
	    		 // Implement the specific command for property change
	    		 var CommandClass = ORYX.Core.Command.extend({
	    			 construct: function() {
	    				 this.force = force;
	    				 this.facade = facade;
	    				 this.shapes = shapes;
	    				 this.labels = labels;
	    				 this.attribute = attribute;
	    				 this.oldValues = oldValues;
	    				 this.newValues = newValues;
	    				 this.shapeChangeIds = shapeChangeIds;
	    				 this.shapeChanges = shapeChanges;
	    			 },

	    			 execute: function(){
	    				 // Apply changes to the labels
			    		 if (this.labels) {
		    				 this.labels.each(function(label) {
		    					 label['set'+this.attribute](this.newValues[label.id]);
		    					 label.update(this.force);
		    				 }.bind(this));
		    				  
	    				 }
	    				 
	    				 // Apply changes to the shapes
	    				 if (this.shapeChanges && this.shapes instanceof Array) {
	    					 this.shapes.each(function(shape) {
	    						 // Get the id of the shape
	    						 var id = shape.getId();
	    						 // If there are changes for the given shape, set the new values
	    						 if (this.newValues[id] && this.newValues[id] !== undefined && this.shapeChangeIds[id] instanceof Array) {
	    							 // Get the value of the changed property by iterating over all changed properties of the current shape
	    							 this.shapeChangeIds[id].each(function(propId) {
	    								 shape.setProperty("oryx-"+ propId, (this.newValues[shape.id][propId] === 'none' ? '' : this.newValues[shape.id][propId]));
	    							 }.bind(this));
	    						 }
	    					 }.bind(this));
	    				 }
	    				
	    				 if (this.executeAgain) {
	    					 this.facade.setSelection(shapes);
	    					 this.facade.getCanvas().update();
	    					 this.facade.updateSelection();
	    				 } else {
	    					 this.facade.getCanvas().update();
	    				 }
	    				 this.executeAgain = true;
					},
					
					rollback: function(){
						// For each label, find it's corresponding shape
						if (this.labels) {
							this.labels.each(function(label) {
								label['set'+this.attribute](this.oldValues[label.id]);
								label.update(this.force);
							}.bind(this));
						}
						
						// Rollback changes of the shapes
	    				if (this.shapeChanges && this.shapes instanceof Array) {
	    					this.shapes.each(function(shape) {
	    						// Get the id of the shape
	    						var id = shape.getId();
	    						// If there were changes for the given shape, set the old values
	    						if (oldValues[id] && oldValues[id] !== undefined && this.shapeChangeIds[id] instanceof Array) {
	    							// Get the value of the changed property by iterating over all changed properties of the current shape
	    							this.shapeChangeIds[id].each(function(propId) {
	    								shape.setProperty("oryx-"+ propId, (this.oldValues[shape.id][propId] === 'none' ? '' : this.oldValues[shape.id][propId]));
	    							}.bind(this));
	    						}
	    					}.bind(this));
	    				}
	    				
						this.facade.setSelection(shapes);
						this.facade.getCanvas().update();
						this.facade.updateSelection();
					}
	    		 });
	    		 // Instanciated the class
	    		 var command = new CommandClass();
					
				// Execute the command
				this.facade.executeCommands([command]);
	    	 }
	     },
	     
	     /**
	      * Replaces the value of a given style tag
	      * @param {String} styles The styles string
	      * @param {String} style The style tag which value should be replaced
	      * @param {String} value The new value
	      * @returns modified styles string
	      */
	     _replaceStyle : function(styles, attribute, value) {
	    	 //	attribute = "font-style"; value = "italic" matches "font-weight:normal;font-style:normal;" and replaces normal with italic
	    	 return styles.replace(new RegExp(""+attribute+":[^;]+;", "gi"), attribute+":"+value+";");
	     },
	     
	     /**
	      * Displays a color picker menu to determine the color to set.
	      * @param button
	      */
	     changeColor : function(callback, colortype, button, toggled) {
	    	 // delete any other previous opened color menu
	    	 if (this.colorMenu) {
        		 this.colorMenu.destroy();
        		 delete this.colorMenu;
        	 }
	    	 
	    	 if (toggled) {
	    		 	 
        		 // Get the selection
    	    	 var shapes = this.facade.getSelection();
    			 if (shapes.length > 0) {
    				 var defaultColor = (colortype === 'BackgroundColor' ?
						 					this.getDefaultBackgroundColor(shapes[0], (this.getBackgroundIds(shapes))||[]) :
						 				colortype === 'BorderColor' ? 
						 					this.getDefaultBorderColor(shapes[0], (this.getBorderIds(shapes))||[]) :
					 					'#000000'
    				 );
    				 
    				 // Get the div to display the color hint
    				 var colorDiv = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", undefined, this.getColorBox(defaultColor));
    				 // Define the color menu
    				 this.colorMenu = new Ext.menu.ColorMenu({
    					 cls				: "y-richtext-color-menu",
    		    		 allowOtherMenus	: false,
    		    		 items				: [
    		    		      				   {
    		    		      					   // Add button for default color
    		    		      					   text: Signavio.I18N.Richtext.defaultColor,
    		    		      					   cls	: 'y-richtext-color-menu-default-color-button',
    		    		      					   listeners : {
    		    		      						   "render" : function(button, event) {
    			    		      						   button.el.dom.appendChild(colorDiv);
    		    		      						   }.bind(this)
    		    		      					   }
    		    		      				   }, '-'
    		    		      				  ]
    		    	 });
    		    	 
    		    	 this.colorMenu.on("itemclick", function(item, event) {
    		    		 callback(item.component ? "#"+item.component.value : defaultColor);
    		    		 delete this.colorMenu;
    		    	 }.bind(this));
    		    	 
    		    	 this.colorMenu.show(button.el, "tl-bl?");	 
    			 }
        	 }
	     },
	     
	     /**
	      * Handles clicking on background color button.
	      * @param foo
	      * @param {String} attribute The attribute to set
	      * @param {String} value The new color
	      */
	     setBackgroundColor : function(foo, attribute, value) {
	    	 // Get all shapes which have a background color property 
	    	 var shapes = this.facade.getSelection().findAll(function(shape) {
	    		 return shape instanceof ORYX.Core.Node &&
	    		 		shape.getStencil().properties().find(function(property) {
	    		 			return property.isBackgroundColor() && !property.readonly();
	    		 		});
	    	 });
	    	 var backgroundIds = this.getBackgroundIds(shapes);
	    	 var oldValues = [], newValues = [], shapeChangeIds = [];
	    	 shapes.each(function(shape) {
	    		 var id = shape.getId() || shape.id;
	    		 var bgid = backgroundIds[id];
	    		 
	    		 oldValues[id] = [];
    			 newValues[id] = [];
    			 
	    		 oldValues[id][bgid] = shape.properties["oryx-"+bgid];
	    		 newValues[id][bgid] = value;
	    		 shapeChangeIds[id] = [bgid];
	    	 }.bind(this));
	    	 // Sets the new color to the background color hint box
	    	 this.setColorToHintBox(this.backgroundColorHint, value);
	    	 
	    	 this.executeStyle(shapes, [], attribute, oldValues, newValues, true, shapeChangeIds, true);
	     },
	     
	     /**
	      * Handles clicking on border color button.
	      * @param foo
	      * @param {String} attribute The attribute to set
	      * @param {String} value The new color
	      */
	     setBorderColor : function(foo, attribute, value) {
	    	 // Get all shapes which have a border color property
	    	 var shapes = this.facade.getSelection().findAll(function(shape) {
	    		 return shape.getStencil instanceof Function && shape.getStencil().properties().find(function(property) {
 		 			return property.isBorderColor() && !property.readonly();
 		 		});
	    	 });
	    	 
	    	 // Get all currently selected pools
	    	 var selectedPools = shapes.findAll(function(shape) {
	    		 return shape.getStencil instanceof Function && 
	    		 	(shape.getStencil().idWithoutNs() === "Pool" ||
	    		 	 shape.getStencil().idWithoutNs() === "VerticalPool");
	    	 });
	    	 
	    	 // Filter all lanes from all selected pools, which have the default border color set
    	 	 selectedPools.each(function(pool) {
    	 		 var lanes = this.getLanesRecursively(pool).flatten().filter(function(lane) {
    	 			 if (!lane) return;
    	 			 // Get the border property
    	 			 var borderIds = this.getBorderIds([lane]);
    	 			 if (!borderIds) return;
    	 			 var id = (lane.id instanceof Function && lane.id() || lane.id);
    	 			 var bid = borderIds[id];
    	 			 
    	 			 var colorsToReplace = [pool.properties["oryx-"+bid], this.getDefaultBorderColor(lane, borderIds)];
    	 			 return colorsToReplace.include(lane.properties["oryx-"+bid]);
    	 		 }.bind(this)).compact();
    	 		 
    	 		 // Add the lanes to the shapes which should be altered
    	 		 shapes = shapes.concat(lanes);
    	 	 }.bind(this));
    	 	 shapes = shapes.flatten().compact().uniq();
	    
    	 	 var borderIds = this.getBorderIds(shapes);
	    	 var oldValues = [], newValues = [], shapeChangeIds = [];
	    	 shapes.each(function(shape) {
	    		 var id = shape.getId() || shape.id;
	    		 var bid = borderIds[id];
	    		 
	    		 oldValues[id] = [];
    			 newValues[id] = [];
    			 
	    		 oldValues[id][bid] = shape.properties["oryx-"+bid];
	    		 newValues[id][bid] = value;
	    		 shapeChangeIds[id] = [bid];
	    	 }.bind(this));
	    	 // Sets the new color to the background color hint box
	    	 this.setColorToHintBox(this.borderColorHint, value);
	    	 
	    	 this.executeStyle(shapes, [], attribute, oldValues, newValues, true, shapeChangeIds, true);
	     },
	     
	     /**
	      * Acquires and caches all styles from the current selection to apply them to other nodes/edges 
	      * @param button
	      * @param toggled
	      */
	     copyStyle : function(button, toggled) {
	    	 if (toggled) {
	    		 // Init values
	    		 var shapes = this.facade.getSelection();
		    	 var nodes = this.getNodes(shapes);
		    	 var labels = this.getLabels(shapes), bcolorToSet, bgcolorToSet;
		    	 this.styles = {};
	    		 var backgroundIds = this.getBackgroundIds(nodes);
	    		 var borderIds = this.getBorderIds(shapes);
	    		 
	    		 // For each shape, get the border color and determine if the new color != all old colors
	    		 shapes.each(function(shape) {
	    			 // Get the color
	    			 var color = this.getColor(shape, borderIds);
	    			 // Get the default color of the node
	    			 var defaultColor = this.getDefaultBorderColor(shape, borderIds);
	    			 // If the shape still has it's default border color, do nothing
	    			 if (color === defaultColor) {
	    				 color = "default";
	    			 }
	    			 
	    			 if (!bcolorToSet) {
	    				 bcolorToSet = color;
	    			 } else if (bcolorToSet === color) {
	    				 return;
	    			 } else if (bcolorToSet !== color) {
	    				 bcolorToSet = undefined;
	    				 throw $break;
	    			 }
	    		 }.bind(this));
	    		 
	    		 if (bcolorToSet) {
	    			 this.bcolorToSet = bcolorToSet;
	    		 }
	    		 
	    		 
	    		 // For each node, get the background color and determine, if the new color != all old colors
		    	 nodes.each(function(node) {
		    		 // Get the color of the node
		    		 var color = this.getColor(node, backgroundIds);
		    		 // Get the default color of the node
		    		 var defaultColor = this.getDefaultBackgroundColor(node, backgroundIds);
		    		 // If the node still has it's default color, do nothing
		    		 if (color === defaultColor) {
		    			 color = "default";
		    		 }
		    		 
		    		 if (!bgcolorToSet) {
		    			 bgcolorToSet = color;	 
		    		 } else if (bgcolorToSet === color) {
		    			 return;
		    		 } else if (bgcolorToSet !== color) {
		    			 bgcolorToSet = undefined;
		    			 throw $break;
		    		 }
		    	 }.bind(this));
		    	 if (bgcolorToSet) {
		    		 this.bgcolorToSet = bgcolorToSet;
		    	 }
		    	 
	    		 this.prevSelection = shapes;
	    		 var serializedLabels = labels.invoke("serialize");
		    	 var keys = $w("bold italic fill font size"), blacklist = [];
		    	 serializedLabels.each(function(serial) {
		    		 if (serial && serial.styles) {
		    			 keys.each(function(key) {
		    				if (blacklist.include(key)) {
		    					return;
		    				}
		    				if (serial.styles[key] && this.styles[key] && serial.styles[key] !== this.styles[key]) {
		    					blacklist.push(key);
		    					delete this.styles[key];
		    				} else if (serial.styles[key] && !this.styles[key]) {
		    					this.styles[key] = serial.styles[key];
		    				}
		    			 }.bind(this));
		    		 }
		    	 }.bind(this));
		    	 this.isCopyingStyles = true;
	    	 } else {
	    		 this.buttons.copyStyleButton.buttonInstance.setPreventFromDisable(false);
	    		 this.buttons.copyStyleButton.buttonInstance.disable();
	    		 delete this.prevSelection;
	    		 delete this.isCopyingStyles;
	    		 delete this.bcolorToSet;
	    		 delete this.bgcolorToSet;
	    		 delete this.styles;
	    	 }
	     },
	     
	     /**
	      * Clears the format of all selected shapes
	      */
	     clearFormat : function() {
	    	 var shapes = this.facade.getSelection();
	    	 var nodes = this.getNodes(shapes);
	    	 var labels = this.getLabels(shapes);
	    	 var colors = [], borderColors = [];
	    	 
	    	 // Get the ids of the border color properties of all selected shapes
	    	 var borderIds = this.getBorderIds(shapes);
	    	 
	    	 shapes.each(function(shape) {
	    		 var id = shape.getId() || shape.id;
	    		 // Get the default colors of all selected shape's borders, if no default color is defined, take black as the default value
	    		 borderColors[id] = this.getDefaultBorderColor(shape, borderIds);
	    	 }.bind(this));
	    	 
	    	 // Get the ids of the background properties of all selected shapes
	    	 var backgroundIds = this.getBackgroundIds(nodes);
	    	 nodes.each(function(node) {
	    		 var id = node.getId()||node.id;
	    		 // Get the default colors of all selected shapes, if no default color is defined, take white as the default value
	    		 colors[id] = this.getDefaultBackgroundColor(node, backgroundIds) || "none";
	    	 }.bind(this));

	    	 if (shapes.length > 0 && nodes.length > 0) {
		    	 // Set the color hint for text color to black
		    	 this.setColorToHintBox(this.fontColorHint, "black");
		    	 // Get the default background color and set it to the hint box
		    	 this.setColorToHintBox(this.backgroundColorHint, colors[nodes[0].getId()]);
	    	 }
	    	 
	    	 if (shapes.length > 0) {
	    		 // Get the default border color and set it to the hint box
	    		 this.setColorToHintBox(this.borderColorHint, borderColors[shapes[0].getId()]);
	    	 }
	    	 
	    	 // Apply default styles to all selected shapes
	    	 this.setNewStylesToSelection(shapes, nodes, labels, borderIds, backgroundIds, borderColors, colors, {});	 
	     },

	     /**
	      * Returns the current value of the 
	      * nodes with the given background ids.
	      * @param node
	      * @param backgroundIds
	      * @returns
	      */
	     getColor : function(node, backgroundIds) {
	    	 var id = node.getId() || node.id;
	    	 if (id && backgroundIds[id]){
	    		 return node.properties["oryx-"+backgroundIds[id]]; 
	    	 } else {
	    		 return undefined;
	    	 }
	     },
	     
	     /**
	      * Returns the default value of the 
	      * nodes with the given background ids.
	      * @param node
	      * @param backgroundIds
	      * @returns
	      */
	     getDefaultBackgroundColor : function(node, backgroundIds) {
	    	 var id = node.getId() || node.id;
	    	 if (id && backgroundIds[id]){
	    		 var prop = node.getStencil().property("oryx-"+backgroundIds[id]);
	    		 return prop ? prop.value() : undefined;
	    	 }
	    	 return undefined;
	     },
	     
	     /**
	      * Returns the default value of the
	      * nodes with the given border ids
	      * @param shape
	      * @param borderIds
	      * @returns
	      */
	     getDefaultBorderColor : function(shape, borderIds) {
	    	 var id = shape.getId() || shape.id;
	    	 if (id && borderIds[id]) {
	    		 var prop = shape.getStencil().property("oryx-"+borderIds[id]);
	    		 return prop ? prop.value() : undefined;
	    	 }
	    	 return undefined;
	     },
	     
	     getRichtextButtons : function() {

             // The combo box to select the font
//             this.fontBox = {
//                 name		: Signavio.I18N.Richtext.font,
//                 isComboBox : true,
//                 comboBox	: this.getFontComboBox.bind(this),
//                 ctCls		: 'y-richtext-toolbar-button',
//                 keepFocus	: true,
//                 group		: 'richtext',
//                 index		: 1,
//                 minShape	: 1
//             };
             return {
                 // The combo box to select the font size
                 fontSizeBox : {
                     name		: Signavio.I18N.Richtext.fontSize,
                     isComboBox : true,
                     comboBox	: this.getFontSizeComboBox.bind(this),
                     ctCls		: 'y-horizontal-menu-button',
                     keepFocus	: true,
                     group		: 'richtext',
                     index		: 2,
                     minShape	: 1
                 },
                 // The button for bold
                 boldButton : {
                     name			: Signavio.I18N.Richtext.bold,
                     icon			: ORYX.CONFIG.EXPLORER_PATH + "/src/img/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-bold.png",
                     functionality	: this.changeFont.bind(this, undefined, 'Bold', 'bold'),
                     toggle			: true,
                     ctCls			: 'y-horizontal-menu-button',
                     group			: 'richtext',
                     index			: 3,
                     minShape		: 1,
                     description	: Signavio.I18N.Richtext.boldDesc
                 },
                 // The button for italic
                 italicButton : {
                     name			: Signavio.I18N.Richtext.italic,
                     icon			: ORYX.CONFIG.EXPLORER_PATH + "/src/img/fugue/icons"+ (Ext.isIPad ? '/24x24' : '') + "/edit-italic.png",
                     functionality	: this.changeFont.bind(this, undefined, 'Italic', 'italic'),
                     toggle			: true,
                     ctCls			: 'y-horizontal-menu-button',
                     group			: 'richtext',
                     index			: 4,
                     minShape		: 1,
                     description	: Signavio.I18N.Richtext.italicDesc
                 },
                 // The font color
                 colorButton : {
                     name			: Signavio.I18N.Richtext.color,
                     icon			: ORYX.CONFIG.EXPLORER_PATH + "/src/img"+ (Ext.isIPad ? '/fugue/new/24x24/color.png' : '/fugue/new/edit-color.png'),
                     functionality	: this.changeColor.bind(this, this.changeFont.bind(this, undefined, "Fill"), "Fill"),
                     keepFocus		: true,
                     toggle			: true,
                     toggleGroup	: 'colorToggle',
                     ctCls			: 'y-horizontal-menu-button',
                     group			: 'richtext',
                     index			: 5,
                     minShape		: 1,
                     description	: Signavio.I18N.Richtext.colorDesc
                 },
                 // The border color
                 borderColorButton : {
                	 name			: Signavio.I18N.Richtext.bordercolor,
                     icon			: ORYX.CONFIG.EXPLORER_PATH + "/src/img" + (Ext.isIPad ? '/famfamfam/24x24/pencil.png' : '/fugue/new/pencil-color.png'),
                     functionality	: this.changeColor.bind(this, this.setBorderColor.bind(this, undefined, "BorderColor"), "BorderColor"),
                     keepFocus		: true,
                     toggle			: true,
                     toggleGroup	: 'colorToggle',
                     ctCls			: 'y-horizontal-menu-button',
                     group			: 'richtext',
                     index			: 6,
                     minShape		: 1,
                     description	: Signavio.I18N.Richtext.borderColorDesc
                 },
                 // The background color
                 bgColorButton : {
                     name			: Signavio.I18N.Richtext.bgcolor,
                     icon			: ORYX.CONFIG.EXPLORER_PATH + "/src/img" + (Ext.isIPad ? '/famfamfam/24x24/paintcan.png' : '/fugue/new/paint-can-color.png'),
                     functionality	: this.changeColor.bind(this, this.setBackgroundColor.bind(this, undefined, "BackgroundColor"), "BackgroundColor"),
                     keepFocus		: true,
                     toggle			: true,
                     toggleGroup	: 'colorToggle',
                     ctCls			: 'y-horizontal-menu-button',
                     group			: 'richtext',
                     index			: 7,
                     minShape		: 1,
                     description	: Signavio.I18N.Richtext.bgcolorDesc
                 },
                 // The clear style button
                 clearButton : {
                     name			: Signavio.I18N.Richtext.clear,
                     icon			: ORYX.CONFIG.EXPLORER_PATH + "/src/img/fugue/icons" + (Ext.isIPad ? "/24x24" : '') + "/eraser.png",
                     functionality	: this.clearFormat.bind(this),
                     keepFocus		: true,
                     ctCls			: 'y-horizontal-menu-button',
                     group			: 'richtext',
                     index			: 8,
                     minShape		: 1,
                     description	: Signavio.I18N.Richtext.clearDesc
                 },
                 // The copy style button
                 copyStyleButton : {
            		 name			: Signavio.I18N.Richtext.copyStyle,
                     icon			: ORYX.CONFIG.EXPLORER_PATH + "/src/img/fugue/icons" + (Ext.isIPad ? "/24x24" : '') + "/broom.png",
                     functionality	: this.copyStyle.bind(this),
                     keepFocus		: true,
                     ctCls			: 'y-horizontal-menu-button',
                     toggle			: true,
                     group			: 'richtext',
                     index			: 9,
                     minShape		: 1,
                     description	: Signavio.I18N.Richtext.copyStyleDesc
                 }};
	     },
	     
	     handleSelectionChanged : function(event){
        	 if (event) {
        		 var shapes = event.elements;	 
        	 } else {
        		 var shapes = this.facade.getSelection();
        	 }
        	 var nodes = this.getNodes(shapes);
        	 var labels = this.getLabels(shapes);
        	 
        	 var borderIds = this.getBorderIds(shapes);
        	 var backgroundIds = this.getBackgroundIds(shapes);
        	 
        	 // If the selection changes, delete the color menu
        	 if (this.colorMenu) {
        		 this.colorMenu.destroy();
        		 delete this.colorMenu;
        		 this.buttons["colorButton"].buttonInstance.toggle(false);
        		 this.buttons["borderColorButton"].buttonInstance.toggle(false);
        		 this.buttons["bgColorButton"].buttonInstance.toggle(false);
        	 }
        	 
        	 if (this.richtextButton && this.richtextButton.menuConfig.toolbar && this.richtextButton.menuConfig.toolbar.rendered) {
        		// If the selection changes, collapse and reset the color size drop down menu
            	 if (this.buttons["fontSizeBox"].buttonInstance.isExpanded()) {
            		 this.resetComboBox(this.buttons["fontSizeBox"]);
            	 }
            	 
            	 // if no selection
            	 if (shapes.length === 0) {
            		 this.hideColorHints();
            		 this.hideValuesOfStyleButtons(shapes, labels, true);
            	 }
            	
            	 // if one selected and not in copy mode
            	 else if (shapes.length === 1 && !this.isCopyingStyles) {
            		 this.handleOneShapeSelected(shapes, nodes, labels, backgroundIds);
    	    	 }
            	 
            	 // If more than one shape selected and not in copy mode
            	 else if (shapes.length > 1 && !this.isCopyingStyles) {
            		 this.handleMultipleShapesSelected(shapes, nodes, labels, backgroundIds);
            	 }
            	 
            	 // If in copy mode and more than one shape selected
            	 else if (shapes.length > 0 && this.isCopyingStyles) {
            		 this.setNewStylesToSelection(shapes, nodes, labels, borderIds, backgroundIds);
            	 }
        	 }

        	 if (!$H(this.buttons).values()) {
        		 return;
        	 }
        	 // Show the Buttons
        	 $H(this.buttons).values().each((function(value){
        		 if (!value.buttonInstance){ // Check if there is a button
        			 return;
        		 }
        		 // Enable the button
        		 value.buttonInstance.enable();
        		 // If there is less elements than minShapes
        		 if(value.minShape && value.minShape > shapes.length)
        			 value.buttonInstance.disable();
        	 }).bind(this));
	    	
         },
	     
	     /**
	      * Applies a given styles object to all selected shapes. To override the exclusion of previous selected shapes,
	      * pass the ORYX.Core.node[] directly.
	      * Handles pools and lanes in a specific way. Lanes are forced to keep their style instead of applying a new one.
	      * @param @optional {ORYX.Core.Shape[]} shapes
	      * @param @optional {ORYX.Core.Node[]} nodes
	      * @param @optional {String[]} backgroundIds
	      * @param {String[]} colors
	      * @param {Object} clearFormat An empty Object
	      */
	     setNewStylesToSelection : function(shapes, nodes, labels, borderIds, backgroundIds, bColors, bgColors, clearFormat) {
	    	 // If no shapes are given, get the current selection
	    	 if (!shapes)
		    	 var shapes = this.handlePoolsAndLanes(this.facade.getSelection());
	    	 
	    	 // Check if only one target is selected. if it's the same as the source for the styles to apply, return
	    	 if (shapes.length === 1 && shapes.findAll(function(shape) {
	  			    	return (this.prevSelection||[]).include(shape);
 	    	 		}.bind(this)).length === 1) {
	    		 this.buttons.copyStyleButton.buttonInstance.toggle(false);
	    		 delete this.prevSelection;
	    		 delete this.isCopyingStyles;
	    		 delete this.bcolorToSet;
	    		 delete this.bgcolorToSet;
	    		 delete this.styles; 
	    		 return;
	    	 }
	    	 
	    	 // If no nodes are given, filter all nodes from the shapes
	    	 if (!nodes) {
	    		 var nodes = this.getNodes(shapes);
	    	 }

	    	 // Get the labels of the shapes
    		 var labels = this.getLabels(shapes);
    		 var oldValues = [], newValues = [], shapeChangeIds = [];
    		 
    		 // If no background ids are given, get all from the selected nodes
    		 if (!backgroundIds)
    			 var backgroundIds = this.getBackgroundIds(nodes);
    		 
    		 // If no border ids are given, get all from the selected shapes
    		 if (!borderIds)
    			 var borderIds = this.getBorderIds(shapes);
    		 
    		 // For each shape, set the border and the background to the given colors
    		 shapes.each(function(shape) {
    			 var id = shape.getId() || shape.id;
    			 var bid = borderIds[id], bColor = this.getColor(shape, borderIds);
    			 var bgid = backgroundIds[id], bgColor = this.getColor(shape, backgroundIds);
    			 
    			 oldValues[id] = [];
    			 newValues[id] = [];
    			 
    			 // If an id for the border color property is defined, save the old value and set the new one
    			 if (bid) {
    				 oldValues[id][bid] = bColor;
    				 newValues[id][bid] = bColors ? bColors[id] : (this.bcolorToSet||this.getDefaultBorderColor(shape, borderIds));
    				 // Postprocess border color: if the color value is 'default', replace the value with the default border color
    				 if (newValues[id][bid] === "default") {
    					 newValues[id][bid] = this.getDefaultBorderColor(shape, borderIds);
    				 }
    			 }
    			 
    			 // If an id for the background color property is defined, save the old value and set the new one
    			 if (bgid) {
    				 oldValues[id][bgid] = bgColor;
        			 newValues[id][bgid] = bgColors ? bgColors[id] : (this.bgcolorToSet||this.getDefaultBackgroundColor(shape, backgroundIds));
    				 // Postprocess background color: if the color value is 'default', replace the value with the default background color
        			 if (newValues[id][bgid] === "default") {
        				 newValues[id][bgid] = this.getDefaultBackgroundColor(shape, backgroundIds);
        			 }
    			 }
    			 
    			 shapeChangeIds[id] = [bid, bgid].compact();
    		 }.bind(this));
    		 
    		 // If at least one pool is selected, set a flag
    		 var poolInSelection = !!shapes.find(function(shape) {
    			 return shape.getStencil().id().endsWith("Pool");
    		 });
    		 
    		 labels.each(function(label) {
    			 var newStyles = {}, n, isLane = false;
    			 var ser = label.serialize();
    			 // If clearFormat is undefined, there is a style object to set
    			 if (!clearFormat){
    				 // If a pool is selected, find the lane containing the current label
					 if (poolInSelection) {
						 n = nodes.find(function(node) {
    						 return node.getLabels().include(label);
    					 });
					 }
					 // If the node containing the label was found, check if it's a lane
					 if (n) {
						 isLane = n.getStencil().id().endsWith("Lane");
					 }
					 
    				 var keys = $w("bold italic fill font size");
    				 keys.each(function(key){
   				         // If the label is the label of a lane, try to keep as much style information as possible
    					 if (poolInSelection && isLane && ser && ser.styles && ser.styles[key]) {
    						 newStyles[key] = ser.styles[key];
    					 }
   				         // If a new style is set, apply it to the label
    					 else if (this.styles[key]) {
    						 newStyles[key] = this.styles[key];
    					 }
    					 // If not, set to default
    					 else if (label.defaultStyles) {
    						 newStyles[key] = this.getDefaultValue(label, key);
    					 }
    					 // If not, keep the old style
    					 else if (ser && ser.styles && ser.styles[key]) {
    						 newStyles[key] = ser.styles[key];
    					 }

    				 }.bind(this));
    			 }
    			 
    			 oldValues[label.id] = Object.clone(ser && ser.styles || {});
    			 newValues[label.id] = Object.clone(newStyles);	
			 }.bind(this));
    		 
    		 this.executeStyle(shapes, labels, 'Style', oldValues, newValues, true, shapeChangeIds, true);
    		 this.buttons.copyStyleButton.buttonInstance.toggle(false);
    		 delete this.prevSelection;
    		 delete this.isCopyingStyles;
    		 delete this.bgcolorToSet;
    		 delete this.styles; 
	     },
	     
	     /**
	      * Returns a valid value for the given style attribute
	      * @param {ORYX.Core.Label} label The current label
	      * @param {String} key The style attribute
	      */
	     getDefaultValue : function(label, key) {
	    	 var names = {
	    			 size	: "font-size",
	    			 font	: "font-family",
	    			 bold	: "font-weight",
	    			 italic	: "font-style",
	    			 fill	: "fill"
	    	 };
	    	 var values = {
	    			 normal	: false,
	    			 bold	: true,
	    			 italic	: true
	    	 };
	    	 var value = label.defaultStyles[names[key]];
	    	 if (!(values[value] === "undefined")) {
	    		 value = values[value];
	    	 } else if (typeof value === "Number") {
	    		 value += "px";
	    	 }
	    	 
	    	 return value;
	     },
	     
	     handlePoolsAndLanes : function(sel) {
	    	 var selection = [];
	    	 sel.each(function(s) {
	    		 if (sel[0].getStencil().id().endsWith("Pool")) {
	    			 selection = selection.concat(this.getLanesRecursively(s).flatten().compact().uniq());	    			 
	    		 } else {
	    			 selection.push(s);
	    		 }
	    	 }.bind(this));
	    	 return selection;
	    	 
	     },

	     getLanesRecursively : function(node) {
    		 if (typeof node.nodes === "object" && node.nodes.length > 0) {
    			 return [node].concat(node.nodes.map(function(n) {
    				 return this.getLanesRecursively(n);
    			 }.bind(this)));
    		 } else {
    			 if (node.getStencil instanceof Function && ["Lane", "VerticalLane"].include(node.getStencil().idWithoutNs())) {
    				 return [node];
    			 } else {
    				 return [];
    			 }
    		 }
    	 }
     });
}();
/** 
 *  (c) 2010 Signavio GmbH
 *   
 *  @author Lukas Brand
 *   
 *  
 */

if (!ORYX) var ORYX = {};
if (!ORYX.Plugins) ORYX.Plugins = {};
if (!ORYX.CONFIG) ORYX.CONFIG = {};

/**
 * Enables Richtext Step 2 functionality
 */
new function(){
	ORYX.Plugins.EnableRichtext2 = Clazz.extend({
		facade : undefined,
		
		construct : function(facade) {
			this.facade = facade;
			this.init();
		},
		
		init : function() {
			if (ORYX.CONFIG) {
				ORYX.CONFIG.RICHTEXT_2_ENABLED = true;
			}
		}
	});
}();/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/


if(!ORYX.Plugins) {
	ORYX.Plugins = new Object();
}

ORYX.Plugins.Toolbar = Clazz.extend({

	facade: undefined,
	plugs:	[],

	construct: function(facade, ownPluginData) {
		this.facade = facade;
		
		this.groupIndex = new Hash();
		ownPluginData.properties.each((function(value){
			if(value.group && value.index != undefined) {
				this.groupIndex[value.group] = value.index
			}
		}).bind(this));
		
		Ext.QuickTips.init();

		this.buttons = [];
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_BUTTON_UPDATE, this.onButtonUpdate.bind(this));
	},
    
    /**
     * Can be used to manipulate the state of a button.
     * @example
     * this.facade.raiseEvent({
     *   type: ORYX.CONFIG.EVENT_BUTTON_UPDATE,
     *   id: this.buttonId, // have to be generated before and set in the offer method
     *   pressed: true
     * });
     * @param {Object} event
     */
    onButtonUpdate: function(event){
        var button = this.buttons.find(function(button){
            return button.id === event.id;
        });
        
        if(event.pressed !== undefined){
            button.buttonInstance.toggle(event.pressed);
        }
    },

	registryChanged: function(pluginsData) {
        // Sort plugins by group and index
		var newPlugs =  pluginsData.sortBy((function(value) {
			return ((this.groupIndex[value.group] != undefined ? this.groupIndex[value.group] : "" ) + value.group + "" + value.index).toLowerCase();
		}).bind(this));
		var plugs = $A(newPlugs).findAll(function(value){
										return !this.plugs.include(value) && (!value.target || value.target === ORYX.Plugins.Toolbar)
									}.bind(this));
		if(plugs.length<1)
			return;

		this.buttons = [];
		
		ORYX.Log.trace("Creating a toolbar.")
		if(!this.toolbar){
			this.toolbar = new Ext.ux.SlicedToolbar({
			height: 24
		});
				var region = this.facade.addToRegion("north", this.toolbar, "Toolbar");
		}
		
		
		var currentGroupsName = this.plugs.last()?this.plugs.last().group:plugs[0].group;
        
        // Map used to store all drop down buttons of current group
        var currentGroupsDropDownButton = {};

		
		plugs.each((function(value, i) {
			if(!value.name) {return}
			this.plugs.push(value);
			// Add seperator if new group begins
			if(currentGroupsName != value.group) {
			    if (!value.addFill && (!plugs[i-1] || !plugs[i-1].addFill))
			    	this.toolbar.add('-');
				currentGroupsName = value.group;
                currentGroupsDropDownButton = {};
			}

			if (value.menuConfig) {
				var button = new Ext.ux.Toolbar.HorizontalMenuButton(value);
				this.toolbar.add(button);
				return;
			}
			
            // If an drop down group icon is provided, a split button should be used
            if(value.dropDownGroupIcon){
                var splitButton = currentGroupsDropDownButton[value.dropDownGroupIcon];
                
                // Create a new split button if this is the first plugin using it 
                if(splitButton === undefined){
                    splitButton = currentGroupsDropDownButton[value.dropDownGroupIcon] = new Ext.Toolbar.SplitButton({
                        cls: "x-btn-icon", //show icon only
                        icon: Ext.isIPad ? value.dropDownGroupIcon.replace('/famfamfam/', '/famfamfam/32x32/') : value.dropDownGroupIcon,
                        menu: new Ext.menu.Menu({
                            items: [] // items are added later on
                        }),
                        listeners: {
                          click: function(button, event){
                            // The "normal" button should behave like the arrow button
                            if(!button.menu.isVisible() && !button.ignoreNextClick){
                                button.showMenu();
                            } else {
                                button.hideMenu();
                            }
                          } 
                        }
                    });
                    
                    this.toolbar.add(splitButton);
                }
                
                
                // General config button which will be used either to create a normal button
                // or a check button (if toggling is enabled)
                var buttonCfg = {
                    icon: value.icon,
                    text: value.name,
                    cls: "x-"+String(value.group.gsub("\\.", "")).toLowerCase(),
                    handler: value.toggle ? undefined : value.functionality,
                    checkHandler: value.toggle ? value.functionality : undefined,
                    splitButton: splitButton,
                    listeners: {
                        render: function(item){
                            // After rendering, a tool tip should be added to component
                            if (value.description) {
                                new Ext.ToolTip({
                                    target: item.getEl(),
                                    title: value.description
                                });
                            }
                        }
                    }
                };
                
                if ("string" === typeof value.style){
                	buttonCfg.style = value.style;
                }
                
                if ("string" === typeof value.iconCls){
                	buttonCfg.iconCls = value.iconCls;
                }
                
                // Create buttons depending on toggle
                if(value.toggle) {
                    var button = new Ext.menu.CheckItem(buttonCfg);
                } else {
                    var button = new Ext.menu.Item(buttonCfg);
                }

                // Add separation before
                if (value.separatedBefore){
                	splitButton.menu.addSeparator();
                }
                
                splitButton.menu.add(button);
                
                // Add separation after
                if (value.separated){
                	splitButton.menu.addSeparator();
                }
                
            }
            else if(value.addFill) {
				this.toolbar.addFill();
			}
				
			// If the item to add to the toolbar is a ComboBox
            else if (value.isComboBox) {
				var combo = value.comboBox();
				this.toolbar.addField(combo);	
				
			} else {// create normal, simple button
				var icon = value.icon.split('/').length === 4 ? value.icon.replace('/editor/images/', '/explorer/src/img/famfamfam/') : value.icon;
                if (Ext.isIPad){
                	icon = icon.replace('/famfamfam/', '/famfamfam/32x32/');
                }
				
				var button = new Ext.ux.Toolbar.Button({
                    icon:           icon,         // icons can also be specified inline
                    cls:            'x-btn-icon',       // Class who shows only the icon
                    itemId:         value.id,
					tooltip:        value.description,  // Set the tooltip
                    tooltipType:    'title',            // Tooltip will be shown as in the html-title attribute
                    handler:        value.toggle ? null : value.functionality,  // Handler for mouse click
                    enableToggle:   value.toggle, // Option for enabling toggling
                    toggleHandler:  value.toggle ? value.functionality : null // Handler for toggle (Parameters: button, active)
                }); 
                
				this.toolbar.add(button);	
				
                button.getEl().onclick = function() {this.blur()}
            }
			
        	value['buttonInstance'] = value.isComboBox ? combo : button;
			this.buttons.push(value);	
			
		}).bind(this));

		this.enableButtons([]);
        
        //TODO this should be done when resizing and adding elements!!!!
        this.toolbar.calcSlices();
		window.addEventListener("resize", function(event){this.toolbar.calcSlices()}.bind(this), false);
		window.addEventListener("onresize", function(event){this.toolbar.calcSlices()}.bind(this), false);

	},
	
	onSelectionChanged: function(event) {
		this.enableButtons(event.elements);
	},

	enableButtons: function(elements) {
		// Show the Buttons
		this.buttons.each((function(value){
			if (!value.buttonInstance){ // Check if there is a button
				return;
			}
			
			// Enable the button
			value.buttonInstance.enable();
						
			// If there is less elements than minShapes
			if(value.minShape && value.minShape > elements.length)
				value.buttonInstance.disable();
			// If there is more elements than minShapes
			if(value.maxShape && value.maxShape < elements.length)
				value.buttonInstance.disable();	
			// If the plugin is not enabled	
			if(value.isEnabled && !value.isEnabled(value.buttonInstance))
				value.buttonInstance.disable();
			
		}).bind(this));		
	}
});

Ext.ns("Ext.ux");
Ext.ux.SlicedToolbar = Ext.extend(Ext.Toolbar, {
    currentSlice: 0,
    iconStandardWidth: 22, //22 px 
    seperatorStandardWidth: 2, //2px, minwidth for Ext.Toolbar.Fill
    toolbarStandardPadding: 2,
    
    initComponent: function(){
        Ext.apply(this, {
        });
        Ext.ux.SlicedToolbar.superclass.initComponent.apply(this, arguments);
    },
    
    onRender: function(){
        Ext.ux.SlicedToolbar.superclass.onRender.apply(this, arguments);
    },
    
    onResize: function(){
        Ext.ux.SlicedToolbar.superclass.onResize.apply(this, arguments);
    },
    
    calcSlices: function(){
        var slice = 0;
        this.sliceMap = {};
        var sliceWidth = 0;
        var toolbarWidth = this.getEl().getWidth();

        this.items.getRange().each(function(item, index){
            //Remove all next and prev buttons
            if (item.helperItem) {
                item.destroy();
                return;
            }
            
            var itemWidth = item.getEl().getWidth();
            
            if(sliceWidth + itemWidth + 5 * this.iconStandardWidth > toolbarWidth){
                var itemIndex = this.items.indexOf(item);
                
                this.insertSlicingButton("next", slice, itemIndex);
                
                if (slice !== 0) {
                    this.insertSlicingButton("prev", slice, itemIndex);
                }
                
                this.insertSlicingSeperator(slice, itemIndex);

                slice += 1;
                sliceWidth = 0;
            }
            
            this.sliceMap[item.id] = slice;
            sliceWidth += itemWidth;
        }.bind(this));
        
        // Add prev button at the end
        if(slice > 0){
            this.insertSlicingSeperator(slice, this.items.getCount()+1);
            this.insertSlicingButton("prev", slice, this.items.getCount()+1);
            var spacer = new Ext.Toolbar.Spacer();
            this.insertSlicedHelperButton(spacer, slice, this.items.getCount()+1);
            Ext.get(spacer.id).setWidth(this.iconStandardWidth);
        }
        
        this.maxSlice = slice;
        
        // Update view
        this.setCurrentSlice(this.currentSlice);
    },
    
    insertSlicedButton: function(button, slice, index){
        this.insertButton(index, button);
        this.sliceMap[button.id] = slice;
    },
    
    insertSlicedHelperButton: function(button, slice, index){
        button.helperItem = true;
        this.insertSlicedButton(button, slice, index);
    },
    
    insertSlicingSeperator: function(slice, index){
        // Align right
        this.insertSlicedHelperButton(new Ext.Toolbar.Fill(), slice, index);
    },
    
    // type => next or prev
    insertSlicingButton: function(type, slice, index){
        var nextHandler = function(){this.setCurrentSlice(this.currentSlice+1)}.bind(this);
        var prevHandler = function(){this.setCurrentSlice(this.currentSlice-1)}.bind(this);
        
        var button = new Ext.Toolbar.Button({
            cls: "x-btn-icon",
            icon: ORYX.CONFIG.ROOT_PATH + "images/toolbar_"+type+".png",
            handler: (type === "next") ? nextHandler : prevHandler
        });
        
        this.insertSlicedHelperButton(button, slice, index);
    },
    
    setCurrentSlice: function(slice){
        if(slice > this.maxSlice || slice < 0) return;
        
        this.currentSlice = slice;

        this.items.getRange().each(function(item){
            item.setVisible(slice === this.sliceMap[item.id]);
        }.bind(this));
    }
});/**
 * Copyright (c) 2009
 * Jan-Felix Schwarz, Willi Tscheschner, Lukas Brand
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if("undefined" == typeof ORYX) {var ORYX = {};}
if("undefined" == typeof ORYX.Plugins) {ORYX.Plugins = {};}

(function(){
	
		/**
	 * Defines the plugin for the shape menu
	 * @class ORYX.Plugins.ShapeMenuPlugin
	 */
	ORYX.Plugins.ShapeMenuPlugin = {
	
		construct: function(facade) {
			this.facade = facade;
			
			this.alignGroups = new Hash();
	
			var containerNode = this.facade.getCanvas().getHTMLContainer();
	
			this.shapeMenu = new ORYX.Plugins.ShapeMenu(containerNode);
			this.currentShapes = [];
	
			// Register on dragging and resizing events for show/hide of ShapeMenu
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_START, this.hideShapeMenu.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_END,  this.showShapeMenu.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_RESIZE_START,  (function(){
				this.hideShapeMenu();
				this.hideMorphMenu();
			}).bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_RESIZE_END,  this.showShapeMenu.bind(this));
			
			// Enable DragZone
			var dragZone = new ORYX.Core.DragZone(containerNode.parentNode, this.facade);
			dragZone.validBoundaries = ["node"];
			dragZone.afterValidDrop = this.afterDragging.bind(this);
			dragZone.afterInvalidDrop = function(){
											this.showShapeMenu();
										}.bind(this);
			dragZone.afterDragEnter = function(){
											if (this.shapeMenu.isVisible){
												this.hideShapeMenu();
											}
										}.bind(this);
			// Disable ATTACHING
			dragZone.canAttach = function(){ return false; }
			// Set Containing 
			dragZone.canContain = this.canContain.bind(this, dragZone);
			// Set Connecting 
			dragZone.canConnect = this.canConnect.bind(this, dragZone);
			
										
			//dragZone.afterDragOver = this.beforeDragOver.bind(this, dragZone);
			
			// Memory of created Buttons
			this.createdButtons = {};
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, (function(){ this.registryChanged(this.pluginsData||[]); }).bind(this));
	
			this.timer = null;
			
			this.resetElements = true;
	
		},
	
		hideShapeMenu: function(event) {
			window.clearTimeout(this.timer);
			this.timer = null;
			this.shapeMenu.hide();
		},
	
		showShapeMenu: function( dontGenerateNew ) {
		
			if( !dontGenerateNew || this.resetElements ){
				
				window.clearTimeout(this.timer);
				this.timer = window.setTimeout(function(){
					
						// Close all Buttons
					this.shapeMenu.closeAllButtons();
			
					// Show the Morph Button
					this.showMorphButton(this.currentShapes);
					
					// Show the Stencil Buttons
					this.showStencilButtons(this.currentShapes);	
					
					// Show the offer specific shapes
					this.showOfferButtons(this.currentShapes);
	
					// Show the ShapeMenu
					this.shapeMenu.show(this.currentShapes);
					
					this.resetElements = false;
				}.bind(this), 10);
				
			} else {
				
				window.clearTimeout(this.timer);
				this.timer = null;
				
				// Show the ShapeMenu
				this.shapeMenu.show(this.currentShapes);
				
			}
		},
	
		registryChanged: function(offers) {
			
			// Get all offers for the shapemenu
			this.pluginsData = (offers||[]).findAll(function(offer){
				return offer && offer.target && offer.target === ORYX.Plugins.ShapeMenuPlugin;
			});
				
			// Reset all buttons		
			this.shapeMenu.removeAllButtons();
			this.shapeMenu.setNumberOfButtonsPerLevel(ORYX.CONFIG.SHAPEMENU_RIGHT, 2);
			this.createdButtons = {};
			
			this.createMorphMenu();
			this.createOfferButtons();
	
			this.baseMorphStencils = this.facade.getRules().baseMorphs();
			
			// Checks if the stencil set has morphing attributes
			var isMorphing = this.facade.getRules().containsMorphingRules();
			
			// Create Buttons for all Stencils of all loaded stencilsets
			var stencilsets = this.facade.getStencilSets();
			stencilsets.values().each((function(stencilSet){
				
				var nodes = stencilSet.nodes();
				
				var groups = nodes.invoke("groups").flatten().uniq();
				
				
				nodes.sortBy(function(node){ 
						return groups.indexOf(node.groups()[0]); 
					}).each((function(stencil) {
						
						// Consider hide property 
						if(stencil.hide()) {
							return;
						}
						
						// Create a button for each node
						var option = {type: stencil.id(), namespace: stencil.namespace(), connectingType: true};
						var button = new ORYX.Plugins.ShapeMenuButton({
							callback: 	this.newShape.bind(this, option),
							icon: 		stencil.icon(),
							align: 		ORYX.CONFIG.SHAPEMENU_RIGHT,
							group:		0,
							//dragcallback: this.hideShapeMenu.bind(this),
							msg:		stencil.title() + " - " + ORYX.I18N.ShapeMenuPlugin.clickDrag,
							cls: 		"x-"+(stencil.idWithoutNs() || "none")
							});
						
						// Add button to shape menu
						this.shapeMenu.addButton(button); 
						
						// Add to the created Button Array
						this.createdButtons[stencil.namespace() + stencil.type() + stencil.id()] = button;
						
						// Drag'n'Drop will enable
						Ext.dd.Registry.register(button.node.lastChild, option);				
					}).bind(this));
			
	
				var edges = stencilSet.edges();
				edges.each((function(stencil) {
					
					// Consider hide property 
					if(stencil.hide()) {
						return;
					}
					
					// Create a button for each edge
					var option = {type: stencil.id(), namespace: stencil.namespace()};
					var button = new ORYX.Plugins.ShapeMenuButton({
						callback: 	this.newShape.bind(this, option),
						icon: 		isMorphing ? ORYX.PATH + "images/edges.png" : stencil.icon(),
						align: 		ORYX.CONFIG.SHAPEMENU_RIGHT,
						group:		1,
						//dragcallback: this.hideShapeMenu.bind(this),
						msg:		(isMorphing ? ORYX.I18N.Edge : stencil.title()) + " - " + ORYX.I18N.ShapeMenuPlugin.drag,
						cls: 		"x-"+(stencil.idWithoutNs() || "none") + " x-edges"
					});
					
					// Add button to shape menu
					this.shapeMenu.addButton(button); 
					
					// Add to the created Button Array
					this.createdButtons[stencil.namespace() + stencil.type() + stencil.id()] = button;
					
					// Drag'n'Drop will enable
					Ext.dd.Registry.register(button.node.lastChild, option);
					
				}).bind(this));
			
			}).bind(this));				
						
		},
		
		createMorphMenu: function() {
			
			this.morphMenu = new Ext.menu.Menu({
				id: 'Oryx_morph_menu',
				items: [],
				hide: function(){
					if (!this.showDelay){
						return Ext.menu.Menu.prototype.hide.apply(this, arguments);
					}
				}
			});
			
			this.morphMenu.on("mouseover", function() {
				this.morphMenuHovered = true;
			}, this);
			this.morphMenu.on("mouseout", function() {
				this.morphMenuHovered = false;
			}, this);
			
			
			// Create the button to show the morph menu
			var button = new ORYX.Plugins.ShapeMenuButton({
				hovercallback: 	(ORYX.CONFIG.ENABLE_MORPHMENU_BY_HOVER ? this.showMorphMenu.bind(this) : undefined), 
				resetcallback: 	(ORYX.CONFIG.ENABLE_MORPHMENU_BY_HOVER ? this.hideMorphMenu.bind(this) : undefined), 
				callback:		(ORYX.CONFIG.ENABLE_MORPHMENU_BY_HOVER ? undefined : this.toggleMorphMenu.bind(this)), 
				icon: 			ORYX.PATH + 'images/wrench_orange.png',
				align: 			ORYX.CONFIG.SHAPEMENU_BOTTOM,
				group:			0,
				msg:			ORYX.I18N.ShapeMenuPlugin.morphMsg,
				cls: 			"x-morph-menu"
			});				
			
			this.shapeMenu.setNumberOfButtonsPerLevel(ORYX.CONFIG.SHAPEMENU_BOTTOM, (this.shapeMenu.numberOfButtonsPerLevel[ORYX.CONFIG.SHAPEMENU_BOTTOM] || 0) + 1);
			this.shapeMenu.addButton(button);
			this.morphMenu.getEl().appendTo(button.node);
			this.morphButton = button;
		},
		
		createOfferButtons: function(){
			
			var btn = (this.pluginsData||[]).findAll(function(offer){
					return offer&&offer.icon&&offer.functionality;
				});
				
			
			btn.sortBy(function(offer){
				return offer.index || 0;
			}).each(function(offer){
				
				var align = offer.align || ORYX.CONFIG.SHAPEMENU_BOTTOM;
				
				// Create the button to show the morph menu
				var button = new ORYX.Plugins.ShapeMenuButton({
					callback:		offer.functionality, 
					icon: 			offer.icon,
					align: 			align,
					group:			0,
					msg:			offer.description,
					offset:			offer.offset || undefined,
					cls: 			offer.title || undefined
				});	
				
				this.shapeMenu.addButton(button);
				this.shapeMenu.setNumberOfButtonsPerLevel(align, (this.shapeMenu.numberOfButtonsPerLevel[align]||0)+1);
				offer.button = button;
			}.bind(this));
		
		},
		
		showMorphMenu: function() {
			this.morphMenu.show(this.morphButton.node);
			this.morphMenu.showDelay = true;
			window.setTimeout(function(){ delete this.morphMenu.showDelay; }.bind(this), 1000);
			this._morphMenuShown = true;
		},
		
		hideMorphMenu: function() {
			this.morphMenu.hide();
			this._morphMenuShown = false;
		},
		
		toggleMorphMenu: function() {
			if(this._morphMenuShown)
				this.hideMorphMenu();
			else
				this.showMorphMenu();
		},
		
		onSelectionChanged: function(event) {
			var elements = event.elements;
	
			this.hideShapeMenu();
			this.hideMorphMenu();
					
			if( this.currentShapes.inspect() !== elements.inspect() ){
				this.currentShapes = elements;
				this.resetElements = true;
				
				this.showShapeMenu();
			} else {
				this.showShapeMenu(true);
			}
			
		},
		
		/**
		 * Show button for morphing the selected shape into another stencil
		 */
		showMorphButton: function(elements) {
			
			if(elements.length != 1) return;
			
			var possibleMorphs = this.facade.getRules().morphStencils({ stencil: elements[0].getStencil() });
			possibleMorphs = possibleMorphs.select(function(morph) {
				if(elements[0].getStencil().type() === "node" && !elements[0].getStencil().hide()) {
							// Check containment rules
					return 	this.facade.getRules().canContain({containingShape:elements[0].parent, containedStencil:morph})&&
							// Check all incoming shapes
							elements[0].getIncomingShapes().all(function(incoming){
								return this.facade.getRules().canConnect({					// Stencil to Target
														sourceShape		: incoming instanceof ORYX.Core.Edge ? incoming.getSource() : incoming,
														edgeShape		: incoming,
														targetStencil	: morph
													});
							}.bind(this)) &&
							// Check all outoing shapes
							elements[0].getOutgoingShapes().all(function(outgoing){
								return this.facade.getRules().canConnect({					// Stencil to Target
														sourceStencil	: morph,
														edgeShape		: outgoing,
														targetShape		: outgoing instanceof ORYX.Core.Edge ? outgoing.getTarget() : outgoing
													});
							}.bind(this));
							
				} else { 
					//check connect rules
					return this.facade.getRules().canConnect({
												sourceShape:	elements[0].dockers.first().getDockedShape(), 
												edgeStencil:	morph, 
												targetShape:	elements[0].dockers.last().getDockedShape()
												});	
				}
			}.bind(this));
			if(possibleMorphs.size()<=1) return; // if morphing to other stencils is not possible, don't show button
			
			this.morphMenu.removeAll();
			
			// populate morph menu with the possible morph stencils
			var buttons = possibleMorphs.map((function(morph) {
				var menuItem = new Ext.menu.Item({ 
					text: morph.title(), 
					icon: morph.icon(),
					identifier: morph.id(), 
					disabled: morph.id()==elements[0].getStencil().id(),
					disabledClass: ORYX.CONFIG.MORPHITEM_DISABLED,
					handler: (function() { this.morphShape(elements[0], morph); }).bind(this)
				});
				this.morphMenu.add(menuItem);
				return menuItem;
			}).bind(this));
			
			this.facade.raiseEvent({type:"shapemenu.showMorphButton", selectedElements: elements, buttons: buttons});
			
			this.morphButton.prepareToShow();
			
			
			
		},
	
		/**
		 * Show buttons for creating following shapes
		 */
		showStencilButtons: function(elements) {
	
			if(elements.length != 1) return;
	
			//TODO temporaere nutzung des stencilsets
			var sset = this.facade.getStencilSets()[elements[0].getStencil().namespace()];
	
			// Get all available edges
			var edges = this.facade.getRules().outgoingEdgeStencils({canvas:this.facade.getCanvas(), sourceShape:elements[0]});
			
			// And find all targets for each Edge
			var targets = new Array();
			var addedEdges = new Array();
			
			var isMorphing = this.facade.getRules().containsMorphingRules();
			
			edges.each((function(edge) {
				
				if (isMorphing){
					if(this.baseMorphStencils.include(edge)) {
						var shallAppear = true;
					} else {
						
						// if edge is member of a morph groups where none of the base morphs is in the outgoing edges
						// we want to display the button (but only for the first one)
						
						var possibleMorphs = this.facade.getRules().morphStencils({ stencil: edge });
						
						var shallAppear = !possibleMorphs.any((function(morphStencil) {
							if(this.baseMorphStencils.include(morphStencil) && edges.include(morphStencil)) return true;
							return addedEdges.include(morphStencil);
						}).bind(this));
						
					}
				}
				if(shallAppear || !isMorphing) {
					if(this.createdButtons[edge.namespace() + edge.type() + edge.id()]) 
						this.createdButtons[edge.namespace() + edge.type() + edge.id()].prepareToShow();
					addedEdges.push(edge);
				}
				
				// get all targets for this edge
				targets = targets.concat(this.facade.getRules().targetStencils(
						{canvas:this.facade.getCanvas(), sourceShape:elements[0], edgeStencil:edge}));
	
			}).bind(this));
			
			targets.uniq();
			
			var addedTargets = new Array();
			// Iterate all possible target 
			targets.each((function(target) {
				
				if (isMorphing){
					
					// continue with next target stencil
					if (target.type()==="edge") return; 
					
					// continue when stencil should not shown in the shape menu
					if (!this.facade.getRules().showInShapeMenu(target)) return; 
					
					// if target is not a base morph 
					if(!this.baseMorphStencils.include(target)) {
						
						// if target is member of a morph groups where none of the base morphs is in the targets
						// we want to display the button (but only for the first one)
						
						var possibleMorphs = this.facade.getRules().morphStencils({ stencil: target });
						if(possibleMorphs.size()==0) return; // continue with next target
		
						var baseMorphInTargets = possibleMorphs.any((function(morphStencil) {
							if(this.baseMorphStencils.include(morphStencil) && targets.include(morphStencil)) return true;
							return addedTargets.include(morphStencil);
						}).bind(this));
						
						if(baseMorphInTargets) return; // continue with next target
					}
				}
				
				// if this is reached the button shall appear in the shape menu:
				if(this.createdButtons[target.namespace() + target.type() + target.id()]) 
					this.createdButtons[target.namespace() + target.type() + target.id()].prepareToShow();
				addedTargets.push(target);
				
			}).bind(this));
			
		},
	 
	 	showOfferButtons: function(selection){
			
			var size = (selection||[]).length;
			(this.pluginsData||[]).each(function(offer){
				if (!offer||!offer.button){
					return;
				}
				
				if((offer.minShape && offer.minShape > size)||(offer.maxShape && offer.maxShape < size)||(offer.isEnabled && !offer.isEnabled())){
					offer.button.prepareToHide();
				} else {				
					offer.button.prepareToShow();
				}
			}.bind(this));
		},
	 
		canContain: function(drag, shapes, stencil){
			
			var candidate = shapes[0];
	
			var possibleMorphs = [].concat(stencil, this.facade.getRules().morphStencils({stencil: stencil}));
			for(var i=0; i<possibleMorphs.size(); i++) {
				canContain = this.facade.getRules().canContain({
					containingShape		: candidate, 
					containedStencil	: possibleMorphs[i]
				});
				if(canContain) {
					drag.setOptions({
										type		: possibleMorphs[i].id(), 
										namespace	: possibleMorphs[i].namespace()
									});
					break;
				}
			}
			
			return canContain;
		},
		
		canConnect: function(drag, shapes, stencil){
			
			var candidate = shapes[0], curCan = shapes[0], orgCan = shapes[0], curShape = this.currentShapes[0];
			var canConnect = false;
			
			if (!curShape){
				return false;
			}
			
			if (curShape.isParent(candidate)){
				candidate = curCan = orgCan = this.facade.getCanvas();
			}
			
			if (candidate === curShape){
				return false;
			}
			
			// Get the possible morphs
			var possibleMorphs = this.facade.getRules().morphStencils({stencil: stencil});
			if (!possibleMorphs.include(stencil)){
				possibleMorphs.push(stencil);
			}
			
			var curCan = candidate;
			while(!canConnect && curCan && !(curCan instanceof ORYX.Core.Canvas)){
				candidate = curCan;
				var i=0, size = possibleMorphs.size();
				for(i=0; i<size; i++) {
					//check connection rules
					canConnect = this.facade.getRules().canConnect({
												sourceShape:	curShape, 
												edgeStencil:	possibleMorphs[i], 
												targetShape:	curCan
											});		
					
					if (canConnect){
						break;
					}					
				}
				if(canConnect) {
					// If ConnectingType is set -> A Node and its edge is going to be created
					if (drag.getOptions().connectingType){
						drag.setOptions({
										connectingType 	: possibleMorphs[i].id(), 
										namespace		: possibleMorphs[i].namespace()
									});
					// Otherwise, only an edge is going to be created
					} else {
						drag.setOptions({
										type		 	: possibleMorphs[i].id(), 
										namespace		: possibleMorphs[i].namespace()
									});
					}
				} else {
					curCan = curCan.parent;
				}
			}
			
			drag._lastOverElement = canConnect ? candidate : orgCan;
			return canConnect;
		},	
	
		/**
		 * Callback if dragging is over and 
		 * a new shape should be created
		 * @param {Object} option
		 * @param {Object} shape
		 * @param {Object} event
		 */
		afterDragging: function(option, shape, event) {
			
			if (!this.currentShapes[0]){
				return;
			}
			
			// Define the connecting shapes		
			option['connectedShape'] = this.currentShapes[0];
			if(option['connectingType']) {
				var stencilset = this.facade.getStencilSets()[option.namespace];
				var containedStencil = stencilset.stencil(option.type);
				var args = { sourceShape: this.currentShapes[0], targetStencil: containedStencil };
				option['connectingType'] = this.facade.getRules().connectMorph(args);
				if (option['connectingType']){
					option['connectingType'] = option['connectingType'].id();
				} else {
					delete option['connectingType'];
				}
			}
			if (ORYX.CONFIG.SHAPEMENU_DISABLE_CONNECTED_EDGE===true) {
				delete option['connectingType'];
			}
			
			// Create and execute the command	
			var command = new ORYX.Plugins.ShapeMenuPlugin.CreateCommand(Object.clone(option), shape, option.position, this);
			this.facade.executeCommands([command]);
			
			// Inform about completed Drag 
			this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_SHAPE_MENU_CLOSE, source:this.currentShapes, destination:this.currentShapes});
		},
	
		newShape: function(option, event) {
			
			var stencilset = this.facade.getStencilSets()[option.namespace];
			var containedStencil = stencilset.stencil(option.type);
	
			if (this.facade.getRules().canContain({
					containingShape	:this.currentShapes.first().parent,
					containedStencil:containedStencil
				})) {
	
				option['connectedShape'] = this.currentShapes[0];
				option['parent'] = this.currentShapes.first().parent;
				option['containedStencil'] = containedStencil;
			
				var args = { sourceShape: this.currentShapes[0], targetStencil: containedStencil };
				var targetStencil = this.facade.getRules().connectMorph(args);
				if (!targetStencil){ return; }// Check if there can be a target shape
				option['connectingType'] = targetStencil.id();
	
				if (ORYX.CONFIG.SHAPEMENU_DISABLE_CONNECTED_EDGE===true) {
					delete option['connectingType'];
				}
				
				var command = new ORYX.Plugins.ShapeMenuPlugin.CreateCommand(Object.clone(option), undefined, undefined, this);
			
				this.facade.executeCommands([command]);
			}
		},
		
		/**
		 * Morph a shape to a new stencil
		 * {Command implemented}
		 * @param {Shape} shape
		 * @param {Stencil} stencil
		 */
		morphShape: function(shape, stencil) {
	
			var MorphTo = ORYX.Core.Command.extend({
				construct: function(shape, stencil, facade){
					this.shape = shape;
					this.stencil = stencil;
					this.facade = facade;
					this.removeEdge = [];
					this.reconnectedEdges = [];
				},
				execute: function(){
	
					var shape = this.shape;
					var stencil = this.stencil;
					var resourceId = shape.resourceId;
					var newShape = null;
	
					// Serialize all attributes
					var serialized = shape.serialize();
					stencil.properties().each((function(prop) {
						if(prop.readonly()) {
							serialized = serialized.reject(function(serProp) {
								return serProp.name==prop.id();
							});
						}
					}).bind(this));
	
					// Get shape if already created, otherwise create a new shape
					if (this.newShape){
						newShape = this.newShape;
						this.facade.getCanvas().add(newShape);
					} else {
						newShape = this.facade.createShape({
										type		: stencil.id(),
										namespace	: stencil.namespace(),
										resourceId	: resourceId,
										dontUpdateSelection : true
									});
						
						// Use same resource id
						newShape.setResourceId(resourceId);
					}

					// calculate new bounds using old shape's upperLeft and new shape's width/height
					var boundsObj = serialized.find(function(serProp){
						return (serProp.prefix === "oryx" && serProp.name === "bounds");
					});
	
					var changedBounds = null;
	
					if(!this.facade.getRules().preserveBounds(shape.getStencil())) {
	
						var bounds = boundsObj.value.split(",");
						if (parseInt(bounds[0], 10) > parseInt(bounds[2], 10)) { // if lowerRight comes first, swap array items
							var tmp = bounds[0];
							bounds[0] = bounds[2];
							bounds[2] = tmp;
							tmp = bounds[1];
							bounds[1] = bounds[3];
							bounds[3] = tmp;
						}
						bounds[2] = parseInt(bounds[0], 10) + newShape.bounds.width();
						bounds[3] = parseInt(bounds[1], 10) + newShape.bounds.height();
						boundsObj.value = bounds.join(",");
	
					}  else {
	
						var height = shape.bounds.height();
						var width  = shape.bounds.width();
	
						// consider the minimum and maximum size of
						// the new shape
	
						if (newShape.minimumSize) {
							if (shape.bounds.height() < newShape.minimumSize.height) {
								height = newShape.minimumSize.height;
							}
	
	
							if (shape.bounds.width() < newShape.minimumSize.width) {
								width = newShape.minimumSize.width;
							}
						}
	
						if(newShape.maximumSize) {
							if(shape.bounds.height() > newShape.maximumSize.height) {
								height = newShape.maximumSize.height;
							}	
	
							if(shape.bounds.width() > newShape.maximumSize.width) {
								width = newShape.maximumSize.width;
							}
						}
	
						changedBounds = {
							a : {
								x: shape.bounds.a.x,
								y: shape.bounds.a.y
							},
							b : {
								x: shape.bounds.a.x + width,
								y: shape.bounds.a.y + height
							}						
						};
	
					}
	
					var oPos = shape.bounds.center();
					if(changedBounds !== null) {
						newShape.bounds.set(changedBounds);
					}
	
					// Set all related dockers
					this.setRelatedDockers(shape, newShape);
	
					// store DOM position of old shape
					var parentNode = shape.node.parentNode;
					var nextSibling = shape.node.nextSibling;
	
					var childShapes = shape.getChildNodes();
	
					// Delete the old shape
					this.facade.deleteShape(shape);
	
					// Deserialize the new shape - Set all attributes
					newShape.deserialize(serialized, shape.toJSON());		
					if(changedBounds !== null) {
						newShape.bounds.set(changedBounds);
					}
					
					if(newShape.getStencil().type()==="edge" || (newShape.dockers.length==0 || !newShape.dockers[0].getDockedShape())) {
						newShape.bounds.centerMoveTo(oPos);
					} 
	
					if(newShape.getStencil().type()==="node" && (newShape.dockers.length==0 || !newShape.dockers[0].getDockedShape())) {
						this.setRelatedDockers(newShape, newShape);
					}
					
					// Try to append the children to the new shape
					this.resetAllChildShapes(childShapes, newShape);
	
					// place at the DOM position of the old shape
					if(nextSibling) parentNode.insertBefore(newShape.node, nextSibling);
					else parentNode.appendChild(newShape.node);
	
					// Set selection
					this.facade.setSelection([newShape]);
					this.facade.updateSelection();
					
					// Check if the default background color of a shape changed due to morphing.
					// If no user defined background color exists, set the new color.
					if (shape instanceof ORYX.Core.Node && newShape instanceof ORYX.Core.Node)
						this.handleDefaultBackgroundColorChange(shape, newShape);
					
					newShape.isChanged = true;
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
					this.newShape = newShape;
	
				},
				rollback: function(){
	
					if (!this.shape || !this.newShape || !this.newShape.parent) {return;}
	
					// Append shape to the parent
					this.newShape.parent.add(this.shape);
									
					// Add child shapes to the new one
					this.newShape.getChildNodes().each(function(s){
						if (this.facade.getRules().canContain({
								containingShape	: this.shape,
								containedShape	: s
							})){
							this.shape.add(s);
						}
					}.bind(this));
					
					
					// Rollback removed edges
					this.removeEdge.each(function(edge){
						this.facade.getCanvas().add(edge);
					}.bind(this));
					
					// Rollback reconnected shapes
					this.reconnectedEdges.each(function(obj){
						obj.docker.setDockedShape(obj.shape);
						obj.docker.setReferencePoint(obj.point);
					}.bind(this));
					
					// Set dockers
					this.setRelatedDockers(this.newShape, this.shape);
					// Delete new shape
					this.facade.deleteShape(this.newShape);
					// Set selection
					this.facade.setSelection([this.shape]);
					// Update
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
				},
	
				getValidChildren: function(children, shape){
					// Add child shapes to the new one
					return children.findAll(function(child){
						return this.facade.getRules().canContain({
								containingShape	: shape instanceof ORYX.Core.Shape ? shape : undefined,
								containingStencil: shape instanceof ORYX.Core.StencilSet.Stencil ? shape : undefined,
								containedShape	: child
							});
					}.bind(this));
				},
	
				resetAllChildShapes: function(children, newShape){
					// Get valid/invalid child shapes
					var validChildren = this.getValidChildren(children, newShape);
					var invalidChildren = children.without.apply(children, validChildren);
					
					var absoluteUL = newShape.absoluteXY();
					this.reconnectedEdges = [];
								
					// Remove edges
					invalidChildren.each(function(child){
						child.getAllDockedShapes().each(function(edge){
							if (!(edge instanceof ORYX.Core.Edge) || !edge.parent){ return; }
							
							var relatedNode = edge.getSource() === child ? edge.getTarget() : edge.getSource();
	
							// Try to reconnect outgoing edges to the new shape
							if (relatedNode && !children.include(relatedNode) && this.facade.getRules().canConnect({
										sourceShape		: edge.getSource() === child ? child : relatedNode,
										edgeShape		: edge,
										targetShape		: edge.getTarget() === child ? child : relatedNode
									})){
										
								var docker 	= edge.getSource() === child ? edge.dockers.first() : edge.dockers.last();
								var point 	= Object.clone(docker.getAbsoluteReferencePoint());
								point.x -= absoluteUL.x;
								point.y -= absoluteUL.y;
								
								this.reconnectedEdges.push({
									shape 	: docker.getDockedShape(),
									docker	: docker,
									point	: Object.clone(docker.referencePoint)
								});
								
								docker.setDockedShape(newShape);
								docker.setReferencePoint(point);
								
							// otherwise remove edge
							} else {
								if (!this.removeEdge.include(edge))
									this.removeEdge.push(edge);
								edge.parent.remove(edge);
							}
							
						}.bind(this));
					}.bind(this));
					
					
					// Add to the new shape
					validChildren.each(function(child){
						newShape.add(child);
					});
				},
	
				/**
				 * Set all incoming and outgoing edges from the shape to the new shape
				 * @param {Shape} shape
				 * @param {Shape} newShape
				 */
				setRelatedDockers: function(shape, newShape){
	
					if(shape.getStencil().type()==="node") {
	
						(shape.incoming||[]).concat(shape.outgoing||[])
							.each(function(i) { 
								i.dockers.each(function(docker) {
									if (docker.getDockedShape() == shape) {
										var rPoint = Object.clone(docker.referencePoint);
										// Move reference point per percent
	
										var rPointNew = {
											x: rPoint.x*newShape.bounds.width()/shape.bounds.width(),
											y: rPoint.y*newShape.bounds.height()/shape.bounds.height()
										};
	
										docker.setDockedShape(newShape);
										// Set reference point and center to new position
										docker.setReferencePoint(rPointNew);
										if(i instanceof ORYX.Core.Edge) {
											docker.bounds.centerMoveTo(rPointNew);
										} else {
											var absXY = shape.absoluteXY();
											docker.bounds.centerMoveTo({x:rPointNew.x+absXY.x, y:rPointNew.y+absXY.y});
											//docker.bounds.moveBy({x:rPointNew.x-rPoint.x, y:rPointNew.y-rPoint.y});
										}
									}
								});	
							});
	
						// for attached events
						if(shape.dockers.length>0&&shape.dockers.first().getDockedShape()) {
							newShape.dockers.first().setDockedShape(shape.dockers.first().getDockedShape());
							newShape.dockers.first().setReferencePoint(Object.clone(shape.dockers.first().referencePoint));
						}
	
					} else { // is edge
						newShape.dockers.first().setDockedShape(shape.dockers.first().getDockedShape());
						newShape.dockers.first().setReferencePoint(shape.dockers.first().referencePoint);
						newShape.dockers.last().setDockedShape(shape.dockers.last().getDockedShape());
						newShape.dockers.last().setReferencePoint(shape.dockers.last().referencePoint);
					}
				},
				
				handleDefaultBackgroundColorChange : function(shape, newShape) {
					// Get the default color of the deleted shape
					var oldBgId;
					var oldDefaultColor = shape.getStencil().properties().find(function(prop) {
					    if (prop.isBackgroundColor() || prop.isBorderColor()) {
					    	oldBgId = prop.id();
					    	return true;
					    }
					});
					
					if (!oldDefaultColor){ return; }
					oldDefaultColor = oldDefaultColor.value();
					
					// Check if the user has set a custom background color
					var customBackgroundColor;
					if (oldBgId) {
						customBackgroundColor = shape.properties['oryx-'+oldBgId];
					}
					
					if (customBackgroundColor && oldDefaultColor && customBackgroundColor === oldDefaultColor) {
						// Get the default color of the new shape
						var newBgId;
						var defaultColor = newShape.getStencil().properties().find(function(prop) {
						    if (prop.isBackgroundColor() || prop.isBorderColor()) {
						    	newBgId = prop.id();
						    	return true;	
						    }
						});
						
						if (!defaultColor){ return; }
						defaultColor = defaultColor.value();
						
						// Set the default color of the new shape to it
						newShape.setProperty('oryx-'+newBgId, defaultColor, true);
					}
				}
			});
	
			var children = shape.getChildNodes();
			var hasInvalidChildren = MorphTo.prototype.getValidChildren.call(this, children, stencil).length !== children.length;
			
			var execute = function(){
				// Create and execute command (for undo/redo)			
				var command = new MorphTo(shape, stencil, this.facade);
				this.facade.executeCommands([command]);
			}.bind(this);
			
			if (hasInvalidChildren) {
				Ext.Msg.confirm(ORYX.I18N.ShapeMenuPlugin.morphWarningTitleMsg, ORYX.I18N.ShapeMenuPlugin.morphWarningMsg, function(btn){
					if (btn == "yes"){
						execute();
					}
				});
			} else {
				execute();
			}
			
			this.hideMorphMenu();
		}
	};
	ORYX.Plugins.ShapeMenuPlugin = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.ShapeMenuPlugin);
	
	ORYX.Plugins.ShapeMenu = {
	
		/***
		 * Constructor.
		 */
		construct: function(parentNode) {
	
			this.bounds = undefined;
			this.shapes = undefined;
			this.buttons = [];
			this.isVisible = false;
	
			this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", $(parentNode),
				['div', {id: ORYX.Editor.provideId(), 'class':'Oryx_ShapeMenu'}]);
			
			this.alignContainers = new Hash();
			this.numberOfButtonsPerLevel = new Hash();
		},
	
		addButton: function(button) {
			this.buttons.push(button);
			// lazy grafting of the align containers
			if(!this.alignContainers[button.align]) {
				this.alignContainers[button.align] = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.node,
						['div', {'class':button.align}]);
				this.node.appendChild(this.alignContainers[button.align]);
				
				// add event listeners for hover effect
				var onBubble = false;
				//this.alignContainers[button.align].addEventListener(ORYX.CONFIG.EVENT_MOUSEOVER, this.hoverAlignContainer.bind(this, button.align), onBubble);
				//this.alignContainers[button.align].addEventListener(ORYX.CONFIG.EVENT_MOUSEOUT, this.resetAlignContainer.bind(this, button.align), onBubble);
				//this.alignContainers[button.align].addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.hoverAlignContainer.bind(this, button.align), onBubble);
			}
			this.alignContainers[button.align].appendChild(button.node);
		},
	
		deleteButton: function(button) {
			this.buttons = this.buttons.without(button);
			this.node.removeChild(button.node);
		},
	
		removeAllButtons: function() {
			var me = this;
			this.buttons.each(function(value){
				if (value.node&&value.node.parentNode)
					value.node.parentNode.removeChild(value.node);
			});
			this.buttons = [];
		},
	
		closeAllButtons: function() {
			this.buttons.each(function(value){ value.prepareToHide(); });
			this.isVisible = false;
		},
	
		
		/**
		 * Show the shape menu
		 */
		show: function(shapes) {
	
			//shapes = (shapes||[]).findAll(function(r){ return r && r.node && r.node.parent });
	
			if(shapes.length <= 0 )
				return;
	
			this.shapes = shapes;
	
			var newBounds = undefined;
			var tmpBounds = undefined;
	
			this.shapes.each(function(value) {
				
				// BUGFIXING: To prevent an exception
				// while getScreenCTM. If the node has
				// no document/parent it raises one.
				if (!value||!value.node||!value.node.parentNode){
					return;
				}
				
				var a = value.node.getScreenCTM();
				var upL = value.absoluteXY();
				a.e = a.a*upL.x;
				a.f = a.d*upL.y;
				tmpBounds = new ORYX.Core.Bounds(a.e, a.f, a.e+a.a*value.bounds.width(), a.f+a.d*value.bounds.height());
	
				/*if(value instanceof ORYX.Core.Edge) {
					tmpBounds.moveBy(value.bounds.upperLeft())
				}*/
	
				if(!newBounds)
					newBounds = tmpBounds;
				else
					newBounds.include(tmpBounds);
	
			});
			
			if (!newBounds){
				return;
			}
	
			this.bounds = newBounds;
			//this.bounds.moveBy({x:document.documentElement.scrollLeft, y:document.documentElement.scrollTop});
	
			var bounds = this.bounds;
	
			var a = this.bounds.upperLeft();
	
			var left = 0,
				leftButtonGroup = 0;
			var top = 0,
				topButtonGroup = 0;
			var bottom = 0,
				bottomButtonGroup;
			var right = 0,
				rightButtonGroup = 0;
			var size = Ext.isIPad ? 30 : 22;
			
			var buttons = this.getWillShowButtons();
			buttons.sortBy(function(button) {
				return button.group;
			});
			
			buttons.each(function(button){
				
				var numOfButtonsPerLevel = this.getNumberOfButtonsPerLevel(button.align);
	
				if (button.align == ORYX.CONFIG.SHAPEMENU_LEFT) {
					// vertical levels
					if(button.group!=leftButtonGroup) {
						left = 0;
						leftButtonGroup = button.group;
					}
					var x = Math.floor(left / numOfButtonsPerLevel);
					var y = left % numOfButtonsPerLevel;
					
					button.setLevel(x);
					
					button.setPosition(a.x-5 - (x+1)*size, 
							a.y+numOfButtonsPerLevel*button.group*size + button.group*0.3*size + y*size);
					
					//button.setPosition(a.x-22, a.y+left*size);
					left++;
	 			} else if (button.align == ORYX.CONFIG.SHAPEMENU_TOP) {
	 				// horizontal levels
	 				if(button.group!=topButtonGroup) {
						top = 0;
						topButtonGroup = button.group;
					}
	 				var x = top % numOfButtonsPerLevel;
	 				var y = Math.floor(top / numOfButtonsPerLevel);
	 				
	 				button.setLevel(y);
	 				
	 				button.setPosition(a.x+numOfButtonsPerLevel*button.group*size + button.group*0.3*size + x*size,
	 						a.y-5 - (y+1)*size);
					top++;
	 			} else if (button.align == ORYX.CONFIG.SHAPEMENU_BOTTOM) {
	 				// horizontal levels
	 				if(button.group!=bottomButtonGroup) {
						bottom = 0;
						bottomButtonGroup = button.group;
					}
	 				var x = bottom % numOfButtonsPerLevel;
	 				var y = Math.floor(bottom / numOfButtonsPerLevel);	
					
					if (button.option.offset){
						x = button.option.offset.x !== undefined ? button.option.offset.x * (size/22) / size : x;
						y = button.option.offset.y !== undefined ? button.option.offset.y * (size/22) / size : y;
						bottom--;
					} else {
						x -= 6 /size;
					}	
	
	 				button.setLevel(y);
	 				
	 				button.setPosition(a.x+numOfButtonsPerLevel*button.group*size + button.group*0.3*size + x*size,
	 						a.y+bounds.height() + 5 + y*size);
					bottom++;
				} else {
					// vertical levels
					if(button.group!=rightButtonGroup) {
						right = 0;
						rightButtonGroup = button.group;
					}
					var x = Math.floor(right / numOfButtonsPerLevel);
					var y = right % numOfButtonsPerLevel;
					
					button.setLevel(x);
					
					button.setPosition(a.x+bounds.width() + 5 + x*size, 
							a.y+numOfButtonsPerLevel*button.group*size + button.group*0.3*size + y*size - 5);
					right++;
				}
	
				button.show();
			}.bind(this));
			this.isVisible = true;
	
		},
	
		/**
		 * Hide the shape menu
		 */
		hide: function() {
	
			this.buttons.each(function(button){
				button.hide();
			});
	
			this.isVisible = false;
			//this.bounds = undefined;
			//this.shape = undefined;
		},
	
		hoverAlignContainer: function(align, evt) {
			this.buttons.each(function(button){
				if(button.align == align) button.showOpaque();
			});
		},
		
		resetAlignContainer: function(align, evt) {
			this.buttons.each(function(button){
				if(button.align == align) button.showTransparent();
			});
		},
		
		isHover: function() {
			return 	this.buttons.any(function(value){
						return value.isHover();
					});
		},
		
		getWillShowButtons: function() {
			return this.buttons.findAll(function(value){return value.willShow;});
		},
		
		/**
		 * Returns a set on buttons for that align value
		 * @params {String} align
		 * @params {String} group
		 */
		getButtons: function(align, group){
			return this.getWillShowButtons().findAll(function(b){ return b.align == align && (group === undefined || b.group == group);});
		},
		
		/**
		 * Set the number of buttons to display on each level of the shape menu in the specified align group.
		 * Example: setNumberOfButtonsPerLevel(ORYX.CONFIG.SHAPEMENU_RIGHT, 2) causes that the buttons of the right align group 
		 * will be rendered in 2 rows.
		 */
		setNumberOfButtonsPerLevel: function(align, number) {
			this.numberOfButtonsPerLevel[align] = number;
		},
		
		/**
		 * Returns the number of buttons to display on each level of the shape menu in the specified align group.
		 * Default value is 1
		 */
		getNumberOfButtonsPerLevel: function(align) {
			if(this.numberOfButtonsPerLevel[align])
				return Math.min(this.getButtons(align,0).length, this.numberOfButtonsPerLevel[align]);
			else
				return 1;
		}
	
	};
	ORYX.Plugins.ShapeMenu = Clazz.extend(ORYX.Plugins.ShapeMenu);
	
	ORYX.Plugins.ShapeMenuButton = {
		
		/**
		 * Constructor
		 * @param option A key map specifying the configuration options:
		 * 					id: 	(String) The id of the parent DOM element for the new button
		 * 					icon: 	(String) The url to the icon of the button
		 * 					msg:	(String) A tooltip message
		 * 					caption:(String) The caption of the button (attention: button width > 22, only set for single column button layouts)
		 * 					align:	(String) The direction in which the button is aligned
		 * 					group: 	(Integer) The button group in the specified alignment 
		 * 							(buttons in the same group will be aligned side by side)
		 * 					callback:		(Function) A callback that is executed when the button is clicked
		 * 					dragcallback:	(Function) A callback that is executed when the button is dragged
		 * 					hovercallback:	(Function) A callback that is executed when the button is hovered
		 * 					resetcallback:	(Function) A callback that is executed when the button is reset
		 * 					arguments:		(Array) An argument array to pass to the callback functions
		 */
		construct: function(option) {
	
			if(option) {
				this.option = option;
				if(!this.option.arguments)
					this.option.arguments = [];
			} else {
				//TODO error
			}
	
			this.parentId = this.option.id ? this.option.id : null;
	
			// graft the button.
			var buttonClassName = this.option.caption ? "Oryx_button_with_caption" : "Oryx_button";
			this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", $(this.parentId),
				['div', {'class':buttonClassName}]);
			
			
			var imgOptions = {src: "/v5designer/libs/ext-2.0.2/resources/images/default/s.gif","class":"x-shapemenu-icon "+(this.option.cls||"").toLowerCase(), style:this.getStyleAttribute(this.option.icon)};
			if(this.option.msg){
				imgOptions.title = this.option.msg;
			}
			
			// graft and update icon (not in grafting for ns reasons).
			//TODO Enrich graft()-function to do this in one of the above steps.
			if(this.option.icon)
				this.img = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.node,
					['img', imgOptions]);
			
			if(this.option.caption) {
				var captionNode = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.node, ['span']);
				ORYX.Editor.graft("http://www.w3.org/1999/xhtml", captionNode, this.option.caption);
			}
	
			var onBubble = false;
	
			if (option.hovercallback||option.dragcallback||option.resetcallback) {
				this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEOVER, this.hover.bind(this), onBubble);
				this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEOUT, this.reset.bind(this), onBubble);
				this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEDOWN, this.activate.bind(this), onBubble);
				this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.hover.bind(this), onBubble);
				this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.move.bind(this), onBubble);
			}
			
			this.node.addEventListener('click', this.trigger.bind(this), onBubble);
			
			this.align = this.option.align ? this.option.align : ORYX.CONFIG.SHAPEMENU_RIGHT;
			this.group = this.option.group ? this.option.group : 0;
	
			this.hide();
	
			this.dragStart 	= false;
			this.isVisible 	= false;
			this.willShow 	= false;
			this.resetTimer;
		},
		
		getStyleAttribute: function(url){
			//注释掉 下面一句, 否则选中图形后的可创建图形的图标无法显示         shanglihui,20111124
			//url = (!url.startsWith("../")?ORYX.CONFIG.ROOT_PATH+url.slice(1):url);
			return "background: url('"+url+"') transparent no-repeat center center;";
		},
		
		setIcon: function(icon){
			if (icon&&this.img){
				//this.img.setAttribute("style", this.getStyleAttribute(icon));
				this.img.style.background = "";
				this.img.setAttribute("src", icon);
			}
		},
	
		setDescription: function(desc){
			if (desc&&this.img){
				this.img.setAttribute("title", desc);
			}
		},
		
		setCallback: function(fn){
			if (fn instanceof Function){
				this.option.callback = fn;
			}
		},
			
		hide: function() {
			this.node.style.display = "none";
			this.isVisible = false;
		},
		
		remove : function() {
			this.node.parentNode.removeChild(this.node);
		},
	
		show: function() {
			this.node.style.display = "";
			//this.node.style.opacity = this.opacity;
			this.isVisible = true;
		},
		
		showOpaque: function() {
			//this.node.style.opacity = 1.0;
		},
		
		showTransparent: function() {
			//this.node.style.opacity = this.opacity;
		},
		
		prepareToShow: function() {
			this.willShow = true;
		},
	
		prepareToHide: function() {
			this.willShow = false;
			this.hide();
		},
	
		setPosition: function(x, y) {
			this.node.style.left = x + "px";
			this.node.style.top = y + "px";
		},
		
		setLevel: function(level) {
			if (this.level !== level){
				
				this.node.className = this.node.className.replace(/x-opacity-[0-9]+/, "");
				
				if(level==0) this.node.className += " x-opacity-50";
				else if(level==1) this.node.className += " x-opacity-20";
				//else if(level==2) this.node.className += " x-opacity-10";
				else this.node.className += " x-opacity-0";
				
				this.level = level;
			}
		},
		
		setChildWidth: function(width) {
			this.childNode.style.width = width + "px";
		},
	
		reset: function(evt) {
			// Delete the timeout for hiding
			window.clearTimeout( this.resetTimer );
			this.resetTimer = window.setTimeout( this.doReset.bind(this), 100);
			
			if(this.option.resetcallback) {
				this.option.arguments.push(evt);
				var state = this.option.resetcallback.apply(this, this.option.arguments);
				this.option.arguments.remove(evt);
			}
		},
		
		doReset: function() {
			
			if(this.node.hasClassName('Oryx_down'))
				this.node.removeClassName('Oryx_down');
	
			if(this.node.hasClassName('Oryx_hover'))
				this.node.removeClassName('Oryx_hover');
	
		},
	
		activate: function(evt) {
			this.node.addClassName('Oryx_down');
			//Event.stop(evt);
			this.dragStart = true;
		},
	
		isHover: function() {
			return this.node.hasClassName('Oryx_hover') ? true: false;
		},
	
		hover: function(evt) {
			// Delete the timeout for hiding
			window.clearTimeout( this.resetTimer );
			this.resetTimer = null;
			
			this.node.addClassName('Oryx_hover');
			this.dragStart = false;
			
			if(this.option.hovercallback) {
				this.option.arguments.push(evt);
				var state = this.option.hovercallback.apply(this, this.option.arguments);
				this.option.arguments.remove(evt);
			}
		},
	
		move: function(evt) {
			if(this.dragStart && this.option.dragcallback) {
				this.option.arguments.push(evt);
				var state = this.option.dragcallback.apply(this, this.option.arguments);
				this.option.arguments.remove(evt);
			}
		},
	
		trigger: function(evt) {
			if(this.option.callback) {
				//Event.stop(evt);
				this.option.arguments.push(evt);
				var state = this.option.callback.apply(this, this.option.arguments);
				this.option.arguments.remove(evt);
			}
			this.dragStart = false;
		},
	
		toString: function() {
			return "HTML-Button " + this.id;
		}
	};
	ORYX.Plugins.ShapeMenuButton = Clazz.extend(ORYX.Plugins.ShapeMenuButton);
	
	//create command for undo/redo
	ORYX.Plugins.ShapeMenuPlugin.CreateCommand = ORYX.Core.Command.extend({
		construct: function(option, currentReference, position, plugin){
			this.option = option;
			this.currentReference = currentReference;
			this.position = position;
			this.plugin = plugin;
			this.selection = plugin.facade.getSelection();
			this.shape;
			this.edge;
			this.targetRefPos;
			this.sourceRefPos;
			this.mousePosition = position;
		},			
		execute: function(){
			
			var resume = false;
			
			/**
			 * CREATE SHAPE
			 * 
			 */
			if (this.shape) {
				if (this.shape instanceof ORYX.Core.Node) {
					this.option.parent.add(this.shape);
					if (this.edge) {
						this.plugin.facade.getCanvas().add(this.edge);
						this.edge.dockers.first().setDockedShape(this.option.connectedShape);
						this.edge.dockers.first().setReferencePoint(this.sourceRefPos);
						this.edge.dockers.last().setDockedShape(this.shape);
						this.edge.dockers.last().setReferencePoint(this.targetRefPos);
					}
					
					this.plugin.facade.setSelection([this.shape]);
					
				} 
				// If the shape to create is an edge
				else if (this.shape instanceof ORYX.Core.Edge) {
					this.plugin.facade.getCanvas().add(this.shape);
					this.shape.dockers.first().setDockedShape(this.option.connectedShape);
					// Determine reference point later
	//				this.shape.dockers.first().setReferencePoint(this.sourceRefPos);
					// If it's redo, restore the new state
					if ("undefined" !== typeof(this.newState)) {
						// The node from which was dragged
						var node = this.shape.dockers.first().getDockedShape();
						this.restoreDockerPos(node, this.shape, this.newState);
					}
				}
				resume = true;
			} else {
				this.shape = this.plugin.facade.createShape(Ext.apply(this.option, {dontUpdateSelection: true}));
				this.edge = (!(this.shape instanceof ORYX.Core.Edge)) ? this.shape.getIncomingShapes().first() : undefined;
				// If the shape to create is an edge
				if (this.shape instanceof ORYX.Core.Edge) {
					// The node from which was dragged
					var node = this.shape.dockers.first().getDockedShape();
					// All edges docked to the active node
					var edges = node.getAllDockedShapes().without(this.shape);
					// Save the old state
					this.oldState = [];
					edges.each(function(edge){
						// Create a new array for each edge
						this.oldState[edge.id] = [];
						// save the bounds of the docker or the reference point at index position in the array
						edge.dockers.each(function(docker, index){
							this.oldState[edge.id][index] = docker.referencePoint || docker.bounds.center();	
						}.bind(this));
					}.bind(this));
				}
			}
			
			if (this.currentReference && this.position) {
				if (this.shape instanceof ORYX.Core.Edge) {
					if (!(this.currentReference instanceof ORYX.Core.Canvas)) {
						this.shape.dockers.last().setDockedShape(this.currentReference);
						
						// @deprecated It now uses simply the midpoint
	//					var upL = this.currentReference.absoluteXY();
	//					var refPos = {
	//						x: this.position.x - upL.x,
	//						y: this.position.y - upL.y
	//					};
	//					
						if (this.shape.getStencil().keepState() !== true) {
							var magnet = this.currentReference.getDefaultMagnet();
							if (magnet){
								magnet = this.currentReference.getDefaultMagnet().bounds.center();
							} else {
								magnet = this.currentReference.bounds.center();
							}
							this.shape.dockers.last().setReferencePoint(magnet);
						}
					} else {
						this.shape.dockers.last().bounds.centerMoveTo(this.position);
					}
					this.sourceRefPos = this.shape.dockers.first().referencePoint;
					this.targetRefPos = this.shape.dockers.last().referencePoint;
					
				} else if (this.edge){
					this.sourceRefPos = this.edge.dockers.first().referencePoint;
					this.targetRefPos = this.edge.dockers.last().referencePoint;
				}
				
				/**
				 * DO Connect
				 */	
				if( this.option.canConnectBetween &&  this.currentReference instanceof ORYX.Core.Edge){
					var from 	= this.currentReference.getSource();
					var to 		= this.currentReference.getTarget();
					var edge;
					if (this.edgeBetween) {
						edge = this.edgeBetween;
						this.plugin.facade.getCanvas().add(this.edgeBetween);
					} else {
						edge = this.plugin.facade.createShape({
							namespace	: this.currentReference.getStencil().namespace(),
							type		: this.currentReference.getStencil().id(),
							dontUpdateSelection: true
						});
					}
					
					var mid = {x:this.shape.bounds.width()/2,y:this.shape.bounds.height()/2};
					if (this.shape.getDefaultMagnet()){
						mid = this.shape.getDefaultMagnet().bounds.center();
					}
					var refTo = this.currentReference.getDockers().last().referencePoint;
					
					var segment = this.currentReference.findSegment(this.shape.absoluteCenterXY());
					var dockers = this.currentReference.dockers.slice(this.currentReference.dockers.indexOf(segment.toDocker), this.currentReference.dockers.length-1);
					
					this.currentReference.getDockers().last().setDockedShape(this.shape);
					this.currentReference.getDockers().last().setReferencePoint(mid);
					
					edge.getDockers().first().setDockedShape(this.shape);
					edge.getDockers().first().setReferencePoint(mid);
					edge.getDockers().last().setDockedShape(to);
					edge.getDockers().last().setReferencePoint(refTo);
					
					this.dockerPosition = this.currentReference.getDockers().map(function(docker){ return docker.bounds.center(); });
					
					// Remove dockers from the old shape
					dockers.each(function(docker){
						this.currentReference.removeDocker(docker);
					}.bind(this));
					
					// Layout edges
					this.plugin.doLayout(this.currentReference);
					this.plugin.doLayout(edge);
					
					this.edgeBetween = edge;
					
					
					if (this.option.connectedShape === from || this.option.connectedShape === to){
						this.plugin.facade.deleteShape(this.edge);
						delete this.edge;
					}
				}
					
		 	/**
		 	 * ADD BY CLICK (Reposition shape)
		 	 */
			} else {
				
				var containedStencil = this.option.containedStencil;
				var connectedShape = this.option.connectedShape;
				var bc = connectedShape.bounds;
				var bs = this.shape.bounds;
				
				var defaultAlign = containedStencil.defaultAlign(this.shape);
				
				var pos = bc.center();
				if(defaultAlign==="north") {
					pos.y -= (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET + (bs.height()/2);
				} else if(defaultAlign==="northeast") {
					pos.x += (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.width()/2);
					pos.y -= (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.height()/2);
				} else if(defaultAlign==="southeast") {
					pos.x += (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.width()/2);
					pos.y += (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.height()/2);
				} else if(defaultAlign==="south") {
					pos.y += (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET + (bs.height()/2);
				} else if(defaultAlign==="southwest") {
					pos.x -= (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.width()/2);
					pos.y += (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.height()/2);
				} else if(defaultAlign==="west") {
					pos.x -= (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET + (bs.width()/2);
				} else if(defaultAlign==="northwest") {
					pos.x -= (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.width()/2);
					pos.y -= (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.height()/2);
				} else {
					pos.x += (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET + (bs.width()/2);
				}
				
				// Move shape to the new position
				this.shape.bounds.centerMoveTo(pos);
				
				// Move all dockers of a node to the position
				if (this.shape instanceof ORYX.Core.Node){
					(this.shape.dockers||[]).each(function(docker){
						docker.bounds.centerMoveTo(pos);
					});
				}
				
				//this.shape.update();
				this.position = pos;
				
				if (this.edge){
					this.sourceRefPos = this.edge.dockers.first().referencePoint;
					this.targetRefPos = this.edge.dockers.last().referencePoint;
				}
			}
			
			// Update
			this.plugin.facade.getCanvas().update();
			this.plugin.facade.updateSelection();
			
			// Layout
			if (!resume) {
				// If there is a connected shape
				if (this.edge){
					// If the edge is a message flow
					if (this.edge.getStencil().keepState() === true) {
						// Try to layout the edges
						var edgesLayouted = this.layoutEdges(this.edge, this.mousePosition);
						// If it fails, call the real edgeLayouter function defined by the callback
						if (!edgesLayouted) this.plugin.doLayout(this.edge);
					} 
					// If it's no messageflow, call the edgeLayouter
					else this.plugin.doLayout(this.edge);
				} 
				// If the shape is a messageflow, do the same as above
				else if (this.shape instanceof ORYX.Core.Edge){
					if (this.shape.getStencil().keepState() === true) {
						var edgesLayouted = this.layoutEdges(this.shape, this.mousePosition);
						if (!edgesLayouted) {
							if (this.currentReference instanceof ORYX.Core.Node){
								var magnet = this.currentReference.getDefaultMagnet();
								if (magnet){
									magnet = this.currentReference.getDefaultMagnet().bounds.center();
								} else {
									magnet = this.currentReference.bounds.center();
								}
								this.shape.dockers.last().setReferencePoint(magnet);
							}
							this.plugin.doLayout(this.shape);
						}
					} else this.plugin.doLayout(this.shape);
				}
			}
			if (this.shape instanceof ORYX.Core.Edge) {
				// The node from which was dragged
				var node = this.shape.dockers.first().getDockedShape();
				// Get all edges docked to the node
				var edges = node.getAllDockedShapes().without(this.shape);
				// Save the new state
				this.newState = [];
				// For all edges, create a new array and save the docker bounds at index position 
				edges.each(function(edge){
					this.newState[edge.id] = [];
					edge.dockers.each(function(docker, index){
						this.newState[edge.id][index] = docker.referencePoint || docker.bounds.center();	
					}.bind(this));
				}.bind(this));
			}
			
			// Set the new shape as selection
			if (!(this.shape instanceof ORYX.Core.Edge)) {
				this.plugin.facade.setSelection([this.shape]);	
			}
		},
		rollback: function(){
			
			/**
			 * ROLLBACK ADDING
			 */
			// Get the active node
			var node;
			if (this.shape instanceof ORYX.Core.Edge) {
				node = this.shape.dockers.first().getDockedShape();
			}
			// Delete the shape
			this.plugin.facade.deleteShape(this.shape);
			// If an old state exists and the removed shape was an edge, restore the docker positions of all inflicted edges
			if (this.oldState && this.shape && this.shape instanceof ORYX.Core.Edge) {
				// Restore all docker positions
				this.restoreDockerPos(node, this.shape, this.oldState);
			}
			if(this.edge) {
				this.plugin.facade.deleteShape(this.edge);
			}
			
			/**
			 * ROLLBACK CONNECTION BETWEEN
			 */
			if (this.edgeBetween&&this.dockerPosition){
				
				// Reset the dockers
				this.removeAllDocker(this.currentReference);
				this.dockerPosition.each(function(pos, i){	
					if (i==0||i==this.dockerPosition.length-1){ return; }					
					var docker = this.currentReference.createDocker(undefined, pos);
					docker.bounds.centerMoveTo(pos);
				}.bind(this));
				
				// Reset the last docker
				this.currentReference.getDockers().last().setDockedShape(this.edgeBetween.getTarget());
				this.currentReference.getDockers().last().setReferencePoint(this.edgeBetween.dockers.last().referencePoint);
				
				// Remove the new edge
				this.plugin.facade.deleteShape(this.edgeBetween);
				
			}
					
			// Update		
			this.plugin.facade.setSelection([].concat(this.selection).compact());
			this.plugin.facade.getCanvas().update();
			this.plugin.facade.updateSelection();
		},
		
		/**
		 * Restore all docker positions of all edges docked to the given node
		 * @param {ORYX.Core.Shape} node
		 * @param {ORYX.Core.Edge} shape
		 * @param {Array[ORYX.Core.Edge.id][Number]} state The state to restore 
		 */
		restoreDockerPos : function(node, shape, state) {
			// Get all edges docked to the node
			edges = node.getAllDockedShapes().without(shape);
			edges.each(function(edge){
				// If the actual docker count and the docker count in the given state mismatch, level it
				if (edge.dockers.length !== state[edge.id].length) {
					// If dockers are missing, fill with the second docker
					while(edge.dockers.length < state[edge.id].length) {
						edge.add(edge.dockers[1].clone(), 1);
					}
					// If dockers need to be removed, simply remove them
					while(edge.dockers.length > state[edge.id].length) {
						edge.remove(edge.dockers[1]);
					}
				}
				// For each docker, set the position according to the state's docker position at the same index
				edge.dockers.each(function(docker, index){
					if (docker.isDocked()) {
						docker.setReferencePoint(state[edge.id][index]);
					} else {
						docker.bounds.centerMoveTo(state[edge.id][index]);
					}
				}.bind(this));
			}.bind(this));
		},
		
		/**
		 * 
		 * @param edge
		 * @param position
		 * @returns {Boolean}
		 */
		layoutEdges : function(edge, position) {
			// Get the dockers of the active edge
			var first = edge.dockers.first();
			var second = edge.dockers[1];
			var last = edge.dockers.last();
			// Get the docked shapes and their bounds
			var from = first.getDockedShape();
			var fromBounds = from.absoluteBounds();
			var to = last.getDockedShape();
			var toBounds = to.absoluteBounds();
			
			// Define the size of small shapes for special treatment
			var smallShapeSize = 200;
			
			// Get the overlapping area
			var overlap = from.getOverlap(to);
			// If it exists, create the edge towards the mouse position
			if (overlap) {
			    var xOverlap = Math.min(fromBounds.lowerRight().x, toBounds.lowerRight().x) - Math.max(fromBounds.upperLeft().x, toBounds.upperLeft().x);
			    var yOverlap = Math.min(fromBounds.lowerRight().y, toBounds.lowerRight().y) - Math.max(fromBounds.upperLeft().y, toBounds.upperLeft().y);
	
			    // Create new edge at mouse position when the target shape is no small shape
			    if (xOverlap > 0 && !(fromBounds.width() < smallShapeSize || toBounds.width() < smallShapeSize) ||
			    	yOverlap > 0 && !(fromBounds.height() < smallShapeSize || toBounds.height() < smallShapeSize)) {
			        
			    	if (toBounds.isIncluded({x: xOverlap > 0 ? position.x : toBounds.center().x,
					            			 y: xOverlap > 0 ? toBounds.center().y : position.y})) {
			        	
			        	first.setReferencePoint({
			                x: xOverlap > 0 ? position.x - fromBounds.upperLeft().x : first.referencePoint.x,
			                y: xOverlap > 0 ? first.referencePoint.y : position.y - fromBounds.upperLeft().y
			            });
			            last.setReferencePoint({
			                x: xOverlap > 0 ? position.x - toBounds.upperLeft().x : last.referencePoint.x,
			                y: xOverlap > 0 ? last.referencePoint.y : position.y - toBounds.upperLeft().y
			            });
			            // Confirm layouting
			            return true;
			        }
				// Update all relevant edges between the newly created edge's docked shapes, if the target is a small shape:
			    } else if (xOverlap > 0 && (fromBounds.width() < smallShapeSize || toBounds.width() < smallShapeSize)||
			    		   yOverlap > 0 && (fromBounds.height() < smallShapeSize || toBounds.height() < smallShapeSize)) {
					if (edge.dockers.length === 2) {
					    // find all edges between the active edge's docked shapes
						
						var side = fromBounds.getSide(first.bounds.center());
						// Find ALL edges from the given side, change flag here: -----------------|
						var relevantEdges = this.getRelevantEdges(from, fromBounds, side, edge, true);
						var l = relevantEdges.length;
					    
					    relevantEdges.each(function(e, index) {
					    	if (e.dockers[0].getDockedShape() === from) {
					            var start = e.dockers[0];
					            var last = e.dockers[1];
					        } else {
					            var start = e.dockers[1];
					            var last = e.dockers[0];
					        }
					    	start.setReferencePoint({
					        	x : xOverlap > 0 ? overlap.upperLeft().x - (fromBounds.upperLeft().x) + (index + 1) / (l + 1) * overlap.width():
					   	    					   fromBounds.center().x - fromBounds.upperLeft().x,
					       	    y : yOverlap > 0 ? overlap.upperLeft().y - (fromBounds.upperLeft().y) + (index + 1) / (l + 1) * overlap.height() :
					       	    				   fromBounds.center().y - fromBounds.upperLeft().y
					        });
							var absRef = start.getAbsoluteReferencePoint();					
							// Set the second docker; if the docked segment was aligned, align it again
							if (last.isDocked()) {
						        last.setReferencePoint({
						        	x : ["top", "bottom"].include(side) ? 
						        			absRef.x - toBounds.upperLeft().x :
						        			last.referencePoint.x,
						 		    y : ["left", "right"].include(side) ?
						 		    		absRef.y - toBounds.upperLeft().y :
						 		    		last.referencePoint.y
						        });
					        } else {
					        	last.bounds.centerMoveTo({
									x : (["left","right"].include(side) ? last.bounds.center().x : start.getAbsoluteReferencePoint().x),
								    y : (["left","right"].include(side) ? start.getAbsoluteReferencePoint().y : last.bounds.center().y)
								});
					        }
					        e._update(true);
					    });
					}
				}
			    // Remap overlaying edges
				var dockers = [];
				var relevantEdges = this.getRelevantEdges(from, fromBounds, side, edge, false);
				// Get all to this.node docked dockers
				relevantEdges.each(function(edge) {
					dockers.push(edge.dockers[0].getDockedShape() === from ? edge.dockers[0] :
				    edge.dockers[edge.dockers.length - 1]);
				}.bind(this)); 
				// Check if 2 or more dockers have the same coordinates, if so, collect the edge
				var etr = [];
				var threshold = 10;
				dockers.each(function(activeDocker){ 
				    dockers.each(function(docker) {
				        if (Math.abs(docker.bounds.center().x - activeDocker.bounds.center().x) < threshold &&
				            Math.abs(docker.bounds.center().y - activeDocker.bounds.center().y) < threshold &&
				            docker !== activeDocker) {
				            if (!etr.include(docker.parent) && docker.parent.getStencil().keepState()) {
				            	etr.push(docker.parent);
				            }
				        }
				    });
				});
	
			    // Realign all overlaying edges
			    etr.each(function(e, i) {
			    	if (e) {
						first.setReferencePoint({
							x : xOverlap > 0 ?
								(overlap.upperLeft().x - fromBounds.upperLeft().x) + (i + 1) / (relevantEdges.length + 1) * overlap.width() :
								first.referencePoint.x,
							y : yOverlap > 0 ?
								(overlap.upperLeft().y - fromBounds.upperLeft().y) + (i + 1) / (relevantEdges.length + 1) * overlap.height() :
								first.referencePoint.y
						});
						
						if (second.isDocked()) {
							second.setReferencePoint({
								x : xOverlap > 0 ?
									(overlap.upperLeft().x - toBounds.upperLeft().x) + (i + 1) / (relevantEdges.length + 1) * overlap.width() :
									second.referencePoint.x,
								y : yOverlap > 0 ?
									(overlap.upperLeft().y - toBounds.upperLeft().y) + (i + 1) / (relevantEdges.length + 1) * overlap.height() :
									second.referencePoint.y
							});
						} else {
							second.bounds.centerMoveTo({
								x : (["left","right"].include(side) ? second.bounds.center().x : first.getAbsoluteReferencePoint().x),
							    y : (["left","right"].include(side) ? first.getAbsoluteReferencePoint().y : second.bounds.center().y)
							});
						}
		    			e._update(true);
			    	}
			    }.bind(this));
			    
			    return true; // Do not layout afterwards
			}
		},
		
		/**
		 * Returns all relevant edges
		 * @param {ORYX.Core.Shape} shape The active shape
		 * @param {ORYX.Core.Bounds} bounds The Bounds of the active shape
		 * @param {String} side The side of the docked segment
		 * @param {ORYX.Core.Edge} optionalEdge The active edge
		 * @param {Boolean} restrictToSharedShapes If true only edges between the same shapes are considered
		 * @returns {ORYX.Core.Edge[]} The relevant edges
		 */
		getRelevantEdges : function(shape, bounds, side, optionalEdge, restrictToSharedShapes) {
			var relevantShapes = optionalEdge ? [optionalEdge.getSource(), optionalEdge.getTarget()].compact() : [];
			
			var edges = shape.getAllDockedShapes().findAll(function(edge){
				// Don't look for attached nodes
				if (edge instanceof ORYX.Core.Node){
	    	    	return false;
	    	    }
				
	    	    if (edge.dockers[0].getDockedShape() === shape) {
	    	    	var second = edge.dockers[1];
	    	    } else {
	    	    	var second = edge.dockers[edge.dockers.length - 2];
	    	    }
	    	    
	    	    // Find only those edges which share the same source/target
	    	    if (restrictToSharedShapes && !(relevantShapes.include(edge.getSource()) && relevantShapes.include(edge.getTarget()))){
	    	    	return false;
	    	    }
	    	    
				return bounds.getSide(second.bounds.center()) === side;// && edge.getStencil().keepState() == true
			}.bind(this));
			
			if (optionalEdge instanceof ORYX.Core.Edge && !edges.include(optionalEdge)) {
				edges.push(optionalEdge);
			}
			return edges
			// Sort ASC by their to this.node docked docker positions
			.sort(function(a,b) {
				if (a.dockers[0].getDockedShape() === shape) {
					var aa = a.dockers[0];
					var ab = a.dockers[1];
				} else {
					var aa = a.dockers[a.dockers.length - 1];
					var ab = a.dockers[a.dockers.length - 2];
				}
				if (b.dockers[0].getDockedShape() === shape) {
					var ba = b.dockers[0];
					var bb = b.dockers[1];
				} else {
					var ba = b.dockers[b.dockers.length - 1];
					var bb = b.dockers[b.dockers.length - 2];
				}
				aa = aa.bounds.center();
				ab = ab.bounds.center();
				ba = ba.bounds.center();
				bb = bb.bounds.center();
				
				return side === "top" || side === "bottom" ?
						Math.round(aa.x - ba.x) < 0 ?
								-1 : (Math.round(aa.x - ba.x) > 0? 1 : 0):
						Math.round(aa.y - ba.y) < 0 ?
								-1 : (Math.round(aa.y - ba.y) > 0 ? 1 : 0);
			});
		},
		
		/**
		 * 
		 * @param edge
		 */
		removeAllDocker: function(edge){
			edge.dockers.slice(1, edge.dockers.length-1).each(function(docker){
				edge.removeDocker(docker);
			});
		}
	});	
	
}());

/**
 * Copyright (c) 2009
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX) { var ORYX = {}; }
if(!ORYX.Plugins) { ORYX.Plugins = {}; }

(function() {
	ORYX.Plugins.SelectStencilSetPerspective = Clazz.extend({

		facade: undefined,
		
		extensions : undefined,
		
		perspectives: undefined,

		construct: function(facade) {
			this.facade = facade;

			var option = {
				cls:'selectssperspective',
				border: false,
				autoWidth:true
			};
			
			if (Ext.isIPad){
				option.anchor = "100%";
				option.layout = "anchor";
			}
			
			var panel = new Ext.Panel(option);

			this.facade.addToRegion("west", panel);
			
			var jsonObject = this.facade.getStencilSetExtensionDefinition();
			
			var stencilsets = this.facade.getStencilSets();
			var namespaces = stencilsets.keys();
			
			/* Determine available extensions */
			this.extensions = {};
			jsonObject.extensions.each(function(ext) {
				if (namespaces.include(ext["extends"])) {
					this.extensions[ext.namespace] = ext;
				}
			}.bind(this));
			
			/* Determine available extensions */
			this.perspectives = {};
			jsonObject.perspectives.each(function(per) {
				if(namespaces.include(per.stencilset)) {
					this.perspectives[per.namespace] = per;
				}
			}.bind(this));

			stencilsets.values().each(function(sset) {

				var validPerspectives = jsonObject.perspectives.findAll(function(perspective){
					return perspective.stencilset == sset.namespace();
				}); 
				
				// If one perspective is defined, load this
				if (validPerspectives.size() === 1) {
					var rescuePerspective = function() {
						this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, rescuePerspective);
						this.loadPerspective(validPerspectives.first().namespace);
					}.bind(this);
					
					this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, rescuePerspective);
				
				// If more than one perspective is defined, add a combobox and load the first one
				} else if (validPerspectives.size() > 1) {
					this.createPerspectivesCombobox(panel, sset, validPerspectives);
				} else {
					var removeExtensions = function() {
						this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, removeExtensions);
						this.loadPerspective();
					}.bind(this);
					
					this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, removeExtensions);
				}

			}.bind(this));
		},

		createPerspectivesCombobox: function(panel, stencilset, perspectives) {
		
			var lang = ORYX.I18N.Language.split("_").first();
		
			var data = [];
			perspectives.each(function(perspective) {
				data.push([perspective.namespace, (perspective["title_"+lang]||perspective.title).unescapeHTML(), perspective["description_"+lang]||perspective.description]);
			});
			
		
			var store = new Ext.data.SimpleStore({
				fields: ['namespace', 'title', 'tooltip'],
				data: data
			});
		
			var combobox = new Ext.form.ComboBox({
				anchor			: "100%",
				store			: store,
				displayField	: 'title',
				valueField		: 'namespace',
				forceSelection	: true,
				typeAhead		: true,
				mode			: 'local',
				allowBlank		: false,
				autoWidth		: true,
				triggerAction	: 'all',
				emptyText		: 'Select a perspective...',
				selectOnFocus	: true,
				tpl				: '<tpl for="."><div '+(Ext.isIE9?'title':'ext:qtip')+'="{tooltip}" class="x-combo-list-item">{[(values.title||"").escapeHTML()]}</div></tpl>',
				editable		: false,
				readOnly		: true
			});
			
			//panel.on("resize", function(){combobox.setWidth(panel.body.getWidth())});
			
			panel.add(combobox);
			panel.doLayout();
			
			combobox.on('beforeselect', this.onSelect ,this);
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, function(){
				this.facade.getStencilSets().values().each(function(stencilset) {
					var ext = stencilset.extensions().values();
				
					if (ext.length > 0){
						var persp = perspectives.find(function(perspective){  
							return	(perspective.extensions || []).include(ext[0].namespace)	// Check if there is the extension part of the extension in the perspectives
									 || (perspective.addExtensions || []).any(function(add){  		
											return (
														// OR Check if the namespace is part of the addExtension part
														add.ifIsLoaded === stencilset.namespace() 
														&& add.add == ext[0].namespace
													) || (
														// OR is some in the default
														add.ifIsLoaded !== stencilset.namespace() 
														&& add["default"] === ext[0].namespace
													); 	
										});
						});
						
						if (!persp){
							persp = perspectives.find(function(r){ 
								return !(r.extensions instanceof Array) || r.extensions.length <= 0; 
							});
						}
						
						if (persp) {
							combobox.setValue(data[perspectives.indexOf(persp)][1]);
							
							// setValue does not trigger the beforeselect event -> perspective
							// won't be loaded. That's why we load it manually.
							this.loadPerspective(data[perspectives.indexOf(persp)][0]);
							throw $break;
						}
					}
					
					// Force to load extension
					combobox.setValue(data[0][1]);
					this.loadPerspective(data[0][0]);
					
				}.bind(this));
			}.bind(this));
		},
		
		onSelect: function(combobox, record) {
			if (combobox.getValue() === record.get("namespace") || combobox.getValue() === record.get("title")){
				return;
			}
			
			this.loadPerspective(record.json[0]);
				
		},
		
		loadPerspective: function(ns){
			// If there is no namespace
			if (!ns){
				// unload all extensions
				this._loadExtensions([], [], true);
				return;
			}
			
			/* Get loaded stencil set extensions */
			var stencilSets = this.facade.getStencilSets();
			var loadedExtensions = new Object();
			var perspective = this.perspectives[ns];
			
			stencilSets.values().each(function(ss) { 
		    	ss.extensions().values().each(function(extension) {
					if(this.extensions[extension.namespace])
						loadedExtensions[extension.namespace] = extension;
				}.bind(this));
			}.bind(this));
			
			
			/* Determine extensions that are required for this perspective */
			var addExtensions = new Array();
			if(perspective.addExtensions||perspective.extensions) {
				[]
				 .concat(this.perspectives[ns].addExtensions||[])
				 .concat(this.perspectives[ns].extensions||[])
				 .compact()
				 .each(function(ext){
					if(!ext.ifIsLoaded) {
						addExtensions.push(this.extensions[ext]);
						return;
					}
					
					if(loadedExtensions[ext.ifIsLoaded] && this.extensions[ext.add]) {
						addExtensions.push(this.extensions[ext.add]);
					} else {
						if(ext["default"] && this.extensions[ext["default"]]) {
							addExtensions.push(this.extensions[ext["default"]]);
						}
					}
				}.bind(this));
			}
			
			/* Determine extension that are not allowed in this perspective */
			
			/* Check if flag to remove all other extension is set */
			if(this.perspectives[ns].removeAllExtensions) {	
				window.setTimeout(function(){
					this._loadExtensions(addExtensions, undefined, true);
				}.bind(this), 10);
				return;		
			}
			
			/* Check on specific extensions */
			var removeExtensions = new Array();
			if(perspective.removeExtensions) {
				perspective.removeExtensions.each(function(ns){
					if (loadedExtensions[ns])
						removeExtensions.push(this.extensions[ns]);
				}.bind(this));
			}
			
			if (perspective.extensions && !perspective.addExtensions && !perspective.removeExtensions) {
				var combined = [].concat(addExtensions).concat(removeExtensions).compact();
				$H(loadedExtensions).each(function(extension){
					var key = extension.key;
					if (!extension.value.includeAlways&&!combined.any(function(r){ return r.namespace == key })) {
						removeExtensions.push(this.extensions[key]);
					}
				}.bind(this))
			}
			
			window.setTimeout(function(){
				this._loadExtensions(addExtensions, removeExtensions, false, ns);
			}.bind(this), 10);
		},
		
		/*
		 * Load all stencil set extensions specified in param extensions (key map: String -> Object)
		 * Unload all other extensions (method copied from addssextension plugin)
		 */
		_loadExtensions: function(addExtensions, removeExtensions, removeAll, ns) {
			var stencilsets = this.facade.getStencilSets();
			
			var atLeastOne = false;
			
			// unload unselected extensions
			stencilsets.values().each(function(stencilset) {
				var unselected = stencilset.extensions().values().select(function(ext) { return addExtensions[ext.namespace] == undefined; }); 
				if(removeAll) {
					unselected.each(function(ext) {
						if(!ext.includeAlways) {
							stencilset.removeExtension(ext.namespace);
							atLeastOne = true;
						}
					});
				} else {
					unselected.each(function(ext) {
						var remove = removeExtensions.find(function(remExt) {
							return ext.namespace === remExt.namespace;
						});
						
						if(remove) {
							stencilset.removeExtension(ext.namespace);
							atLeastOne = true;
						}
					});
				}
			});
			
			// load selected extensions
			addExtensions.each(function(extension) {
				
				if (!extension || !extension["extends"]){
					return;
				}
				
				var stencilset = stencilsets[extension["extends"]];
				
				if(stencilset) {
					// Load absolute
					if ((extension.definition || "").startsWith("/")) {
						stencilset.addExtension(extension.definition);
					// Load relative
					} else {
						stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + extension.definition);
					}
					atLeastOne = true;
				}
			}.bind(this));
			
			if (atLeastOne) {
				stencilsets.values().each(function(stencilset) {
					this.facade.getRules().initializeRules(stencilset);
				}.bind(this));
			}
			
			var perspectiveExtensions = {};
			if(ns) {
				
				[]
				 .concat(this.perspectives[ns].addExtensions||[])
				 .concat(this.perspectives[ns].extensions||[])
				 .compact().each(function(extDef) {
					 var extension = undefined;
					 stencilsets.values().any(function(stencilset) {
						 extension = stencilset.extensions().values().find(function(ssExtension) {
							 return (ssExtension.namespace === extDef);
						 }.bind(this));
						 
						 return extension;
					 }.bind(this));
					 
					 if(extension) {
						 perspectiveExtensions[extension.namespace] = extension;
					 }
				 }.bind(this));
			}
				 
			this.facade.raiseEvent({
				type: ORYX.CONFIG.EVENT_STENCIL_SET_LOADED,
				stencilsets: stencilsets,
				extensions: perspectiveExtensions
			});
				
			if (atLeastOne) {
				var selection = this.facade.getSelection();
				this.facade.setSelection();
				if (!selection || selection.length == 0) {
					this.facade.raiseEvent({
						type : ORYX.CONFIG.EVENT_SELECTION_CHANGED,
						elements : [],
						force : false
					});
				} else {
					this.facade.setSelection(selection);
				}
			}
		}

	});
})();


/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner, Lukas Brand
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/


if (!ORYX.Plugins) {
	ORYX.Plugins = new Object();
}

ORYX.Plugins.ShapeRepository = {

	facade: undefined,

	construct: function(facade) {
		this.facade = facade;
		this._currentParent;
		this._canContain = undefined;
		this._canAttach  = undefined;

		this.shapeList = new Ext.tree.TreeNode({
			
		});

		var option = {
	            cls:'shaperepository',
				loader: new Ext.tree.TreeLoader(),
				root: this.shapeList,
				autoScroll:true,
				rootVisible: false,
				lines: false
			};
		
		if (Ext.isIPad){
			option.anchor = '100% -20';
		} else {
			option.anchors = '0, -30';
		}
		
		var panel = new Ext.tree.TreePanel(option)
		var region = this.facade.addToRegion("west", panel, ORYX.I18N.ShapeRepository.title);
	
		// Create a Drag-Zone for Drag'n'Drop
		var DragZone = new ORYX.Core.DragZone(this.shapeList.getUI().getEl(), this.facade);
		DragZone.afterValidDrop = this.drop.bind(this);
		
		// Load all Stencilssets
		this.setStencilSets();
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, this.setStencilSets.bind(this));

	},
	
	/**
	 * Check for offers to hook into the shape repository
	 * @param {Array} offers
	 */
	registryChanged: function(offers) {
		// Get all offers for the shape repository
		this.pluginsData = (offers||[]).findAll(function(offer){
			return offer && offer.target && offer.target === ORYX.Plugins.ShapeRepository;
		});
	},
	
	/**
	 * Load all stencilsets in the shaperepository
	 */
	setStencilSets: function(event) {
		// Remove all childs
		var child = this.shapeList.firstChild;
		while(child) {
			this.shapeList.removeChild(child);
			child = this.shapeList.firstChild;
		}

		var invalidStencilIds = [];
		if(event && event.stencilsets && event.extensions) {
			event.stencilsets.values().each(function(stencilset) {
				stencilset.extensions().values().each(function(extension) {
					if(!($H(event.extensions).keys().member(extension.namespace)) && extension.stencils) {
						extension.stencils.each(function(stencil) {
							invalidStencilIds.push(stencil.id);
						}.bind(this));
					}
				}.bind(this));
			}.bind(this));
		}
		
		// Go thru all Stencilsets and stencils
		this.facade.getStencilSets().values().each(function(sset) {
			
			// For each Stencilset create and add a new Tree-Node
			var stencilSetNode;
			
			var typeTitle = sset.title(), cls = "x-stencilset-"+String(sset.namespace().split("/").last()).toLowerCase().replace(/[^a-z0-9]/g, "");
			var extensions = sset.extensions();
			if (extensions && extensions.size() > 0) {
				var selectedExtension = extensions.values().find(function(r){ return !r.includeAlways && r.title; });
				typeTitle += selectedExtension ? " / " + ORYX.Core.StencilSet.getTranslation(selectedExtension, "title") : "";
				if (selectedExtension){
					cls += " " + "x-stencilsetextension-" + String(selectedExtension.namespace.split("/").last()).toLowerCase().replace(/[^a-z0-9]/g, "");
				}
			} 
			
			this.shapeList.appendChild(stencilSetNode = new Ext.tree.TreeNode({
				text:Signavio.Utils.escapeHTML(typeTitle), 			// Stencilset Name
				allowDrag:false,
        		allowDrop:false,           
				iconCls:'headerShapeRepImg',
	            cls:'headerShapeRep',
				singleClickExpand:true}));
			
			// Set class name to the container
			stencilSetNode.ui.render = function(){
				Ext.tree.TreeNodeUI.prototype.render.apply(this, arguments);
				this.wrap.className += " "+cls;
			};
			
			stencilSetNode.render();
			stencilSetNode.expand();				

			/* CREATE THE SHAPE REPOSITORY FOR EACH STENCIL SET */
			
			// Get Stencils from Stencilset
			var stencils = sset.stencils(this.facade.getCanvas().getStencil(),
										 this.facade.getRules());

			// Wrap any existing plugins to stencils
			if (this.pluginsData) {
				var addedPlugins = [];
				this.pluginsData.each(function(offer) {
					var offerWrap = this.getOfferWrap(offer, event);
					stencils.push(offerWrap);
				}.bind(this));
			}
			
			// Get all groups
			var stencilGroups = stencils.invoke("groups").flatten().compact().uniq();
			
			// Filter all hidden stencils
			stencils = stencils.findAll(function(s) {
				return !s.hide();
			});
			
			// Check if groups should be displayed at all
			var noGroups = (stencils.length - invalidStencilIds.length <= ORYX.CONFIG.MAX_NUM_SHAPES_NO_GROUP || stencilGroups.length <= 1);
			
			
			// Initialize stencil groups
			var stencilsByGroups = new Hash();
			stencilsByGroups["noGroup"] = [];
			stencilGroups.each(function(group) {
				stencilsByGroups[group] = [];
			});
			
			
			// Order all stencils according to their groups
			stencils.sortBy(function(stencil){
				return ("function" == typeof stencil.index ? stencil.index() : null) || 0;
			}).each(function(stencil) {
				var groups = stencil.groups instanceof Function && stencil.groups() || [];

				// If the stencil has no group, push it to the list of stencils with no group
				if (groups.length === 0) {
					groups = ["noGroup"];
				}
				
				groups.each(function(group) {
					if ("function" == typeof stencil.index && "number" === typeof stencil.index()) {
						// If an index is defined, insert the stencil at the given position
						stencilsByGroups[group] = stencilsByGroups[group].slice(0, stencil.index()).concat(stencil, stencilsByGroups[group].slice(stencil.index()));
					} else {
						// Else push the stencil to the group
						stencilsByGroups[group].push(stencil);
					}
				}.bind(this));
			});
			
			// If no groups should be displayed, just add all available stencils to the shape repository tree
			if (noGroups) {
				(stencilsByGroups.values().flatten()||[]).each(function(stencil) {
					// Filter all invalid stencils
					if (!(invalidStencilIds && invalidStencilIds.member(stencil.id()))) {
						// If a callback is registered to handle the tree add, call it now
						if (stencil.onTreeAdd instanceof Function) {
							stencil.onTreeAdd(this, stencilSetNode, addedPlugins);
						} else {
							// Add the stencil to the shape repository
							this.createStencilTreeNode(stencilSetNode, stencil);
						}						
					}
				}.bind(this));
			}
			// If groups should be displayed, add all available stencils to their groups
			else {
				
				var treeGroups = new Hash();
				
				// Generate a tree node for each group, add all stencils
				stencilsByGroups.each(function(pair) {
					if (pair.key === "noGroup" || pair.value.length === 0) {
						return;
					}
					
					// If there is a new group
					if(!treeGroups[pair.key]) {
						// Create a new group
						treeGroups[pair.key] = new Ext.tree.TreeNode({
							text:pair.key,					// Group-Name
							allowDrag:false,
	    					allowDrop:false,            
							iconCls:'headerShapeRepImg', // Css-Class for Icon
				            cls:'headerShapeRepChild',  // CSS-Class for Stencil-Group
							singleClickExpand:true});
						
						treeGroups[pair.key].ui.render = function(){
							Ext.tree.TreeNodeUI.prototype.render.apply(this, arguments);
							this.wrap.className += " "+"x-stencil-group-"+pair.key.toLowerCase();
						};
						
						// Add the Group to the ShapeRepository
						stencilSetNode.appendChild(treeGroups[pair.key]);
						treeGroups[pair.key].render();	
					}
					
					pair.value.each(function(stencil) {
						// Add all valid stencils from that group
						if (!(invalidStencilIds && invalidStencilIds.member(stencil.id()))) {
							// If a callback is registered to handle the tree add, call it now
							if (stencil.onTreeAdd instanceof Function) {
								stencil.onTreeAdd(this, treeGroups[pair.key], addedPlugins);
							} else {
								this.createStencilTreeNode(treeGroups[pair.key], stencil);
							}
						}	
					}.bind(this));
				}.bind(this));
				
				// If stencils have no group, add them directly to the shape repository
				if (stencilsByGroups["noGroups"]) {
					stencilsByGroups["noGroups"].each(function(stencil) {
						// Add all valid stencils from that group
						if (!(invalidStencilIds && invalidStencilIds.member(stencil.id()))) {
							// If a callback is registered to handle the tree add, call it now
							if (stencil.onTreeAdd instanceof Function) {
								stencil.onTreeAdd(this, stencilSetNode, addedPlugins);
							} else {
								this.createStencilTreeNode(stencilSetNode, stencil);
							}
						}	
					}.bind(this));
				}
			}
			
			// If plugins exist, register dragzones for each plugin
			if (this.pluginsData) {
				// Register a drag zone for each added plugin
				addedPlugins.each(function(plugin) {
					var element = plugin.element;
					var offer = plugin.offer;
					var callbacks = offer.callbacks;
					
					// Create a new drag zone for the plugin
					var PluginDragZone = new ORYX.Core.DragZone(element.getUI().getEl(), this.facade);
					
					if (callbacks) {
						if (callbacks.afterDragEnter)
							PluginDragZone.afterDragEnter = callbacks.afterDragEnter;
						if (callbacks.afterDragOver)
							PluginDragZone.afterDragOver = callbacks.afterDragOver;
						if (callbacks.afterDragOut)
							PluginDragZone.afterDragOut = callbacks.afterDragOut;
						if (callbacks.afterDragDrop)
							PluginDragZone.afterDragDrop = callbacks.afterDragDrop;
						if (callbacks.onValidDrop)
							PluginDragZone.onValidDrop = callbacks.onValidDrop;
					}
				}.bind(this));
			}

			if (this.shapeList.firstChild.firstChild) {
				this.shapeList.firstChild.firstChild.expand(false, true);
			}	
		}.bind(this));
	},

	createPluginTreeNode : function(parentTreeNode, plugin) {
		// Create and add the plugin to the Group
		var newElement = new Ext.tree.TreeNode({
				text:		plugin.title(), 		// Text of the plugin
				icon:		plugin.icon(),			// Icon of the plugin
				allowDrag:	false,					// Don't use the Drag and Drop of Ext-Tree
				allowDrop:	false,
				iconCls:	'ShapeRepEntreeImg', 	// CSS-Class for Icon
				cls:		'ShapeRepEntree'		// CSS-Class for the Tree-Entree
				});

		parentTreeNode.appendChild(newElement);		
		newElement.render();	
				
		var ui = newElement.getUI();
		
		// Set the tooltip
		ui.elNode.setAttributeNS(null, "title", plugin.description());
		
		// Register the Stencil on Drag and Drop
		Ext.dd.Registry.register(ui.elNode, {
				node: 		ui.node,
		        handles: 	[ui.elNode, ui.textNode].concat($A(ui.elNode.childNodes)), // Set the Handles
		        isHandle: 	false,
				type:		plugin.id(),			// Set Type of plugin 
				namespace:	plugin.namespace()		// Set Namespace of plugin
				});
		
		return newElement;
	},
	
	/**
	 * Creates a new Tree node for a given stencil
	 * @param parentTreeNode
	 * @param stencil
	 * @returns {Ext.tree.TreeNode}
	 */
	createStencilTreeNode: function(parentTreeNode, stencil) {

		// Create and add the Stencil to the Group
		var newElement = new Ext.tree.TreeNode({
				text:		stencil.title(), 		// Text of the stencil
				icon:		stencil.icon(),			// Icon of the stencil
				allowDrag:	false,					// Don't use the Drag and Drop of Ext-Tree
				allowDrop:	false,
				iconCls:	'ShapeRepEntreeImg', 	// CSS-Class for Icon
				cls:		'ShapeRepEntree ' + ("x-stencil-"+stencil.idWithoutNs().toLowerCase())		
													// CSS-Class for the Tree-Entree
				});

		parentTreeNode.appendChild(newElement);		
		newElement.render();	
				
		var ui = newElement.getUI();
		
		// Set the tooltip
		ui.elNode.setAttributeNS(null, "title", stencil.description());
		
		// Register the Stencil on Drag and Drop
		Ext.dd.Registry.register(ui.elNode, {
				node: 		ui.node,
		        handles: 	[ui.elNode, ui.textNode].concat($A(ui.elNode.childNodes)), // Set the Handles
		        isHandle: 	false,
				type:		stencil.id(),			// Set Type of stencil 
				namespace:	stencil.namespace()		// Set Namespace of stencil
				});
		
		return newElement;
		
	},
	
	drop: function(option, shape, event) {

		//var position = this.facade.eventCoordinates( event.browserEvent );	
		var command = new ORYX.Core.CreateShapeCommand(option, shape, option.position, this);
		this.facade.executeCommands([command]);
		
		this._currentParent = undefined;
	},
	
	getOfferWrap : function(offer, event) {
		return {
			title		: function() {return offer.title;},
			description	: function() {return offer.description;},
			icon		: (offer.icon instanceof Function ? offer.icon : function() {return offer.icon;}),
			id			: function() {return offer.id;},
			idWithoutNs	: function() {return offer.id.replace(offer.namespace, ""); },
			groups		: function() {return (offer.groups instanceof Array ? offer.groups : [offer.groups]);},
			namespace	: function() {return offer.namespace;},
			hide		: function() {return (offer.hide instanceof Function ? offer.hide(event) : false);},
			callbacks	: {
				afterDragEnter	: offer.afterDragEnterClb,
				afterDragOver	: offer.afterDragOverClb,
				afterDragOut	: offer.afterDragOutClb,
				afterDragDrop 	: offer.afterDragDropClb,
				onValidDrop 	: offer.onValidDropClb
			},
			onTreeAdd	: function(context, stencilSetNode, addedPlugins) {
				if (!addedPlugins) addedPlugins = [];
				addedPlugins.push({
					element	: context.createStencilTreeNode.apply(context, [stencilSetNode, this]),
					offer	: this
				});
			},
			index		: function(){
				return ("function" == typeof offer.index ? offer.index() : offer.index) || null;
			}
		};
	}
};

ORYX.Plugins.ShapeRepository = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.ShapeRepository);
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if (!ORYX) var ORYX = {};
if (!ORYX.Plugins) ORYX.Plugins = {};

(function(){
		
	ORYX.Plugins.PropertyWindow = {
	
		facade: undefined,
	
		construct: function(facade) {
			// Reference to the Editor-Interface
			this.facade = facade;
	
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHOW_PROPERTYWINDOW, this.init.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.selectDiagram.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHOW_PROPERTYWINDOW_DIALOG, this.handleShowDialog.bind(this));
			
			this.init();
			this.initStencilSetSpecifics();
			
			// Provide cookie state manage to store state of complex type editor
			var cp = new Ext.state.CookieProvider({
		       path: window.location.pathname,								// Set cookie path
		       expires: new Date(new Date().getTime()+(1000*60*60*24*7)) 	// 7 days
		   });
		   Ext.state.Manager.setProvider(cp);
		   
		   
		   /**
		    * Defines the initial expanded groups
		    */
		   this.expandedGroups = $H({
				   meta : true,
				   popular: true,
				   tim: true,
				   saperion: true
		   });
		},
		
		/**
		 * Handler for Event ORYX.CONFIG.EVENT_SHOW_PROPERTYWINDOW_DIALOG
		 * 
		 * Opens a dialog to edit the property.
		 * 
		 * Expects propertyKey option
		 */
		handleShowDialog: function(event) {
			// vars used in function
			var prop, col, row, editor, fn;
			
			if(!event.propertyKey) {return;}
			
			// Lookup for property e.g. "oryx-tasks"
			prop = event.propertyKey;
			
			// Get column where the values are
			col = this.grid.getColumnModel().getIndexById("propertywindow_column_value");
			// Get the row where the property is
			row = this.grid.store.findBy(function(r){ return r.get("gridProperties").propId == prop;});
			
			// Start editing
			this.grid.startEditing(row, col);
			
			// Tigger pop up
			editor = this.grid.getColumnModel().config[col].editor;
			editor.setValue(this.grid.store.getAt(row).get("value"));
			editor.field.onTriggerClick();
			
			// Hide field
			fn = function(){
				editor.un("startedit", fn, this);
				this.grid.stopEditing();
			};
			editor.on("startedit", fn, this);
		},
		
		initStencilSetSpecifics: function(){
			
			// FOR T!M
//			if (this.facade.getStencilSets().keys().include("http://b3mn.org/stencilset/timjpdl3#")){
//				// Show a button beneath the morph menu to add Tasks-Attribute
//				this.facade.offer({
//					target 			: ORYX.Plugins.ShapeMenuPlugin,
//					functionality	: function(){
//						
//						// Lookup for "Tasks"
//						var prop = "oryx-tasks";
//						
//						// Get column where the values are
//						var col = this.grid.getColumnModel().getIndexById("propertywindow_column_value");
//						// Get the row where the property is
//						var row = this.grid.store.findBy(function(r){ return r.get("gridProperties").propId == prop});
//						
//						// Start editing
//						this.grid.startEditing(row, col);
//						
//						// Tigger pop up
//						var editor = this.grid.getColumnModel().config[col].editor;
//						editor.setValue(this.grid.store.getAt(row).get("value"))
//						editor.field.onTriggerClick();
//						
//						// Hide field
//						var fn = function(){
//							editor.un("startedit", fn, this);
//							this.grid.stopEditing();
//						}
//						editor.on("startedit", fn, this);
//						
//					}.bind(this),
//		            icon			: ORYX.CONFIG.EXPLORER_PATH+"/src/img/tim/tasks-icon.png",
//		            description		: "Change Tasks-Attribute",
//		            align			: ORYX.CONFIG.SHAPEMENU_BOTTOM,
//					//offset			: {x: 60, y: 0}, // Hack: Set the button next to morph button - ordering doesn't work, because of first generation generall buttons, then add morphbutton
//		            minShape		: 1,
//		            maxShape		: 1,
//					isEnabled		: function(){
//						// only enabled for tasks
//						return this.facade.getSelection()[0].getStencil().id().endsWith("TaskNode")
//					}.bind(this)
//				});
//			}
		},
		
		registryChanged: function(offers) {
			
			// Get all offers for the property window
			this.pluginsData = (offers||[]).findAll(function(offer){
				return offer && offer.target && offer.target === ORYX.Plugins.PropertyWindow && !(offer.getPanel instanceof Function);
			});
			
			
			// add the panels to the right main panel
			var root = this.grid.view.scroller;			
			(offers||[]).findAll(function(offer){
				return offer && offer.target && offer.target === ORYX.Plugins.PropertyWindow && offer.getPanel instanceof Function;
			}).each(function(offer){
				var offerPanel = offer.getPanel();
				offerPanel.ownerCt = this.grid;
				offerPanel.render(root);
//				this.grid.on("resize",function(){
//					if (offerPanel){
//						offerPanel.doLayout();
//					}
//				}.bind(this));				
			}.bind(this));
	
			
		},
		
		init: function(){
	
			// The parent div-node of the grid
			this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml",
				null,
				['div']);
	
			// If the current property in focus is of type 'Date', the date format
			// is stored here.
			this.currentDateFormat;
	
			// the properties array
			this.popularProperties = [];
			this.characteristicNrProperties = [];
			this.otherProperties = [];
			this.metaProperties = [];
			this.properties = [];
			
			/* The currently selected shapes whos properties will shown */
			this.shapeSelection = new Hash();
			this.shapeSelection.shapes = new Array();
			this.shapeSelection.commonProperties = new Array();
			this.shapeSelection.commonPropertiesValues = new Hash();
			
			this.updaterFlag = false;
	
			// creating the column model of the grid.
			this.columnModel = new Ext.grid.ColumnModel([
				{
					//id: 'name',
					header: ORYX.I18N.PropertyWindow.name,
					dataIndex: 'name',
					width: 90,
					sortable: true,
					editable : false,
					renderer: this.tooltipRenderer.bind(this)
				}, {
					//id: 'value',
					header: ORYX.I18N.PropertyWindow.value,
					dataIndex: 'value',
					id: 'propertywindow_column_value',
					width: 110,
					editor: new Ext.form.TextField({
						allowBlank: false
					}),
					renderer: this.renderer.bind(this)
				},
				{
					header: "Category",
					dataIndex: 'category',
					hidden: true,
					editable : false,
					sortable: true
				}
			]);
	
			// creating the store for the model.
	        this.dataSource = new Ext.data.GroupingStore({
				afterEdit : function(record){
			        if(this.indexOf(record) == -1){
						// HACK: If (1) Select a shape, (2) edit an attribute, (3) shift,
						// (4) edit the next attribute (5) hit enter -> an error occurs because
						// of the record which was edit was not in the store anymore. So the 
						// solution was, find the regarding record and edit those!
			        	var rr = this.data.items.find(function(r){ return r.get("gridProperties").propId === record.get("gridProperties").propId });
						if (!rr){ return };
						rr.isEditing = true;
						rr.set("value", record.get("value"));
						rr.isEditing = false;
						record = rr;
			        }
			        Ext.data.GroupingStore.prototype.afterEdit.apply(this, [record]);
			    },
				proxy: new Ext.data.MemoryProxy(this.properties),
				reader: new Ext.data.ArrayReader({}, [
					{name: 'category'},
					{name: 'name'},
					{name: 'value'},
					{name: 'icons'},
					{name: 'gridProperties'}
				]),
				sortInfo: {field: 'category', direction: "ASC"},
				sortData : function(f, direction){
			        direction = direction || 'ASC';
			        var st = this.fields.get(f).sortType;
			        var fn = function(r1, r2){
			            var v1 = st(r1.data[f]), v2 = st(r2.data[f]);
						var p1 = r1.data['category'], p2  = r2.data['category'];
						if (p1==p2) return (v1 > v2 ? 1 : (v1 < v2 ? -1 : 0));
						else if (p1=="meta") return -1;
						else if (p2=="meta") return 1;
						else if (p1=="popular") return -1;
						else if (p2=="popular") return 1;
						else if (p1=="saperion") return -1;
						else if (p2=="saperion") return 1;
						else if (p1=="carestation") return -1;
						else if (p2=="carestation") return 1;
						else if (p1=="characteristicNr") return -1;
						else if (p2=="characteristicNr") return 1;
						else if (p1=="tim") return -1;
						else if (p2=="tim") return 1;
						else return 0;
			        };
			        this.data.sort(direction, fn);
			        if(this.snapshot && this.snapshot != this.data){
			            this.snapshot.sort(direction, fn);
					}
			    },
				groupField: 'category'
	        });
			this.dataSource.load();
			
			this.grid = new Ext.grid.EditorGridPanel({
				clicksToEdit	: 1,
				stripeRows		: true,
				selModel		: new Ext.grid.CellSelectionModel({
					listeners : {
						beforecellselect: function(foo, rowIndex, colIndex){
							return !this.columnModel.isHidden(colIndex) && colIndex === 1;
					    }.bind(this)
					}
				}),
				anchor	: "100% 100%",
				autoExpandColumn: "propertywindow_column_value",
				width			: 'auto',
				// the column model
				colModel		: this.columnModel,
				enableHdMenu	: false,
				enableColumnMove: false,
				view			: new Ext.grid.GroupingView({
					forceFit		: true,
					groupTextTpl	: '{[ORYX.I18N.PropertyWindow.Category[(values.rs.first().data.category||"").toLowerCase()]||ORYX.I18N.PropertyWindow.Category.others]}',
					// Dont cancel edit if group get toggled
					toggleGroup 	: function(group, expanded){
				        this.grid.stopEditing(); // @changed Commit changes and dont cancel
				        Ext.grid.GroupingView.prototype.toggleGroup.apply(this, arguments);
				    }
				}),
				
				// the data store
				store			: this.dataSource,
				listeners		: {
					click	: function(){
						this.facade.getCanvas().focus();
					}.bind(this),
					cellclick: function(grid, row, column){
						if (column === 0){
							grid.fireEvent("cellclick", grid, row, 1);
						}
					} 
				}
				
			});
			// 
			
//			this.attributePanel = new Ext.Panel({
//				width: 220,
//				height: 500,
//				//layout: "anchor",
//				border: false,
//				id: "id#attributePanel",
//				//title: 'Properties',
//				items: [
//					this.grid 
//				]
//			})
			
			this.region = this.facade.addToRegion('east', this.grid , ORYX.I18N.PropertyWindow.title);
	
			// Register on Events
			this.grid.on('beforeedit', this.beforeEdit, this, true);
			this.grid.on('afteredit', this.afterEdit, this, true);
			this.grid.view.on('refresh', this.onRefresh, this, true);
			
			//this.grid.on(ORYX.CONFIG.EVENT_KEYDOWN, this.keyDown, this, true);
			
			// Renderer the Grid
			this.grid.enableColumnMove = false;
			//this.grid.render();
	
			// Sort as Default the first column
			//this.dataSource.sort('name');
	
		},
		
		// Select the Canvas when the editor is ready
		selectDiagram: function() {
			this.shapeSelection.shapes = [this.facade.getCanvas()];
			
			this.setPropertyWindowTitle();
			this.identifyCommonProperties();
			this.createProperties();
		},
	
		specialKeyDown: function(field, event) {
			// If there is a TextArea and the Key is an Enter
			if(field instanceof Ext.form.TextArea && event.button == ORYX.CONFIG.KEY_Code_enter) {
				// Abort the Event
				return false
			}
		},
		tooltipRenderer: function(value, p, record) {
			// VARs
			var prop;
			
			// Set the tooltip
			if (record.data && record.data.gridProperties && record.data.gridProperties.tooltip) {
				p.cellAttr = 'title="' + record.data.gridProperties.tooltip + '"';
			}

			
			if(!record.data.gridProperties) {
				return;
			}
			
			prop = record.data.gridProperties.property;
			
			if (ORYX.CONFIG.MULTI_LANGUAGES_ENABLED && prop && prop.language()){
				var oprop = prop.origin();
				
				// GRAY: Properties in other language
				if(this.facade.getCanvas().getLanguage() != prop.language()) {
					p.css = 'x-cell-inactive';
				
				// RED: If there is no value but has values in other languages
				} else if (prop.value() == record.get("value") && $H(ORYX.CONFIG.MULTI_LANGUAGES||{}).keys().any(function(lang){
					var key = oprop.prefix() + "-" + oprop.id() + (lang == ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT ? "" : "_" + lang );
					return (this.shapeSelection.commonPropertiesValues[key]||"") != oprop.value();
				}.bind(this))){
					p.css  = 'x-cell-invalid';
				}
			}
			return value;
		},
		
		stripEvilCharacters: function(value, remove) {
			value = value.gsub("<", remove ? "" : "&lt;");
			value = value.gsub(">", remove ? "" : "&gt;");
			value = value.gsub("%", remove ? "" : "&#37;");
			value = value.gsub("&", remove ? "" : "&amp;");
			
			return value;
		},
		
		/**
		 * Returns the value which will
		 * be displayed in the value field
		 * of the attribute
		 * 
		 * @param {Object} value
		 * @param {Object} p
		 * @param {Object} record
		 * @return {String} Displayed value
		 */
		renderer: function(value, p, record) {
			//VARs
			var type, optType;
			
			if(record.data.gridProperties && record.data.gridProperties.type) {
				type = record.data.gridProperties.type;
			} else {
				optType = record.fields.items.find(function(t) {return t.name === p.id;});
				if(optType) {
					type = optType.type;
				}
			}
			
			this.tooltipRenderer(value, p, record);
			
			if (typeof value === "boolean"){
				value = String(value).toLowerCase();
			}
			
			// If DATE		
			if(value instanceof Date) {
				// TODO: Date-Schema is not generic
				value = value.dateFormat(record.data.gridProperties.property.dateFormat() || ORYX.I18N.PropertyWindow.dateFormat);
				
			// IF String	
			} else if(typeof value == "string" && !value.include("<a href='")) {
				// Shows the Value in the Grid in each Line
				
				// Strip any tags from the value to display it nicely in the property window
				//value = Ext.ux.Richtext.getPlainText(value);
				
				value = this.stripEvilCharacters(value);
	
				// IF COLOR
				if(type === ORYX.CONFIG.TYPE_COLOR) {
					if (value) {
						value = "<div class='prop-background-color' style='background-color:" + value + "' />";
					}
					
				// IF GLOSSARY LINK 
				} else if(type === ORYX.CONFIG.TYPE_GLOSSARY_LINK) {
					value = this.parseGlossaryValue(value, record.data.gridProperties.propId);
					
				// IF CHOICE
				} else if (type === ORYX.CONFIG.TYPE_CHOICE) {
					var item = record.get("gridProperties").property.item(value);
					value = item ? this.stripEvilCharacters(item.title(), true) : value;
					
				// IF COMPLEX
				} else if (type === ORYX.CONFIG.TYPE_COMPLEX) {
					try {
						value = value.evalJSON().items.map(function(o){
								return $H(o).values().map(function(r){ 
									return (r && typeof r == "string" ? Signavio.Utils.escapeHTML(Signavio.Utils.unescapeHTML(r).truncate(10, "<small>…</small>")) : "") || undefined; }).compact().join(", ");
							}).truncate(5).join("<br/>");
					} catch(e){}
				
				// IF BOOLEAN
				} else if (type === ORYX.CONFIG.TYPE_BOOLEAN) {
					value = value === true || value === "true" || value === 1 || value === "1" ? "<img src='"+ORYX.CONFIG.EXPLORER_PATH+"/src/img/famfamfam/check_small.png' style='left:6px;margin-left:-6px;position:relative;top:1px;'/>": "";
				
				// IF FLOAT
				} else if (type === ORYX.CONFIG.TYPE_FLOAT) {
					value = String(value).replace(".", ",");

				// IF LINK/URL
				} else if (type === ORYX.CONFIG.TYPE_URL && value.trim()) {
					value = '<a href="'+(value)+'" target="_blank" class="x-link" onclick="window.open(\''+(value)+'\');return false;">'+(value)+'</a>';

				// IF a renderer function is defined
				} else if (record.data.gridProperties
						&& record.data.gridProperties.editor 
						&& record.data.gridProperties.editor.field
						&& record.data.gridProperties.editor.field.renderer instanceof Function) {
					value = record.data.gridProperties.editor.field.renderer(value);
				} 
				
	
				// If ICONS are defined
				if(record.data.icons instanceof Array) {
					record.data.icons.each(function(each) {
						if(each.name == value) {
							if(each.icon) {
								value = "<img src='" + each.icon + "' /> " + value;
							}
						}
					});
				}
				
			// IF ARRAY
			} else if(value instanceof Array){
				
				// IF GLOSSARY LINK 
				if(type === ORYX.CONFIG.TYPE_GLOSSARY_LINK) {
					value = value.map(function(glossary){
						return this.parseGlossaryValue(glossary, record.data.gridProperties.propId);
					}.bind(this)).flatten().uniq();
					
				// IF URL
				} else if (type === ORYX.CONFIG.TYPE_URL) {
					value = value.map(function(url){
						if (url && url.url)
							return '<a href="'+(Signavio.Utils.escapeHTML(url.url))+'" target="_blank" class="x-link" onclick="window.open(\''+(Signavio.Utils.escapeHTML(url.url))+'\');return false;">'+(Signavio.Utils.escapeHTML(url.label||url.url||"-"))+'</a>';
						else 
							return "";
					}).compact();
				}
				return value.truncate(5).join("<br/>");
				
			// IF NUMBER
			} else if("number" == typeof value){
				value = String(value).replace(".", ",");
				
			// IF CUSTOM RENDERER
			} else if ("object" == typeof value && record.data.gridProperties 
					&& record.data.gridProperties.editor 
					&& record.data.gridProperties.editor.field
					&& record.data.gridProperties.editor.field.renderer instanceof Function) {
				value = record.data.gridProperties.editor.field.renderer(value);
			} 
		
			return value;
		},
		
		parseGlossaryValue: function(value, property){
			var shape = this.shapeSelection.shapes[0] || undefined;
			if (shape){
				var glossary;
				if(ORYX.Utils.isGlossaryEntry(value)) {
					glossary = {
						text 		: ORYX.Utils.glossaryTitle(value),
						glossary 	: ORYX.Utils.glossaryId(value)
					}
				} else if(this.facade.hasGlossaryExtension) {
					glossary = this.facade.getGlossary(shape, property);
				}
				
				if (glossary){
					if (glossary instanceof Array) {
						return glossary.map(function(g){
							return "<a href='"+ORYX.CONFIG.SERVER_GLOSSARY_PREFIX+g.glossary+"' class='x-show-glossary' target='_blank'>"+Signavio.Utils.escapeHTML(g.text)+"</a>";
						})
					} else {
						return "<a href='"+ORYX.CONFIG.SERVER_GLOSSARY_PREFIX+glossary.glossary+"' class='x-show-glossary' target='_blank'>"+Signavio.Utils.escapeHTML(glossary.text)+"</a>";
					}
				}
			}
			return value;
		},
		
		
		onRefresh: function(){
			
			// Support for "show" for a glossary link
			this.grid.view.el.select("a.x-show-glossary")
				.on("click", function(evt){	// Add click event listeners
					Event.stop(evt);
					var gId = (evt.target.getAttribute("href")||"").replace(ORYX.CONFIG.SERVER_GLOSSARY_PREFIX, "");
					if (gId){
						this.facade.raiseEvent({
							type	: ORYX.CONFIG.EVENT_GLOSSARY_SHOW,
							glossary: gId
						})
					}
				}.bind(this))
				.removeClass("x-show-glossary");
			
		},
	
		beforeEdit: function(option) {
	
			var editorGrid 		= this.dataSource.getAt(option.row).data.gridProperties.editor;
			var editorRenderer 	= this.dataSource.getAt(option.row).data.gridProperties.renderer;
			var key 			= this.dataSource.getAt(option.row).data.gridProperties.propId;
			var prop 			= this.dataSource.getAt(option.row).data.gridProperties.property;
	
			if(editorGrid) {
				// Disable KeyDown
				if (!editorGrid.field.readOnly)
					this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
	
				option.grid.getColumnModel().setEditor(1, editorGrid);
				
				editorGrid.field.row = option.row;
				// Render the editor to the grid, therefore the editor is also available 
				// for the first and last row
				editorGrid.render(this.grid);
				
				//option.grid.getColumnModel().setRenderer(1, editorRenderer);
				editorGrid.setSize(option.grid.getColumnModel().getColumnWidth(1), editorGrid.height);
			} else {
				return false;
			}
			
			this.oldValues = new Hash();
			this.oldFormats = new Hash();
			
			if (key && prop){
				this.shapeSelection.shapes.each(function(shape){
					var glossary = (this.facade.hasGlossaryExtension)?this.facade.getGlossary(shape, prop):undefined;
					if (glossary){
						this.oldValues[shape.getId()] = glossary instanceof Array ? glossary.invoke("toString") : glossary.toString();
					} else {
						this.oldValues[shape.getId()] = shape.properties[key];
						this.oldFormats[shape.getId()] = shape.formats[key];
					}
				}.bind(this)); 
			}
		},
	
		afterEdit: function(option) {
			//Ext1.0: option.grid.getDataSource().commitChanges();
			option.grid.getStore().commitChanges();
	
			var key 			 = option.record.data.gridProperties.propId;
			
			var selectedElements = this.shapeSelection.shapes.filter(function(shape) {
				return shape.getStencil().property(key) !== undefined;			
			});
			
			var oldValues 	= this.oldValues;
			var oldFormats	= this.oldFormats;
			var newValue	= option.value;
			var newFormat	= option.format;
			var facade		= this.facade;
			
			if (!oldValues.any(function(r){ return r.value !== newValue }) &&
				!oldFormats.any(function(f) { return f.value !== newFormat})) {
				return;
			}
				
			// Implement the specific command for property change
			var commandClass = ORYX.Core.Command.extend({
				construct: function(){
					this.key 		= key;
					this.selectedElements = selectedElements;
					this.oldValues 	= oldValues;
					this.oldFormats	= oldFormats;
					this.newValue 	= newValue;
					this.newFormat	= newFormat;
					this.facade		= facade;
					this.grid		= option.grid;
					this.record 	= option.record;
				},			
				execute: function(){
					var needsupdate = false;
					this.selectedElements.each(function(shape){
						if(!shape.getStencil().property(this.key).readonly()) {
							shape.setFormat(this.key, this.newFormat);
							shape.setProperty(this.key, this.newValue);
						}
						needsupdate = needsupdate || shape.getStencil().property(this.key).dependentProperties().length > 0;
					}.bind(this));
					
					// Force to update the propertylist if a property has dependencies
					if (needsupdate){
						this.facade.setSelection([]);
					}
					
					// Propagate property changes
					var me = this;
					this.facade.raiseEvent({
						type 		: ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, 
						elements	: me.selectedElements,
						key			: me.key,
						value		: me.newValue
					});
					
					this.facade.setSelection(this.selectedElements);
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
					this.record.set("value", this.newValue);
					this.grid.getStore().commitChanges();
					this.grid.view.refresh();
			
				},
				rollback: function(){
					var needsupdate = false;
					this.selectedElements.each(function(shape){
						shape.setFormat(this.key, this.oldFormats[shape.getId()]);
						shape.setProperty(this.key, this.oldValues[shape.getId()]);
						this.record.set("value", this.oldValues[shape.getId()]);
						
						needsupdate = needsupdate || shape.getStencil().property(this.key).dependentProperties().length > 0;
					}.bind(this));
					
					// Force to update the propertylist if a property has dependencies
					if (needsupdate){
						this.facade.setSelection([]);
					}
					
					// Propagate property changes by event
					var me = this;
					this.facade.raiseEvent({
						type 		: ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, 
						elements	: me.selectedElements,
						key			: me.key,
						values		: me.oldValues
					});
					
					this.facade.setSelection(this.selectedElements);
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
					this.grid.getStore().commitChanges();
					this.grid.view.refresh();
				}
			});		
			// Instanciated the class
			var command = new commandClass();
			
			// Execute the command
			this.facade.executeCommands([command]);
	
	
			// Not necessary anymore due to event propagation moved to command?
			// extended by Kerstin (start)
	//
//			this.facade.raiseEvent({
//				type 		: ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, 
//				elements	: selectedElements,
//				key			: key,
//				value		: option.value
//			});
			// extended by Kerstin (end)
			
		},
		
		// Cahnges made in the property window will be shown directly
		editDirectly:function(key, value){
			
			this.shapeSelection.shapes.each(function(shape){
				if(shape.getStencil().property(key) !== undefined && !shape.getStencil().property(key).readonly()) {
					shape.setProperty(key, value);
					//shape.update();
				}
			}.bind(this));
			
			/* Propagate changed properties */
			var selectedElements = this.shapeSelection.shapes.filter(function(shape) {
				return shape.getStencil().property(key) !== undefined;			
			}.bind(this));
			
			this.facade.raiseEvent({
				type 		: ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, 
				elements	: selectedElements,
				key			: key,
				value		: value
			});
	
			this.facade.getCanvas().update();
			
		},
		
		// if a field becomes invalid after editing the shape must be restored to the old value
		updateAfterInvalid : function(key) {
			this.shapeSelection.shapes.each(function(shape) {
				if(!shape.getStencil().property(key).readonly()) {
					shape.setProperty(key, this.oldValues[shape.getId()]);
					shape.update();
				}
			}.bind(this));
			
			this.facade.getCanvas().update();
		},
	
		// extended by Kerstin (start)	
		dialogClosed: function(data, format) {
			var row = this.field ? this.field.row : this.row 
			this.scope.afterEdit({
				grid:this.scope.grid, 
				record:this.scope.grid.getStore().getAt(row), 
				//value:this.scope.grid.getStore().getAt(this.row).get("value")
				value: data,
				format: format
			})
			// reopen the text field of the complex list field again
			//this.scope.grid.startEditing(row, this.col);
		},
		// extended by Kerstin (end)
		
		/**
		 * Changes the title of the property window panel according to the selected shapes.
		 */
		setPropertyWindowTitle: function() {
			if(this.shapeSelection.shapes.length == 1) {
				// add the name of the stencil of the selected shape to the title
					this.region.setTitle(ORYX.I18N.PropertyWindow.title +' ('+this.shapeSelection.shapes.first().getStencil().title()+')' );
			} else {
				this.region.setTitle(ORYX.I18N.PropertyWindow.title +' ('
								+ this.shapeSelection.shapes.length
								+ ' '
								+ ORYX.I18N.PropertyWindow.selected 
								+')');
			}
		},
		/**
		 * Sets this.shapeSelection.commonPropertiesValues.
		 * If the value for a common property is not equal for each shape the value
		 * is left empty in the property window.
		 */
		setCommonPropertiesValues: function() {
			this.shapeSelection.commonPropertiesValues = new Hash();
			this.shapeSelection.commonProperties.each(function(property){
				var key = property.prefix() + "-" + property.id();
				var emptyValue = false;
				var firstShape = this.shapeSelection.shapes.first();
				
				var valueToCompareWith = firstShape.properties[key];
				
				if ("undefined" == typeof valueToCompareWith){
					valueToCompareWith = property.value();
				} else if ("" === valueToCompareWith && valueToCompareWith !== property.value()){
					valueToCompareWith = property.value();
				}
				
				this.shapeSelection.shapes.each(function(shape){
					if (property.alwaysAppearInMultiselect()) { 
						if (valueToCompareWith === undefined && shape.properties[key] !== undefined) {
							valueToCompareWith = shape.properties[key];
						} else if (valueToCompareWith !== undefined && shape.properties[key] !== undefined && valueToCompareWith != shape.properties[key]) {
							emptyValue = true;
						}
					} else if(valueToCompareWith != shape.properties[key] && "undefined" != typeof shape.properties[key] && "" !== shape.properties[key]) {
						emptyValue = true;
					}
				}.bind(this));
				
				/* Set property value */
				if(!emptyValue) {
					this.shapeSelection.commonPropertiesValues[key]
						= valueToCompareWith;
				}
			}.bind(this));
		},
		
		/**
		 * Returns the set of stencils used by the passed shapes.
		 */
		getStencilSetOfSelection: function() {
			var stencils = new Hash();
			
			this.shapeSelection.shapes.each(function(shape) {
				stencils[shape.getStencil().id()] = shape.getStencil();
			})
			return stencils;
		},
		
		/**
		 * Identifies the common Properties of the selected shapes.
		 */
		identifyCommonProperties: function() {
			this.shapeSelection.commonProperties.clear();
			
			/* 
			 * A common property is a property, that is part of 
			 * the stencil definition of the first and all other stencils.
			 */
			var stencils = this.getStencilSetOfSelection();
			var firstStencil = stencils.values().first();
			var comparingStencils = stencils.values().without(firstStencil);
			
			
			if(comparingStencils.length == 0) {
				this.shapeSelection.commonProperties = firstStencil.properties();
			} else {
				var properties = new Hash();
				var propertiesAlwaysToAppear = new Hash();
				
				/* put all properties of on stencil in a Hash */
				firstStencil.properties().each(function(property){
					if (property.alwaysAppearInMultiselect()) {
						propertiesAlwaysToAppear[property.namespace() + '-' + property.id() +	'-' +property.type()] = property;
					}
					else {
						properties[property.namespace() + '-' + property.id() +	'-' +property.type()] = property;
					}
								
				});
				
				/* Calculate intersection of properties. */
				
				comparingStencils.each(function(stencil){
					var intersection = new Hash();
					stencil.properties().each(function(property){
						if (property.alwaysAppearInMultiselect()) {
							propertiesAlwaysToAppear[property.namespace() + '-' + property.id() + '-' + property.type()] = property;
						}
						else {
							if (properties[property.namespace() + '-' + property.id() + '-' + property.type()]) {
								intersection[property.namespace() + '-' + property.id() + '-' + property.type()] = property;
							}
						}
					});
					properties = intersection;	
				});
				
				propertiesAlwaysToAppear.each( function(pair) { 
					properties[pair.key] = pair.value; 
				} );
				
				this.shapeSelection.commonProperties = properties.values();
				
				// Remove all diagrams links from the list of properties, if the selection is more than 1
				if (this.shapeSelection.shapes.length > 1){
					this.shapeSelection.commonProperties = this.shapeSelection.commonProperties.findAll(function(prop){ 
						return prop.type() !== ORYX.CONFIG.TYPE_DIAGRAM_LINK})
				}
				
			}
		},
		
		isEqual: function(a,b){
			return 	(a === b 
					 || (a.length === b.length && a.all(function(r){ return b.include(r); })))
					&& 
					(a.length == 0 
					 || this.shapeSelection.commonProperties);
		},
		
		isDirty: function(a){
			return a.any(function(shape){ return shape.isPropertyChanged(); });
		},
		
		onSelectionChanged: function(event) {
			
			if (this.shapeSelection&&this.isEqual(this.shapeSelection.shapes,event.elements)&&event.force){ 
				return; 
			}
			
			/* Event to call afterEdit method */
			var ar = this.grid.activeEditor;
			this.grid.stopEditing();
			if (ar) {
				ar.destroy()
			}
			window.clearTimeout(this.timer);
			
			/* Selected shapes */
			this.shapeSelection.shapes = event.elements;
			
			/* Case: nothing selected */
			if(event.elements.length == 0) {
				this.shapeSelection.shapes = [this.facade.getCanvas()];
			}
			
			/* subselection available */
			if(event.subSelection){
				this.shapeSelection.shapes = [event.subSelection];
			}
			
			/* define common properties (async)*/
			
			this.timer = window.setTimeout(function(){
				
				this.setPropertyWindowTitle();
				this.identifyCommonProperties();
				this.setCommonPropertiesValues();
			
				// Create the Properties
				this.createProperties();
				
			}.bind(this), 1);
		},
		
		
		/**
		 * Creates the properties for the ExtJS-Grid from the properties of the
		 * selected shapes.
		 */
		createProperties: function() {
			this.properties = [];
			this.popularProperties = [];
			this.metaProperties = [];
			this.characteristicNrProperties = [];
			this.otherProperties = [];
			
			if(this.shapeSelection.commonProperties) {
				
				// add new property lines
				this.shapeSelection.commonProperties.each((function(pair, index) {
	
					// Check if the property has a valid dependency to other properties
					if (!pair.hasValidDependency(this.shapeSelection.commonPropertiesValues)){
						return;
					}
	
					// Check for multi language support
					if (!ORYX.CONFIG.MULTI_LANGUAGES_ENABLED && pair.language() && pair.language() != this.facade.getCanvas().getLanguage()){
						return;
					}
					
					
					var key = pair.prefix() + "-" + pair.id();
					
					// Get the property pair
					var name		= pair.title()+(ORYX.CONFIG.MULTI_LANGUAGES_ENABLED&&pair.language()?" ("+Signavio.I18N.Multilanguage[pair.language().toUpperCase()+"_Short"]+")" : "");
					var icons		= [];
					var attribute	= this.shapeSelection.commonPropertiesValues[key];
					
					var editorGrid = undefined;
					var editorRenderer = null;
					var me = this;
					
					var refToViewFlag = false;
					
					if(!pair.readonly()){
						switch(pair.type()) {
							
							/**
							 * TYPE - String
							 */
							case ORYX.CONFIG.TYPE_STRING:
								// If the Text is MultiLine
								var editor;
								
								// Multi-Line-Editor
								if(pair.wrapLines()) {
								
								// Set the Editor as TextArea
									editor = new Ext.form.TextArea({alignment: "tl-tl", allowBlank: pair.optional(),  msgTarget:'title', maxLength:pair.length()});
									editor.on('keyup', function(textArea, event) {
										this.editDirectly(key, textArea.getValue());
									}.bind(this));									
								/*
									// Use the richtext editor for multi line string attributes
									editor = new Ext.form.ComplexTextField({
										allowBlank: pair.optional(),
										triggerClass: "x-trigger-other",
										dataSource: this.dataSource,
										cls: "x-gray-background",
										grid: this.grid,
										readOnly: true,
										row: index,
										facade: this.facade
									});
									editor.on('dialogClosed', this.dialogClosed, {scope:this, row:index, col:1,field:editor});							
									
								*/
								// Autocomplete One-Line-Editor
								} else if(pair.autocomplete()) {

									var conf = pair.autocomplete();

									editor = new Ext.ux.form.ComboBox({
										hideTrigger: conf.trigger === false,
										forceSelection: conf.optional === false,
								        typeAhead: conf.optional === false, 
								        url: conf.url,
										allowBlank: pair.optional()
								    });
								
								// One-Line-Editor
								} else {
									// If not, set the Editor as InputField
									editor = new Ext.form.TextField({allowBlank: pair.optional(),  msgTarget:'title', maxLength:pair.length()});
									editor.on('keyup', function(input, event) {
										this.editDirectly(key, input.getValue());
									}.bind(this));
									
									// reverts the shape if the editor field is invalid
									editor.on('blur', function(input) {
										if(!input.isValid(false))
											this.updateAfterInvalid(key);
									}.bind(this));
									
									editor.on("specialkey", function(input, e) {
										if(!input.isValid(false))
											this.updateAfterInvalid(key);
									}.bind(this));
								}
								
								editorGrid = new Ext.Editor(editor);
									
								break;
								
								
							/**
							 * TYPE - Boolean
							 */
							case ORYX.CONFIG.TYPE_BOOLEAN:
								// Set the Editor as a CheckBox
								var editorCheckbox = new Ext.form.Checkbox();
								editorCheckbox.on('check', function(c,checked) {
									this.editDirectly(key, checked);
								}.bind(this));
								
								/** 
								 * Chrome-Bug-Fix: The checkbox was hidden before
								 * click event was raised. The workaround is to 
								 * cancel the mousedown to led the focus at the cb.
								 */
								editorCheckbox.on('render', function(){
									editorCheckbox.el.on('mousedown', function(evt){
										Event.stop(evt);
									});
								});
								
								editorGrid = new Ext.Editor(editorCheckbox);
								
								break;
								
								
							/**
							 * TYPE - Integer
							 */
							case ORYX.CONFIG.TYPE_INTEGER:
								// Set as an Editor for Integers
								var numberField = new Ext.form.NumberField({allowBlank: pair.optional(), allowDecimals:false, msgTarget:'title', minValue: pair.min(), maxValue: pair.max()});
								numberField.on('keyup', function(input, event) {
									this.editDirectly(key, input.getValue());
								}.bind(this));							
								
								editorGrid = new Ext.Editor(numberField);
								
								break;
								
								
							/**
							 * TYPE - Float
							 */
							case ORYX.CONFIG.TYPE_FLOAT:
								// Set as an Editor for Float
								var numberField = new Ext.form.NumberField({ allowBlank: pair.optional(), allowDecimals:true, msgTarget:'title', minValue: pair.min(), maxValue: pair.max(), decimalPrecision:10, decimalSeparator:',',  baseChars: "0123456789."});
								numberField.on('keyup', function(input, event) {
									this.editDirectly(key, input.getValue());
								}.bind(this));
								
								editorGrid = new Ext.Editor(numberField);
								
								break;
								
								
							/**
							 * TYPE - Color
							 */
							case ORYX.CONFIG.TYPE_COLOR:
								// Set as a ColorPicker
								// Ext1.0 editorGrid = new gEdit(new form.ColorField({ allowBlank: pair.optional(),  msgTarget:'title' }));
								var editorPicker = new Ext.ux.ColorField({ allowBlank: pair.optional(),  msgTarget:'title' });
								
								editorPicker.on('select', function(picker) {
									this.editDirectly(key, picker.getValue());
								}.bind(this));
								
								editorGrid = new Ext.Editor(editorPicker);
	
								break;
								
							/**
							 * TYPE - Choice
							 */
							case ORYX.CONFIG.TYPE_CHOICE:
								var items = pair.items();
														
								var options = [];
								items.each(function(value) {
									if(value.value() == attribute)
										attribute = value.title();
										
									if(value.refToView()[0])
										refToViewFlag = true;
									
									var title = value.title() || "";
									title = title.replace("<<", "&lt;&lt;");
									title = title.replace(">>", "&gt;&gt;");
																	
									options.push([value.icon() || "", (title||"").unescapeHTML(), (value.value()||"").unescapeHTML()]);
																
									icons.push({
										name: value.title(),
										icon: value.icon() || ""
									});
								});
								
								var store = new Ext.data.SimpleStore({
							        fields: [
							            {name: 'icon'},
										{name: 'title'},
										{name: 'value'}	
									],
							        data : options // from states.js
							    });
								
								// Set the grid Editor
	
							    var editorCombo = new Ext.ux.form.ComboBox({
									tpl: '<tpl for="."><div class="x-combo-list-item">{[(values.icon) ? "<img src=\'" + values.icon + "\' />" : ""]} {[values.title.escapeHTML()]}</div></tpl>',
							        store: store,
							        displayField:'title',
									valueField: 'value',
							        typeAhead: true,
							        mode: 'local',
							        triggerAction: 'all',
							        selectOnFocus:true,
							        // Type text directly into the field
							        editable: true,
							        // True to force selection to values inside of the dropdown
							        forceSelection: pair.allowCustomValue(),
							        // This only sets the element's readOnly DOM attribute
							        readOnly: false
							    });
									
								editorCombo.on('select', function(combo, record, index) {
									this.editDirectly(key, combo.getValue());
								}.bind(this))
								
								editorGrid = new Ext.Editor(editorCombo);
	
								break;
								
							/**
							 * TYPE - Date
							 */
							case ORYX.CONFIG.TYPE_DATE:
							
								// Define the date format
								var format = pair.dateFormat();
								var altFormat = "d/m/y|d.m.y|Y-m-d\\TH:i:s";
								
								// Try to parse to Date
								if(!(attribute instanceof Date)){
									attribute = [].concat(format, altFormat.split("|"))
										.map(function(form){
											return Date.parseDate(attribute, form) || null
										}) 						// Parse the date
										.compact() 				// Remove wrong formats
										.first() || attribute; 	// Set the result
								}
								
								// Set the editor
								editorGrid = new Ext.Editor(new Ext.form.DateField({ allowBlank: pair.optional(), format:format, altFormats:altFormat, msgTarget:'title'}));
								break;
							
							/**
							 * TYPE - Text
							 */
							case ORYX.CONFIG.TYPE_TEXT:
								
								var cf = new Ext.form.ComplexTextField({
									allowBlank: pair.optional(),
									triggerClass: "x-trigger-other",
									dataSource: this.dataSource,
									cls: "x-gray-background",
									grid: this.grid,
									readOnly: true,
									row: index,
									facade: this.facade
								});
								cf.on('dialogClosed', this.dialogClosed, {scope:this, row:index, col:1,field:cf});							
								editorGrid = new Ext.Editor(cf);
								break;
								
							/**
							 * TYPE - Complex
							 */
							case ORYX.CONFIG.TYPE_COMPLEX:
								
								var cf = new Ext.form.ComplexListField({ 
									allowBlank: pair.optional(),
									rendererFn: this.renderer.bind(this),
									readOnly: true}, 
									pair, 
									key, 
									this.facade);
								cf.on('dialogClosed', this.dialogClosed, {scope:this, row:index, col:1,field:cf});							
								editorGrid = new Ext.Editor(cf);
								break;
							/**
							 * TYPE - EPC Frequency
							 */
							case ORYX.CONFIG.TYPE_EPC_FREQ:
								
								var cf = new Ext.form.EpcFrequencyTypeField({
									allowBlank: pair.optional(),
									dataSource:this.dataSource,
									grid:this.grid,
									row:index,
									facade:this.facade
								});
								cf.on('dialogClosed', this.dialogClosed, {scope:this, row:index, col:1,field:cf});							
								editorGrid = new Ext.Editor(cf);
								break;
							
							/**
							 * TYPE - Diagram Link
							 */
							case ORYX.CONFIG.TYPE_DIAGRAM_LINK:					
								editorGrid = new Ext.Editor(new Ext.form.TriggerField({
									hideTrigger		: false,
									triggerClass	: "x-trigger-other",
									onTriggerClick	: function(){
										this.facade.raiseEvent({
											type	: "showlinkingwindow",
											shape	: this.shapeSelection.shapes[0],
											property: key
										})
									}.bind(this)
								}))
								
								break;
							
							/**
							 * TYPE - Glossary Link
							 */
							case ORYX.CONFIG.TYPE_GLOSSARY_LINK:							
									
								editorGrid = new Ext.Editor(new Ext.ux.form.GlossaryField({
										linkableType	: pair.linkableType(),	    
										loadingText		: Signavio.I18N.Glossary_Support.renameLoading,
									    emptyTextList	: '<div class="x-no-entry">'+Signavio.I18N.Glossary_Support.renameEmpty+'</div>',
										zindex			: 8000,
										initValue		: function(){
											/*if (this.value !== undefined && ORYX.Utils.isGlossaryEntry(this.value)){
												this.setRawValue(ORYX.Utils.glossaryTitle(this.value));
											} else {
												Ext.ux.form.GlossaryField.superclass.initValue.apply(this, arguments);
											}*/
											
											if (this.value !== undefined && ORYX.Utils.isGlossaryEntry(this.value)){
												this.records = [Ext.ux.data.RecordCreator.create("gitem", "/glossary/"+ORYX.Utils.glossaryId(this.value), {title: ORYX.Utils.glossaryTitle(this.value)})];
												this.value = ORYX.Utils.glossaryTitle(this.value);
											} else {
												Ext.ux.form.GlossaryField.superclass.initValue.apply(this, arguments);
											}
										},
										setValue : function(value) {
											if (value !== undefined && ORYX.Utils.isGlossaryEntry(value))
												value = ORYX.Utils.glossaryTitle(value);
									    	Ext.ux.form.GlossaryField.superclass.setValue.apply(this, [value]);
										},
										getValue: function(){
											return (this.records||[]).map(function(rec){ 
												return rec.get("href") ? ORYX.Utils.getInGlossarySchema(rec.get("href"), rec.get("rep").title) : rec.get("rep") 
											})[0] || "";
										},
										onCreateNew: function(record){
											if (!me.facade.hasGlossaryExtension){ return true; }
											// Disbale all blur events on the glossary field
											this.disableBlur();
											
											// Create needed attributes
											var sh = {properties:{}};
											sh.properties[pair.id()] = record.get("rep").title;
											sh.category = record.get("rep").category;
											
											// Raise event to show the new window
											me.facade.raiseEvent({
												type	: ORYX.CONFIG.EVENT_GLOSSARY_NEW,
												shape	: sh,
												hasCategorySwitch : !this.linkableType,
												property: pair.id(),
												callback: function(record){
													if (record instanceof Ext.data.Record){
														this.onSelect(record);
													} else {
														this.collapse();
														this.selectedIndex = -1;
													}
													this.enableBlur();
												}.bind(this)
											});
											return false;
										},
										onNewRecord: function(record){
											this.records = [record];
											me.grid.stopEditing(false); // Stop editing and take the changes
										}
									}))
		
								break;

							/**
							 * TYPE - URL
							 */
							case ORYX.CONFIG.TYPE_URL:
								
								if (!pair.isList()) {
									var editorInput = new Ext.form.TextField({
													allowBlank : pair.optional(),
													msgTarget : 'title',
													maxLength : pair.length(),
													enableKeyEvents : true,
													prefixFileLocal: Ext.ux.form.UrlLinkFieldList.prototype.prefixFileLocal,
													prefixFileNetwork: Ext.ux.form.UrlLinkFieldList.prototype.prefixFileNetwork,
													prefixHTTP: Ext.ux.form.UrlLinkFieldList.prototype.prefixHTTP,
													getValue: function(){
														var url = Ext.form.TextField.prototype.getRawValue.call(this);
														if (Ext.ux.form.UrlLinkFieldList.prototype.isURL.call(this, url)){
															url = this.prefixHTTP + url;
														}
														return url;
													},
													listeners : {
														render : function() {
															editorInput.el.on('keyup',function(event) {
																Ext.ux.form.UrlLinkFieldList.prototype.evaluateLokalURL.call(editorInput);
																this.editDirectly(key,editorInput.getRawValue());
															}.bind(this));
														}.bind(this)}});
									editorGrid = new Ext.Editor(editorInput);
	
									break;
								}
							/**
							 * TYPE - Other
							 */
							default:
								
								// Try to find an editor from the ux namespace
								var EditorClass = Ext.ux.propertyeditor.getEditor(pair.type());
								if (EditorClass){
									var field = new EditorClass(pair, this.facade);
									editorGrid = new Ext.Editor(field);
									field.editor = editorGrid;
									field.on('dialogClosed', function(field, value, oldValue){
										this.scope.grid.onEditComplete(editorGrid, value, oldValue);	
									}, {scope:this, editor:editorGrid});		
								}
								
								
								// If not, use a string editor
								if (!editorGrid){
									var editorInput = new Ext.form.TextField({ allowBlank: pair.optional(),  msgTarget:'title', maxLength:pair.length(), enableKeyEvents: true});
									editorInput.on('keyup', function(input, event) {
										this.editDirectly(key, input.getValue());
									}.bind(this));
									editorGrid = new Ext.Editor(editorInput);
								}
						}
	
						/**
						 * IF LIST, Use another editor
						 */
						if(pair.isList()){
							
							var cf = new Ext.form.ListView({
									allowBlank: pair.optional(),
									cls: "x-grey-background",
									readOnly: true
								},
								editorGrid, 
								pair,
								this.facade)
							editorGrid = new Ext.Editor(cf);
								
							
							cf.on('dialogClosed', this.dialogClosed, {scope:this, row:index, col:1,field:cf});		
						}
								
	
						// Register Event to enable KeyDown
						editorGrid.on('beforehide', this.facade.enableEvent.bind(this, ORYX.CONFIG.EVENT_KEYDOWN));
						editorGrid.on('specialkey', this.specialKeyDown.bind(this));
	
					} else if(pair.type() === ORYX.CONFIG.TYPE_URL || pair.type() === ORYX.CONFIG.TYPE_DIAGRAM_LINK){
						attribute = String(attribute).search("http") !== 0 ? ("http://" + attribute) : attribute;
						attribute = "<a href='" + attribute + "' target='_blank'>" + attribute.split("://")[1] + "</a>"
					}
					
					// Push to the properties-array
					if(pair.visible()) {
						// Popular Properties are those with a refToView set or those which are set to be popular
						if (pair.category() == "popular" || pair.refToView()[0] && !pair.category() || refToViewFlag && !pair.category()) {
							pair.setCategory("popular");
						}  
						
						var option = [pair.category() || "others",
						              name,
						              attribute,
						              icons,
						              {
									  	editor	: editorGrid,
									  	propId	: key,
									  	type	: pair.type(),
										property: pair,
									  	tooltip	: pair.description(),
									  	renderer: editorRenderer,
										isList	: pair.isList()
						              }];
						
						// Set the editor behind any window
						if (editorGrid) {
							editorGrid.on("render", function(editor){
								editor.el.setZIndex(7000);
							});
						}
						
						if(pair.category() == "popular") {
							this.popularProperties.push(option);
						} else if (pair.category() == "characteristicNr") {
							this.characteristicNrProperties.push(option);
						} else if (pair.category() == "meta") {
							this.metaProperties.push(option);
						} else if (pair.category()) {
							this.otherProperties.push(option);
						} else {					
							this.properties.push(option);
						}
					}
	
				}).bind(this));
			}
	
			this.setProperties();
		},
	
		setProperties: function() {
			var props = [].concat(this.otherProperties, this.metaProperties, this.popularProperties, this.characteristicNrProperties, this.properties);
			
			if (ORYX.CONFIG.SHOW_ID_IN_PROPERTYWINDOW 
					&& this.shapeSelection.shapes.length === 1 
					&& this.shapeSelection.shapes[0] instanceof ORYX.Core.Shape ){
				props.push(["others",
				            	Signavio.I18N.field.ID,
				            	this.shapeSelection.shapes[0].resourceId,
				            	[],
				            	{editor: new Ext.Editor(new Ext.form.TextField({readOnly: true}))}]);
			}
	
			// property fields created by other plugins
			if(this.pluginsData) {
				this.pluginsData.each(function(propField) {
					
					if(!(propField.enabled instanceof Function) 
							|| propField.enabled()) {
						if(propField.value instanceof Function) {
							var propValue = propField.value();
						}
						props.push([
						            (propField.category || "other"),
						            (propField.name || ""),
						            (propValue || propField.value || ""),
						            (propField.icons || []),
						            {editor: ((propField.generateEditor instanceof Function && propField.generateEditor()) || new Ext.Editor(new Ext.form.TextField({readOnly: true})))}
						]);
					}
				}.bind(this));
			}
			
			this.dataSource.loadData(props);
			
			// Expand all initially open groups
			var view = this.grid.view;
			$A(view.getGroups()||[]).each(function(group){
				var id = group.id.split("-").last();
				if (view.state[group.id] || (view.state[group.id] === undefined && this.expandedGroups[id])){
					view.toggleGroup(view.getGroupId(id), true);
				} else {
					view.toggleGroup(view.getGroupId(id), false);
				}
			}.bind(this));
	
		}
	};
	
	ORYX.Plugins.PropertyWindow = Clazz.extend(ORYX.Plugins.PropertyWindow);
	
	
	
	/**
	 * The dialog to show a set on entries
	 * as a list.
	 * 
	 * @class Ext.form.ListView
	 * 
	 * @param {Object} config
	 * @param {Object} input
	 * @param {Object} prop
	 * @param {Object} facade
	 */
	Ext.form.ListView = function(config, input, prop, facade) {
		Ext.form.ListView.superclass.constructor.call(this, config);
		this.input 	= input;
		this.prop	= prop;
		this.facade = facade;
		this.type 	= prop.type();
	};
	
	Ext.extend(Ext.form.ListView, Ext.form.TriggerField, {
		
		store	: undefined,
		list	: undefined,
		recordSchema: undefined,
		tpl		: undefined,
		triggerClass:"x-trigger-other",
		
		initValue		: function(){
			Ext.form.ListView.superclass.initValue.apply(this, arguments);
			this.updateRawValue();
		},
		
		setValue : function(){
			Ext.form.ListView.superclass.setValue.apply(this, arguments);
			this.updateRawValue();
		},
		
		parseListValue: function(value){
			if (typeof value === "string" && ORYX.Utils.isGlossaryEntry(value)){
				return ORYX.Utils.glossaryTitle(value);
			} else if (typeof value === "object"&&(value.label||value.url)){
				return (value.label||value.url);
			} else {
				return value;
			}
		},
		
		updateRawValue: function(){
			if (this.value instanceof Array){
				this.setRawValue(this.value.map(this.parseListValue.bind(this)).join(", "));
			} else {
				try {
					this.setRawValue((this.value||"[]").evalJSON().map(this.parseListValue.bind(this)).join(", "))
				} catch(e){}
			}
		},
		
		/**
		 * Return the value of the field
		 */
		getValue : function(){
			if (this.facade.hasGlossaryExtension && this.type === ORYX.CONFIG.TYPE_GLOSSARY_LINK) {
				var data = this.data || this.value;
				if (data instanceof Array) {
					return data.map(this.getGlossaryValue.bind(this)).flatten().uniq();
				} else {
					return this.getGlossaryValue(data);
				}
			} else {
				return (this.data || this.value);
			}
		},
		
		getGlossaryValue: function(value){
			return ([this.facade.getGlossary(this.facade.getSelection()[0]||this.facade.getCanvas(), this.prop) || value].flatten()).map(function(r){ return typeof r == "object" ? ORYX.Utils.getInGlossarySchema(r.glossary, r.text) : r});
		},
		
		onTriggerClick: function() {
			if(this.disabled) {
				return;
			}
			
			// Get the value
			var value = this.getValue();
			this.data = value;
			
			if (value instanceof Array) { value = value.clone()}
			else if (value instanceof Object) { value = Object.clone(value)}
			
			// Get a new field
			var option = Ext.apply({}, this.input.field.initialConfig, {value: value});
			var field = FieldItemGenerator.generate(this.prop.type().capitalize()+"List", option);
			field.anchor = "100%";
					
			// Basic Dialog
			this.dialog = new Ext.Window({
				autoCreate: true,
				title: ORYX.I18N.PropertyWindow.ListView.title + this.prop.title(),
				cls: "x-manage-list",
				minWidth: 200,
				minHeight:200,
				height: 300,
				width: 440,
				modal: true,
				collapsible: false,
				fixedcenter: true,
				shadow: true,
				proxyDrag: true,
				layout: "anchor",
				bodyStyle: "padding:10px;background-color:#FFFFFF;",
				autoScroll: true,
				keys: [{
					key: 27,
					fn: function(){
						this.dialog.hide
					}.bind(this)
				}],
				items: [field],
				listeners: {
					show : function(t){
						// Hide Editor
						this.fireEvent("blur");
						// Set Focus to the field
						window.setTimeout(this.field.focus.bind(field), 100);
					}.bind(this)
				},
				buttons: [{
					text: ORYX.I18N.PropertyWindow.ListView.save,
					handler: this.saveEntry.bind(this)
				}, {
					text: Signavio.I18N.Buttons.cancel,
					handler: function(){
						this.dialog.close();
					}.bind(this)
				}]
			});		
			
			this.dialog.on(Ext.apply({}, this.dialogListeners, {
	       		scope:this
	        }));
			
			this.field = field;
			this.dialog.show();
			
			// Force to set z-index of the field in front of the window
			if (field instanceof Ext.form.ComboBox && field.list){
				field.list.setZIndex((parseInt(this.dialog.el.getStyle("z-index"), 10)||9000));
			}
		},
		
		saveEntry: function() {
//			// stop editing and apply value changes
//			if(this.field.editing !== undefined) {
//				this.field.onTriggerClick();
//			}
			
			this.data = this.field.getValue();
			this.dialog.close();
		},

		
		keydownHandler: function(event) {
			return false;
		},
		
	    dialogListeners : {
	        show : function(){ // retain focus styling
	            this.onFocus();	
				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keydownHandler.bind(this));
				this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
				return;
	        },
	        hide : function(){
	
	            var dl = this.dialogListeners;
	            this.dialog.un("show", dl.show,  this);
	            this.dialog.un("hide", dl.hide,  this);
				
				this.dialog.destroy(true);
				delete this.dialog;
				
				//this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keydownHandler.bind(this));
				this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
				
				// store data and notify parent about the closed dialog
				// parent has to handel this event and start editing the text field again
				this.fireEvent('dialogClosed', this.data);
				
				Ext.form.ListView.superclass.setValue.call(this, this.data);
				
				//TODO: Remove that flag
				//Avoid copied value over fields
				this.data = undefined;
	        }
	    }
	});
	
	
	/**
	 * Class for remote glossary entry search
	 * 
	 * @class
	 * @param attr
	 * @return
	 */
	var GlossaryInputField = function(attr){
	
		// Set attr
	    attr = attr || {};
		
		var params = {select:"title",originId:attr.parentDir}
		
		if (attr.linkableType){
			params.category  = attr.linkableType
		}
	    
		// Set the new store
		attr.store = new Ext.data.Store({
			baseParams: params,
	        proxy: new Ext.data.HttpProxy({
	        	useAjax	: true,
	        	method	: "GET", 
	        	headers	: {accept:"application/json"},
	            url		: '/p/glossary'
	        }),
	        reader: new Signavio.Helper.RecordReader()
	    });
		
		// Set the template
		attr.tpl = new Ext.XTemplate(
				            '<tpl for="."><div class="search-item">',
								'<img class="x-{[values.rep.category.toLowerCase()]} x-image" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>',
								'<tpl if="values.href">',
			            			'<tpl for="rep">{[Signavio.Utils.escapeHTML(values.title)]}</tpl>',
								'</tpl>',
								'<tpl if="!values.href">',
			            			'<tpl for="rep">{emptyTitle}</tpl>',
								'</tpl>',
				            '</div></tpl>'
			        	);
		// Overwrite some attributes
		attr.cls = "x-glossary-support";
	
		// Call super
	    GlossaryInputField.superclass.constructor.call(this, attr);	    
	};
	
	Ext.extend(GlossaryInputField, Ext.form.ComboBox, {
	    lazyRender		: false,
	    lazyInit 		: false,
	    listClass 		: 'x-glossary-support',
	    valueField		: 'value',
	    typeAhead		: false,
	    loadingText		: Signavio.I18N.Glossary_Support.renameLoading,
	    emptyTextList	: '<div class="x-no-entry">'+Signavio.I18N.Glossary_Support.renameEmpty+'</div>',
	    queryDelay		: 100,
	    minChars		: 2,
	    preventScrollbars:true,
	    queryParam		: "q",
	    hideTrigger		: true,
	    resizable 		: true,			
	    itemSelector	: 'div.search-item',
	    loadingText		: Signavio.I18N.Glossary_Support.renameLoading,
	    emptyTextList	: '<div class="x-no-entry">'+Signavio.I18N.Glossary_Support.renameEmpty+'</div>',
		initValue		: function(){
			if (this.value !== undefined && ORYX.Utils.isGlossaryEntry(this.value)){
				this.setRawValue(ORYX.Utils.glossaryTitle(this.value));
			} else {
				GlossaryInputField.superclass.initValue.apply(this, arguments);
			}
		},
		addNewRecord	: function(record){
			
		},
		setValue : function(value) {
			if (value !== undefined && ORYX.Utils.isGlossaryEntry(value))
				value = ORYX.Utils.glossaryTitle(value);
			
	    	GlossaryInputField.superclass.setValue.apply(this, [value]);
		},
	    onSelect: function(record, index){ // override default onSelect to do redirect
				
										
			var title = record.get("rep").title || record.get("rep").name || "";
			var id	  = record.get("rep").id;
												
			this.value = "glossary://" + id + "/" + title + ";;";									
			
			this.collapse();
			this.setRawValue(title);
			
			this.addNewRecord(record);
			
			this.fireEvent('select', this, record, index);
			//GlossaryInputField.superclass.onSelect.apply(this, arguments);
	
	    },
		
		getCursorPosition: function(){
			var input = this.el.dom;
			if (input && typeof input.selectionStart !== "undefined") {
				return input.selectionStart;
			} else {
				return input.value.length;
			}
		},
	    
	    initList: function(){
	    	GlossaryInputField.superclass.initList.apply(this, arguments);
	    	
	    	if (this.emptyTextList) {
	    		this.view.emptyText = this.emptyTextList;
	    	}
	    	
	    	if (this.view) {
	    		this.view.onMouseOut = function(e){
	                if(this.lastItem){
	                	try {
	                		if(!e.within(this.lastItem, true)){
	                			Ext.fly(this.lastItem).removeClass(this.overClass);
	                			delete this.lastItem;
	                		}
	                	} catch(error){ }
	                }
	            }.bind(this.view);
	    	}
	    	
	    	this.pageSize = 10;
	    },
	    
	    onDestroy : function(){
	        if(this.textSizeEl){
	            Ext.removeNode(this.textSizeEl);
	        }
	        
	        if (this.view&&this.view.lastItem) {
	        	delete this.view.lastItem;
	        }
		    
	        GlossaryInputField.superclass.onDestroy.call(this);
	    },
	    getValue: function(){
	        if(this.valueField){
				// Reset the value if nothing is inside the textarea
	            return typeof this.value != 'undefined' && this.el.getValue() ? this.value : '';
	        }else{
	            return Ext.form.ComboBox.superclass.getValue.call(this);
	        }
		},
	    onBeforeLoad : function(){
	        if(!this.hasFocus){
	            return;
	        }
	        
	        if (!this.innerList.child("div.loading-indicator")) {
	        	if (this.store.getCount()>0) {
	        		this.innerList.createChild({tag: 'div', cls: 'loading-indicator', html: this.loadingText});
	        	} else {
	        		this.innerList.update(this.loadingText ? '<div class="loading-indicator">'+this.loadingText+'</div>' : '');
	        	}
	        } 
	        if (this.selectedIndex>=0){
	        	this.lastSelectedRecord = this.store.getAt(this.selectedIndex);
	        } else {
	        	delete this.lastSelectedRecord;
	        }
	        
	        this.restrictHeight();
	    },
	
		/**
		 * @Overwrite
		 */
	    initQuery : function(){
	    	if (this.list) {
	    		var text = this.getRawValue();
				/*
	    		var cursor = this.getCursorPosition();
			
				var pre = text.slice(0, cursor);
				var words = pre.split(/[\W]+/g);
			
				this.doQuery(words.last());	
				*/
				this.doQuery(text);
			}
	    },
	
		/**
		 * @Overwrite
		 */
	    doQuery : function(q, forceAll){
	    	if(!this.store) {
	    		return;
	    	}
	        if(q === undefined || q === null){
	            q = '';
	        }
	        var qe = {
	            query: q,
	            forceAll: forceAll,
	            combo: this,
	            cancel:false
	        };
	        if(this.fireEvent('beforequery', qe)===false || qe.cancel){
	            return false;
	        }
	        q = qe.query;
	        forceAll = qe.forceAll;
	        var qq = (q||"").split(/\s+/).findAll(function(r){ return r.length >= this.minChars }.bind(this))
	        if(forceAll === true || qq.length > 0){
	        	qq = qq.join(" ");
	            if(this.lastQuery !== qq){
	                this.lastQuery = qq;
	                if(this.mode == 'local'){
	                    this.selectedIndex = -1;
	                    if(forceAll){
	                        this.store.clearFilter();
	                    }else{
	                        this.store.filter(this.displayField, q);
	                    }
	                    this.onLoad();
	                }else{
	                    this.store.baseParams[this.queryParam] = qq;
	                    this.store.load({
	                        params: this.getParams(qq)
	                    });
	                    this.expand();
	                }
	            }else{
	                this.selectedIndex = -1;
	                this.onLoad();
	            }
	        }
	    },
	    
		/**
		 * @Overwrite
		 */
	    onLoad : function(){
	        if(!this.hasFocus){
	            return;
	        }
	        if(this.store.getCount() > 0){
	            this.expand();
	            this.restrictHeight();
	            if(this.lastQuery == this.allQuery){
	                if(this.editable){
	                    this.el.dom.select();
	                }
	                /*if(!this.selectByValue(this.value, true)){
	                    this.select(0, true);
	                }*/
	            }else{
	                //this.selectNext();
	                if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
	                    this.taTask.delay(this.typeAheadDelay);
	                }
	            }
	            
	            var index = -1;
	            if (this.lastSelectedRecord) {
	            	index = this.store.find("href", this.lastSelectedRecord.get("href"));
	            }
	        	this.select(index, true);
	        	
	        }else{
	            this.onEmptyResults();
	        }
	        //this.el.focus();
	    },
	    
	    onEmptyResults : function(){
	    	this.restrictHeight()
	    }
	});
	
	/**
	 * Editor for complex type
	 * 
	 * When starting to edit the editor, it creates a new dialog where new attributes
	 * can be specified which generates json out of this and put this 
	 * back to the input field.
	 * 
	 * This is implemented from Kerstin Pfitzner
	 * 
	 * @param {Object} config
	 * @param {Object} items
	 * @param {Object} key
	 * @param {Object} facade
	 */
	
	
	Ext.form.ComplexListField = function(config, property, key, facade){
	    Ext.form.ComplexListField.superclass.constructor.call(this, config);
	    this.property = property;
		this.items 	= property.complexItems();
		this.propertyTitle = property.title();
		this.key 	= key;
		this.facade = facade;
	};
	
	/**
	 * This is a special trigger field used for complex properties.
	 * The trigger field opens a dialog that shows a list of properties.
	 * The entered values will be stored as trigger field value in the JSON format.
	 */
	Ext.extend(Ext.form.ComplexListField, Ext.form.TriggerField,  {
		/**
	     * @cfg {String} triggerClass
	     * An additional CSS class used to style the trigger button.  The trigger will always get the
	     * class 'x-form-trigger' and triggerClass will be <b>appended</b> if specified.
	     */
	    triggerClass:	'x-form-complex-trigger',
		readOnly:		true,
		emptyText: 		ORYX.I18N.PropertyWindow.clickIcon,
		
		/**
		 * Retrives the values of the radio button columns and commits the
		 * value to the store.
		 */
		retrieveRadioButtonValue: function() {
			// VARS
			var me = this;
			var inputEls = this.grid.body.query("input.x-complexfield-radio-button[type=radio]");
			var store = this.grid.getStore();
			var row, col, value;
			
			if(inputEls instanceof Array) {
				inputEls.each(function(i) {
					if(!i.value) {return;}
					
					// example value: "row_3_col_34"
					value = i.value.split("_");
					if(value.size() != 4) {return;}
					
					row = value[1];
					col = me.grid.getColumnModel().config[value[3]].dataIndex;
					
					if(store.getAt(row) && store.getAt(row).data 
							&& typeof(store.getAt(row).data[col]) !== "undefined") {
						
						// Set checked value
						store.getAt(row).data[col] = !!i.checked;
					}
				});
			}
		},
			
		/**
		 * Builds the JSON value from the data source of the grid in the dialog.
		 */
		buildValue: function() {
			this.retrieveRadioButtonValue();
			var ds = this.grid.getStore();
			ds.commitChanges();
			
			if (ds.getCount() == 0) {
				return "";
			}
			
			var jsonString = "[";
			for (var i = 0; i < ds.getCount(); i++) {
				var data = ds.getAt(i);		
				jsonString += "{";	
				for (var j = 0; j < this.items.length; j++) {
					var key = this.items[j].id();
					jsonString += key + ':' + ("" + Object.toJSON(data.get(key)));
					if (j < (this.items.length - 1)) {
						jsonString += ", ";
					}
				}
				jsonString += "}";
				if (i < (ds.getCount() - 1)) {
					jsonString += ", ";
				}
			}
			jsonString += "]";
			
			jsonString = "{'totalCount':" + ds.getCount().toJSON() + 
				", 'items':" + jsonString + "}";
			return Object.toJSON(jsonString.evalJSON());
		},
		
		/**
		 * Returns the field key.
		 */
		getFieldKey: function() {
			return this.key;
		},
		
		/**
		 * Returns the actual value of the trigger field.
		 * If the table does not contain any values the empty
		 * string will be returned.
		 */
	    getValue : function(){
			// return actual value if grid is active
			if (this.grid) {
				return this.buildValue();			
			} else if (this.data == undefined) {
				return "";
			} else {
				return this.data;
			}
	    },
		
		/**
		 * Sets the value of the trigger field.
		 * In this case this sets the data that will be shown in
		 * the grid of the dialog.
		 * 
		 * @param {Object} value The value to be set (JSON format or empty string)
		 */
		setValue: function(value) {	
			if (value.length > 0) {
				// set only if this.data not set yet
				// only to initialize the grid
				if (this.data == undefined) {
					this.data = value;
				}
			}
		},
		
		/**
		 * Returns false. In this way key events will not be propagated
		 * to other elements.
		 * 
		 * @param {Object} event The keydown event.
		 */
		keydownHandler: function(event) {
			return false;
		},
		
		/**
		 * The listeners of the dialog. 
		 * 
		 * If the dialog is hidden, a dialogClosed event will be fired.
		 * This has to be used by the parent element of the trigger field
		 * to reenable the trigger field (focus gets lost when entering values
		 * in the dialog).
		 */
	    dialogListeners : {
	        show : function(){ // retain focus styling
	            this.onFocus();	
				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keydownHandler.bind(this));
				this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
				return;
	        },
	        hide : function(){
	
	            var dl = this.dialogListeners;
	            this.dialog.un("show", dl.show,  this);
	            this.dialog.un("hide", dl.hide,  this);
				
				this.dialog.destroy(true);
				this.grid.destroy(true);
				delete this.grid;
				delete this.dialog;
				
				this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keydownHandler.bind(this));
				this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
				
				// store data and notify parent about the closed dialog
				// parent has to handel this event and start editing the text field again
				this.fireEvent('dialogClosed', this.data);
				
				Ext.form.ComplexListField.superclass.setValue.call(this, this.data);
	        }
	    },	
		
		/**
		 * Builds up the initial values of the grid.
		 * 
		 * @param {Object} recordType The record type of the grid.
		 * @param {Object} items      The initial items of the grid (columns)
		 */
		buildInitial: function(recordType, items) {
			var initial = new Hash();
			
			for (var i = 0; i < items.length; i++) {
				var id = items[i].id();
				if(items[i].value() instanceof Array) {
					initial[id] = items[i].value().clone();
				} else if(typeof(items[i].value()) == "string") {
					initial[id] = "" + items[i].value();
				} else if(items[i].value() instanceof Object) {
					initial[id] = Object.clone(items[i].value());
				}
			}
			
			var RecordTemplate = Ext.data.Record.create(recordType);
			return new RecordTemplate(initial);
		},
		
		/**
		 * Builds up the column model of the grid. The parent element of the
		 * grid.
		 * 
		 * Sets up the editors for the grid columns depending on the 
		 * type of the items.
		 * 
		 * @param {Object} parent The 
		 */
		buildColumnModel: function(parent) {
			var cols = [];
			for (var i = 0; i < this.items.length; i++) {
				var renderer = undefined;
				var id 		= this.items[i].id();
				var header 	= this.items[i].name();
				var width 	= this.items[i].width();
				var type 	= this.items[i].type();
				var isList	= this.items[i].isList();
				var optional = this.items[i].optional();
				var item = this.items[i];
				var editor = undefined;
				
				// TYPE STRING
				if (type == ORYX.CONFIG.TYPE_STRING) {
					editor = new Ext.form.TextField({ allowBlank : this.items[i].optional(), width : width});
				
				/*
					if (this.items[i].property().wrapLines()) {
						var ct = new Ext.form.ComplexTextField({
							allowBlank: this.items[i].optional(),
							triggerClass: "x-trigger-other",
							width: width
						});
						
						editor = new Ext.grid.GridEditor(ct);
						ct.on('dialogClosed', function(editor, value){
							var rec = editor.record;
							var dIn = this.grid.getColumnModel().config[editor.col].dataIndex;
							rec.set(dIn, value);
							rec.commit();
						}.bind(this, editor));	
					} else {
						editor = new Ext.form.TextField({ allowBlank : this.items[i].optional(), width : width});
					}
					*/
				// TYPE TEXT
				} else if (type == ORYX.CONFIG.TYPE_TEXT) {
//					var ct = new Ext.form.ComplexTextField({
//									allowBlank: optional,
//									triggerClass: "x-trigger-other",
//									width: width,
//									facade: this.facade
//								});
					/**
				     * If the trigger was clicked a dialog has to be opened
				     * to enter the values for the complex property.
				     */
					var triggerFn = function(){
							
				        if(this.disabled){
				            return;
				        }	

				        var selection = (this.facade.getSelection().length > 0 ? this.facade.getSelection()[0] : this.facade.getCanvas());
				        
				       
			        	// Else create only a normal text area
			        	var grid = new Ext.form.TextArea({
				        	anchor		: '100% 100%',
							value		: this.value,
							listeners	: {
								focus: function(){
									if (this.facade)
										this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
								}.bind(this)
							}
						});
			        
						// Basic Dialogue
						var dialog = new Ext.Window({ 
							layout		: 'anchor',
							autoCreate	: true, 
							title		: ORYX.I18N.PropertyWindow.text, 
							height		: 500, 
							width		: 500, 
							modal		: true,
							collapsible	: false,
							fixedcenter	: true, 
							shadow		: true, 
							proxyDrag	: true,
							keys:[{
								key	: 27,
								fn	: function(){
										dialog.hide();
								}.bind(this)
							}],
							items		:[grid],
							listeners	:{
								hide: function(){
									// If the editing happened on a not supported browser, clear the saved formats
									var formats;
									if (Ext.isGecko || Ext.isSafari || Ext.isIE || Ext.isChrome || Ext.isOpera) {
										formats = [];
									}
									this.fireEvent('dialogClosed', this.value, formats);
									dialog.destroy();
								}.bind(this)				
							},
							buttons		: [{
				                text: ORYX.I18N.PropertyWindow.ok,
				                handler: function() {
									// store dialog input
									var value = grid.getValue();
									this.setValue(value);
									
									dialog.hide();
				                }.bind(this)
				            }, {
				                text: ORYX.I18N.PropertyWindow.cancel,
				                handler: function(){
									this.setValue(this.value);
				                	dialog.hide();
				                }.bind(this)
				            }]
						});	
							
						dialog.show();		
						grid.render();
						
						if (this.grid)
							this.grid.stopEditing();
						
						grid.focus( false, 100 );
					};
					
								
					var ct = new Ext.form.TriggerField({
						allowBlank: optional,
						triggerClass: "x-trigger-other",
						width: width,
						facade: this.facade,
						onTriggerClick: triggerFn
						
					});
					
					editor = new Ext.grid.GridEditor(ct);
					ct.on('dialogClosed', function(editor, value){
						var rec = editor.record;
						var dIn = this.grid.getColumnModel().config[editor.col].dataIndex;
						rec.set(dIn, value);
						rec.commit();
					}.bind(this, editor));							

				// TYPE CHOICE
				} else if (type == ORYX.CONFIG.TYPE_CHOICE) {				
					var items = this.items[i].items();
					var select = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", parent, ['select', {style:'display:none'}]);
					var optionTmpl = new Ext.Template('<option value="{value}">{value}</option>');
					items.each(function(value){ 
						optionTmpl.append(select, {value:value.value()}); 
					});				
					
					editor = new Ext.ux.form.ComboBox({
						typeAhead		: true, 
						triggerAction	: 'all',
						transform		: select, 
						lazyRender		: true,
						msgTarget		: 'title',
						mode			: "local",
						width			: width,
				        editable		: true,
				        readOnly		: false,
				        emptyText		: "",
				        selectOnFocus	: true,
						forceSelection	: !this.items[i].allowCustomValue()
					});	
						
				// TYPE BOOLEAN		
				} else if (type == ORYX.CONFIG.TYPE_BOOLEAN) {
					editor = new Ext.form.Checkbox( { width : width } );
				
				// TYPE RADIO
				} else if (type == ORYX.CONFIG.TYPE_RADIOBUTTON) {
					renderer = this.renderRadioButton.bind(this);
				}
				
				// TYPE URL
				else if (type == ORYX.CONFIG.TYPE_URL) {
					if(!isList) {
						var editorInput = new Ext.form.TextField({
							width:width,
							allowBlank : optional,
							msgTarget : 'title',
							enableKeyEvents : true,
							prefixFileLocal: Ext.ux.form.UrlLinkFieldList.prototype.prefixFileLocal,
							prefixFileNetwork: Ext.ux.form.UrlLinkFieldList.prototype.prefixFileNetwork,
							prefixHTTP: Ext.ux.form.UrlLinkFieldList.prototype.prefixHTTP,
							getValue: function(){
								var url = Ext.form.TextField.prototype.getRawValue.call(this);
								if (Ext.ux.form.UrlLinkFieldList.prototype.isURL.call(this, url)){
									url = this.prefixHTTP + url;
								}
								return url;
							},
							listeners : {
								render : function() {
									editorInput.el.on('keyup',function(event) {
										Ext.ux.form.UrlLinkFieldList.prototype.evaluateLokalURL.call(editorInput);
//										this.editDirectly(key,editorInput.getRawValue());
									}.bind(this));
								}.bind(this)}});
						editor = new Ext.Editor(editorInput);
						
						// Commit changes to the connected store
						editor.on('dialogClosed', function(editor, value) {
							var rec = editor.record;
							var dIn = this.grid.getColumnModel().config[editor.col].dataIndex;
							rec.set(dIn, value);
							rec.commit();
						}.bind(this, editor));
					}
				}
				
				// AS LIST
				/**
				 * IF LIST, Use another editor
				 */
				if(isList){
					
					if(!editor) {
						// Use string editor
						var editorInput = new Ext.form.TextField({ allowBlank: optional,  msgTarget:'title', enableKeyEvents: true});
//					editorInput.on('keyup', function(input, event) {
//						this.editDirectly(key, input.getValue());
//					}.bind(this));
						editor = new Ext.Editor(editorInput);
						
					}
					
					// Create List
					var cf = new Ext.form.ListView({
							allowBlank: optional,
							cls: "x-grey-background",
							readOnly: true, 
							//anchor: "100% 100%",
							width: width
						},
						editor, 
						item,
						this.facade);
					
					editor = new Ext.Editor(cf);	
					
					cf.on('dialogClosed', function(editor, value){
						var rec = editor.record;
						var dIn = this.grid.getColumnModel().config[editor.col].dataIndex;
						rec.set(dIn, value);
						rec.commit();
					}.bind(this, editor));
					
					
//					cf.on('dialogClosed', function(data, format){
//						var row = (this.field ? this.field.row : this.row) || this.row; 
//						this.scope.afterEdit({
//							grid:this.scope.grid, 
//							record:this.scope.grid.getStore().getAt(row), 
//							//value:this.scope.grid.getStore().getAt(this.row).get("value")
//							value: data,
//							format: format
//						});
//					}, {scope:this, editor:editor, row:i, col:1,field:cf});
//					cf.on('dialogClosed', this.dialogClosed, {scope:this, /*row:index,*/ col:1,field:cf});	
				}
				
				// Check if there is a custom defined render method, otherwise
				// use the default editor and render function
				if(!(renderer instanceof Function) && (this.rendererFn instanceof Function)) {
					renderer = this.rendererFn;
				} else if(!(this.rendererFn instanceof Function)) {
					renderer = function(value){
						return Signavio.Utils.escapeHTML(value);
					};
				}
				
				cols.push({
					id: 		id,
					header: 	header,
					dataIndex: 	id,
					resizable: 	true,
					editor: 	editor,
					width:		width,
					renderer: 	renderer
		        });
				
			}
			

			var cm = new Ext.grid.ColumnModel(cols), me = this;
			cm.isCellEditable = function(colIndex, rowIndex){
		        if (Ext.grid.ColumnModel.prototype.isCellEditable.apply(this, arguments)){
		        	return me.isRowReadOnly(rowIndex);
		        }
		        return false;
		    };
			
			return cm;
		},
		
		/**
		 * Returns true if the row is editable
		 * @param rowIndex
		 * @returns {Boolean}
		 */
		isRowReadOnly: function(rowIndex){
			if (this.property.defaultValueReadOnly() === true){
        		var value = this.property.value() || "{'items':[]}";
        		try {
        			value = value.evalJSON();
        			return value.items.length <= rowIndex;
        		} catch(e){}
        	} 
			return true;
		},
		
		/**
		 * 
		 * @param value
		 * @param metadata
		 * @param record
		 * @param rowIndex
		 * @param colIndex
		 * @param store
		 * @returns {String}
		 */
		renderRadioButton: function(value, metadata, record, rowIndex, colIndex, store) {
			var checked = (!!value?" checked='checked'":"");
			var button = "<input value='row_" + rowIndex + "_col_" + colIndex + "' class='x-row-" + rowIndex + " x-complexfield-radio-button' type='radio'" + checked + " name='radio-" + (metadata.id||1) + "' onclick='if(!(!this.checked || !this.svenflag)) {this.checked=false; this.svenflag=false;} else {this.svenflag=true;}' />";
			return button;
			
//			"<input class='x-row-" + rowIndex + "' type='radio'" + checked + " name='radio-" + (metadata.id||1) + "' onclick='if(!!this.checked && !!this.svenflag) console.log(\"ttt\")' />";
//			"<input class='x-row-" + rowIndex + "' type='radio'" + checked + " name='test' onclick='if(!!this.checked && this.svenflag) {this.checked = false; this.svenflag=false;} else {this.svenflag = true;}'/>";
		},
		
//		dialogClosed: function() {
//			console.log(arguments);
//			field.on('dialogClosed', function(field, value, oldValue){
//				this.scope.grid.onEditComplete(editorGrid, value, oldValue);	
//			}, {scope:this, editor:editorGrid});
//			var row = this.field ? this.field.row : this.row 
//			this.scope.afterEdit({
//				grid:this.scope.grid, 
//				record:this.scope.grid.getStore().getAt(row), 
//				//value:this.scope.grid.getStore().getAt(this.row).get("value")
//				value: data,
//				format: format
//			})
//		},
		
		/**
		 * After a cell was edited the changes will be commited.
		 * 
		 * @param {Object} option The option that was edited.
		 */
		afterEdit: function(option) {
			option.grid.getStore().commitChanges();
			option.grid.view.refresh();
		},
			
		/**
		 * Before a cell is edited it has to be checked if this 
		 * cell is disabled by another cell value. If so, the cell editor will
		 * be disabled.
		 * 
		 * @param {Object} option The option to be edited.
		 */
		beforeEdit: function(option) {
	
			var state = this.grid.getView().getScrollState();
			
			var col = option.column;
			var row = option.row;
			var editId = this.grid.getColumnModel().config[col].id;
			// check if there is an item in the row, that disables this cell
			for (var i = 0; i < this.items.length; i++) {
				// check each item that defines a "disable" property
				var item = this.items[i];
				var disables = item.disable();
				if (disables != undefined) {
					
					// check if the value of the column of this item in this row is equal to a disabling value
					var value = this.grid.getStore().getAt(row).get(item.id());
					for (var j = 0; j < disables.length; j++) {
						var disable = disables[j];
						if (disable.value == value) {
							
							for (var k = 0; k < disable.items.length; k++) {
								// check if this value disables the cell to select 
								// (id is equals to the id of the column to edit)
								var disItem = disable.items[k];
								if (disItem == editId) {
									this.grid.getColumnModel().getCellEditor(col, row).disable();
									return;
								}
							}
						}
					}		
				}
			}
			this.grid.getColumnModel().getCellEditor(col, row).enable();
			//this.grid.getView().restoreScroll(state);
		},
		
	    /**
	     * If the trigger was clicked a dialog has to be opened
	     * to enter the values for the complex property.
	     */
	    onTriggerClick : function(){
	        if(this.disabled){
	            return;
	        }	
			
			//if(!this.dialog) { 
			
				var dialogWidth = 0;
				var recordType 	= [];
				
				for (var i = 0; i < this.items.length; i++) {
					var id 		= this.items[i].id();
					var width 	= this.items[i].width();
					var type 	= this.items[i].type();	
					var convertFn = undefined;
						
					if (type == ORYX.CONFIG.TYPE_CHOICE) {
						type = ORYX.CONFIG.TYPE_STRING;
					} else if (type == ORYX.CONFIG.TYPE_TEXT) {
						type = ORYX.CONFIG.TYPE_STRING;
					} else if (type == ORYX.CONFIG.TYPE_URL) {
						convertFn = function(v, rec) {
							return rec.links;
						};
					} else if (type == ORYX.CONFIG.TYPE_RADIOBUTTON) {
						type = ORYX.CONFIG.TYPE_BOOLEAN;
					}
							
					dialogWidth += width;
					recordType[i] = {name:id, type:type, convert:convertFn};
				}			
				
				if (dialogWidth > 800) {
					dialogWidth = 800;
				}
				dialogWidth += 22;
				
				var data = this.data;
				if (data == "") {
					// empty string can not be parsed
					data = "{}";
				}
				
				
				var ds = new Ext.data.Store({
			        proxy: new Ext.data.MemoryProxy(eval("(" + data + ")")),				
					reader: new Ext.data.JsonReader({
			            root: 'items',
			            totalProperty: 'totalCount'
			        	}, recordType)
		        });
				ds.load();
						
					
				var cm = this.buildColumnModel();
										
				//var gridHead = this.grid.getView().getHeaderPanel(true);
				var toolbar = new Ext.Toolbar(
				[{
					text: ORYX.I18N.PropertyWindow.add,
					icon: ORYX.CONFIG.EXPLORER_PATH + '/src/img/famfamfam/add.png',
					iconCls: "x-dummy",
					handler: function(){
						var ds = this.grid.getStore();
						var index = ds.getCount();
						this.grid.stopEditing();
						var p = this.buildInitial(recordType, this.items);
						ds.insert(index, p);
						ds.commitChanges();
						this.grid.startEditing(index, 0);
					}.bind(this)
				},{
					text: ORYX.I18N.PropertyWindow.rem,
					icon: ORYX.CONFIG.EXPLORER_PATH + '/src/img/famfamfam/delete.png',
					iconCls: "x-dummy",
					disabled: true,
			        handler : function(){
						var ds = this.grid.getStore();
						var selection = this.grid.getSelectionModel().getSelectedCell();
						if (selection == undefined) {
							return;
						}
						this.grid.getSelectionModel().clearSelections();
			            this.grid.stopEditing();					
						var record = ds.getAt(selection[0]);
						ds.remove(record);
						ds.commitChanges();           
					}.bind(this)
				}]);			

				
				this.grid = new Ext.grid.EditorGridPanel({
					store: ds,
					cm: cm,
					stripeRows: true,
					clicksToEdit: 1,
					autoScroll: true,
					stateId: "x-editor-complex-grid",
					anchor: "100% 100%",
					viewConfig: {
				        forceFit: true
				    },
					enableHdMenu: false, // Disable header menu
					selModel: new Ext.grid.CellSelectionModel(),
					tbar:toolbar
				});	
				
				this.grid.getSelectionModel().on("selectionchange", function(foo, selection){
					if (selection && this.isRowReadOnly(selection.cell[0])){
						toolbar.items.get(1).enable();
					} else {
						toolbar.items.get(1).disable();
					}
					
				}.bind(this));
				
				
				// Basic Dialog
				this.dialog = new Ext.Window({ 
					autoCreate: true, 
					layout: "anchor",
					stateful: true,
					stateId: "x-editor-complex-window",
					title: ORYX.I18N.PropertyWindow.complex_part1 + this.propertyTitle + ORYX.I18N.PropertyWindow.complex_part2, 
					height: 350, 
					width: dialogWidth, 
					modal:true,
					collapsible:false,
					fixedcenter: true, 
					shadow:true, 
					proxyDrag: true,
					keys:[{
						key: 27,
						fn: function(){
							this.dialog.hide();
						}.bind(this)
					}],
					items:[this.grid],
					bodyStyle:"background-color:#FFFFFF",
					buttons: [{
		                text: ORYX.I18N.PropertyWindow.ok,
		                handler: function(){
		                    this.grid.stopEditing();	
							// store dialog input
							this.data = this.buildValue();
							this.dialog.hide();
		                }.bind(this)
		            }, {
		                text: ORYX.I18N.PropertyWindow.cancel,
		                handler: function(){
		                	this.dialog.hide();
		                }.bind(this)
		            }]
				});		
					
				this.dialog.on(Ext.apply({}, this.dialogListeners, {
		       		scope:this
		        }));
			
				this.dialog.show();	
			
		
				this.grid.on('beforeedit', 	this.beforeEdit, 	this, true);
				this.grid.on('afteredit', 	this.afterEdit, 	this, true);
				
				this.grid.render();			
		    
			/*} else {
				this.dialog.show();		
			}*/
			
		}
	});
	
	Ext.form.ComplexTextField = Ext.extend(Ext.form.TriggerField,  {
	
		defaultAutoCreate : {tag: "textarea", rows:1, style:"height:16px;overflow:hidden;" },
	
	    /**
	     * If the trigger was clicked a dialog has to be opened
	     * to enter the values for the complex property.
	     */
	    onTriggerClick : function(){
			
	        if(this.disabled){
	            return;
	        }	

	        var buttons = [];
	        
	        // Add buttons for each registered language
	        if (this.dataSource){
	        	buttons = this.addLanguageButtons(buttons);
			}
	        
	        /*
	         * Create an advanced editor grid if richtext step 2 is enabled and a supported browser is used
	         */
	        if (ORYX.CONFIG.RICHTEXT_2_ENABLED && !Ext.isIPad) {
	        	// Create an advanced richtext editor
	        	var grid = this.getRichtextEditor();
	        } else {
	        	// Else create only a normal text area
	        	var grid = this.getSimpleEditor();
	        }
	        
			if (grid) {
				var dialog = this.getEditorWindow(grid, buttons);
			}
			
			if (!dialog) {
				return;
			}
			
			if (Ext.isIPad) {
				// If no supported browser is used, warn the user if he wants to proceed
				// If the browser is running on iPad, warn that richtext editing is currently not available on mobile devices
	        	// If the user wants to proceed, show a normal text dialogue
	        	Ext.MessageBox.show({
	    			title: ORYX.I18N.PropertyWindow.Richtext.notAvailableTitle,
	    			msg: ORYX.I18N.PropertyWindow.Richtext.notAvailableWarning,
	    			buttons: Ext.MessageBox.OKCANCEL,
	    			fn: function (btn) {
	    				if (btn == 'ok') {
	    					dialog.show();		
	    					grid.render();
	    					
	    					if (this.grid)
	    						this.grid.stopEditing();
	    					grid.focus( false, 100 );
	    				}
	    			}.bind(this),
	    			icon: Ext.MessageBox.WARNING
	    		});
			} else {
				dialog.show();		
				grid.render();
			
				if (ORYX.CONFIG.RICHTEXT_2_ENABLED) {
					// Adds a button to the richtext editor toolbar to switch to the basic text editing mode
					grid.getToolbar().add(this.getSimpleEditorButton(dialog));
				}
				
				if (this.grid)
					this.grid.stopEditing();
				grid.focus( false, 100 );
			}

			

			
		},
		
		/**
		 * Returns a new window for editing text blocks.
		 * If richtext 2 functionality is enabled, an advanced editor is used, else only a basic editor.
		 * @param grid
		 * @param buttons
		 * @returns {Ext.Window}
		 */
		getEditorWindow : function(grid, buttons, disableRichtext) {
			if (!disableRichtext && ORYX.CONFIG.RICHTEXT_2_ENABLED && !Ext.isIPad) {
				// Advanced Richtext Dialogue
				var dialog = new Ext.Window({ 
					layout		: 'anchor',
					autoCreate	: true, 
					// Get the title of the property to change
					title		: (this.dataSource ? this.dataSource.getAt(this.row).get("gridProperties").property.title() : ORYX.I18N.PropertyWindow.text), 
					height		: 500,
					width		: 650,
					minWidth	: 400,
					modal		: true, 
					shadow		: true,
					maximizable : true,
//					tbar		: (buttons && buttons.length > 0) ? buttons : undefined,
					keys:[{
						key	: 27,
						fn	: function(){
								dialog.hide();
						}.bind(this)
					}],
					items		:[grid],
					listeners	:{
						hide: function(){
							dialog.destroy();
						}.bind(this)
					},
					
					buttons		: [{
						/*
						 * The OK Button in the richtext editor
						 */
		                text: ORYX.I18N.PropertyWindow.ok,
		                handler: function(){	 

		                	var content = Ext.ux.Richtext.decode(grid.body);
		                	
		                	this.value = content.text;
		                	this.newFormat = content.format;
		                	
		                	this.setValue(this.value);
							
							if (this.dataSource) {
								this.dataSource.getAt(this.row).set('value', this.value);
								this.dataSource.commitChanges();
							}

							this.fireEvent('dialogClosed', this.value, this.newFormat);
							dialog.hide();
		                }.bind(this)
		            }, {
		            	/*
		            	 * The Cancel Button in the richtext editor
		            	 */
		                text: ORYX.I18N.PropertyWindow.cancel,
		                handler: function(){
		                	//this.setValue(this.value);
		                	dialog.hide();
		                }.bind(this)
		            }]
				});		
			} else {
				// Basic Dialogue
				var dialog = new Ext.Window({ 
					layout		: 'anchor',
					autoCreate	: true, 
					title		: ORYX.I18N.PropertyWindow.text, 
					height		: 500, 
					width		: 500, 
					modal		: true,
					collapsible	: false,
					fixedcenter	: true, 
					shadow		: true, 
					proxyDrag	: true,
					maximizable : true,
					tbar		: (buttons && buttons.length > 0) ? buttons : undefined,
					keys:[{
						key	: 27,
						fn	: function(){
								dialog.hide();
						}.bind(this)
					}],
					items		:[grid],
					listeners	:{
						hide: function(){
							// If the editing happened on a not supported browser, clear the saved formats
							var formats;
							if (Ext.isGecko || Ext.isSafari || Ext.isIE || Ext.isChrome || Ext.isOpera) {
								formats = [];
							}
							this.fireEvent('dialogClosed', this.value, formats);
							dialog.destroy();
						}.bind(this)				
					},
					buttons		: [{
		                text: ORYX.I18N.PropertyWindow.ok,
		                handler: function() {
							// Get value
							var value = grid.getValue();
							// Slice value if a max length is defined
							if ("number" == typeof grid.maxLength && String(value).length > grid.maxLength){
								value = String(value).slice(0, grid.maxLength);
							}
							// Set value
							this.setValue(value);
							
							if (this.dataSource) {
								this.dataSource.getAt(this.row).set('value', value);
								this.dataSource.commitChanges();
							}
		
							dialog.hide();
		                }.bind(this)
		            }, {
		                text: ORYX.I18N.PropertyWindow.cancel,
		                handler: function(){
							this.setValue(this.value);
		                	dialog.hide();
		                }.bind(this)
		            }]
				});		
			}

			return dialog;
		},
		
		/**
		 * Adds a button for each registered language to import text content
		 * @param {Button[]} buttons
		 */
		addLanguageButtons : function(buttons) {
	    	var values = this.events.dialogclosed.listeners[0].scope.scope.shapeSelection.commonPropertiesValues; 
	    	var property = this.dataSource.getAt(this.row).get("gridProperties").property;
				
			
			if (ORYX.CONFIG.MULTI_LANGUAGES_ENABLED && property.language()){
				var oprop = property.origin();
				$H(ORYX.CONFIG.MULTI_LANGUAGES||{}).keys().any(function(lang){
					var key = oprop.prefix() + "-" + oprop.id() + (lang == ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT ? "" : "_" + lang );
					if (property.language() != lang && (values[key]||"") != oprop.value()){
						buttons.push({
							icon: ORYX.CONFIG.EXPLORER_PATH + "/src/img/flags/" + ORYX.CONFIG.MULTI_LANGUAGES[lang],
							iconCls: "x-dummy",
							text: " <img src='"+ORYX.CONFIG.EXPLORER_PATH+"/src/img/famfamfam/bullet_go.png' style='margin-bottom:-5px;margin-left:-13px;margin-right:-5px;position:relative;'/>",
							handler: function(){
								grid.setValue([grid.getValue()||"", Ext.ux.Richtext.encode(values[key], selection.getFormat(key))||undefined].compact().join("\n"));
								// If the grid is an advanced richtext grid, log the changes after setting the value 
								if ("function" === typeof grid.logKeys) {
									grid.logKeys();
								}
							}
						});
					}
				}.bind(this));
			}
			
			return buttons;
		},
		
		/**
		 * Returns a new tbar button to switch to the simple editing mode
		 * @returns {Button}
		 */
		getSimpleEditorButton : function(dialog) {
			return {
					icon		: ORYX.CONFIG.EXPLORER_PATH + "/src/img/fugue/icons/selection-input.png",
					iconCls		: "x-dummy",
					cls			: "x-btn-icon y-horizontal-menu-button",
					tooltip 	: {
						title		: ORYX.I18N.PropertyWindow.Richtext.simpleEditingModeTitle,
						text		: ORYX.I18N.PropertyWindow.Richtext.simpleEditingModeDesc
					}, 
					handler		: function () {
						// Display a warning that all formats could be lost
						Ext.MessageBox.show({
							title	: ORYX.I18N.PropertyWindow.Richtext.simpleEditingModeTitle,
							msg		: ORYX.I18N.PropertyWindow.Richtext.simpleEditingModeWarning,
							buttons	: Ext.MessageBox.OKCANCEL,
							fn		: function(btn) {
								if (btn === "ok") {
									// Create a new simple editor
									var simpleEditor = this.getSimpleEditor();
									// Apply the plain text of the richtext editor to the simple editor
									simpleEditor.setValue(Ext.ux.Richtext.decode(dialog.items.get(0).body).text);
									
									// Create a new Window for it
									var simpleEditorWindow = this.getEditorWindow(simpleEditor, this.addLanguageButtons([]), true);
									
									
									// Get the old window state
									var box = dialog.getBox();
									dialog.hide();
									
									// Show the new window
									simpleEditorWindow.show();
									// Set its state
									simpleEditorWindow.updateBox(box);
									
									simpleEditor.render();
		    				        if (this.grid) {
		    				        	this.grid.stopEditing();
		    				        }
		    				        // Focus the simple editor
		    				        simpleEditor.focus( false, 100 );
								}
							}.bind(this),
							icon	: Ext.MessageBox.WARNING
						});
					}.bind(this)
			};
		},
		
		/**
		 * Returns a simple multiline text editor
		 * @returns {Ext.form.TextArea}
		 */
		getSimpleEditor : function() {
			var maxLength = Number.MAX_VALUE;
			
			if (this.dataSource) {
				var property = this.dataSource.getAt(this.row).get("gridProperties").property;
				if (property && property.length instanceof Function) {
					maxLength = property.length();
				}
			}
			
			return new Ext.form.TextArea({
	        	anchor		: '100% 100%',
				value		: this.value,
				maxLength	: maxLength,
				listeners	: {
					focus: function(){
						if (this.facade)
							this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
					}.bind(this)
				}
			});
		},
		
		/**
		 * Returns an advanced multiline text editor
		 * @returns {Ext.ux.form.RichtextEditor}
		 */
		getRichtextEditor : function(buttons) {
        	
			var selection = (this.facade.getSelection().length > 0 ? this.facade.getSelection()[0] : this.facade.getCanvas());
	        
			var id = this.dataSource.getAt(this.row).data.gridProperties.propId;
        	var json = (selection.getFormat(id)||[]);
			
			var richtextEditor = new Ext.ux.form.RichtextEditor({
        		enableSourceEdit: false,
        		anchor			: '100% 100%',
        		value			: (this.value === '' ? '<br/>' : Ext.ux.Richtext.encode(this.value, json)),
        		modal			: true,
        		ctCls			: 'y-richtext-editor' + (Ext.isIE9 ? ' y-richtext-editor-ie9' : Ext.isChrome ? ' y-richtext-editor-chrome' : ''),
        		listeners		: {
        			initialize	: function(comp) {
        				this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
        			}.bind(this),
        			destroy		: function() {
        				this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
        			}.bind(this)
        		},
        		// Add the multi language support button to the richtext editor's toolbar
        		tbar			: (buttons && buttons.length > 0) ? buttons : undefined
        	});
			
			return richtextEditor;
		}
	});
	
	
	/**
	 * 
	 * Specific implementation of a trigger field which triggers a panel
	 * to configure regions in an EPC
	 * @class Ext.form.EpcFrequencyTypeField
	 */
	Ext.form.EpcFrequencyTypeField = Ext.extend(Ext.form.TriggerField,  {
		
		triggerClass	: "x-trigger-other",
	    
		/**
	     * If the trigger was clicked a dialog has to be opened
	     * to enter the values for the complex property.
	     */
	    onTriggerClick : function(){
		
			if (this.disabled) {
		    	return;
		    }
		
			new Ajax.Request("epcregions", {
	            method: 'get',
	            asynchronous: true,
				requestHeaders: {"Accept":"application/json"},
				encoding: 'UTF-8',
				onSuccess: (function(transport) {
					this.buildDialog( transport.responseText.evalJSON().rep.regions ) ;
				}).bind(this),
				onFailure: (function(transport) {
					Ext.MessageBox.show({
				           title: ORYX.I18N.PropertyWindow.error,
				           msg: ORYX.I18N.PropertyWindow.retrieveError,
				           buttons: Ext.MessageBox.OK,
				           icon: Ext.MessageBox.ERROR
				   });
				}).bind(this)
				
			});
	
			
		},
		
		buildDialog : function(knownRegions) {
	
			var added = [];
			var deleted = [];
			
	        var input = this.getInputValue();
	
	        var ds = new Ext.data.SimpleStore({
	   			fields: ['regionName', 'freq'],
	    		data : []
			});
	        
	        for (var i = 0; i<knownRegions.length; i++) {
	        	var region = knownRegions[i];
	        	var foundFreq = "0";
	        	if (region != "") {
	        		for (var j = 0; j<input.regions.length; j++) {
	        			if (input.regions[j].regionName == region) {
	        				foundFreq = input.regions[j].freq;
	        				break;
	        			}
	        		}
	                ds.add(new Ext.data.Record({ regionName: region, freq : foundFreq }));
	        	}
	        }
	        
	        var freqPerYearField = new Ext.form.NumberField({
			    fieldLabel: ORYX.I18N.PropertyWindow.freqPerYear,
			    labelStyle: 'width:120px;',
			    name: 'freq_per_year',
			    allowBlank: true,
			    width: 100,
			    value: input.freqPerYear,
			    disabled: input.useRegions,
			    allowDecimals:false
			});
	        var formPanel = new Ext.Panel ({ 
	        	layout : 'form', 
	        	border: false, 
	        	items : [ freqPerYearField ]	
	        });
	        
	        var useRegionsBox = new Ext.form.Checkbox({
				boxLabel: ORYX.I18N.PropertyWindow.useRegions,
				labelStyle: 'width:180px;',
			    name: 'store_pa',
			    checked: input.useRegions,
			    style: 'margin-top:24px;margin-bottom:12px;'
			});
	        
	        var grid = new Ext.grid.EditorGridPanel({
				store			: ds,
		        cm				: new Ext.grid.ColumnModel([
			        {
						id: 		"regionName",
						header: 	ORYX.I18N.PropertyWindow.region,
						dataIndex: 	"regionName",
						editor: 	new Ext.form.TextField({ width : 150, disabled : true }),
						width : 	167
			        }, {
			        	id: 		"freq",
						header: 	ORYX.I18N.PropertyWindow.freqPerYear,
						dataIndex: 	"freq",
						editor: 	new Ext.form.NumberField({ width : 150, disabled : false }),
						width : 	167
			        }
		        ]),
				stripeRows  	: true,
				clicksToEdit	: 1,
				height			: 160,
		        selModel		: new Ext.grid.CellSelectionModel(),
		        disabled		: !input.useRegions
		    });	
	        grid.addListener('afteredit', function () {
	        	freqPerYearField.setValue(this.getSumOfFrequenciesInStore(ds.data.items));
	        }.bind(this));
	        
	        var addButton = new Ext.Button({
	        	text : ORYX.I18N.PropertyWindow.buttonAdd,
	        	handler : function() {
	        		Ext.MessageBox.prompt(ORYX.I18N.PropertyWindow.addPromptTitle, ORYX.I18N.PropertyWindow.addPromptMsg, function(btn, newName) {
	        			if (btn == 'ok') {
		        			if (this.storeContainsRegionName(ds.data.items, newName)) {
		        				Ext.MessageBox.show({
		        			           title: ORYX.I18N.PropertyWindow.addErrorTitle,
		        			           msg: ORYX.I18N.PropertyWindow.addErrorMsg,
		        			           buttons: Ext.MessageBox.OK,
		        			           icon: Ext.MessageBox.ERROR
		        			   });
		        			} else {
		        				ds.add(new Ext.data.Record({ regionName: newName, freq : "0" }));
		        				if (!(this.removeFromArray(deleted, newName))) {
		        					added.push(newName);
		                		}
		        			}
	        			}
	        		}.bind(this));
	        	}.bind(this),
	        	style : 'display:inline;margin:3px;'
	        });
	        
	        var delButton = new Ext.Button({
	        	text : ORYX.I18N.PropertyWindow.buttonDelete,
	        	handler : function() {
		        	 Ext.MessageBox.show({
		        		 title: ORYX.I18N.PropertyWindow.deletConfirmTitle,
		        		 msg: ORYX.I18N.PropertyWindow.deletConfirmMsg,
		        		 buttons: Ext.MessageBox.YESNO,
		        		 fn: function (btn) {
		        		 	if (btn == 'yes') {
		        		 		var selection = grid.getSelectionModel().getSelectedCell();
		        				if (selection == undefined) {
		        					return;
		        				}
		        				var record = ds.getAt(selection[0])
		        				grid.getSelectionModel().clearSelections();	
		                		ds.remove(record);
		                		if (!(this.removeFromArray(added, record.data.regionName))) {
		                			deleted.push (record.data.regionName)
		                		}
		                		freqPerYearField.setValue(this.getSumOfFrequenciesInStore(ds.data.items));
		        		 	}
			        	 }.bind(this),
			        	 animEl: 'mb4',
			        	 icon: Ext.MessageBox.QUESTION
		             });
	        	}.bind(this),
	        	style : 'display:inline;margin:3px;'
	        });
	        
	        var buttonPanel = new Ext.Panel ( { 
	        	border : false, 
	        	items : [addButton, delButton],
	        	disabled : !input.useRegions,
	        	style   : 'padding:3px 3px 0'
	        });
	        
	        useRegionsBox.addListener('check', function (node, checked) {
	        	if (checked) {
	        		freqPerYearField.setDisabled(true);
	        		grid.setDisabled(false);
	        		buttonPanel.setDisabled(false);
	        		freqPerYearField.setValue(this.getSumOfFrequenciesInStore(ds.data.items));
	        	} else {
	        		freqPerYearField.setDisabled(false);
	        		grid.setDisabled(true);
	        		buttonPanel.setDisabled(true);
	        	}
	        }.bind(this));
	        
			var dialog = new Ext.Window({ 
				bodyStyle   : 'background-color:#ffffff;padding:15px 15px 0',
				layout		: 'anchor',
				title		: ORYX.I18N.PropertyWindow.freqTitle, 
				height		: 400, 
				width		: 400, 
				modal		: true,
				collapsible	: false,
				fixedcenter	: true, 
				shadow		: true, 
				proxyDrag	: true,
				keys:[{
					key	: 27,
					fn	: function(){
							dialog.hide()
					}.bind(this)
				}],
				items		:[
				    formPanel,
					useRegionsBox,
					grid,
					buttonPanel
				],
				listeners	:{
					hide: function(){
						this.fireEvent('dialogClosed', this.value);
						dialog.destroy();
					}.bind(this)				
				},
				buttons		: [{
	                text: ORYX.I18N.PropertyWindow.ok,
	                handler: function(){	 
						var value = this.buildValue(
								useRegionsBox.getValue(),
								freqPerYearField.getValue(),
								ds.data.items
						);
						this.setValue(value);
						
						this.dataSource.getAt(this.row).set('value', value)
						this.dataSource.commitChanges()
	
						if ((added.length + deleted.length) > 0) {
							new Ajax.Request('epcregions', {
									method: 'post',
									asynchronous: false,
									parameters: {
										added: added,
										deleted: deleted
									},
									onSuccess: (function(transport) {
										try {
											if (transport.responseText.evalJSON().rep.result != 'ok'){
												Ext.MessageBox.show({
													title: ORYX.I18N.PropertyWindow.error,
													msg: ORYX.I18N.PropertyWindow.storeError,
													buttons: Ext.MessageBox.OK,
											    	icon: Ext.MessageBox.ERROR
											   });
											}
										} catch (e) {
											Ext.MessageBox.show({
												title: ORYX.I18N.PropertyWindow.error,
												msg: ORYX.I18N.PropertyWindow.storeError,
												buttons: Ext.MessageBox.OK,
												icon: Ext.MessageBox.ERROR
										   });
										}
									}).bind(this),
									onFailure: (function(transport) {
										Ext.MessageBox.show({
											title: ORYX.I18N.PropertyWindow.error,
											msg: ORYX.I18N.PropertyWindow.storeError,
											buttons: Ext.MessageBox.OK,
											icon: Ext.MessageBox.ERROR
									   });
									}).bind(this)
							});
						}
							
	                
						dialog.hide()
	                }.bind(this)
	            }, {
	                text: ORYX.I18N.PropertyWindow.cancel,
	                handler: function(){
						this.setValue(this.value);
	                	dialog.hide()
	                }.bind(this)
	            }]
			});	
			
			dialog.show();		
		},
		
		buildValue : function(useRegions_, freqPerYear_, storeItems){
			if (!useRegions_ && freqPerYear_ === "") {
				return "";
			}
			var result = {
				 useRegions : useRegions_,
				 freqPerYear : freqPerYear_,
				 regions : []
			};
			for (var i = 0; i<storeItems.length; i++) {
				result.regions.push({ 
					regionName : storeItems[i].data.regionName,
					freq : storeItems[i].data.freq
				});
			}
			return Object.toJSON( result );
		},
		
		getInputValue : function() {
			var input;
			try {
		    	input = this.value.evalJSON();
		    	if (typeof(input.useRegions) == "undefined" || typeof(input.freqPerYear) == "undefined" || typeof(input.regions) == "undefined") {
		    		if (typeof(input) == "number" ) {
		    			input = { useRegions : false, freqPerYear : input, regions : [] };
		    		} else {
		    			input = { useRegions : false, freqPerYear : 0, regions : [] };
		    		}
		    	}
		    } catch (e) {
		    	input = { useRegions : false, freqPerYear : 0, regions : [] };
		    }
		    return input;
		},
		
		storeContainsRegionName: function(storeItems, newName) {
			for (var i = 0; i<storeItems.length; i++) {
				if (storeItems[i].data.regionName == newName){
					return true;
				}
			}
			return false;
		},
		
		getSumOfFrequenciesInStore: function(storeItems) {
			var sum = 0
			for (var i = 0; i<storeItems.length; i++) {
				sum += parseInt( storeItems[i].data.freq );
			} 
			return sum;
		},
		
		removeFromArray: function(array, value) {
			for (var i = 0; i<array.length; i++) {
				if (array[i] == value){
					array.splice(i, 1);
					return true;
				}
			}
			return false;
		}
		
	});
	
	/**
	 * 
	 * Specific implementation of a trigger field which triggers a panel
	 * to configure regions in an EPC
	 * @class Ext.form.EpcFrequencyTypeField
	 */
	Ext.form.EpcFrequencyTypeField = Ext.extend(Ext.form.TriggerField,  {
		
		triggerClass	: "x-trigger-other",
	    
		/**
	     * If the trigger was clicked a dialog has to be opened
	     * to enter the values for the complex property.
	     */
	    onTriggerClick : function(){
		
			if (this.disabled) {
		    	return;
		    }
		
			new Ajax.Request("epcregions", {
	            method: 'get',
	            asynchronous: true,
				requestHeaders: {"Accept":"application/json"},
				encoding: 'UTF-8',
				onSuccess: (function(transport) {
					this.buildDialog( transport.responseText.evalJSON().rep.regions ) ;
				}).bind(this),
				onFailure: (function(transport) {
					Ext.MessageBox.show({
				           title: ORYX.I18N.PropertyWindow.error,
				           msg: ORYX.I18N.PropertyWindow.retrieveError,
				           buttons: Ext.MessageBox.OK,
				           icon: Ext.MessageBox.ERROR
				   });
				}).bind(this)
				
			});
	
			
		},
		
		buildDialog : function(knownRegions) {
	
			var added = [];
			var deleted = [];
			
	        var input = this.getInputValue();
	
	        var ds = new Ext.data.SimpleStore({
	   			fields: ['regionName', 'freq'],
	    		data : []
			});
	        
	        for (var i = 0; i<knownRegions.length; i++) {
	        	var region = knownRegions[i];
	        	var foundFreq = "0";
	        	if (region != "") {
	        		for (var j = 0; j<input.regions.length; j++) {
	        			if (input.regions[j].regionName == region) {
	        				foundFreq = input.regions[j].freq;
	        				break;
	        			}
	        		}
	                ds.add(new Ext.data.Record({ regionName: region, freq : foundFreq }));
	        	}
	        }
	        
	        var freqPerYearField = new Ext.form.NumberField({
			    fieldLabel: ORYX.I18N.PropertyWindow.freqPerYear,
			    labelStyle: 'width:120px;',
			    name: 'freq_per_year',
			    allowBlank: false,
			    width: 100,
			    value: input.freqPerYear,
			    disabled: input.useRegions,
			    allowDecimals:false
			});
	        var formPanel = new Ext.Panel ({ 
	        	layout : 'form', 
	        	border: false, 
	        	items : [ freqPerYearField ]	
	        });
	        
	        var useRegionsBox = new Ext.form.Checkbox({
				boxLabel: ORYX.I18N.PropertyWindow.useRegions,
				labelStyle: 'width:180px;',
			    name: 'store_pa',
			    checked: input.useRegions,
			    style: 'margin-top:24px;margin-bottom:12px;'
			});
	        
	        var grid = new Ext.grid.EditorGridPanel({
				store			: ds,
		        cm				: new Ext.grid.ColumnModel([
			        {
						id: 		"regionName",
						header: 	ORYX.I18N.PropertyWindow.region,
						dataIndex: 	"regionName",
						editor: 	new Ext.form.TextField({ width : 150, disabled : true }),
						width : 	167
			        }, {
			        	id: 		"freq",
						header: 	ORYX.I18N.PropertyWindow.freqPerYear,
						dataIndex: 	"freq",
						editor: 	new Ext.form.NumberField({ width : 150, disabled : false }),
						width : 	167
			        }
		        ]),
				stripeRows  	: true,
				clicksToEdit	: 1,
				height			: 160,
		        selModel		: new Ext.grid.CellSelectionModel(),
		        disabled		: !input.useRegions
		    });	
	        grid.addListener('afteredit', function () {
	        	freqPerYearField.setValue(this.getSumOfFrequenciesInStore(ds.data.items));
	        }.bind(this));
	        
	        var addButton = new Ext.Button({
	        	text : ORYX.I18N.PropertyWindow.buttonAdd,
	        	handler : function() {
	        		Ext.MessageBox.prompt(ORYX.I18N.PropertyWindow.addPromptTitle, ORYX.I18N.PropertyWindow.addPromptMsg, function(btn, newName) {
	        			if (btn == 'ok') {
		        			if (this.storeContainsRegionName(ds.data.items, newName)) {
		        				Ext.MessageBox.show({
		        			           title: ORYX.I18N.PropertyWindow.addErrorTitle,
		        			           msg: ORYX.I18N.PropertyWindow.addErrorMsg,
		        			           buttons: Ext.MessageBox.OK,
		        			           icon: Ext.MessageBox.ERROR
		        			   });
		        			} else {
		        				ds.add(new Ext.data.Record({ regionName: newName, freq : "0" }));
		        				if (!(this.removeFromArray(deleted, newName))) {
		        					added.push(newName);
		                		}
		        			}
	        			}
	        		}.bind(this));
	        	}.bind(this),
	        	style : 'display:inline;margin:3px;'
	        });
	        
	        var delButton = new Ext.Button({
	        	text : ORYX.I18N.PropertyWindow.buttonDelete,
	        	handler : function() {
		        	 Ext.MessageBox.show({
		        		 title: ORYX.I18N.PropertyWindow.deletConfirmTitle,
		        		 msg: ORYX.I18N.PropertyWindow.deletConfirmMsg,
		        		 buttons: Ext.MessageBox.YESNO,
		        		 fn: function (btn) {
		        		 	if (btn == 'yes') {
		        		 		var selection = grid.getSelectionModel().getSelectedCell();
		        				if (selection == undefined) {
		        					return;
		        				}
		        				var record = ds.getAt(selection[0])
		        				grid.getSelectionModel().clearSelections();	
		                		ds.remove(record);
		                		if (!(this.removeFromArray(added, record.data.regionName))) {
		                			deleted.push (record.data.regionName)
		                		}
		        		 	}
			        	 }.bind(this),
			        	 animEl: 'mb4',
			        	 icon: Ext.MessageBox.QUESTION
		             });
	        	}.bind(this),
	        	style : 'display:inline;margin:3px;'
	        });
	        
	        var buttonPanel = new Ext.Panel ( { 
	        	border : false, 
	        	items : [addButton, delButton],
	        	disabled : !input.useRegions,
	        	style   : 'padding:3px 3px 0'
	        });
	        
	        useRegionsBox.addListener('check', function (node, checked) {
	        	if (checked) {
	        		freqPerYearField.setDisabled(true);
	        		grid.setDisabled(false);
	        		buttonPanel.setDisabled(false);
	        		freqPerYearField.setValue(this.getSumOfFrequenciesInStore(ds.data.items));
	        	} else {
	        		freqPerYearField.setDisabled(false);
	        		grid.setDisabled(true);
	        		buttonPanel.setDisabled(true);
	        	}
	        }.bind(this));
	        
			var dialog = new Ext.Window({ 
				bodyStyle   : 'background-color:#ffffff;padding:15px 15px 0',
				layout		: 'anchor',
				title		: ORYX.I18N.PropertyWindow.freqTitle, 
				height		: 400, 
				width		: 400, 
				modal		: true,
				collapsible	: false,
				fixedcenter	: true, 
				shadow		: true, 
				proxyDrag	: true,
				keys:[{
					key	: 27,
					fn	: function(){
							dialog.hide()
					}.bind(this)
				}],
				items		:[
				    formPanel,
					useRegionsBox,
					grid,
					buttonPanel
				],
				listeners	:{
					hide: function(){
						this.fireEvent('dialogClosed', this.value);
						dialog.destroy();
					}.bind(this)				
				},
				buttons		: [{
	                text: ORYX.I18N.PropertyWindow.ok,
	                handler: function(){	 
						var value = this.buildValue(
								useRegionsBox.getValue(),
								freqPerYearField.getValue(),
								ds.data.items
						);
						this.setValue(value);
						
						this.dataSource.getAt(this.row).set('value', value)
						this.dataSource.commitChanges()
	
						if ((added.length + deleted.length) > 0) {
							new Ajax.Request('epcregions', {
									method: 'post',
									asynchronous: false,
									parameters: {
										added: added,
										deleted: deleted
									},
									onSuccess: (function(transport) {
										try {
											if (transport.responseText.evalJSON().rep.result != 'ok'){
												Ext.MessageBox.show({
													title: ORYX.I18N.PropertyWindow.error,
													msg: ORYX.I18N.PropertyWindow.storeError,
													buttons: Ext.MessageBox.OK,
											    	icon: Ext.MessageBox.ERROR
											   });
											}
										} catch (e) {
											Ext.MessageBox.show({
												title: ORYX.I18N.PropertyWindow.error,
												msg: ORYX.I18N.PropertyWindow.storeError,
												buttons: Ext.MessageBox.OK,
												icon: Ext.MessageBox.ERROR
										   });
										}
									}).bind(this),
									onFailure: (function(transport) {
										Ext.MessageBox.show({
											title: ORYX.I18N.PropertyWindow.error,
											msg: ORYX.I18N.PropertyWindow.storeError,
											buttons: Ext.MessageBox.OK,
											icon: Ext.MessageBox.ERROR
									   });
									}).bind(this)
							});
						}
							
	                
						dialog.hide()
	                }.bind(this)
	            }, {
	                text: ORYX.I18N.PropertyWindow.cancel,
	                handler: function(){
						this.setValue(this.value);
	                	dialog.hide()
	                }.bind(this)
	            }]
			});	
			
			dialog.show();		
		},
		
		buildValue : function(useRegions_, freqPerYear_, storeItems){
			var result = {
				 useRegions : useRegions_,
				 freqPerYear : freqPerYear_,
				 regions : []
			};
			for (var i = 0; i<storeItems.length; i++) {
				result.regions.push({ 
					regionName : storeItems[i].data.regionName,
					freq : storeItems[i].data.freq
				});
			}
			return Object.toJSON( result );
		},
		
		getInputValue : function() {
			var input;
			try {
		    	input = this.value.evalJSON();
		    	if (typeof(input.useRegions) == "undefined" || typeof(input.freqPerYear) == "undefined" || typeof(input.regions) == "undefined") {
		    		if (typeof(input) == "number" ) {
		    			input = { useRegions : false, freqPerYear : input, regions : [] };
		    		} else {
		    			input = { useRegions : false, freqPerYear : 0, regions : [] };
		    		}
		    	}
		    } catch (e) {
		    	input = { useRegions : false, freqPerYear : 0, regions : [] };
		    }
		    return input;
		},
		
		storeContainsRegionName: function(storeItems, newName) {
			for (var i = 0; i<storeItems.length; i++) {
				if (storeItems[i].data.regionName == newName){
					return true;
				}
			}
			return false;
		},
		
		getSumOfFrequenciesInStore: function(storeItems) {
			var sum = 0
			for (var i = 0; i<storeItems.length; i++) {
				sum += parseInt( storeItems[i].data.freq );
			} 
			return sum;
		},
		
		removeFromArray: function(array, value) {
			for (var i = 0; i<array.length; i++) {
				if (array[i] == value){
					array.splice(i, 1);
					return true;
				}
			}
			return false;
		}
		
	});
	
	
	


	
	/**
	 * COPIED FROM THE Glossary implementation
	 * new.js
	 */

 	var GlossaryListItemTpl = 	'<tpl for=".">'+
									'<div class="x-inline">'+	
										'<tpl if="values.data.href">'+
											'<div class="x-glossary-title-list">'+
												'{[Signavio.Utils.escapeHTML(values.data.rep.title)]} '+
											'</div>'+
											'<span>(<a href="/p/glossary#gitem={[values.data.rep.id]}" class="x-open" target="_blank">{[ORYX.I18N.PropertyWindow.btnOpen]}</a>, <a href="#{[values.data.rep.id]}" class="x-remove">{[ORYX.I18N.PropertyWindow.btnRemove]}</a>)</span>'+
										'</tpl>'+
										'<tpl if="!values.data.href">'+	
											'<div class="x-glossary-title-list">'+
												'{[Signavio.Utils.escapeHTML(values.data.rep.title)]} '+
											'</div>'+
											'<span>({[ORYX.I18N.PropertyWindow.createNew]}, <a href="#{[values.data.rep.id]}" class="x-remove">{[ORYX.I18N.PropertyWindow.btnRemove]}</a>)</span>'+														
										'</tpl>'+
										'<tpl if="xindex!==xcount">, </tpl>'+
									'</div>'+
								'</tpl>';
	
	
	var FieldItemGenerator = {
		generate: function(type, option){
			option = Object.clone(option);
			if (this["generate"+type] instanceof Function){
				return this["generate"+type](option||{});
			} else {
				return this.generateStringList(option||{})
			}
		},
		generateUrlList: function(option){
			return new Ext.ux.form.UrlLinkFieldList(Ext.apply({
				triggerClass: "x-form-add-trigger",
				emptyListText: ORYX.I18N.PropertyWindow.ListView.dataViewEmptyText
			}, option))
		},
		generateStringList: function(option){
			return new Ext.form.TriggerField(Ext.apply({
						triggerClass	: "x-form-add-trigger",
						data			: [],
						onTriggerClick 	: function(){
							if (this.editing !== undefined){
								this.data[this.editing] = this.getRawValue();
								this.stopEdit();
							} else {
								this.data.push(this.getRawValue());
							}
							this.setRawValue("");
							this.updateView();
							
						},
						initValue: function(){
							if (typeof this.value == "string"){
								this.value = this.value ? [this.value] : [];
							}
							if (this.value instanceof Array){
								this.data = this.value;
								this.value = "";
							}
							Ext.form.TriggerField.prototype.initValue.apply(this, arguments);	
							
						},
						startEdit: function(index){
							this.editing = index;
							var el = this.itemField.query("li")[index];
							Ext.fly(el).addClass("x-editing");
							this.setValue(this.data[index]);
							this.focus();
						},
						stopEdit: function(){
							if (this.editing === undefined){
								return;
							}
							var el = this.itemField.query("li")[this.editing];
							Ext.fly(el).removeClass("x-editing");
							delete this.editing;
							this.setRawValue("");
						},
						onRender:function(){
							Ext.form.TriggerField.prototype.onRender.apply(this, arguments);	
							this.itemField = Ext.get(Ext.DomHelper.append(this.wrap, {tag:"div", style:"margin:1px 0px 4px 0px;display:none;"}));
							this.itemFieldTpl = new Ext.XTemplate('<tpl if="values.length===0"><span class="x-empty">{[ORYX.I18N.PropertyWindow.ListView.dataViewEmptyText]}</span></tpl>','<ol><tpl for="."><li>{.} ',
																	'<span class="x-smaller">',
																	'(',
																	'<tpl if="xindex != 1">',
																		'<a href="#{[xindex-1]}" class="x-move-up">{[ORYX.I18N.PropertyWindow.btnUp]}</a>, ',
																	'</tpl>',
																	'<tpl if="xindex != xcount">',
																		'<a href="#{[xindex-1]}" class="x-move-down">{[ORYX.I18N.PropertyWindow.btnDown]}</a>, ',
																	'</tpl>',
																	'<a href="#{[xindex-1]}" class="x-edit">{[ORYX.I18N.PropertyWindow.btnEdit]}</a>, ',
																	'<a href="#{[xindex-1]}" class="x-remove">{[ORYX.I18N.PropertyWindow.btnRemove]}</a>)</span>',
																	'</li></tpl></ol>');
							this.updateView();
						},
						updateView: function(){
							this.itemFieldTpl.overwrite(this.itemField, this.data||[]);
							this.itemField.setDisplayed(true);
							this.updateEvents()
							if (this.ownerCt&&this.ownerCt.updateSize){
								this.ownerCt.updateSize();
							}
						},
						moveData: function(index, off){
							var a, b;
							a = this.data[index];
							this.data[index] = b = this.data[index+off];
							this.data[index+off] = a;
						},
						updateEvents: function(){
							this.itemField.select("a.x-move-up").on("click", function(e){
								Event.stop(e);
								var index = parseInt(e.target.getAttribute("href").slice(1));
								this.moveData(index, -1);
								this.updateView();
							}.bind(this));

							this.itemField.select("a.x-move-down").on("click", function(e){
								Event.stop(e);
								var index = parseInt(e.target.getAttribute("href").slice(1));
								this.moveData(index, 1);
								this.updateView();
							}.bind(this));
							
							this.itemField.select("a.x-remove").on("click", function(e){
								Event.stop(e);
								var index = parseInt(e.target.getAttribute("href").slice(1));
								delete this.data[index];
								this.data = this.data.compact();
								this.updateView();
							}.bind(this));

							this.itemField.select("a.x-edit").on("click", function(e){
								Event.stop(e);
								var index = parseInt(e.target.getAttribute("href").slice(1));
								this.startEdit(index);
							}.bind(this));
							
							
							var lis = this.itemField.select("li");
							lis.addClassOnOver("x-hover")
							lis.on("mouseover", function(r, t){ Ext.fly(t).addClass("x-hover"); });	
							lis.on("mouseout", function(r, t){  Ext.fly(t).removeClass("x-hover"); });		
												
						},
						listeners: {
							specialkey: function(t, e){
								if (e.getKey() === e.ENTER) {
									t.onTriggerClick();
								} else if (e.getKey() === e.ESC) {
									t.stopEdit();
								}
							}
						},
						getValue: function(){
							return [].concat(this.getRawValue().trim()||undefined, this.data || []).compact();
						}
					
				}, option))
		},
		
		generateGlossarylinkList: function(option){
			return Ext.ux.form.FieldFactory.generateMetaDataGlossaryLinkList(Ext.apply({}, {
				zindex		: 9015,
				valueTpl 	: new Ext.XTemplate(GlossaryListItemTpl),
				initValue	: function(){
					if (this.value instanceof Array){
						this.records = this.value.map(function(rec){ 
							if (typeof rec === "string"){
								rec = {
									id 		: ORYX.Utils.glossaryId(rec),
									title 	: ORYX.Utils.glossaryTitle(rec)
								}
							}
							if (!rec||!rec.id){
								return null;
							}
							return Signavio.Helper.createRecord("gitem", "/glossary/"+rec.id, rec)
						}).compact();
						this.value = "";
					}
					Ext.ux.form.GlossaryField.superclass.initValue.apply(this, arguments);
				},
				getValue	: function(){
					return (this.records||[]).map(function(rec){ 
						return rec.get("href") ? ORYX.Utils.getInGlossarySchema(rec.get("href"), rec.get("rep").title) : rec.get("rep") 
					}) 
				},
				setValue	:function(){
					Ext.ux.form.GlossaryField.superclass.setValue.apply(this, arguments);
				},
				onNewRecord	: function(record){
					// Update
					this.updateValueList();
					this.setValue();
				}
			}, option))
		}
	}
	
}());

/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) {
    ORYX.Plugins = new Object();
}

/**
 * This plugin is responsible for displaying loading indicators and to prevent
 * the user from accidently unloading the page by, e.g., pressing the backspace
 * button and returning to the previous site in history.
 * @param {Object} facade The editor plugin facade to register enhancements with.
 */
ORYX.Plugins.Loading = {

    construct: function(facade){
    
        this.facade = facade;
        
        // The parent Node
        this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.facade.getCanvas().getHTMLContainer().parentNode.parentNode, ['div', {
            'class': 'LoadingIndicator'
        }, '']);
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADING_ENABLE, this.enableLoading.bind(this));
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADING_DISABLE, this.disableLoading.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADING_STATUS, this.showStatus.bind(this));
        
        this.disableLoading();
    },
    
    enableLoading: function(options){
		if(options.text) 
			this.node.innerHTML = options.text + "...";
		else
			this.node.innerHTML = ORYX.I18N.Loading.waiting;
		this.node.removeClassName('StatusIndicator');
		this.node.addClassName('LoadingIndicator');
        this.node.style.display = "block";
		
		var pos = this.facade.getCanvas().rootNode.parentNode.parentNode.parentNode.parentNode;

		this.node.style.top 		= pos.offsetTop + 'px';
		this.node.style.left 		= pos.offsetLeft +'px';
					
    },
    
    disableLoading: function(){
        this.node.style.display = "none";
    },
	
	showStatus: function(options) {
		if(options.text) {
			this.node.innerHTML = options.text;
			this.node.addClassName('StatusIndicator');
			this.node.removeClassName('LoadingIndicator');
			this.node.style.display = 'block';

			var pos = this.facade.getCanvas().rootNode.parentNode.parentNode.parentNode.parentNode;

			this.node.style.top 	= pos.offsetTop + 'px';
			this.node.style.left 	= pos.offsetLeft +'px';
												
			var tout = options.timeout ? options.timeout : 2000;
			
			window.setTimeout((function(){
            
                this.disableLoading();
                
            }).bind(this), tout);
		}
		
	}
}

ORYX.Plugins.Loading = Clazz.extend(ORYX.Plugins.Loading);
/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) {
    ORYX.Plugins = new Object();
}

/**
 * This plugin is responsible for resizing the canvas.
 * @param {Object} facade The editor plugin facade to register enhancements with.
 */
ORYX.Plugins.CanvasResize = Clazz.extend({

	BLACKLIST : ["http://www.signavio.com/stencilsets/processdoctemplate#"],
	
    construct: function(facade){
		
        this.facade = facade;
        
        var currentStencilSet = $H(this.facade.getStencilSets()).keys().first();
        
        if (!Ext.isIPad && !this.BLACKLIST.include(currentStencilSet)) {
    		new ORYX.Plugins.CanvasResizeButton( this.facade.getCanvas(), "N", this.resize.bind(this));
    		new ORYX.Plugins.CanvasResizeButton( this.facade.getCanvas(), "W", this.resize.bind(this));
    		new ORYX.Plugins.CanvasResizeButton( this.facade.getCanvas(), "E", this.resize.bind(this));
    		new ORYX.Plugins.CanvasResizeButton( this.facade.getCanvas(), "S", this.resize.bind(this));
        }

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_CANVAS_RESIZE, this.handleResizeEvent.bind(this));

    },
    
    /**
     * Handles events to extend/resize the canvas by the given options 
     * @param options
     */
    handleResizeEvent : function(options) {
    	if (!options || !options.position) {
    		return;
    	}
    	
    	this.resize(options.position, options.shrink, options.size);
    },
    
    /**
     * Resizes the canvas in the given direction
     * @param {String} position The direction to extend/shrink the canvas
     * @param {Boolean} shrink True to shrink the canvas instead of extending
     * @param {Number} size The distance to extend/shrink
     */
    resize: function( position, shrink, size ){
    	
    	var resizeCanvas = function(position, extentionSize, facade) {
        	var canvas 		= facade.getCanvas();
    		var b 			= canvas.bounds;
    		var scrollNode 	= facade.getCanvas().getHTMLContainer().parentNode.parentNode;
    		
    		if( position == "E" || position == "W"){
    			canvas.setSize({width: (b.width() + extentionSize)*canvas.zoomLevel, height: (b.height())*canvas.zoomLevel})

    		} else if( position == "S" || position == "N"){
    			canvas.setSize({width: (b.width())*canvas.zoomLevel, height: (b.height() + extentionSize)*canvas.zoomLevel})
    		}

    		if( position == "N" || position == "W"){
    			
    			var move = position == "N" ? {x: 0, y: extentionSize}: {x: extentionSize, y: 0 };

    			// Move all children
    			canvas.getChildNodes(false, function(shape){ shape.bounds.moveBy(move); });
    			// Move all dockers which are not docked
    			var edges = canvas.getChildEdges();
    			var dockers = edges.collect(function(edge){ 
    							return edge.dockers.findAll(function(docker){ 
    									return !docker.getDockedShape();
    								});
    							}).flatten();
    			dockers.each(function(docker){ 
    				docker.bounds.moveBy(move);
    			});
    		} else if( position == "S" ){
    			scrollNode.scrollTop += extentionSize;
    		} else if( position == "E" ){
    			scrollNode.scrollLeft += extentionSize;
    		}
    		
    		canvas.update();
    		facade.updateSelection();
        }
		
		var commandClass = ORYX.Core.Command.extend({
			construct: function(position, extentionSize, facade){
				this.position = position;
				this.extentionSize = extentionSize;
				this.facade = facade;
			},			
			execute: function(){
				resizeCanvas(this.position, this.extentionSize, this.facade);
			},
			rollback: function(){
				resizeCanvas(this.position, -this.extentionSize, this.facade);
			},
			update:function(){
			}
		});
		
		var extentionSize = ("number" === typeof size ? size : ORYX.CONFIG.CANVAS_RESIZE_INTERVAL);
		if(shrink) extentionSize = -extentionSize;
		var command = new commandClass(position, extentionSize, this.facade);
		
		this.facade.executeCommands([command]);
			
    }
});


ORYX.Plugins.CanvasResizeButton = Clazz.extend({
	
	construct: function(canvas, position, callback){
		this.canvas = canvas;
		var parentNode = canvas.getHTMLContainer().parentNode.parentNode.parentNode;
		
		window.myParent=parentNode
		var scrollNode 	= parentNode.firstChild;
		var svgRootNode = scrollNode.firstChild.firstChild;
		// The buttons
		var buttonGrow 	= ORYX.Editor.graft("http://www.w3.org/1999/xhtml", parentNode, ['div', { 'class': 'canvas_resize_indicator canvas_resize_indicator_grow' + ' ' + position ,'title':ORYX.I18N.RESIZE.tipGrow+ORYX.I18N.RESIZE[position]}]);
		var buttonShrink 	= ORYX.Editor.graft("http://www.w3.org/1999/xhtml", parentNode, ['div', { 'class': 'canvas_resize_indicator canvas_resize_indicator_shrink' + ' ' + position ,'title':ORYX.I18N.RESIZE.tipShrink+ORYX.I18N.RESIZE[position]}]);
		
		// Defines a callback which gives back
		// a boolean if the current mouse event 
		// is over the particular button area
		var offSetWidth = 60;
		var isOverOffset = function(event){
			if(event.target!=parentNode && event.target!=scrollNode&& event.target!=scrollNode.firstChild&& event.target!=svgRootNode&& event.target!=scrollNode){ return false }
			//if(inCanvas){offSetWidth=30}else{offSetWidth=30*2}
			//Safari work around
			var X=event.layerX !== undefined ? event.layerX : event.offsetX;
			var Y=event.layerY !== undefined ? event.layerY : event.offsetY;
			
			if((X - scrollNode.scrollLeft)<0 ||Ext.isSafari||Ext.isIE){	X+=scrollNode.scrollLeft;}
			if((Y - scrollNode.scrollTop )<0 ||Ext.isSafari||Ext.isIE){ Y+=scrollNode.scrollTop ;}
			
			//

			if(position == "N"){
				return  Y < offSetWidth+scrollNode.firstChild.offsetTop;
			} else if(position == "W"){
				return X < offSetWidth + scrollNode.firstChild.offsetLeft;
			} else if(position == "E"){
				//other offset
				var offsetRight=(scrollNode.offsetWidth-(scrollNode.firstChild.offsetLeft + scrollNode.firstChild.offsetWidth));
				if(offsetRight<0)offsetRight=0;
				return X > scrollNode.scrollWidth-offsetRight-offSetWidth;
			} else if(position == "S"){
				//other offset
				var offsetDown=(scrollNode.offsetHeight-(scrollNode.firstChild.offsetTop  + scrollNode.firstChild.offsetHeight));
				if(offsetDown<0)offsetDown=0;

				return Y > scrollNode.scrollHeight -offsetDown- offSetWidth;
			}
			
			return false;
		}
		
		var showButtons = (function() {
			buttonGrow.show(); 
        
			var x1, y1, x2, y2;
			try {
				var bb = this.canvas.getRootNode().childNodes[1].getBBox();
				x1 = bb.x;
				y1 = bb.y;
				x2 = bb.x + bb.width;
				y2 = bb.y + bb.height;
			} catch(e) {
				this.canvas.getChildShapes(true).each(function(shape) {
					var absBounds = shape.absoluteBounds();
					var ul = absBounds.upperLeft();
					var lr = absBounds.lowerRight();
					if(x1 == undefined) {
						x1 = ul.x;
						y1 = ul.y;
						x2 = lr.x;
						y2 = lr.y;
					} else {
						x1 = Math.min(x1, ul.x);
						y1 = Math.min(y1, ul.y);
						x2 = Math.max(x2, lr.x);
						y2 = Math.max(y2, lr.y);
					}
				});
			}
        
			var w = canvas.bounds.width();
			var h = canvas.bounds.height();
        
			var isEmpty = canvas.getChildNodes().size()==0;
        
			if(position=="N" && (y1>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL || (isEmpty && h>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL))) buttonShrink.show();
			else if(position=="E" && (w-x2)>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL) buttonShrink.show();
			else if(position=="S" && (h-y2)>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL) buttonShrink.show();
			else if(position=="W" && (x1>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL || (isEmpty && w>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL))) buttonShrink.show();
			else buttonShrink.hide();
		}).bind(this);
        
		var hideButtons = function() {
			buttonGrow.hide(); 
			buttonShrink.hide();
		}	
        
		// If the mouse move is over the button area, show the button
		scrollNode.addEventListener(	ORYX.CONFIG.EVENT_MOUSEMOVE, 	function(event){ if( isOverOffset(event) ){showButtons();} else {hideButtons()}} , false );
		// If the mouse is over the button, show them
		buttonGrow.addEventListener(		ORYX.CONFIG.EVENT_MOUSEOVER, 	function(event){showButtons();}, true );
		buttonShrink.addEventListener(		ORYX.CONFIG.EVENT_MOUSEOVER, 	function(event){showButtons();}, true );
		// If the mouse is out, hide the button
		//scrollNode.addEventListener(		ORYX.CONFIG.EVENT_MOUSEOUT, 	function(event){button.hide()}, true )
		parentNode.addEventListener(	ORYX.CONFIG.EVENT_MOUSEOUT, 	function(event){hideButtons()} , true );
		//svgRootNode.addEventListener(	ORYX.CONFIG.EVENT_MOUSEOUT, 	function(event){ inCanvas = false } , true );
        
		// Hide the button initialy
		hideButtons();

		// Add the callbacks
	    buttonGrow.addEventListener('click', function(){callback( position ); showButtons();}, true);
	    buttonShrink.addEventListener('click', function(){callback( position, true ); showButtons();}, true);

	}
});

/**
 * Copyright (c) 2009
 * Signavio GmbH
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 * @author Willi Tscheschner
 * 
 * 
 **/
if (!ORYX) { var ORYX = new Object(); }
if (!ORYX.Plugins) { ORYX.Plugins= new Object(); }
if (!Signavio) { var Signavio = new Object(); }
if (!Signavio.Helper) { Signavio.Helper = new Object(); }

new function() {
	
	var Config = {};
	
	Config.RENAME_SHAPES_DIRECTLY = {
		"http://b3mn.org/stencilset/epc#" : true,
		"http://www.signavio.com/stencilsets/organigram#" : true,
		"http://www.signavio.com/stencilsets/processmap#" : true,
		"Task" : true,
		"CollapsedSubprocess" : true,
		"Pool" : true,
		"CollapsedPool" : true,
		"VerticalPool" : true,
		"CollapsedVerticalPool" : true,
		"Lane" : true,
		"VerticalLane" : true,
		"DataObject" : true,
		"TextAnnotation" : true,
		"CollapsedEventSubprocess" : true,
		"EventSubprocess" : true,
		"ChoreographyTask" : true,
		"ChoreographySubprocessCollapsed" : true,
		"ChoreographySubprocessExpanded" : true,
		"Participant" : true
	};
	
	
	Config.DONT_RENAME_SHAPES_DIRECTLY = {
		"grect" : true,
		"gdiamond" : true, 
		"gellipse" : true
	};
	
	Config.RENAME_SHAPES_CATEGORIES = {
		"Pool" : ["IT_SYSTEM", "ORG_UNIT"],
		"Lane" : ["IT_SYSTEM", "ORG_UNIT"]
	};
	
	// Define small and medium letters
	var one = ["i", "I", "j", "l"];
	var two = ["a", "b", "d", "e", "f", "J", "k", "n", "o", "r", "s", "t", "u", "v", "y", "z"];
	
	Signavio.Helper.TruncateByWidth = function(text, width, suffix){
	
		text = text || "";
		suffix = suffix || "&hellip;";
		var s = 0;
		var res = "";
		// Go through every letter and checks them
		var isSmaller = text.toArray().all(function(a){
			s += one.include(a) ? 3 : (two.include(a) ? 5 : 9);
			if (s <= width) {
				res += a;
				return true;
			}
			return false;
		});
		
		return isSmaller ? res : res.slice(0, res.length - 1) + suffix;
	};
	
	
	ORYX.Plugins.RenameShapes = Clazz.extend({
		
		openRenameForProperties : ["oryx-name", "oryx-title", "oryx-text"],
		
		enableRenameOnAdd: !Ext.isIPad,
		
	    construct: function(facade){
		
		    this.facade = facade;
			this.editorInitialized = false;
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, function(){
				this.editorInitialized = true;
			}.bind(this));

			if (this.enableRenameOnAdd){
				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, this.onAdd.bind(this));
	    	}
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DBLCLICK, this.actOnDBLClick.bind(this)); 
			
			this.facade.offer({
					 keyCodes: [{
							keyCode: 113, // F2-Key
							keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
						}
					 ],
				     functionality: this.renamePerF2.bind(this)
			     });
			
			$(this.facade.getCanvas().getHTMLContainer()).addClassName("x-glossary-support-container");
			
			
            // Init for blur (un-focus)
    	    var onClick = function(e){
    			if (this.shownTextField && (!e || !this.shownTextField.el || (e.target !== this.shownTextField.el.dom && (!this.shownTextField.list || !this.shownTextField.list.contains(e.target)))) && !e.target.className.toString().include("x-combo-selected")) {
    				this.shownTextField.onBlur();
    			}
    	    }.bind(this);
    	    
    	    if (!ORYX.Utils.isIPad()){
    	    	Ext.getBody().on("click", onClick);
    	    }
		},
		
		/**
		 * Hide the input field if selection changed
		 *
		 */
		onSelectionChanged: function(){
			if (this.shownTextField&&this.shownTextField.el&&!this.isOnSelecting){
				this.shownTextField.onBlur();
			}
		},
		
		renamePerF2 : function() {
			var selectedShapes = this.facade.getSelection();
			this.actOnDBLClick(undefined, selectedShapes.first());
		},
		
		addedShapes: [],
		
		onAdd: function(evt){
			
			var shape = evt.shape;
			
			if (!this.editorInitialized&&shape instanceof ORYX.Core.Node) {
				this.addedShapes.push(shape.id);
				return;
			}
			
			if (shape instanceof ORYX.Core.Node && (Config.RENAME_SHAPES_DIRECTLY[shape.getStencil().namespace()] || Config.RENAME_SHAPES_DIRECTLY[shape.getStencil().idWithoutNs()]) && !Config.DONT_RENAME_SHAPES_DIRECTLY[shape.getStencil().idWithoutNs()] && !this.addedShapes.include(shape.id)) {
				
				if (this.addTimeout){				
					this.addedShapes.push(shape.id);
					return;
				}
				
				var label, pname;
				
				this.openRenameForProperties.each(function(r){
					var prop = shape.getStencil().property(r);
					if (prop) {
						if (prop.refToView().any(function(ref){
								label = shape._labels[shape.id+ref];
								return !!label;
							})){
							pname = r;
							throw $break;
						}
					}
				});
				
				// Show input field for the label
				this.addTimeout = window.setTimeout(function(){
					// Check if the prop is empty
					if (!shape.properties[pname])
						this.showInputForLabel(shape, label);	
					delete this.addTimeout;
				}.bind(this), 150);
				
				this.addedShapes.push(shape.id);
			}
		},
		
		/**
		 * Implementation of the behavior if double clicking
		 * 
		 */
		actOnDBLClick: function(evt, shape){
			// Check if shape
			if( !(shape instanceof ORYX.Core.Shape) ){ return; }
			
			// Get label
			var label 	= this.getNearestLabel(evt, shape);
			
			// Show input field for the label
			this.showInputForLabel(shape, label);
		},
			
		getScale: function(){
			try {
				return this.facade.getCanvas().node.transform.baseVal.getItem(0).matrix.a;
			} catch(e) {
				return 1;
			}
		},
		
		/**
		 * Shows an input field regarding to a label and a shape
		 * @param {ORYX.Core.Shape} shape
		 * @param {ORYX.Core.Label} label
		 */
		showInputForLabel: function(shape, label) {
			
			if (!shape||!label) { return; }
			
			shape.editing = true;
			
			// Get property to that label
			var prop 	= this.getPropertyByLabel(shape, label);
			/*
			if(prop.type() === ORYX.CONFIG.TYPE_TEXT) {
			    var cf = new Ext.form.ComplexTextField({
                    allowBlank: prop.optional(),
                    triggerClass: "x-trigger-other",
                    property: prop,
                    cls: "x-gray-background",
                    readOnly: true,
                    facade: this.facade
                });

			    cf.setValue(shape.getProperty(prop.id()));
			    
			    cf.on("dialogClosed", function(value, format) {
			        shape.setFormat(prop.prefix() + "-" + prop.id(), format);
			        shape.setProperty(prop.id(), value);
			    });
			    
			    cf.onTriggerClick();
			    
			    return;
			}
			*/
			if (prop.type() != ORYX.CONFIG.TYPE_STRING) { return; }
			var id 		= prop.prefix() + "-" + prop.id();
			
			// Destroys the old input, if there is one
			this.close();

	        var isTextArea = prop.wrapLines();
	        
	        var width	= shape.bounds.width();
	        var height	= shape.bounds.height();
	        
	        // Add margin to position
	        var off = 3;
	        width	 -= off*2;
	        height 	 -= off*2;

	        width = Math.max(90, Math.min(width, 150));
	        height = Math.max(70, Math.min(height, 100));
	        
			// Get center
			var center 	= this.getCenterPosition( label.node );
			
			center.x	-= (width/2);
			center.y 	-= isTextArea ? (height/2)+1 : 22/2;

			// Consider WebKits padding
			if (Ext.isSafari && !Ext.isChrome){
				center.x += 1;
				center.y += 1;
				width	-= 2;
				height	-= 2;
			} else if (Ext.isIE){
				center.y += 1;
				width	+= 1;
			}
			
			center.x	= Math.max(center.x, 5)
			center.y	= Math.max(center.y, 5)
						        
			var parentDir = this.facade.getModelMetaData().parent;
			
	        // Define config for the textfield
			
			var config 		= 	{
					renderTo	: this.facade.getCanvas().getHTMLContainer().id,
					value		: this.getPropertyValue(shape, id), //strippedValue
					x			: center.x,
					y			: center.y,
					width		: width,
					height		: height,
					allowBlank	: prop.optional(), 
					maxLength	: prop.length(),
					renderAsTextArea: isTextArea,
					growMin		: height,
					grow		: isTextArea,
					parentDir	: parentDir
				};
	        
			// Get the categories out of the config
			var cf = Config.RENAME_SHAPES_CATEGORIES[$H(Config.RENAME_SHAPES_CATEGORIES).keys()
			                                         	.find(function(r){ return shape.getStencil().id().endsWith(r); })];
			if (cf){
				config.categories = [].concat(cf);
			}
			
	        // Create search field
			if (this.facade.hasGlossaryExtension 
					&& this.facade.stencilHasGlossarySupport(shape, id.replace(/_[a-z]+$/i, ""))
					&& !this.hasGlossary(shape, prop)) {
				this.shownTextField = new GlossarySearchFieldBox(config);
		        this.shownTextField.wrap.setStyle("position", "absolute");
			} else {
				config.style = "position:absolute;visibility:hidden;left:-10000px;";
				config.cls = "x-plugin-rename-field";
				// Add esc listener to close the textarea
				config.listeners = {
						specialKey : function(field, e) {
							if (e.keyCode === 27) {
								field.onBlur();
							}
						}
				};

				if (isTextArea) {
					this.shownTextField = new Ext.form.TextArea(config);
				} else {
					delete config.height;
					this.shownTextField = new Ext.form.TextField(config);
				}
			}

			// Bugfix for Chrome: Chrome does not support specialKey or keypress listeners, so use keydown
			if (Ext.isChrome) {
				this.shownTextField.el.on("keydown", function(e, field) {
					if (e.getKey() === 27) {
						this.shownTextField.onBlur();
					}
				}.bind(this));	
			}
			

			// ON Blur, remove field
            this.shownTextField.on('blur', function(textArea) {     
                if (!(this.lastClick && (this.lastClick.className || "").toString().include("keep-focus"))) {
                    this.destroy();
                    shape.editing = false;
                } 
            }.bind(this));
			// ON Change
			this.shownTextField.on('change', this.onChange.bind(this, shape, prop));
			// ON Select
			this.shownTextField.onSelect = this.onSelect.bind(this, shape, prop, label, this.shownTextField);
			
			// Fade in
			window.setTimeout(function(){
				if (this.shownTextField&&this.shownTextField.el){
					if (this.shownTextField.autoSize instanceof Function){
						this.shownTextField.autoSize();
					}
					this.shownTextField.el.fadeIn({duration:0.2, callback:function(){
						if (this.shownTextField) {
							// Set focus
							this.shownTextField.focus();
						}
					}.bind(this)});
				}
			}.bind(this), 10);
			
			// Disable all further key down events
			//this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
			shape.textField = this.shownTextField;
		},
		
		getPropertyValue: function(shape, id){
			
			// TODO: Use only glossary item and not the whole text
//			var prop = shape.getStencil().property(id).origin();
//			
//			if (ORYX.CONFIG.MULTI_LANGUAGES_ENABLED && prop.language() && (shape.properties[id]||"") == prop.value()){
//		
//				if (this.facade.hasGlossaryExtension 
//					&& this.facade.stencilHasGlossarySupport(shape, id.replace(/_[a-z]+$/i, ""))){
//					
//					var glossary = $H(ORYX.CONFIG.MULTI_LANGUAGES||{}).keys().map(function(lang){
//						var key = prop.prefix() + "-" + prop.id() + (lang == ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT ? "" : "_" + lang );
//						return this.facade.getGlossary(shape, shape.getStencil().property(key)) || undefined;
//					}.bind(this)).compact().first();
//					
//					if (glossary){
//						return glossary.text;
//					}
//				}
//			}
			return shape.properties[id];
			
		},
		
		/**
		 * Returns TRUE if the property (or the property in any other language)
		 * has already a glossary entry set
		 * @param {ORYX.Core.Shape} shape
		 * @param {ORYX.Core.Property} prop
		 * @return {Boolean}
		 */
		hasGlossary: function(shape, prop){
			
			// Check the glossary in any language
			if (ORYX.CONFIG.MULTI_LANGUAGES_ENABLED && prop.language()){
				prop = prop.origin();
				return $H(ORYX.CONFIG.MULTI_LANGUAGES||{}).keys().any(function(lang){
					var key = prop.prefix() + "-" + prop.id() + (lang == ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT ? "" : "_" + lang );
					return this.facade.hasGlossary(shape, shape.getStencil().property(key));
				}.bind(this));
			} else {
				return this.facade.hasGlossary(shape, prop);
			}
		},
		
		/**
		 * Callback if the label of an element has change.
		 */
		onChange: function(shape, prop, node, value){
			if (this.facade.hasGlossaryExtension && this.facade.hasGlossary(shape, prop)){ 
				// Check if there is a value
				if (!(value||"").strip()) {
					Ext.Msg.confirm(Signavio.I18N.Glossary_Support.removeTitle, Signavio.I18N.Glossary_Support.removeDesc, function(btn){
						if (btn=="yes") {
							// Set property
							this.setProperty(shape, prop, value);
						}
					}.bind(this))
				} else {
					var doSome = function(btn){
						if (btn=="yes") {
							// Set property
							this.setProperty(shape, prop, value, false, true);
						}
					}.bind(this);
					
					// Is dirty
					if (this.facade.hasGlossaryExtension && this.facade.checkGlossaryIsDirty(value, shape.properties[prop.prefix()+"-"+prop.id()])) {
						Ext.Msg.confirm(Signavio.I18N.Glossary_Support.changeTitle, Signavio.I18N.Glossary_Support.changeDesc, doSome);
					} else {
						doSome("yes");
					}
				}
			} else {
				this.setProperty(shape, prop, value);
			}
		},

		/**
		 * Replace all common stings from string1 with those
		 * which are in the string2
		 * @param {String} string1
		 * @param {String} string2
		 * @param {int} cursor (Optional)
		 * 
		 */
		replaceCommonSubString : function(string1, string2, cursor) {
			return Signavio.Utils.replaceCommonSubString(string1, string2, cursor);
		},
		
		/**
		 * Callback if a glossary entry is selected 
		 */
		onSelect: function(shape, prop, label, field, record){
			this.isOnSelecting = true;
			var value = Signavio.Utils.unescapeHTML(record.get("rep").title||"");
			if (field) {
				
				var text = field.getValue();
				var pos = this.getCursorPosition(field.el.dom);
				// Replace common substings
				value = this.replaceCommonSubString(text, value, pos);
			}
			
			// Add to the model glossary store
			if (this.facade.hasGlossaryExtension) {
				//this.facade.updateGlossaryUI(shape);
				this.setProperty(shape, prop, value, true, {glossary:record.get("rep").id, isDirty:this.facade.checkGlossaryIsDirty(value, Signavio.Utils.unescapeHTML(record.get("rep").title)) });
				
				//add maximum text width to svg xml document as an attribute of the text tag
				var textWidth = label.getReferencedElementWidth();
				if(textWidth) {
					label.node.setAttribute("oryx:textWidth", textWidth);
				}
			}
			
			if (field) {
				field.setValue(value);
				
				// Hide list
				field.collapse();
				field.list.remove();
				delete field.list;
			}
			
			
			delete this.isOnSelecting;
			
			// Set to the property
			//this.setProperty(shape, prop, value, true);
			//this.destroy();
		},
		
		getCursorPosition: function(input){
			if (input && typeof input.selectionStart !== "undefined") {
				return input.selectionStart;
			} else {
				return input.value.length;
			}

		},
		
		close: function(){

			/*if (this.shownTextField) {
				var sel = this.facade.getSelection();
				this.shownTextField.hide();
				this.shownTextField.onBlur();
				this.facade.setSelection(sel||[]);
			}*/
			
			this.destroy();
		},
		
		destroy: function(e){
			
			if (this.addTimeout) {
				window.clearTimeout(this.addTimeout);
				delete this.addTimeout;
			}
			
			if( this.shownTextField){
				if (this.shownTextField.list) {
					this.shownTextField.list.hide();
				}
				//var id = this.shownTextField.el.id;
				
				//this.shownTextField.el.fadeOut({duration:0.1, callback:function(){
				//	var cmp = Ext.getCmp(id);
				//	if (cmp) {
						this.shownTextField.destroy(); 
				//	}
					this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
				//}.bind(this)});
				delete this.shownTextField;
			}
		},
		
		/**
		 * Sets a property with a given value
		 * @param {ORYX.Core.Shape} shape
		 * @param {ORYX.Core.Property} prop
		 * @param {String} value
		 */
		setProperty: function(shape, prop, value, force, setGlossary){
			
			var id			= prop.prefix() + "-" + prop.id();
			var oldValue	= shape.properties[id]; 
			var newValue	= value;
			var facade		= this.facade;
			
			var label = shape.getLabel(prop.id());

			// If the value is different, or the glossary connection has changes
			if (oldValue != newValue || (this.facade.hasGlossaryExtension && !this.facade.getGlossary(shape, prop) && setGlossary instanceof Object)) {
				// Implement the specific command for property change
				var commandClass = ORYX.Core.Command.extend({
					construct: function(){
						this.facade = facade;
						this.el = shape;
						this.propId = id;
						this.prop = prop;
						this.oldValue = oldValue;
						this.newValue = newValue;
						this.setGlossary = setGlossary;
						this.oldGlossary = this.facade.hasGlossaryExtension ? this.facade.getGlossary(shape, prop) : null;
					},
					execute: function(){
						
						if (this.facade.hasGlossaryExtension){
							if (this.setGlossary){
								var isDirty, id;
								if (typeof this.setGlossary == "object"&&this.setGlossary.glossary){
									id = this.setGlossary.glossary;
									isDirty = !!this.setGlossary.isDirty;
								} else {
									id = this.facade.getGlossary(this.el, this.prop).glossary;
									isDirty = this.facade.checkGlossaryIsDirty(this.newValue, this.el.properties[this.prop.prefix()+"-"+this.prop.id()])
								}
								
								this.facade.setGlossary(this.el, this.prop, id, this.newValue, isDirty);
							} else {
								this.facade.setGlossary(this.el, this.prop);
							}
						}
								
						this.el.setProperty(this.propId, this.newValue, force);
						//this.el.update();
						if (this.executeAgain) {
							this.facade.setSelection([this.el]);
							this.facade.getCanvas().update();
							this.facade.updateSelection();
						} else {
							this.facade.getCanvas().update();
						}
						
						this.executeAgain = true;
					},
					rollback: function(){
						
						if (this.facade.hasGlossaryExtension){
							if (this.oldGlossary){
								var og = this.oldGlossary;
								this.facade.setGlossary(this.el, this.prop, og.glossary, og.text, og.isDirty);
							} else {
								this.facade.setGlossary(this.el, this.prop);
							}
						}
						
						this.el.setProperty(this.propId, this.oldValue, force);
						//this.el.update();
						this.facade.setSelection([this.el]);
						this.facade.getCanvas().update();
						this.facade.updateSelection();
					}
				})
				// Instanciated the class
				var command = new commandClass();
				
				// Execute the command
				this.facade.executeCommands([command]);
			}
		},
		
		/**
		 * Returns the center position of a svg node
		 * @param {SVGElement} node
		 */
		getCenterPosition: function(svgNode){
			
			if (!svgNode) { return {x:0, y:0} }
			
			var center 		= {x: 0, y:0 };
			var trans,scale,transLocal,bounds;
			var useParent = false;
			try {
				
				if (('hidden' === svgNode.getAttributeNS(null, 'visibility')&&svgNode.childNodes.length>0)
					||svgNode.childNodes.length === 0) {
					useParent = true;
				}
				
				var el 		= useParent ? svgNode.parentNode : svgNode;
				
				trans 		= el.getTransformToElement(this.facade.getCanvas().rootNode.lastChild);
				scale 		= this.facade.getCanvas().rootNode.lastChild.getScreenCTM();
				transLocal 	= el.getTransformToElement(el.parentNode);
			} catch(e){
				return {x:0, y:0}
			}
			
			center.x 	= trans.e - transLocal.e;
			center.y 	= trans.f - transLocal.f;
			
			
			try {
				bounds = Object.clone(svgNode.getBBox());
				
				if (!useParent&&!(bounds.x<-1000)) {
					bounds.y += 1;
					if (Ext.isGecko){
						bounds.x -= 1;
					}
				} else {
					bounds = {x:parseInt(svgNode.getAttribute('x')), y:parseInt(svgNode.getAttribute('y')), width:0, height:0};
				}
			} catch(e){
				bounds = {x:parseInt(svgNode.getAttribute('x')), y:parseInt(svgNode.getAttribute('y')), width:0, height:0};
			}
			
			center.x += bounds.x;
			center.y += bounds.y;
				
			center.x += bounds.width/2;
			center.y += bounds.height/2;
							
			center.x *= scale.a;
			center.y *= scale.d;
			
			return center;			
		},
		
		/**
		 * Returns the nearest label from a shape
		 * @param {Event} evt
		 * @param {ORYX.Core.Shape} shape
		 */
		getNearestLabel: function(evt, shape){

			// Get the current language
			var currentLanguage = this.facade.getCanvas().getLanguage();
			
			// Get all properties which where at least one ref to view is set
			var props = shape.getStencil().properties().findAll(function(item) {
						return 	item.refToView()
								&& item.refToView().length > 0; });
			// from these, get all properties where write access are and the type is String
			props = props.findAll(function(item) {
						return 	!item.readonly()
								//&& (item.type() == ORYX.CONFIG.TYPE_STRING || item.type() === ORYX.CONFIG.TYPE_TEXT)
								&& item.type() == ORYX.CONFIG.TYPE_STRING
								&& (!item.directlyEditable || item.directlyEditable())
								&& (!item.language() || item.language() == currentLanguage); });
			
			// Get all ref ids
			var allRefToViews	= props.collect(function(prop){ return prop.refToView(); }).flatten().compact();
			// Get all labels from the shape with the ref ids
			var labels			= shape.getLabels().findAll(function(label){ return allRefToViews.any(function(toView){ return label.id.endsWith(toView) }); })
			
			// If there are no referenced labels --> return
			if( labels.length == 0 ){ return } 
			
			// Define the nearest label
			var nearestLabel 	= labels.length <= 1 ? labels[0] : null;	
			if( !nearestLabel ){
				
				nearestLabel = labels.find(function(label){ return !evt || label.node == evt.target || label.node == evt.target.parentNode })
				if( !nearestLabel ){
					
					var evtCoord 	= this.facade.eventCoordinates(evt);

					var trans		= this.facade.getCanvas().rootNode.lastChild.getScreenCTM();
					evtCoord.x		*= trans.a;
					evtCoord.y		*= trans.d;

					var diff = labels.collect(function(label){ 
								var center 	= this.getCenterPosition( label.node ); 
								var len 	= Math.sqrt( Math.pow(center.x - evtCoord.x, 2) + Math.pow(center.y - evtCoord.y, 2));
								return {diff: len, label: label} 
							}.bind(this));
					
					diff.sort(function(a,b){ return a.diff > b.diff ? 1 : (a.diff == b.diff ? -1 : -1)})
					
					nearestLabel = 	diff[0].label;

				}
			}
			
			return nearestLabel;
		},
		
		/**
		 * Returns the property for a given label
		 * @param {ORYX.Core.Shape} shape
		 * @param {ORYX.Core.Label} label
		 * @return {ORYX.Core.Property}
		 */
		getPropertyByLabel: function(shape, label){

			// Get the current language
			var currentLanguage = this.facade.getCanvas().getLanguage();
			
			// Get all properties
			var props = shape.getStencil().properties().findAll(function(item) {
						return 	item.refToView()
								&& item.refToView().length > 0
								&& (!item.language() || item.language() == currentLanguage); });
			return props.find(function(item) {
				return item.refToView().any(function(toView) {
					return label.id == shape.id + toView;
				});
			});
		}
		
	});

	
	/**
	 * Class for remote glossary entry search
	 * 
	 * @class
	 * @param attr
	 * @return
	 */
	var GlossarySearchFieldBox = function(attr){
		
		// Set paging parameter to offset
		Ext.PagingToolbar.prototype.paramNames.start = "offset";
		
		// Set attr
	    attr = attr || {};
	    
	    var params = {select:"title",originId:attr.parentDir, operator:'OR'};
	    if (attr.categories){
	    	params.category = attr.categories;
	    }
	    
		// Set the new store
		attr.store = new Ext.data.Store({
							baseParams: params,
				            proxy: new Ext.data.HttpProxy({
				            	useAjax	: true,
				            	method	: "GET", 
				            	headers	: {accept:"application/json"},
				                url		: '/p/glossary'
				            }),
				            reader: new Signavio.Helper.RecordReader()
				        });
		
		// Set the template
		/*attr.tpl = new Ext.XTemplate(
				            '<tpl for="."><div class="search-item">',
			            	'<tpl for="rep">',
				                '<h3>{title}</h3>',
				                '{[Signavio.Helper.TruncateByWidth(values.description, 500, "...")]}',
			                '</tpl>',
			            '</div></tpl>'
			        );*/
		attr.tpl = new Ext.XTemplate(
				            '<tpl for="."><div class="search-item">',
							'<img class="x-{[(values.rep.category||"").toLowerCase()]} x-image" src="/v5designer/libs/ext-2.0.2/resources/images/default/s.gif"/>',
			            	'<tpl for="rep">{[Signavio.Utils.escapeHTML(values.title||"")]}</tpl>',
				            '</div></tpl>'
			        	);
		// Overwrite some attributes
		attr.style = "";
		attr.cls = "x-glossary-support";
		
		// Define dom element
		this.defaultAutoCreate = {
		        tag: attr.renderAsTextArea ? "textarea" : "input",
		        autocomplete: "off",
		        style:"visibility:hidden;"
		    };
		
		// Set attr
		this.renderAsTextArea = attr.renderAsTextArea;
		
		// Call super
	    GlossarySearchFieldBox.superclass.constructor.call(this, attr);
	    
	};
	Ext.extend(GlossarySearchFieldBox, Ext.form.ComboBox, {
        lazyRender		: false,
        listClass 		: 'x-glossary-support',
        listWidth 		: 200,
        displayField	: 'href',
        typeAhead		: false,
        loadingText		: Signavio.I18N.Glossary_Support.renameLoading,
        emptyTextList	: '<div class="x-no-entry">'+Signavio.I18N.Glossary_Support.renameEmpty+'</div>',
        pageSize		: 10,
        lazyInit 		: false,
        queryDelay		: 100,
        minChars		: 2,
        preventScrollbars:true,
        queryParam		: "q",
        hideTrigger		: true,
        resizable 		: true,
        itemSelector	: 'div.search-item',
        onSelect		: function(record){ // override default onSelect to do redirect

        },
        
        initList: function(){
        	GlossarySearchFieldBox.superclass.initList.apply(this, arguments);
			
        	if (this.emptyTextList) {
        		this.view.emptyText = this.emptyTextList;
        	}
        	
        	if (this.view) {
        		this.view.onMouseOut = function(e){
	                if(this.lastItem){
	                	try {
	                		if(!e.within(this.lastItem, true)){
	                			Ext.fly(this.lastItem).removeClass(this.overClass);
	                			delete this.lastItem;
	                		}
	                	} catch(error){ }
	                }
	            }.bind(this.view);
        	}
			
			if (this.pageTb){
				// Remove all items
				var tb = this.pageTb;
				this.pageTb.items.each(function(item){
					if (!(item == tb.first||item == tb.prev||item == tb.next||item == tb.last)){
						item.hide();
					}
				})
				
				// Add text
				var te = tb.addText("");
				var index = 2;
				tb.tr.insertBefore(te.el.parentNode, tb.tr.childNodes[index]);
				tb.items.remove(te);
				tb.items.insert(index, te);
				tb.displayMsg = "{0}/{1}"
				tb.displayEl = Ext.fly(te.el).createChild({cls:'x-paging-info', style:{display:"inline",position:"relative",left:"0",top:"0"}}); // Text will be automatically updated through original class
				
				// Add spacer
				var sp = tb.addFill();
				tb.tr.insertBefore(sp.el.parentNode, tb.tr.childNodes[++index]);
				tb.items.remove(sp);
				tb.items.insert(index, sp);
				
				var count = this.pageSize, me = this;
				tb.updateInfo = function(){
			        if(this.displayEl){
			            var msg = this.store.getTotalCount() <= count ?
			                "" :
			                String.format(
			                    this.displayMsg,
			                    Math.ceil((this.cursor+1)/count), Math.ceil(this.store.getTotalCount()/count)
			                );
			           this.displayEl.update(msg);
					   if (!msg){
						   	me.assetHeight -= !this.hidden ? 23 : 0;
					   		this.hide();
					   } else {
						   	me.assetHeight += this.hidden ? 23 : 0;
					   		this.show();
					   }
        			}
				}
			}
        	
        	//this.pageSize = 10;
        },
        
        onRender: function(){
        	GlossarySearchFieldBox.superclass.onRender.apply(this, arguments);
    	    
            if(this.grow){
                this.textSizeEl = Ext.DomHelper.append(document.body, {
                    tag: "pre", cls: "x-form-grow-sizer"
                });
                if(this.preventScrollbars){
                    this.el.setStyle("overflow", "hidden");
                }
                this.el.setHeight(this.growMin);
            }    
        },
        
        onDestroy : function(){
            if(this.textSizeEl){
                Ext.removeNode(this.textSizeEl);
            }
            
            if (this.view&&this.view.lastItem) {
            	delete this.view.lastItem;
            }
    	    
            GlossarySearchFieldBox.superclass.onDestroy.call(this);
        },

        
        growMin : 60,
        growMax: 1000,
        growAppend : '&#160;',
        growPad : 0,

    	
        // private
        onKeyUp : function(e){
        	GlossarySearchFieldBox.superclass.onKeyUp.apply(this, arguments);
        	
        	// IF textarea AND the key code is an ENTER, DELETE, or REMOVE key
            if(this.renderAsTextArea && (e.getKey() == e.ENTER || e.getKey() ==  e.DELETE || e.getKey() == 8 || true)){    
            	// Update textarea size
    			this.autoSize();
            }
        },
        
        // private
        onBlur : function(evt, target){
        	
        	// Workaround for IE9:
        	// If click on the list, the blur event
        	// was raised, which now will be stopped.
        	if (Ext.isIE9 && target === this.el.dom){
        		Event.stop(evt.browserEvent);
        		return;
        	}
        	
            this.beforeBlur();
            if(!Ext.isOpera && this.focusClass){ // don't touch in Opera
                this.el.removeClass(this.focusClass);
            }
            this.hasFocus = false;
            if(this.validationEvent !== false && this.validateOnBlur && this.validationEvent != "blur"){
                this.validate();
            }
            var v = this.getValue();
            if(String(v) !== String(this.startValue)){
                this.fireEvent('change', this, v, this.startValue);
            }
            this.fireEvent("blur", this);
        },

        
        onBeforeLoad : function(){
            if(!this.hasFocus){
                return;
            }
            
            if (!this.innerList.child("div.loading-indicator")) {
            	if (this.store.getCount()>0) {
            		this.innerList.createChild({tag: 'div', cls: 'loading-indicator', html: this.loadingText});
            	} else {
            		this.innerList.update(this.loadingText ? '<div class="loading-indicator">'+this.loadingText+'</div>' : '');
            	}
            } 
            if (this.selectedIndex>=0){
            	this.lastSelectedRecord = this.store.getAt(this.selectedIndex);
            } else {
            	delete this.lastSelectedRecord;
            }
            
            this.restrictHeight();
        },

    	/**
    	 * @Overwrite
    	 */
        initQuery : function(){
        	if (this.list)
        		this.doQuery(this.getRawValue());
        },
		
	    getParams : function(q){
	        var p = {};
	        if(this.pageSize){
	            p.offset = 0;
	            p.limit = this.pageSize;
	        }
	        return p;
	    },
		
    	/**
    	 * @Overwrite
    	 */
        doQuery : function(q, forceAll){
        	if(!this.store) {
        		return;
        	}
            if(q === undefined || q === null){
                q = '';
            }
            var qe = {
                query: q,
                forceAll: forceAll,
                combo: this,
                cancel:false
            };
            if(this.fireEvent('beforequery', qe)===false || qe.cancel){
                return false;
            }
            q = qe.query;
            forceAll = qe.forceAll;
            var qq = (q||"").split(/\s+/).findAll(function(r){ return r.length >= this.minChars }.bind(this))
            if(forceAll === true || qq.length > 0){
            	qq = qq.join(" ");
                if(this.lastQuery !== qq){
                    this.lastQuery = qq;
                    if(this.mode == 'local'){
                        this.selectedIndex = -1;
                        if(forceAll){
                            this.store.clearFilter();
                        }else{
                            this.store.filter(this.displayField, q);
                        }
                        this.onLoad();
                    }else{
                        this.store.baseParams[this.queryParam] = qq;
                        this.store.load({
                            params: this.getParams(qq)
                        });
                        this.expand();
                    }
                }else{
                    this.selectedIndex = -1;
                    this.onLoad();
                }
            }
        },
        
    	/**
    	 * @Overwrite
    	 */
        onLoad : function(){
            if(!this.hasFocus){
                return;
            }
            if(this.store.getCount() > 0){
                this.expand();
                this.restrictHeight();
                if(this.lastQuery == this.allQuery){
                    if(this.editable){
                        this.el.dom.select();
                    }
                    /*if(!this.selectByValue(this.value, true)){
                        this.select(0, true);
                    }*/
                }else{
                	
                    //this.selectNext();
                    if(this.typeAhead && this.lastKey != Ext.EventObject.BACKSPACE && this.lastKey != Ext.EventObject.DELETE){
                        this.taTask.delay(this.typeAheadDelay);
                    }
                }
                
                var index = -1;
                if (this.lastSelectedRecord) {
                	index = this.store.find("href", this.lastSelectedRecord.get("href"));
                }
            	this.select(index, true);
            	
            }else{
                this.onEmptyResults();
            }
            //this.el.focus();
        },
        
        onEmptyResults : function(){
        	this.restrictHeight()
        },

        
    	/**
    	 * @Overwrite
    	 */
        initEvents : function(){
            Ext.form.ComboBox.superclass.initEvents.call(this);

            this.keyNav = new Ext.KeyNav(this.el, {
                "up" : function(e){
            		if (this.selectedIndex == 0) {
            			this.select(-1);
            		} else if (this.selectedIndex > 0) {
	                    this.inKeyMode = true;
	                    this.selectPrev();
            		}
                },

                "down" : function(e){
                	if (this.store.getCount() > 0) {
	                    if(!this.isExpanded()){
	                        this.onTriggerClick();
	                    }else {
	                        this.inKeyMode = true;
	                        this.selectNext();
	                    }
                	}
                },

                "enter" : function(e){
                	if (this.selectedIndex >= 0 && this.isExpanded()) {
	                    this.onViewClick();
	                    this.delayedCheck = true;
	    				this.unsetDelayCheck.defer(10, this);
                	}
                	
                	if (e.ctrlKey) {
                		this.onBlur();
                	}
                },

                "esc" : function(e){
                	if (this.isExpanded()) {
                		this.collapse();
                	} else {
                		this.onBlur();
                	}
                },

                "tab" : function(e){
                    this.onViewClick(false);
                    return true;
                },

                scope : this,

                doRelay : function(foo, bar, hname){
                    if (hname == 'down' && this.scope.store.getCount() > 0){
                    	return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    } else if (hname == 'down') {
                    	return true;
                    }
                    if (hname == 'up' && this.scope.selectedIndex < 0) {
                    	return true;
                    }
                    if (hname == 'enter' && this.scope.isExpanded() && this.scope.selectedIndex >= 0) {
                        return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    }
                    if (hname == 'esc') {
                        return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    }
                    if (hname != 'enter' && this.scope.isExpanded()) {
                        return Ext.KeyNav.prototype.doRelay.apply(this, arguments);
                    }
                    return true;
                },

                forceKeyDown : true
            });
            this.queryDelay = Math.max(this.queryDelay || 10,
                    this.mode == 'local' ? 10 : 250);
            this.dqTask = new Ext.util.DelayedTask(this.initQuery, this);
            if(this.typeAhead){
                this.taTask = new Ext.util.DelayedTask(this.onTypeAhead, this);
            }
            if(this.editable !== false){
                this.el.on("keyup", this.onKeyUp, this);
            }
            if(this.forceSelection){
                this.on('blur', this.doForce, this);
            }
            
            // FIXED: Fixed the problem, that the click event was too late
            // processed, so the onChange and onBlur was called before onSelect
            // was called (mainly in Chrome)
            this.list.dom.addEventListener("mousedown", function(e){
            	Event.stop(e)
            }, false);

            this.footer.dom.addEventListener("mousedown", function(e){
            	Event.stop(e)
            }, false);
        },
        
        /**
         * Automatically grows the field to accomodate the height of the text up to the maximum field height allowed.
         * This only takes effect if grow = true, and fires the autosize event if the height changes.
         */
        autoSize : function(){
            if(!this.grow || !this.textSizeEl){
                return;
            }
            var el = this.el;
            var v = el.dom.value;
            var ts = this.textSizeEl;
            if (!ts||!el){ return }
            ts.innerHTML = '';
            ts.appendChild(document.createTextNode(v));
            v = ts.innerHTML;

            try {
            	Ext.fly(ts).setWidth(this.el.getWidth());
            } catch(e) { }
            
            if(v.length < 1){
                v = "&#160;&#160;";
            }else{
                if(Ext.isIE){
                    //v = v.replace(/\n/g, '<p>&#160;</p>');
                }
                v += this.growAppend;
            }
            ts.innerHTML = v;
            var h = Math.min(this.growMax, Math.max(ts.offsetHeight, this.growMin)+this.growPad);
            if(h != this.lastHeight){
                this.lastHeight = h;
                this.el.setHeight(h);
                this.fireEvent("autosize", this, h);
                if (this.list) {
                	this.list.alignTo(this.el, this.listAlign);
                }
            }
        }


    }); 
}();

/**
 * Copyright (c) 2009
 * Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

/**
 * Enables exporting and importing current model in JSON.
 */
ORYX.Plugins.JSONSupport = ORYX.Plugins.AbstractPlugin.extend({

    construct: function(){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
        
        this.facade.offer({
            'name': ORYX.I18N.JSONSupport.exp.name,
            'functionality': this.exportJSON.bind(this),
            'group': ORYX.I18N.JSONSupport.exp.group,
            dropDownGroupIcon: ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/page_white_get.png",
			'icon': ORYX.PATH + "images/page_white_javascript.png",
            'description': ORYX.I18N.JSONSupport.exp.desc,
            'index': 0,
            'minShape': 0,
            'maxShape': 0
        });
        
        this.facade.offer({
            'name': ORYX.I18N.JSONSupport.imp.name,
            'functionality': this.showImportDialog.bind(this),
            'group': ORYX.I18N.JSONSupport.imp.group,
            dropDownGroupIcon: ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/page_white_put.png",
			'icon': ORYX.PATH + "images/page_white_javascript.png",
            'description': ORYX.I18N.JSONSupport.imp.desc,
            'index': 1,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    exportJSON: function(){
        var json = this.facade.getSerializedJSON();
        this.openDownloadWindow(window.document.title + ".json", json);
    },
    
    /**
     * Opens a upload dialog.
     *
     */
    showImportDialog: function(successCallback){
    
        var form = new Ext.form.FormPanel({
            baseCls: 'x-plain',
            labelWidth: 50,
            defaultType: 'textfield',
            items: [{
                text: ORYX.I18N.JSONSupport.imp.selectFile,
                style: 'font-size:12px;margin-bottom:10px;display:block;',
                anchor: '100%',
                xtype: 'label'
            }, {
                fieldLabel: ORYX.I18N.JSONSupport.imp.file,
                name: 'subject',
                inputType: 'file',
                style: 'margin-bottom:10px;display:block;',
                itemCls: 'ext_specific_window_overflow'
            }, {
                xtype: 'textarea',
                hideLabel: true,
                name: 'msg',
                anchor: '100% -63'
            }]
        });
        
        // Create the panel
        var dialog = new Ext.Window({
            autoCreate: true,
            layout: 'fit',
            plain: true,
            bodyStyle: 'padding:5px;',
            title: ORYX.I18N.JSONSupport.imp.name,
            height: 350,
            width: 500,
            modal: true,
            fixedcenter: true,
            shadow: true,
            proxyDrag: true,
            resizable: true,
            items: [form],
            buttons: [{
                text: ORYX.I18N.JSONSupport.imp.btnImp,
                handler: function(){
                
                    var loadMask = new Ext.LoadMask(Ext.getBody(), {
                        msg: ORYX.I18N.JSONSupport.imp.progress
                    });
                    loadMask.show();
                    
                    window.setTimeout(function(){
                        var json = form.items.items[2].getValue();
                        try {
                            this.facade.importJSON(json, true);
                            dialog.close();
                        } 
                        catch (error) {
                            Ext.Msg.alert(ORYX.I18N.JSONSupport.imp.syntaxError, error.message);
                        }
                        finally {
                            loadMask.hide();
                        }
                    }.bind(this), 100);
                    
                }.bind(this)
            }, {
                text: ORYX.I18N.JSONSupport.imp.btnClose,
                handler: function(){
                    dialog.close();
                }.bind(this)
            }]
        });
        
        // Show the panel
        dialog.show();
        
        // Adds the change event handler to 
        form.items.items[1].getEl().dom.addEventListener('change', function(evt){
            var text = evt.target.files[0].getAsText('UTF-8');
            form.items.items[2].setValue(text);
        }, true)
        
    }
    
});

/**
 * Copyright (c) 2009, Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = {};


ORYX.Plugins.FeedbackPlugin = ORYX.Plugins.AbstractPlugin.extend({
    construct: function(){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
        
        this.facade.offer({
            'name': ORYX.I18N.Feedback.name,
            'functionality': this.showWindow.bind(this),
            'group': "Help",
            'description': ORYX.I18N.Feedback.desc,
            'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/email.png",
            'index': 0,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    showWindow: function(){
	
		var mode = this.facade.getModelMetaData().mode;
		var model = this.facade.getSerializedJSON();
		var url = ORYX.CONFIG.SERVER_HANDLER_ROOT + "/support";
		var supportAdress = this.facade.getModelMetaData().supportMailAddress;
		
		new Ext.ux.view.FeedbackWindow(mode, url, ORYX.CONFIG.EXPLORER_PATH, model,supportAdress);
	}
});

/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/


/**
 * This plugin offer the functionality of undo/redo
 * Therewith the command pattern is used.
 * 
 * A Plugin which want that the changes could get undo/redo has 
 * to implement a command-class (which implements the method .execute(), .rollback()).
 * Those instance of class must be execute thru the facade.executeCommands(). If so,
 * those command get stored here in the undo/redo stack and can get reset/restore.
 *
 **/

if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Undo = Clazz.extend({
	
	// Defines the facade
    facade		: undefined,
    
	// Defines the undo/redo Stack
	undoStack	: [],
	redoStack	: [],
	
	// Constructor 
    construct: function(facade){
    
        this.facade = facade;     
		
		// Offers the functionality of undo                
        this.facade.offer({
			name			: ORYX.I18N.Undo.undo,
			description		: ORYX.I18N.Undo.undoDesc,
			icon			: ORYX.PATH + "images/arrow_undo.png",
			keyCodes: [{
					metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
					keyCode: 90,
					keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
				}
		 	],
			functionality	: this.doUndo.bind(this),
			group			: ORYX.I18N.Undo.group,
			isEnabled		: function(){ return this.undoStack.length > 0 }.bind(this),
			index			: 0
		}); 

		// Offers the functionality of redo
        this.facade.offer({
			name			: ORYX.I18N.Undo.redo,
			description		: ORYX.I18N.Undo.redoDesc,
			icon			: ORYX.PATH + "images/arrow_redo.png",
			keyCodes: [{
					metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
					keyCode: 89,
					keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
				}
		 	],
			functionality	: this.doRedo.bind(this),
			group			: ORYX.I18N.Undo.group,
			isEnabled		: function(){ return this.redoStack.length > 0 }.bind(this),
			index			: 1
		}); 
		
		// Register on event for executing commands --> store all commands in a stack		 
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_EXECUTE_COMMANDS, this.handleExecuteCommands.bind(this) );
    	
	},
	
	/**
	 * Stores all executed commands in a stack
	 * 
	 * @param {Object} evt
	 */
	handleExecuteCommands: function( evt ){
		
		// If the event has commands
		if( !evt.commands ){ return }
					
		// Add the commands to a undo stack ...
		this.undoStack.push( evt.commands );
		
		// ...and delete the redo stack
		this.redoStack = [];
		
		
		// --> this has been moved to #executeCommandas method in main.js
		// Update
		//this.facade.getCanvas().update();
		//this.facade.updateSelection();
		
	},
	
	/**
	 * Does the undo
	 * 
	 */
	doUndo: function(){
		
		// Get the last commands
		var lastCommands = this.undoStack.pop();
		
		if( lastCommands ){
			// Add the commands to the redo stack
			this.redoStack.push( lastCommands );
			
			this.facade.raiseEvent({
				type 	: ORYX.CONFIG.EVENT_UNDO_BEFORE_ROLLBACK, 
				forceExecution : true,
				commands: lastCommands
			});
			
			// Rollback every command
			for(var i=lastCommands.length-1; i>=0; --i){
				lastCommands[i].rollback();
			}
					
			// Update and refresh the canvas
			//this.facade.getCanvas().update();
			//this.facade.updateSelection();
			this.facade.raiseEvent({
				type 	: ORYX.CONFIG.EVENT_UNDO_ROLLBACK, 
				commands: lastCommands
			});
			
			// Update
			this.facade.getCanvas().update();
			this.facade.updateSelection();
		}
	},
	
	/**
	 * Does the redo
	 * 
	 */
	doRedo: function(){
		
		// Get the last commands from the redo stack
		var lastCommands = this.redoStack.pop();
		
		if( lastCommands ){
			// Add this commands to the undo stack
			this.undoStack.push( lastCommands );
			
			this.facade.raiseEvent({
				type 	: ORYX.CONFIG.EVENT_UNDO_BEFORE_EXECUTE, 
				forceExecution : true,
				commands: lastCommands
			});
			
			// Execute those commands
			lastCommands.each(function(command){
				command.execute();
			}.bind(this));
			
			// Update and refresh the canvas		
			//this.facade.getCanvas().update();
			//this.facade.updateSelection();
			this.facade.raiseEvent({
				type 	: ORYX.CONFIG.EVENT_UNDO_EXECUTE, 
				commands: lastCommands
			});
			
			// Update
			this.facade.getCanvas().update();
			this.facade.updateSelection();
		}
	}
	
});
/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * Supports EPCs by offering a syntax check and export and import ability..
 * 
 * 
 */
ORYX.Plugins.ProcessLink = Clazz.extend({

	facade: undefined,

	/**
	 * Offers the plugin functionality:
	 * 
	 */
	construct: function(facade) {

		this.facade = facade;
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.propertyChanged.bind(this) );
		
	},


	/**
	 * 
	 * @param {Object} option
	 */
	propertyChanged: function( option, node){

		if( option.name !== "oryx-refuri" || !node instanceof ORYX.Core.Node ){ return }
		
		
		if( option.value && option.value.length > 0 && option.value != "undefined"){
			
			this.show( node, option.value );
					
		} else {

			this.hide( node );

		}				

	},
	
	/**
	 * Shows the Link for a particular shape with a specific url
	 * 
	 * @param {Object} shape
	 * @param {Object} url
	 */
	show: function( shape, url){

		
		// Generate the svg-representation of a link
		var linkContainer  = ORYX.Editor.graft("http://www.w3.org/2000/svg", null ,		
				['g',{},	
					[ 'a',
						{'target': '_blank'},
						['path', { "style": "fill:white;stroke:grey;stroke-linecap:round;stroke-linejoin:round;stroke-width:0.72", "d": "M0 1.44 L0 15.05 L11.91 15.05 L11.91 5.98 L7.37 1.44 L0 1.44 Z"}],
						['path', { "style": "stroke:grey;stroke-linecap:round;stroke-linejoin:round;stroke-width:0.72;fill:#EEEEEE;", "transform": "translate(7.5, -8.5)", "d": "M0 10.51 L0 15.05 L4.54 15.05"}],
						['path', { "style": "fill:silver;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-width:0.72", "transform": "translate(-3, -1)", "d": "M0 8.81 L0 13.06 L5.95 13.06 L5.95 15.05 A50.2313 50.2313 -175.57 0 0 10.77 11.08 A49.9128 49.9128 -1.28 0 0 5.95 6.54 L5.95 8.81 L0 8.81 Z"}]
					]
				]);

		var link = linkContainer.childNodes[0];
	/*
	 * 
	 * 					[ 'a',
						{'target': '_blank'},
						['path', { "style": "fill:none;stroke-width:0.5px; stroke:#000000", "d": "M7,4 l0,2"}],
						['path', { "style": "fill:none;stroke-width:0.5px; stroke:#000000", "d": "M4,8 l-2,0 l0,6"}],
						['path', { "style": "fill:none;stroke-width:0.5px; stroke:#000000", "d": "M10,8 l2,0 l0,6"}],
						['rect', { "style": "fill:#96ff96;stroke:#000000;stroke-width:1", "width": 6, "height": 4, "x": 4, "y": 0}],
						['rect', { "style": "fill:#ffafff;stroke:#000000;stroke-width:1", "width": 6, "height": 4, "x": 4, "y": 6}],
						['rect', { "style": "fill:#96ff96;stroke:#000000;stroke-width:1", "width": 6, "height": 4, "x": 0, "y": 12}],
						['rect', { "style": "fill:#96ff96;stroke:#000000;stroke-width:1", "width": 6, "height": 4, "x": 8, "y": 12}],
						['rect', { "style": "fill:none;stroke:none;pointer-events:all", "width": 14, "height": 16, "x": 0, "y": 0}]
					]);
	 */
		
		// Set the link with the special namespace
		link.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", url);
		
		
		// Shows the link in the overlay					
		this.facade.raiseEvent({
					type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
					id: 			"arissupport.urlref_" + shape.id,
					shapes: 		[shape],
					node:			linkContainer,
					nodePosition:	"SE"
				});	
							
	},	

	/**
	 * Hides the Link for a particular shape
	 * 
	 * @param {Object} shape
	 */
	hide: function( shape ){

		this.facade.raiseEvent({
					type: 			ORYX.CONFIG.EVENT_OVERLAY_HIDE,
					id: 			"arissupport.urlref_" + shape.id
				});	
							
	}		
});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

Array.prototype.insertFrom = function(from, to){
	to 			= Math.max(0, to);
	from 		= Math.min( Math.max(0, from), this.length-1 );
		
	var el 		= this[from];
	var old 	= this.without(el);
	var newA 	= old.slice(0, to);
	newA.push(el);
	if(old.length > to ){
		newA 	= newA.concat(old.slice(to))
	};
	return newA;
}

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.Arrangement = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,

	construct: function(facade) {
		this.facade = facade;

		// Z-Ordering
		/** Hide for SIGNAVIO 
		
		this.facade.offer({
			'name':ORYX.I18N.Arrangement.btf,
			'functionality': this.setZLevel.bind(this, this.setToTop),
			'group': ORYX.I18N.Arrangement.groupZ,
			'icon': ORYX.PATH + "images/shape_move_front.png",
			'description': ORYX.I18N.Arrangement.btfDesc,
			'index': 1,
			'minShape': 1});
			
		this.facade.offer({
			'name':ORYX.I18N.Arrangement.btb,
			'functionality': this.setZLevel.bind(this, this.setToBack),
			'group': ORYX.I18N.Arrangement.groupZ,
			'icon': ORYX.PATH + "images/shape_move_back.png",
			'description': ORYX.I18N.Arrangement.btbDesc,
			'index': 2,
			'minShape': 1});

		this.facade.offer({
			'name':ORYX.I18N.Arrangement.bf,
			'functionality': this.setZLevel.bind(this, this.setForward),
			'group': ORYX.I18N.Arrangement.groupZ,
			'icon': ORYX.PATH + "images/shape_move_forwards.png",
			'description': ORYX.I18N.Arrangement.bfDesc,
			'index': 3,
			'minShape': 1});

		this.facade.offer({
			'name':ORYX.I18N.Arrangement.bb,
			'functionality': this.setZLevel.bind(this, this.setBackward),
			'group': ORYX.I18N.Arrangement.groupZ,
			'icon': ORYX.PATH + "images/shape_move_backwards.png",
			'description': ORYX.I18N.Arrangement.bbDesc,
			'index': 4,
			'minShape': 1});

		// Aligment
		this.facade.offer({
			'name':ORYX.I18N.Arrangement.ab,
			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_BOTTOM]),
			'group': ORYX.I18N.Arrangement.groupA,
			'icon': ORYX.PATH + "images/shape_align_bottom.png",
			'description': ORYX.I18N.Arrangement.abDesc,
			'index': 1,
			'minShape': 2});



		this.facade.offer({
			'name':ORYX.I18N.Arrangement.at,
			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_TOP]),
			'group': ORYX.I18N.Arrangement.groupA,
			'icon': ORYX.PATH + "images/shape_align_top.png",
			'description': ORYX.I18N.Arrangement.atDesc,
			'index': 3,
			'minShape': 2});

		this.facade.offer({
			'name':ORYX.I18N.Arrangement.al,
			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_LEFT]),
			'group': ORYX.I18N.Arrangement.groupA,
			'icon': ORYX.PATH + "images/shape_align_left.png",
			'description': ORYX.I18N.Arrangement.alDesc,
			'index': 4,
			'minShape': 2});

		this.facade.offer({
			'name':ORYX.I18N.Arrangement.ar,
			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_RIGHT]),
			'group': ORYX.I18N.Arrangement.groupA,
			'icon': ORYX.PATH + "images/shape_align_right.png",
			'description': ORYX.I18N.Arrangement.arDesc,
			'index': 6,
			'minShape': 2});

		**/
		
		this.facade.offer({
			'name':ORYX.I18N.Arrangement.am,
			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_MIDDLE]),
			'group': ORYX.I18N.Arrangement.groupA,
			'icon': ORYX.PATH + "images/shape_align_middle.png",
			'description': ORYX.I18N.Arrangement.amDesc,
			'index': 1,
			'minShape': 2});
			
		this.facade.offer({
			'name':ORYX.I18N.Arrangement.ac,
			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_CENTER]),
			'group': ORYX.I18N.Arrangement.groupA,
			'icon': ORYX.PATH + "images/shape_align_center.png",
			'description': ORYX.I18N.Arrangement.acDesc,
			'index': 2,
			'minShape': 2});

			
		this.facade.offer({
			'name':ORYX.I18N.Arrangement.as,
			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_SIZE]),
			'group': ORYX.I18N.Arrangement.groupA,
			'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/arrow_inout.png",
			'description': ORYX.I18N.Arrangement.asDesc,
			'index': 3,
			'minShape': 2});
			


		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ARRANGEMENT_TOP, 	this.setZLevel.bind(this, this.setToTop)	);
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ARRANGEMENT_BACK, 	this.setZLevel.bind(this, this.setToBack)	);
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ARRANGEMENT_FORWARD, 	this.setZLevel.bind(this, this.setForward)	);
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ARRANGEMENT_BACKWARD, 	this.setZLevel.bind(this, this.setBackward)	);						

	
	},
	
	onSelectionChanged: function(elemnt){
		var selection = this.facade.getSelection();
		if (selection.length === 1 && selection[0] instanceof ORYX.Core.Edge) {
			this.setToTop(selection);
		}
	},
	
	setZLevel:function(callback, event){
			
		//Command-Pattern for dragging one docker
		var zLevelCommand = ORYX.Core.Command.extend({
			construct: function(callback, elements, facade){
				this.callback 	= callback;
				this.elements 	= elements;
				// For redo, the previous elements get stored
				this.elAndIndex	= elements.map(function(el){ return {el:el, previous:el.parent.children[el.parent.children.indexOf(el)-1]} })
				this.facade		= facade;
			},			
			execute: function(){
				
				// Call the defined z-order callback with the elements
				this.callback( this.elements )			
				this.facade.setSelection( this.elements )
			},
			rollback: function(){
				
				// Sort all elements on the index of there containment
				var sortedEl =	this.elAndIndex.sortBy( function( el ) {
									var value 	= el.el;
									var t 		= $A(value.node.parentNode.childNodes);
									return t.indexOf(value.node);
								}); 
				
				// Every element get setted back bevor the old previous element
				for(var i=0; i<sortedEl.length; i++){
					var el			= sortedEl[i].el;
					var p 			= el.parent;			
					var oldIndex 	= p.children.indexOf(el);
					var newIndex 	= p.children.indexOf(sortedEl[i].previous);
					newIndex		= newIndex || 0
					p.children 	= p.children.insertFrom(oldIndex, newIndex)			
					el.node.parentNode.insertBefore(el.node, el.node.parentNode.childNodes[newIndex+1]);
				}

				// Reset the selection
				this.facade.setSelection( this.elements )
			}
		});
	
		// Instanziate the dockCommand
		var command = new zLevelCommand(callback, this.facade.getSelection(), this.facade);
		if( event.excludeCommand ){
			command.execute();
		} else {
			this.facade.executeCommands( [command] );	
		}
		
	},

	setToTop: function(elements) {

		// Sortieren des Arrays nach dem Index des SVGKnotens im Bezug auf dem Elternknoten.
		var tmpElem =  elements.sortBy( function(value, index) {
			if (!value.node || !value.node.parentNode){ return 0; }
			var t = $A(value.node.parentNode.childNodes);
			return t.indexOf(value.node);
		});
		// Sortiertes Array wird nach oben verschoben.
		tmpElem.each( function(value) {
			if (!value.node || !value.node.parentNode){ return; }
			var p = value.parent;
			if (p.children.last() === value){
				return;
			}
			p.children = p.children.without( value )
			p.children.push(value);
			value.node.parentNode.appendChild(value.node);			
		});
	},

	setToBack: function(elements) {
		// Sortieren des Arrays nach dem Index des SVGKnotens im Bezug auf dem Elternknoten.
		var tmpElem =  elements.sortBy( function(value, index) {
			var t = $A(value.node.parentNode.childNodes);
			return t.indexOf(value.node);
		});

		tmpElem = tmpElem.reverse();

		// Sortiertes Array wird nach unten verschoben.
		tmpElem.each( function(value) {
			var p = value.parent
			p.children = p.children.without( value )
			p.children.unshift( value );
			value.node.parentNode.insertBefore(value.node, value.node.parentNode.firstChild);
		});
		
		
	},

	setBackward: function(elements) {
		// Sortieren des Arrays nach dem Index des SVGKnotens im Bezug auf dem Elternknoten.
		var tmpElem =  elements.sortBy( function(value, index) {
			var t = $A(value.node.parentNode.childNodes);
			return t.indexOf(value.node);
		});

		// Reverse the elements
		tmpElem = tmpElem.reverse();
		
		// Delete all Nodes who are the next Node in the nodes-Array
		var compactElem = tmpElem.findAll(function(el) {return !tmpElem.some(function(checkedEl){ return checkedEl.node == el.node.previousSibling})});
		
		// Sortiertes Array wird nach eine Ebene nach oben verschoben.
		compactElem.each( function(el) {
			if(el.node.previousSibling === null) { return; }
			var p 		= el.parent;			
			var index 	= p.children.indexOf(el);
			p.children 	= p.children.insertFrom(index, index-1)			
			el.node.parentNode.insertBefore(el.node, el.node.previousSibling);
		});
		
		
	},

	setForward: function(elements) {
		// Sortieren des Arrays nach dem Index des SVGKnotens im Bezug auf dem Elternknoten.
		var tmpElem =  elements.sortBy( function(value, index) {
			var t = $A(value.node.parentNode.childNodes);
			return t.indexOf(value.node);
		});


		// Delete all Nodes who are the next Node in the nodes-Array
		var compactElem = tmpElem.findAll(function(el) {return !tmpElem.some(function(checkedEl){ return checkedEl.node == el.node.nextSibling})});
	
			
		// Sortiertes Array wird eine Ebene nach unten verschoben.
		compactElem.each( function(el) {
			var nextNode = el.node.nextSibling		
			if(nextNode === null) { return; }
			var index 	= el.parent.children.indexOf(el);
			var p 		= el.parent;
			p.children 	= p.children.insertFrom(index, index+1)			
			el.node.parentNode.insertBefore(nextNode, el.node);
		});
	},


	alignShapes: function(way) {

		var elements = this.facade.getSelection();

		// Set the elements to all Top-Level elements
		elements = this.facade.getCanvas().getShapesWithSharedParent(elements);
		// Get only nodes
		elements = elements.findAll(function(value) {
			return (value instanceof ORYX.Core.Node)
		});
		// Delete all attached intermediate events from the array
		elements = elements.findAll(function(value) {
			var d = value.getIncomingShapes()
			return d.length == 0 || !elements.include(d[0])
		});
		if(elements.length < 2) { return; }

		// get bounds of all shapes.
		var bounds = elements[0].absoluteBounds().clone();
		elements.each(function(shape) {
		        bounds.include(shape.absoluteBounds().clone());
		});
		
		// get biggest width and heigth
		var maxWidth = 0;
		var maxHeight = 0;
		elements.each(function(shape){
			maxWidth = Math.max(shape.bounds.width(), maxWidth);
			maxHeight = Math.max(shape.bounds.height(), maxHeight);
		});

		var commandClass = ORYX.Core.Command.extend({
			construct: function(elements, bounds, maxHeight, maxWidth, way, plugin){
				this.elements = elements;
				this.bounds = bounds;
				this.maxHeight = maxHeight;
				this.maxWidth = maxWidth;
				this.way = way;
				this.facade = plugin.facade;
				this.plugin = plugin;
				this.orgPos = [];
			},
			setBounds: function(shape, maxSize) {
				if(!maxSize)
					maxSize = {width: ORYX.CONFIG.MAXIMUM_SIZE, height: ORYX.CONFIG.MAXIMUM_SIZE};

				if(!shape.bounds) { throw "Bounds not definined." }
				
				var newBounds = {
                    a: {x: shape.bounds.upperLeft().x - (this.maxWidth - shape.bounds.width())/2,
                        y: shape.bounds.upperLeft().y - (this.maxHeight - shape.bounds.height())/2},
                    b: {x: shape.bounds.lowerRight().x + (this.maxWidth - shape.bounds.width())/2,
                        y: shape.bounds.lowerRight().y + (this.maxHeight - shape.bounds.height())/2}
	            }
				
				/* If the new width of shape exceeds the maximum width, set width value to maximum. */
				if(this.maxWidth > maxSize.width) {
					newBounds.a.x = shape.bounds.upperLeft().x - 
									(maxSize.width - shape.bounds.width())/2;
					
					newBounds.b.x =	shape.bounds.lowerRight().x + (maxSize.width - shape.bounds.width())/2
				}
				
				/* If the new height of shape exceeds the maximum height, set height value to maximum. */
				if(this.maxHeight > maxSize.height) {
					newBounds.a.y = shape.bounds.upperLeft().y - 
									(maxSize.height - shape.bounds.height())/2;
					
					newBounds.b.y =	shape.bounds.lowerRight().y + (maxSize.height - shape.bounds.height())/2
				}
				
				/* set bounds of shape */
				shape.bounds.set(newBounds);
				
			},			
			execute: function(){
				// align each shape according to the way that was specified.
				this.elements.each(function(shape, index) {
					this.orgPos[index] = shape.bounds.upperLeft();
					
					var relBounds = this.bounds.clone();
					var newCoordinates;
					if (shape.parent && !(shape.parent instanceof ORYX.Core.Canvas) ) {
						var upL = shape.parent.absoluteBounds().upperLeft();
						relBounds.moveBy(-upL.x, -upL.y);
					}
					
					switch (this.way) {
						// align the shapes in the requested way.
						case ORYX.CONFIG.EDITOR_ALIGN_BOTTOM:
			                newCoordinates = {
								x: shape.bounds.upperLeft().x,
								y: relBounds.b.y - shape.bounds.height()
							}; break;
		
				        case ORYX.CONFIG.EDITOR_ALIGN_MIDDLE:
			                newCoordinates = {
								x: shape.bounds.upperLeft().x,
								y: (relBounds.a.y + relBounds.b.y - shape.bounds.height()) / 2
							}; break;
		
				        case ORYX.CONFIG.EDITOR_ALIGN_TOP:
			                newCoordinates = {
								x: shape.bounds.upperLeft().x,
								y: relBounds.a.y
							}; break;
		
				        case ORYX.CONFIG.EDITOR_ALIGN_LEFT:
			                newCoordinates = {
								x: relBounds.a.x,
								y: shape.bounds.upperLeft().y
							}; break;
		
				        case ORYX.CONFIG.EDITOR_ALIGN_CENTER:
			                newCoordinates = {
								x: (relBounds.a.x + relBounds.b.x - shape.bounds.width()) / 2,
								y: shape.bounds.upperLeft().y
							}; break;
		
				        case ORYX.CONFIG.EDITOR_ALIGN_RIGHT:
			                newCoordinates = {
								x: relBounds.b.x - shape.bounds.width(),
								y: shape.bounds.upperLeft().y
							}; break;
							
						case ORYX.CONFIG.EDITOR_ALIGN_SIZE:
							if(shape.isResizable) {
								this.orgPos[index] = {a: shape.bounds.upperLeft(), b: shape.bounds.lowerRight()};
								this.setBounds(shape, shape.maximumSize);
							}
							break;
					}
					
					if (newCoordinates){
						var offset =  {
							x: shape.bounds.upperLeft().x - newCoordinates.x,
							y: shape.bounds.upperLeft().y - newCoordinates.y
						}
						// Set the new position
						shape.bounds.moveTo(newCoordinates);
						this.plugin.layoutEdges(shape, shape.getAllDockedShapes(),offset);
						//shape.update()
					}			
				}.bind(this));
		
				//this.facade.getCanvas().update();
				//this.facade.updateSelection();
			},
			rollback: function(){
				this.elements.each(function(shape, index) {
					if (this.way == ORYX.CONFIG.EDITOR_ALIGN_SIZE) {
						if(shape.isResizable) {shape.bounds.set(this.orgPos[index]);}
					} else {shape.bounds.moveTo(this.orgPos[index]);}
				}.bind(this));
				
				//this.facade.getCanvas().update();
				//this.facade.updateSelection();
			}
		})
		
		var command = new commandClass(elements, bounds, maxHeight, maxWidth, parseInt(way), this);
		
		this.facade.executeCommands([command]);	
	}
});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Save = Clazz.extend({
	
    facade: undefined,
	
	processURI: undefined,
	
	changeSymbol : "*",
	
    construct: function(facade){
		this.facade = facade;
		
		this.facade.offer({
			'name': ORYX.I18N.Save.save,
			'functionality': this.save.bind(this,false),
			'group': ORYX.I18N.Save.group,
			'icon': ORYX.PATH + "images/disk.png",
			'description': ORYX.I18N.Save.saveDesc,
			'index': 1,
			'minShape': 0,
			'maxShape': 0,
			keyCodes: [{
			 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
					keyCode: 83, // s-Keycode
					keyAction: ORYX.CONFIG.KEY_ACTION_UP 
				}
			 ]
		});
		
		document.addEventListener("keydown", function(e){
			if (e.ctrlKey&&e.keyCode === 83){
				Event.stop(e);
			}
		}, false)
		
		
		this.facade.offer({
			'name': ORYX.I18N.Save.saveAs,
			'functionality': this.save.bind(this,true),
			'group': ORYX.I18N.Save.group,
			'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/save_as.png",
			'description': ORYX.I18N.Save.saveAsDesc,
			'index': 2,
			'minShape': 0,
			'maxShape': 0
		});	
		
		window.onbeforeunload = this.onUnLoad.bind(this)
		
		this.changeDifference = 0;
		
		// Register on event for executing commands --> store all commands in a stack		 
		// --> Execute
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_EXECUTE, function(){ 
			this.changeDifference++; 
			this.updateTitle(); 
		}.bind(this) );
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_EXECUTE_COMMANDS, function(){ 
			this.changeDifference++; 
			this.updateTitle(); 
		}.bind(this) );
		// --> Rollback
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_ROLLBACK, function(){ 
			this.changeDifference--; 
			this.updateTitle(); 
		}.bind(this) );
		
		// --> Editor Loaded, to update the title of imported diagrams
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.updateTitle.bind(this) );
		
		//TODO very critical for load time performance!!!
		//this.serializedDOM = DataManager.__persistDOM(this.facade);
	},
	
	updateTitle: function(){
		
		var value = window.document.title || document.getElementsByTagName("title")[0].childNodes[0].nodeValue;
		
		if (this.changeDifference === 0 && value.startsWith(this.changeSymbol)){
			window.document.title = value.slice(1);
		} else if ((this.isNewNonEmptyModel() || this.changeDifference !== 0) && !value.startsWith(this.changeSymbol)){
			window.document.title = this.changeSymbol + "" + value;
		}
	},
	
	/**
     *	Returns true if the model has child elements and is newly created or
     *	imported.
     */	
	isNewNonEmptyModel: function() {
		return this.facade.getModelMetaData()['new'] && this.facade.getModelMetaData().model.childShapes;
	},
	
	onUnLoad: function(){
		if(this.changeDifference !== 0 || this.isNewNonEmptyModel()) {
			return ORYX.I18N.Save.unsavedData;
		}
	},
		
	//保存逻辑新增方法  shanglihui 20111125
	saveSynchronously_smartdot: function(forceNew, modelInfo){
		var reqURI= "/v5designer/edit_smartdot.html?model=default&data";
		this.saving = false;

		var svgClone 	= this.facade.getCanvas().getSVGRepresentation(true);
        var svgDOM 		= DataManager.serialize(svgClone);
		this.serializedDOM = Ext.encode(this.facade.getJSON());
		  
		var params = { data: this.serializedDOM, svg: svgDOM, title: 'default', summary: '', type: "http://b3mn.org/stencilset/smartdot#" };
		var url = "/v5designer/save?new=/v5designer/index.html";
		// Send the request to the server.
		new Ajax.Request(url, {
                method: 'POST',
                asynchronous: false,
                parameters: params,
				onSuccess: (function(transport) {				
					var loc = transport.getResponseHeader("location");
					if (loc) {
						this.processURI = loc;
					}
					else {
						this.processURI = url;
					}
	
					//raise saved event
					this.facade.raiseEvent({
						type:ORYX.CONFIG.EVENT_MODEL_SAVED
					});
					//show saved status
					this.facade.raiseEvent({
							type:ORYX.CONFIG.EVENT_LOADING_STATUS,
							text:ORYX.I18N.Save.saved
						});
				}).bind(this),
				onFailure: (function(transport) {
					// raise loading disable event.
	                this.facade.raiseEvent({
	                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
	                });
	
	
					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.failed);
					
					ORYX.log.warn("Saving failed: " + transport.responseText);
				}).bind(this),
				on403: (function(transport) {
					// raise loading disable event.
	                this.facade.raiseEvent({
	                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
	                });
	
	
					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.noRights);
					
					ORYX.log.warn("Saving failed: " + transport.responseText);
				}).bind(this)
		});
						
	},
	
    saveSynchronously: function(forceNew, modelInfo){
		
		if (!modelInfo) {
			return;
		}
		
		var modelMeta = this.facade.getModelMetaData();
		var reqURI = modelMeta.modelHandler;

		//shanglihui 20111125 仅发送请求到后台, 不会弹出对话框; 原来的逻辑被忽略 
		if (location.pathname.include( 'edit_smartdot.html' )){
			this.saveSynchronously_smartdot(forceNew, modelInfo);
			return;
		}

		// Get the stencilset
		var ss = this.facade.getStencilSets().values()[0]
		
		var typeTitle = ss.title();
		
		// Define Default values
		var name = (modelMeta["new"] ? modelMeta.name || ORYX.I18N.Save.newProcess : (modelMeta.name !== modelInfo.name ? modelMeta.name : modelInfo.name));
		
//		var name = (modelMeta["new"] && modelMeta.name === "") ? ORYX.I18N.Save.newProcess : modelInfo.name;
		var defaultData = {title:Signavio.Utils.escapeHTML(name||"").replace(/["]/g, "&quot;"), summary:Signavio.Utils.escapeHTML(modelInfo.description||""), type:typeTitle, url: reqURI, namespace: modelInfo.model.stencilset.namespace, comment: '' }
		
		// Create a Template
		var dialog = new Ext.XTemplate(		
					// TODO find some nice words here -- copy from above ;)
					'<form class="oryx_repository_edit_model" action="#" id="edit_model" onsubmit="return false;">',
									
						'<fieldset>',
							'<p class="description">' + ORYX.I18N.Save.dialogDesciption + '</p>',
							'<input type="hidden" name="namespace" value="{namespace}" />',
							'<p><label for="edit_model_title">' + ORYX.I18N.Save.dialogLabelTitle + '</label><input type="text" class="text" name="title" value="{title}" id="edit_model_title" onfocus="this.className = \'text activated\'" onblur="this.className = \'text\'"/></p>',
							'<p><label for="edit_model_summary">' + ORYX.I18N.Save.dialogLabelDesc + '</label><textarea rows="5" name="summary" id="edit_model_summary" onfocus="this.className = \'activated\'" onblur="this.className = \'\'">{summary}</textarea></p>',
							(modelMeta.versioning) ? '<p><label for="edit_model_comment">' + ORYX.I18N.Save.dialogLabelComment + '</label><textarea rows="5" name="comment" id="edit_model_comment" onfocus="this.className = \'activated\'" onblur="this.className = \'\'">{comment}</textarea></p>' : '',
							'<p><label for="edit_model_type">' + ORYX.I18N.Save.dialogLabelType + '</label><input type="text" name="type" class="text disabled" value="{type}" disabled="disabled" id="edit_model_type" /></p>',
							
						'</fieldset>',
					
					'</form>')
		
		// Create the callback for the template
		callback = function(form){

			    // raise loading enable event
		        /*this.facade.raiseEvent({
		            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
					text: ORYX.I18N.Save.saving
		        });*/

				var title 		= form.elements["title"].value.strip();
				title 			= title.length == 0 ? defaultData.title : title;
				
				var summary 	= form.elements["summary"].value.strip();	
				//summary 		= summary.length == 0 ? defaultData.summary : summary;
				
				var namespace	= form.elements["namespace"].value.strip();
				namespace		= namespace.length == 0 ? defaultData.namespace : namespace;
				
				var comment 	= form .elements["comment"].value.strip();
				comment			= comment.length == 0 ? defaultData.comment : comment;
				
				modelMeta.name = title;
				modelMeta.description = summary;
				modelMeta.parent = modelInfo.parent;
				modelMeta.namespace = namespace;
	        		
				//added changing title of page after first save, but with the changed flag
				if(!forceNew) window.document.title = this.changeSymbol + title + " | " + ORYX.CONFIG.APPNAME;
					
					
		        // Get json
				var json = this.facade.getJSON(),
					glossary = [];
				
		        // Set offset of the canvas
		        var bb = this.facade.getCanvas().getShapeBounds(), 
		        	bs = this.facade.getCanvas().getShapeSize();
		        if (bb.upperLeft().x !== bs.upperLeft().x || bb.upperLeft().y !== bs.upperLeft().y){
		        	json.offset = {	x: bb.upperLeft().x - bs.upperLeft().x,
		        					y: bb.upperLeft().y - bs.upperLeft().y };
		        }
		        
		        
				//Support for glossary
				if (this.facade.hasGlossaryExtension) {
					
					Ext.apply(json, ORYX.Core.AbstractShape.JSONHelper);
					var allNodes = json.getChildShapes(true);
					
					var orders = {};
					
					this.facade.getGlossary().each(function(entry){
						if ("undefined" == typeof orders[entry.shape.resourceId+"-"+entry.property.prefix()+"-"+entry.property.id()]){
							orders[entry.shape.resourceId+"-"+entry.property.prefix()+"-"+entry.property.id()] = 0;
						}
						// Add entry
						glossary.push({
							itemId		: entry.glossary,
			            	elementId	: entry.shape.resourceId,
			            	propertyId	: entry.property.prefix()+"-"+entry.property.id(),
				            order		: orders[entry.shape.resourceId+"-"+entry.property.prefix()+"-"+entry.property.id()]++
						});
						
						// Replace the property with the generated glossary url
						/*var rId = entry.shape.resourceId;
						var pKe = entry.property.id();
						for (var i=0, size=allNodes.length; i<size; ++i) {
							var sh = allNodes[i];
							if (sh.resourceId == rId) {
								for (var prop in sh.properties) {
									if (prop === pKe) {
										sh.properties[prop] = this.facade.generateGlossaryURL(entry.glossary, sh.properties[prop]);
										break;
									}
								}
								break;
							}
						}*/
						
						
						// Replace SVG
						if (entry.property.refToView() && entry.property.refToView().length > 0) {
							entry.property.refToView().each(function(ref){
								var node = $(entry.shape.id+""+ref);
								if (node)
									node.setAttribute("oryx:glossaryIds", entry.glossary + ";")
							})
						}
					}.bind(this))
					

					// Set the json as string
					json = json.serialize();

				} else {
					json = Ext.encode(json);
				}
				
				
				// Set the glossaries as string
				glossary = Ext.encode(glossary);
				
				var selection = this.facade.getSelection();
				this.facade.setSelection([]);

				// Get the serialized svg image source
		        var svgClone 	= this.facade.getCanvas().getSVGRepresentation(true);
				this.facade.setSelection(selection);
				
				// Remove all node which should not been shown (like identification numbers)
		        if (this.facade.getCanvas().properties["oryx-showstripableelements"] !== true) {
		        	var stripOutArray = Element.getElementsByClassName(svgClone, "stripable-element"); // Workaround for IE9, use global function instead of local one.
		        	for (var i=stripOutArray.length-1; i>=0; i--) {
		        		stripOutArray[i].parentNode.removeChild(stripOutArray[i]);
		        	}
		        }
				  
				// Remove all forced stripable elements 
	        	var stripOutArray = Element.getElementsByClassName(svgClone, "stripable-element-force");
	        	for (var i=stripOutArray.length-1; i>=0; i--) {
	        		stripOutArray[i].parentNode.removeChild(stripOutArray[i]);
	        	}
				          
				// Parse dom to string
		        var svgDOM 	= DataManager.serialize(svgClone);
		        
		        var params = {
		        		json_xml: json,
		        		svg_xml: svgDOM,
		        		name: title,
		        		type: defaultData.type,
		        		parent: modelMeta.parent,
		        		description: summary,
		        		comment: comment,
		        		glossary_xml: glossary,
		        		namespace: modelMeta.namespace,
		        		views: Ext.util.JSON.encode(modelMeta.views || [])
		        };
		        
				var success = false;
				
				var successFn = function(transport) {
					var loc = transport.getResponseHeader.location;
					if (!this.processURI && loc) {
						this.processURI = loc;
					}
	
					if( forceNew ){
						var resJSON = transport.responseText.evalJSON();
						
						var modelURL = location.href.substring(0, location.href.indexOf(location.search)) + '?id=' + resJSON.href.substring(7);
						var newURLWin = new Ext.Window({
							title:		ORYX.I18N.Save.savedAs, 
							bodyStyle:	"background:white;padding:10px", 
							width:		'auto', 
							height:		'auto',
							html:"<div style='font-weight:bold;margin-bottom:10px'>"+ORYX.I18N.Save.savedDescription+":</div><span><a href='" + modelURL +"' target='_blank'>" + modelURL + "</a></span>",
							buttons:[{text:'Ok',handler:function(){newURLWin.destroy()}}]
						});
						newURLWin.show();
						
						window.open(modelURL);
					}
	
					//show saved status
					/*this.facade.raiseEvent({
							type:ORYX.CONFIG.EVENT_LOADING_STATUS,
							text:ORYX.I18N.Save.saved
						});*/
						
					success = true;
					
					win.close();
				
					
					
					// set new model data
					var resJSON = transport.responseText.evalJSON();
					// get new views 
					if (resJSON && resJSON instanceof Array){
						var newViews = [],
							viewJSON = resJSON.find(function(t){ return "views" == t.rel;});
						if (viewJSON && viewJSON.rep.length > 0){
							viewJSON.rep.each(function(view){
							   newViews.push(view.rep.view);
							}.bind(this));					
							modelMeta.views = newViews;
						} else {
							modelMeta.views = [];
						}
					}
					
					if (success) {
						// Reset changes
						this.changeDifference = 0;
						this.updateTitle();					
						
						if(modelMeta["new"]) {
							modelMeta["new"] = false;
						}
					}
					
					delete this.saving;
					
					// 
					
					// Raise Event
					this.facade.raiseEvent({
						type: ORYX.CONFIG.EVENT_SAVED
					});
					
					if(modelMeta["isTestSystem"]) {
						//Display message if SVG difference was found
						var resJSON = transport.responseText.evalJSON();
						if (resJSON instanceof Array){
							resJSON = resJSON.find(function(t){ return t.rel == "info"; });
						}
						if (resJSON && resJSON.rep && resJSON.rep.svgDiff){
							this.window = new Ext.Window({
    							title: 	"SVG Renderer Difference!",
    							html:	"The SVG rendered by the server component differs significantly from the editor SVG!<br/>" +
										"An additional revision has automatically been created as the head revision. " +
										"Please compare the SVGs of the last (server SVG) and next to last (client SVG) revisions.<br/>" + 
										"If there are any visible differences please report them to the developers!" +
										"<br/><br/>" + resJSON.rep.svgDiffString,
								renderTo: document.body,
								height: 600,
								width:	800,
								bodyStyle: "overflow:auto;",
								buttons:[new Ext.Button({
    								text:"close",
    								handler:function(){this.window.close()}.bind(this)
								})]
							})
							this.window.show()
						}
					}
				}.bind(this);
				
				var failure = function(transport) {
						// raise loading disable event.
		                this.facade.raiseEvent({
		                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
		                });
						
						win.close();
						
						if(transport.status && transport.status === 401) {
							Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.notAuthorized).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();
						} else if(transport.status && transport.status === 403) {
							Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.noRights).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();
						} else if(transport.statusText === "transaction aborted") {
							Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.transAborted).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();
						} else if(transport.statusText === "communication failure") {
							Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.comFailed).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();
						} else {
							Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.failed).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).center().syncSize();
						}
						
						delete this.saving;
						
					}.bind(this);
				
				if(modelMeta["new"]) {	
					// Send the request out
					params.id = modelMeta.modelId;					
					this.sendSaveRequest('POST', reqURI, params, forceNew, successFn, failure);
				} else if(forceNew) {
					this.sendSaveRequest('POST', reqURI, params, forceNew, successFn, failure);
				} else {
					if (!reqURI.include(modelMeta.modelId))
						reqURI += "/" + modelMeta.modelId;
						
					params.id = modelMeta.modelId;
					// Send the request out
					this.sendSaveRequest('PUT', reqURI, params, false, successFn, failure);
				}
		}.bind(this);
			
		// Create a new window				
		win = new Ext.Window({
			id		: 'Propertie_Window',
	        width	: 'auto',
	        height	: 'auto',
		    title	: forceNew ? ORYX.I18N.Save.saveAsTitle : ORYX.I18N.Save.save,
	        modal	: true,
	        resize	: false,
			bodyStyle: 'background:#FFFFFF',
	        html	: dialog.apply( defaultData ),
	        defaultButton: 0,
			buttons:[{
				text: ORYX.I18N.Save.saveBtn,
				handler: function(){
				
					win.body.mask(ORYX.I18N.Save.pleaseWait, "x-waiting-box");
					
					window.setTimeout(function(){
						
						callback($('edit_model'));
						
					}.bind(this), 10);			
				},
				listeners:{
					render:function(){
						this.focus();
					}
				}
			},{
            	text: ORYX.I18N.Save.close,
            	handler: function(){
	               win.close();
            	}.bind(this)
			}],
			listeners: {
				close: function(){					
                	win.destroy();
					delete this.saving;
				}.bind(this)
			}
	    });
				      
		win.show();
    },
	
	/**
	 * Get the model data and call the success callback
	 * 
	 * @param {Function} success Success callback
	 */
	retrieveModelData: function(success){
		
		var onComplete = function(){
			Ext.getBody().unmask();
		}
		
		new Ajax.Request(window.location.href.replace(/#.*/g, "").replace(ORYX.CONFIG.SERVER_EDITOR_HANDLER.replace("..", ""),ORYX.CONFIG.SERVER_EDITOR_DATA_HANDLER.replace("..","")), {
            method: 'get',
            asynchronous: true,
			requestHeaders: {
				"Accept":"application/json"
			},
			encoding: 'UTF-8',
			onSuccess: (function(transport) {
				modelInfo = (transport.responseText||"{}").evalJSON();
				onComplete();
				success(modelInfo);
			}).bind(this),
			onException: function(){
				// raise loading disable event.
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });

				delete this.saving;
				onComplete();
				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.exception).setIcon(Ext.Msg.ERROR).getDialog().setWidth(260).syncSize();
			}.bind(this),
			onFailure: (function(transport) {
				// raise loading disable event.
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
				
				delete this.saving;
				onComplete();
				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.failed).setIcon(Ext.Msg.ERROR).getDialog().setWidth(260).syncSize();
			}).bind(this),
			on401: (function(transport) {
				// raise loading disable event.
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
				
				delete this.saving;
				onComplete();
				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.notAuthorized).setIcon(Ext.Msg.WARNING).getDialog().setWidth(260).syncSize();
			}).bind(this),
			on403: (function(transport) {
				// raise loading disable event.
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
				
				delete this.saving;
				onComplete();
				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.noRights).setIcon(Ext.Msg.ERROR).getDialog().setWidth(260).syncSize();
			}).bind(this)
		});
	},
	
	sendSaveRequest: function(method, url, params, forceNew, success, failure){
		
		// Send the request to the server.
		Ext.Ajax.request({
			url				: url,
			method			: method,
			timeout			: 1800000,
			disableCaching	: true,
			headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
			params			: params,
			success			: success,
			failure			: failure
		});
	},
    
    /**
     * Saves the current process to the server.
     */
    save: function(forceNew, event){
        //dhz
    	var json = this.facade.getJSON();
		json = json.serialize();
		console.log(json);
		// Check if currently is saving
		if (this.saving){
			return;
		}
		
		this.saving = true;
		
		this.facade.raiseEvent({
			type: ORYX.CONFIG.EVENT_ABOUT_TO_SAVE
		});
		
        // ... save synchronously
        window.setTimeout((function(){
            
			var meta = this.facade.getModelMetaData();
			
			//改变后面的代码执行逻辑, 触发保存; shanglihui 20111125
			if (!meta["new"]){
				meta["new"] = true;
			}
			
			// Check if new...
			if (meta["new"]){
         		this.saveSynchronously(forceNew, meta);
			} else {
				Ext.getBody().mask(ORYX.I18N.Save.retrieveData, "x-waiting-box");
				// ...otherwise, get the current model data first.
				this.retrieveModelData(this.saveSynchronously.bind(this, forceNew))
			}
        }).bind(this), 10);

        
        return true;
    }	
});
	
	
	
ORYX.Plugins.File = Clazz.extend({

    facade: undefined,
	    
    construct: function(facade){
        this.facade = facade;
        
        /**
         
        this.facade.offer({
            'name': ORYX.I18N.File.print,
            'functionality': this.print.bind(this),
            'group': ORYX.I18N.File.group,
            'icon': ORYX.PATH + "images/printer.png",
            'description': ORYX.I18N.File.printDesc,
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
        **/
        
        this.facade.offer({
            'name': ORYX.I18N.File.info,
            'functionality': this.info.bind(this),
            'group': ORYX.I18N.File.group,
            'icon': ORYX.PATH + "images/information.png",
            'description': ORYX.I18N.File.infoDesc,
            'index': 5,
            'minShape': 0,
            'maxShape': 0
        });

    },
    

    
    info: function(){
    
        var info = '<iframe src="' + ORYX.CONFIG.LICENSE_URL + '" type="text/plain" ' + 
				   'style="border:none;display:block;width:575px;height:480px;"/>';

		this.infoBox = Ext.Msg.show({
		   title: ORYX.I18N.Oryx.title,
		   msg: info,
		   width: 640,
		   maxWidth: 640,
		   maxHeight: 480,
		   buttons: Ext.MessageBox.OK
		});
        
        return false;
    },
    
    exportPDF: function(){
    	
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.File.genPDF});
		
        var resource = location.href;
        
        // Get the serialized svg image source
        var svgClone = this.facade.getCanvas().getSVGRepresentation(true);
        
        var svgDOM = DataManager.serialize(svgClone);
		
        // Send the svg to the server.
        //TODO make this better by using content negotiation instead of format parameter.
        //TODO make this better by generating svg on the server, too.
        new Ajax.Request(ORYX.CONFIG.PDF_EXPORT_URL, {
            method: 'POST',
            parameters: {
                resource: resource,
                data: svgDOM,
                format: "pdf"
            },
            onSuccess: (function(request){
            	this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
				
                // Because the pdf may be opened in the same window as the
                // process, yet the process may not have been saved, we're
                // opening every other representation in a new window.
                // location.href = request.responseText
                window.open(request.responseText);
            }).bind(this),
			onFailure: (function(){
				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
				
				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.File.genPDFFailed);
			}).bind(this)
        });
    },
    
    print: function(){
		
		Ext.Msg.show({
		   title		: ORYX.I18N.File.printTitle,
		   msg			: ORYX.I18N.File.printMsg,
		   buttons		: Ext.Msg.YESNO,
		   icon			: Ext.MessageBox.QUESTION,
		   fn			:  function(btn) {
	        
								if (btn == "yes") {
								
									// Set all options for the new window
									var option = $H({
										width: 300,
										height: 400,
										toolbar: "no",
										status: "no",
										menubar: "yes",
										dependent: "yes",
										resizable: "yes",
										scrollbars: "yes"
									});
									
									// Create the new window with all the settings
									var newWindow = window.open("", "PrintWindow", option.invoke('join', '=').join(','));
									
									// Add a style tag to the head and hide all controls
									var head = newWindow.document.getElementsByTagName('head')[0];
									var style = document.createElement("style");
									style.innerHTML = " body {padding:0px; margin:0px} .svgcontainer { display:none; }";
									head.appendChild(style);
									
									// Clone the svg-node and append this to the new body
									newWindow.document.getElementsByTagName('body')[0].appendChild(this.facade.getCanvas().getSVGRepresentation());
									var svg = newWindow.document.getElementsByTagName('body')[0].getElementsByTagName('svg')[0];
									
									// Set the width and height
									svg.setAttributeNS(null, 'width', 1100);
									svg.setAttributeNS(null, 'height', 1400);
									
									// Set the correct size and rotation
									svg.lastChild.setAttributeNS(null, 'transform', 'scale(0.47, 0.47) rotate(270, 1510, 1470)');
									
									var markers = ['marker-start', 'marker-mid', 'marker-end']
									var path = $A(newWindow.document.getElementsByTagName('path'));
									path.each(function(pathNode){
										markers.each(function(marker){
											// Get the marker value
											var url = pathNode.getAttributeNS(null, marker);
											if (!url) {
												return
											};
											
											// Replace the URL and set them new
											url = "url(about:blank#" + url.slice(5);
											pathNode.setAttributeNS(null, marker, url);
										});
									});
									
									// Get the print dialog
									newWindow.print();
									
									return true;
								}
							}.bind(this)
			});
    }   
});
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
*/
if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * The view plugin offers all of zooming functionality accessible over the 
 * tool bar. This are zoom in, zoom out, zoom to standard, zoom fit to model.
 * 
 * @class ORYX.Plugins.View
 * @extends Clazz
 * @param {Object} facade The editor facade for plugins.
*/
ORYX.Plugins.View = {
	/** @lends ORYX.Plugins.View.prototype */
	facade: undefined,

	construct: function(facade, ownPluginData) {
		this.facade = facade;
		//Standard Values
		this.zoomLevel = 1.0;
		this.maxFitToScreenLevel=1.5;
		this.minZoomLevel = 0.1;
		this.maxZoomLevel = 2.5;
		this.diff=5; //difference between canvas and view port, s.th. like toolbar??
		
		//Read properties
		ownPluginData.properties.each( function(property) {			
			if (property.zoomLevel) {this.zoomLevel = Number(1.0);}		
			if (property.maxFitToScreenLevel) {this.maxFitToScreenLevel=Number(property.maxFitToScreenLevel);}
			if (property.minZoomLevel) {this.minZoomLevel = Number(property.minZoomLevel);}
			if (property.maxZoomLevel) {this.maxZoomLevel = Number(property.maxZoomLevel);}
		}.bind(this));

		
		/* Register zoom in */
		this.facade.offer({
			'name':ORYX.I18N.View.zoomIn,
			'functionality': this.zoom.bind(this, [1.0 + ORYX.CONFIG.ZOOM_OFFSET]),
			'group': ORYX.I18N.View.group,
			'icon': ORYX.PATH + "images/magnifier_zoom_in.png",
			'description': ORYX.I18N.View.zoomInDesc,
			'index': 1,
			'minShape': 0,
			'maxShape': 0,
			'isEnabled': function(){return this.zoomLevel < this.maxZoomLevel }.bind(this),
			'keyCodes': [{
				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: 107,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
			}]});
		
		/* Register zoom out */
		this.facade.offer({
			'name':ORYX.I18N.View.zoomOut,
			'functionality': this.zoom.bind(this, [1.0 / (1.0 + ORYX.CONFIG.ZOOM_OFFSET)]),
			'group': ORYX.I18N.View.group,
			'icon': ORYX.PATH + "images/magnifier_zoom_out.png",
			'description': ORYX.I18N.View.zoomOutDesc,
			'index': 2,
			'minShape': 0,
			'maxShape': 0,
			'isEnabled': function(){ return this._checkSize() }.bind(this),
			'keyCodes': [{
				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: 109,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
			}]});
		
		/* Register zoom standard */
		this.facade.offer({
			'name':ORYX.I18N.View.zoomStandard,
			'functionality': this.setAFixZoomLevel.bind(this, 1),
			'group': ORYX.I18N.View.group,
			'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/zoom_layer.png",
			'cls' : 'icon-large',
			'description': ORYX.I18N.View.zoomStandardDesc,
			'index': 3,
			'minShape': 0,
			'maxShape': 0,
			'isEnabled': function(){return this.zoomLevel != 1; }.bind(this),
			'keyCodes': [{
				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: 48,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
			}]
		});
		
		/* Register zoom fit to model */
		this.facade.offer({
			'name':ORYX.I18N.View.zoomFitToModel,
			'functionality': this.zoomFitToModel.bind(this),
			'group': ORYX.I18N.View.group,
			'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/zoom_extend.png",
			'description': ORYX.I18N.View.zoomFitToModelDesc,
			'index': 4,
			'minShape': 0,
			'maxShape': 0
		});
		
		
		// TODO: This only works in FireFox. In Chrome CTRL-Wheel/CTRL-(+/-) 
		// leaves to a text zooming which can't be canceled.
		document.addEventListener(Ext.isGecko ? "DOMMouseScroll" : "mousewheel", function(e){
			if (e.ctrlKey){
				Event.stop(e);
				// BACK --> Zoom out
				if (e.detail < 0 || (!e.detail && e.wheelDelta > 0)){
					this.zoom(1.0 + ORYX.CONFIG.ZOOM_OFFSET, e);
					
				// FRONT --> Zoom in
				} else {
					this.zoom(1.0 / (1.0 + ORYX.CONFIG.ZOOM_OFFSET), e);
				}
			}
		}.bind(this), false);
		
		
		if (Ext.isIPad){
			
			this.facade.registerOnEvent('dblclick', function(event, uiObj){
				if (event.touchCount != 2 && uiObj instanceof ORYX.Core.Canvas)
					this.zoom(1.0 + (ORYX.CONFIG.ZOOM_OFFSET*2), event);
			}.bind(this));
			
			this.facade.registerOnEvent('dblclick', function(event, uiObj){
				if (event.touchCount == 2 && uiObj instanceof ORYX.Core.Canvas)
					this.zoom(1.0 / (1.0 + ORYX.CONFIG.ZOOM_OFFSET), event);
			}.bind(this));
			
			
//			(function(){
//				var initialScale, canvas = this.facade.getCanvas();
//				document.addEventListener("gesturestart", function(ev){
//					initialScale = this.zoomLevel;
//				}.bind(this), false);
//				document.addEventListener("gesturechange", function(ev){
//					if ("undefined" != typeof initialScale && Math.abs(ev.scale-1) > 0.1){
//						var scale = ((ev.scale-1)*0.5) + 1;
//						this.zoom((initialScale * scale)/this.zoomLevel);
//						ev.preventDefault();
//						ev.stopPropagation();
//						if (canvas.iscroll){
//							canvas.iscroll.scrolling = false;
//							canvas.iscroll.resetPosition();
//						}
//					}
//				}.bind(this), false);
//				document.addEventListener("gestureend", function(ev){
//					initialScale = undefined;
//				}, false);
//			}.bind(this)());

		}
	},
	
	/**
	 * It sets the zoom level to a fix value and call the zooming function.
	 * 
	 * @param {Number} zoomLevel
	 * 			the zoom level
	 */
	setAFixZoomLevel : function(zoomLevel) {
		this.zoomLevel = zoomLevel;
		this._checkZoomLevelRange();
		this.zoom(1, true);
	},
	
	/**
	 * It does the actual zooming. It changes the viewable size of the canvas 
	 * and all to its child elements.
	 * 
	 * @param {Number} factor
	 * 		the factor to adjust the zoom level
	 */
	zoom: function(factor, evt) {
		// TODO: Zoomen auf allen Objekten im SVG-DOM
		
		if (evt&&evt.event){
			Event.stop(evt.event);
		}
		
		if ((this.zoomLevel > this.maxZoomLevel && factor > 1) || (!this._checkSize() && factor < 1) || (factor === 1.0 && evt !== true) ){
			return;
		}
		
		this.zoomLevel *= factor;
		var scrollNode 	= this.facade.getCanvas().getHTMLContainer().parentNode.parentNode;
		var canvas 		= this.facade.getCanvas();
		var oldWidth 	= canvas.getHTMLContainer().parentNode.getWidth() - 8;
		var oldHeight 	= canvas.getHTMLContainer().parentNode.getHeight() - 8;
		var newWidth 	= canvas.bounds.width()  * this.zoomLevel;
		var newHeight 	= canvas.bounds.height() * this.zoomLevel;
		
		/* Set new top offset */
		if (!Ext.isIPad){		
			var offsetTop = (canvas.node.parentNode.parentNode.parentNode.offsetHeight - newHeight) / 2.0;	
			offsetTop = offsetTop > 20 ? offsetTop - 20 : 0;
			
			canvas.node.parentNode.parentNode.style.marginTop = offsetTop + "px";
			offsetTop += 5;
			canvas.getHTMLContainer().style.top = offsetTop + "px";	
		} else {
			canvas.getHTMLContainer().style.top = "-1px";	
		}
		
		var scrollPosition = canvas.getScrollPosition();
		
		
		var getPoint = function(){
			var fn = Ext.fly(scrollNode), sn = fn.parent(), cn = Ext.fly(canvas.rootNode.parentNode);
			
			if (evt){
				var x = Event.pointerX(evt);
				var y = Event.pointerY(evt);
				x -= cn.getMargins("l") + cn.getBorderWidth("l") + cn.getOffsetsTo(fn)[0];
				y -= cn.getMargins("t") + cn.getBorderWidth("t");
					
				var offset = evt ? sn.translatePoints(x, y) : undefined;
				if (offset 
					&& offset.left >= 0 && offset.left < sn.getWidth() 
					&& offset.top >= 0 && offset.top < sn.getHeight()){	
					return {
						x: offset.left,
						y: offset.top
					};
				}
			}
			return {
				x: scrollNode.getWidth() / 2,
				y: scrollNode.getHeight() / 2
			};
		};
		
		var getScroll = function(scroll, oldVal, newVal, eventPos){
			return ((scroll+(eventPos))*(newVal/oldVal))-(eventPos);
		};
		
		/*readjust scrollbar*/
		var point = getPoint();
		var newScrollTop = getScroll(scrollPosition.top, oldHeight, newHeight, point.y);
		var newScrollLeft =	getScroll(scrollPosition.left, oldWidth, newWidth, point.x);
		
		//canvas.startUpdate();
		
		/* Set new Zoom-Level */
		canvas.setSize({width: newWidth, height: newHeight}, true);

		if (Ext.isIPad){
			canvas.setScrollPosition(newScrollLeft, newScrollTop);
		}
		
		/* Set Scale-Factor */
		canvas.setZoom(this.zoomLevel);

		/* Refresh the Selection */
		this.facade.updateSelection();
		
		//canvas.endUpdate();
		
		/* Set the scroll position */
		canvas.setScrollPosition(newScrollLeft, newScrollTop);

		/* Update the zoom-level*/
		canvas.zoomLevel = this.zoomLevel;
		
		/* Raise event */
		this.facade.raiseEvent({
			type 	: ORYX.CONFIG.EVENT_ZOOM, 
			zoom	: this.zoomLevel
		});
	},
	
	
	/**
	 * It calculates the zoom level to fit whole model into the visible area
	 * of the canvas. Than the model gets zoomed and the position of the 
	 * scroll bars are adjusted.
	 * 
	 */
	zoomFitToModel: function() {
		
		/* Get the size of the visible area of the canvas */
		var scrollNode 	= this.facade.getCanvas().getHTMLContainer().parentNode.parentNode;
		var visibleHeight = scrollNode.getHeight() - 30;
		var visibleWidth = scrollNode.getWidth() - 30;
		
		var nodes = this.facade.getCanvas().getChildShapes();
		
		if(!nodes || nodes.length < 1) {
			return false;			
		}
			
		/* Calculate size of canvas to fit the model */
		var bounds = nodes[0].absoluteBounds().clone();
		nodes.each(function(node) {
			bounds.include(node.absoluteBounds().clone());
		});
		
		
		/* Set new Zoom Level */
		var scaleFactorWidth =  visibleWidth / bounds.width();
		var scaleFactorHeight = visibleHeight / bounds.height();
		
		/* Choose the smaller zoom level to fit the whole model */
		var zoomFactor = scaleFactorHeight < scaleFactorWidth ? scaleFactorHeight : scaleFactorWidth;
		
		/*Test if maximum zoom is reached*/
		if(zoomFactor>this.maxFitToScreenLevel){zoomFactor=this.maxFitToScreenLevel}
		/* Do zooming */
		this.setAFixZoomLevel(zoomFactor);
		
		/* Set scroll bar position */
		this.facade.getCanvas().setScrollPosition(Math.round(bounds.upperLeft().x * this.zoomLevel) - 5, Math.round(bounds.upperLeft().y * this.zoomLevel) - 5);
		
	},
	
	/**
	 * It checks if the zoom level is less or equal to the level, which is required
	 * to schow the whole canvas.
	 * 
	 * @private
	 */
	_checkSize:function(){
		var canvasParent=this.facade.getCanvas().getHTMLContainer().parentNode;
		var minForCanvas= Math.min((canvasParent.parentNode.getWidth()/canvasParent.getWidth()),(canvasParent.parentNode.getHeight()/canvasParent.getHeight()));
		return 1.05 > minForCanvas;
		
	},
	/**
	 * It checks if the zoom level is included in the definined zoom
	 * level range.
	 * 
	 * @private
	 */
	_checkZoomLevelRange: function() {
		/*var canvasParent=this.facade.getCanvas().getHTMLContainer().parentNode;
		var maxForCanvas= Math.max((canvasParent.parentNode.getWidth()/canvasParent.getWidth()),(canvasParent.parentNode.getHeight()/canvasParent.getHeight()));
		if(this.zoomLevel > maxForCanvas) {
			this.zoomLevel = maxForCanvas;			
		}*/
		if(this.zoomLevel < this.minZoomLevel) {
			this.zoomLevel = this.minZoomLevel;			
		}
		
		if(this.zoomLevel > this.maxZoomLevel) {
			this.zoomLevel = this.maxZoomLevel;			
		}
	}
};

ORYX.Plugins.View = Clazz.extend(ORYX.Plugins.View);
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner, 
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins) 
	ORYX.Plugins = new Object();

ORYX.Plugins.DragDropResize = ORYX.Plugins.AbstractPlugin.extend({

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;

		// Initialize variables
		this.currentShapes 		= [];			// Current selected Shapes
		this.pluginsData 		= [];			// Available Plugins
		this.toMoveShapes 		= [];			// Shapes there will be moved
		this.isResizing 		= false;		// Flag: If there was currently resized
		this.dragEnable 		= false;		// Flag: If Dragging is enabled
		this.dragIntialized 	= false;		// Flag: If the Dragging is initialized
		this.edgesMovable		= true;			// Flag: If an edge is docked it is not movable
		this.offSetPosition 	= {x: 0, y: 0};	// Offset of the Dragging
		this.faktorXY 			= {x: 1, y: 1};	// The Current Zoom-Faktor
		this.containmentParentNode;				// the current future parent node for the dragged shapes
		this.isAddingAllowed 	= false;		// flag, if adding current selected shapes to containmentParentNode is allowed
		this.isAttachingAllowed = false;		// flag, if attaching to the current shape is allowed
		
		this.callbackMouseMove	= this.handleMouseMove.bind(this);
		this.callbackMouseUp	= this.handleMouseUp.bind(this);
		
		// Get the SVG-Containernode 
		var containerNode = this.facade.getCanvas().getSvgContainer();
		
		// Create the Selected Rectangle in the SVG
		this.selectedRect = new ORYX.Core.SelectedRect(containerNode);
		
		// Grid lines
		this.vLines = [];
		this.hLines = [];
		
		// Show grid line if enabled
		if (ORYX.CONFIG.SHOW_GRIDLINE) {
			this.vLine = new ORYX.Core.GridLine(containerNode, ORYX.Core.GridLine.DIR_VERTICAL);
			this.hLine = new ORYX.Core.GridLine(containerNode, ORYX.Core.GridLine.DIR_HORIZONTAL);
		}
		
		// Get a HTML-ContainerNode
		containerNode = this.facade.getCanvas().getHTMLContainer();
		
		this.scrollNode = this.facade.getCanvas().rootNode.parentNode.parentNode;
		
		this.snap = new ORYX.Core.SnapToGrid(this.facade);
		
		// Create the southeastern button for resizing
		this.resizerSE = new ORYX.Plugins.Resizer(containerNode, "southeast", this.facade, this.snap);
		this.resizerSE.registerOnResize(this.onResize.bind(this)); // register the resize callback
		this.resizerSE.registerOnResizeEnd(this.onResizeEnd.bind(this)); // register the resize end callback
		this.resizerSE.registerOnResizeStart(this.onResizeStart.bind(this)); // register the resize start callback
		
		// Create the northwestern button for resizing
		this.resizerNW = new ORYX.Plugins.Resizer(containerNode, "northwest", this.facade, this.snap);
		this.resizerNW.registerOnResize(this.onResize.bind(this)); // register the resize callback
		this.resizerNW.registerOnResizeEnd(this.onResizeEnd.bind(this)); // register the resize end callback
		this.resizerNW.registerOnResizeStart(this.onResizeStart.bind(this)); // register the resize start callback
		
		// For the Drag and Drop
		// Register on MouseDown-Event on a Shape
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));
	},

	/**
	 * On Mouse Down
	 *
	 */
	handleMouseDown: function(event, uiObj) {
		// If the selection Bounds not intialized and the uiObj is not member of current selectio
		// then return
		if(!this.dragBounds || !this.currentShapes.member(uiObj) || !this.toMoveShapes.length) {return};
		
		// Start Dragging
		this.dragEnable = true;
		this.dragIntialized = true;
		this.edgesMovable = true;

		// Calculate the current zoom factor
		var a = this.facade.getCanvas().node.getScreenCTM();
		this.faktorXY.x = a.a;
		this.faktorXY.y = a.d;

		// Set the offset position of dragging
		var upL = this.dragBounds.upperLeft();
		this.offSetPosition =  {
			x: Event.pointerX(event) - (upL.x * this.faktorXY.x),
			y: Event.pointerY(event) - (upL.y * this.faktorXY.y)};
			
	   // Store the start position of dragging
       var upL = this.dragBounds.upperLeft();
       this.startPosition =  {
       	x: upL.x * this.faktorXY.x,
       	y: upL.y * this.faktorXY.y};
		
		this.offsetScroll	= {x:this.scrollNode.scrollLeft,y:this.scrollNode.scrollTop};
			
		// Register on Global Mouse-MOVE Event
		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.callbackMouseMove, false);	
		// Register on Global Mouse-UP Event
		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.callbackMouseUp, true);			

		return;
	},

	/**
	 * On Key Mouse Up
	 *
	 */
	handleMouseUp: function(event) {
		
		//disable containment highlighting
		this.facade.raiseEvent({
									type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
									highlightId:"dragdropresize.contain"
								});
								
		this.facade.raiseEvent({
									type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
									highlightId:"dragdropresize.attached"
								});

		// If Dragging is finished
		if(this.dragEnable) {
		
			// and update the current selection
			if(!this.dragIntialized) {
				
				// Do Method after Dragging
				this.dragDrop(undefined, undefined, event);	
				
//				if (this.pluginsData.length > 0 && this.pluginsData[0].onValidDropClb instanceof Function) {
//					var allowDrop = this.pluginsData[0].onValidDropClb.apply(this, [undefined, undefined, event]);
//					if (allowDrop) {
//						this.isAddingAllowed = true;
//					}
//				} 
				
				
				// Get the position and the docker					
				var position = this.facade.eventCoordinates( event );	
				
				// Check if the Shape is allowed to dock to the other Shape						
				if ( 	this.isAttachingAllowed &&
						this.toMoveShapes.length == 1 && this.toMoveShapes[0] instanceof ORYX.Core.Node  &&
						this.toMoveShapes[0].dockers.length > 0) {
					
					var docker 		= this.toMoveShapes[0].dockers[0];
			
					//Command-Pattern for dragging several Shapes
					var dockCommand = ORYX.Core.Command.extend({
						construct: function(docker, position, newDockedShape, facade){
							this.docker 		= docker;
							this.newPosition	= position;
							this.newDockedShape = newDockedShape;
							this.newParent 		= newDockedShape.parent || facade.getCanvas();
							this.oldPosition	= docker.parent.bounds.center();
							this.oldDockedShape	= docker.getDockedShape();
							this.oldParent 		= docker.parent.parent || facade.getCanvas();
							this.facade			= facade;
							
							if( this.oldDockedShape ){
								this.oldPosition = docker.parent.absoluteBounds().center();
							}
							
						},			
						execute: function(){
							this.dock( this.newDockedShape, this.newParent,  this.newPosition );
							
							// Raise Event for having the docked shape on top of the other shape
							this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_ARRANGEMENT_TOP, excludeCommand: true})									
						},
						rollback: function(){
							this.dock( this.oldDockedShape, this.oldParent, this.oldPosition );
						},
						dock:function( toDockShape, parent, pos ){
							// Add to the same parent Shape
							parent.add( this.docker.parent )
							
							// Set the Docker to the new Shape
							this.docker.setDockedShape( undefined );
							this.docker.bounds.centerMoveTo( pos )				
							this.docker.setDockedShape( toDockShape );	
							//this.docker.update();
							
							this.facade.setSelection( [this.docker.parent] );	
							this.facade.getCanvas().update();
							this.facade.updateSelection();										
											
						}
					});
			
					// Instanziate the dockCommand
					var commands = [new dockCommand(docker, position, this.containmentParentNode, this.facade)];
					this.facade.executeCommands(commands);	
					

				// Check if adding is allowed to the other Shape	
				} else if( this.isAddingAllowed||this.isConnectingAllowed ) {

					// Refresh all Shapes --> Set the new Bounds
					this.refreshSelectedShapes();
				}
				
				this.facade.updateSelection();

				this.afterDragDrop();
//				if (this.pluginsData.length > 0 && this.pluginsData[0].afterDragDropClb instanceof Function) {
//					this.pluginsData[0].afterDragDropClb.apply(this, []);
//				}
//				
				//this.currentShapes.each(function(shape) {shape.update()})
				// Raise Event: Dragging is finished
				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_DRAGDROP_END});
			}	

			if (this.vLine)
				this.vLine.hide();
			if (this.hLine)
				this.hLine.hide();
				
			this.vLines.concat(this.hLines).each(function(gl) {
				gl.hide();
			});
		}

		// Disable 
		this.dragEnable = false;	
		

		// UnRegister on Global Mouse-UP/-Move Event
		document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.callbackMouseUp, true);	
		document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.callbackMouseMove, false);				
			
		return;
	},

	/**
	* On Key Mouse Move
	*
	*/
	handleMouseMove: function(event) {
		// If dragging is not enabled, go return
		if(!this.dragEnable) { 
			return };
		
		var isInitializing = false;

		// Calculate the new position
		var position = {
			x: Event.pointerX(event) - this.offSetPosition.x,
			y: Event.pointerY(event) - this.offSetPosition.y }

		position.x 	-= this.offsetScroll.x - this.scrollNode.scrollLeft; 
		position.y 	-= this.offsetScroll.y - this.scrollNode.scrollTop;
		
		
		// If Dragging is initialized
		if(this.dragIntialized) {
			// Wait till the mouse has been moved (workaround for IE9 
			// after a mousedown, a mousemove are raised even when its not been moved)
			if (Math.abs(position.x-this.startPosition.x) < 2 && Math.abs(position.y-this.startPosition.y) < 2){
				return;
			}
			
			// Raise Event: Drag will be started
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_DRAGDROP_START});
			this.dragIntialized = false;
			isInitializing = true;
			
			// And hide the resizers and the highlighting
			this.resizerSE.hide();
			this.resizerNW.hide();
			
			// if only edges are selected, containmentParentNode must be the canvas
			this._onlyEdges = this.currentShapes.all(function(currentShape) {
				return (currentShape instanceof ORYX.Core.Edge);
			});
			
//			/* If only edges are selected, check if they are movable. An Edge is
//			 * movable in case it is not docked
//			 */
//			if(this._onlyEdges) {
//				this.currentShapes.each(function(edge) {
//					if(edge.isDocked()) {
//						this.edgesMovable = false;
//						throw $break;
//					}
//				}.bind(this));
//			}
			
			// Do method before Drag
			this.beforeDrag();
			
			
//				if (this.pluginsData.length > 0 && this.pluginsData[0].afterDragEnterClb instanceof Function) {
//					this.pluginsData[0].afterDragEnterClb.apply(this, []);
//				}
			
			
			this._currentUnderlyingNodes = [];
			
		}
		
		if(event.shiftKey) {
		    // if shift is pressed moving is locked in one direction
		    
		    var offset = {
    		    x: position.x-this.startPosition.x, 
    		    y: position.y-this.startPosition.y
    		};

		    if(Math.abs(offset.y)>Math.abs(offset.x))
		        position.x=this.startPosition.x;
		    else                               
		        position.y=this.startPosition.y;
		}

		// If not the Control-Key are pressed
		var modifierKeyPressed = event.altKey || event.ctrlKey;
		if(ORYX.CONFIG.GRID_ENABLED && !modifierKeyPressed && !isInitializing) {
			// Snap the current position to the nearest Snap-Point
			position = this.snapToGrid(position);
		} else {
			if (this.vLine)
				this.vLine.hide();
			if (this.hLine)
				this.hLine.hide();
			this.vLines.concat(this.hLines).each(function(gl) {
				gl.hide();
			});
		}

		// Adjust the point by the zoom faktor 
		position.x /= this.faktorXY.x;
		position.y /= this.faktorXY.y;

		// Set that the position is not lower than zero
		position.x = Math.max( 0 , position.x);
		position.y = Math.max( 0 , position.y);

		// Set that the position is not bigger than the canvas
		var c = this.facade.getCanvas();
		position.x = Math.min( c.bounds.width() - this.dragBounds.width(), 		position.x);
		position.y = Math.min( c.bounds.height() - this.dragBounds.height(), 	position.y);

		// Drag this bounds
		this.dragBounds.moveTo(position);

		// Update all selected shapes and the selection rectangle
		//this.refreshSelectedShapes();
		this.resizeRectangle(this.dragBounds);
		this.selectedRect.scrollIntoView(event, this.handleMouseMove.bind(this));
			
		
		this.isAttachingAllowed = false;
		var pluginOptions = {preventHighlights: false};
		
		this.dragOver(this.containmentParentNode, event, pluginOptions);
		
//		if (this.pluginsData.length > 0 && this.pluginsData[0].afterDragOverClb instanceof Function) {
//			this.pluginsData[0].afterDragOverClb.apply(this, [this.containmentParentNode, event]);
//			var preventHighlights = true;
//		}
		
		//check, if a node can be added to the underlying node
		var underlyingNodes = $A(this.facade.getCanvas().getAbstractShapesAtPosition(this.facade.eventCoordinates(event)));
		
		var checkIfAttachable = this.toMoveShapes.length == 1 && this.toMoveShapes[0] instanceof ORYX.Core.Node && (this.toMoveShapes[0].dockers.length > 0 || this.toMoveShapes[0].getStencil().idWithoutNs() === "Lane");
		checkIfAttachable	= checkIfAttachable && underlyingNodes.length != 1;
		
			
		if(		!checkIfAttachable &&
				underlyingNodes.length === this._currentUnderlyingNodes.length  &&
				underlyingNodes.all(function(node, index){return this._currentUnderlyingNodes[index] === node}.bind(this))
			) {
					
			return;
			
		} else if(this._onlyEdges) {
			this.isAddingAllowed = true;
			this.containmentParentNode = this.facade.getCanvas();
			
		} else {
		
			/* Check the containment and connection rules */
			var options = {
				event : event,
				underlyingNodes : underlyingNodes,
				checkIfAttachable : checkIfAttachable
			};
			this.checkRules(options);
							
		}
		
		this._currentUnderlyingNodes = underlyingNodes.reverse();
		
		if (pluginOptions.preventHighlights) {
			return;
		}
		
		//visualize the containment result
		if( this.isAttachingAllowed ) {
			this.facade.raiseEvent({
									type: 			ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,
									highlightId: 	"dragdropresize.attached",
									elements: 		[this.containmentParentNode],
									style: 			ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE,
									color: 			ORYX.CONFIG.SELECTION_VALID_COLOR
								});
								
		} else {
			
			this.facade.raiseEvent({
									type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
									highlightId:"dragdropresize.attached"
								});
		}
		
		if( !this.isAttachingAllowed ){
			if( this.isAddingAllowed || this.isConnectingAllowed) {

				this.facade.raiseEvent({
										type:ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,
										highlightId:"dragdropresize.contain",
										elements:[this.containmentParentNode],
										color: ORYX.CONFIG.SELECTION_VALID_COLOR
									});

			} else {

				this.facade.raiseEvent({
										type:ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,
										highlightId:"dragdropresize.contain",
										elements:[this.containmentParentNode],
										color: ORYX.CONFIG.SELECTION_INVALID_COLOR
									});

			}
		} else {
			this.facade.raiseEvent({
									type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
									highlightId:"dragdropresize.contain"
								});			
		}	

		// Stop the Event
		//Event.stop(event);
		return;
	},
	
//	/**
//	 * Rollbacks the docked shape of an edge, if the edge is not movable.
//	 */
//	redockEdges: function() {
//		this._undockedEdgesCommand.dockers.each(function(el){
//			el.docker.setDockedShape(el.dockedShape);
//			el.docker.setReferencePoint(el.refPoint);
//		})
//	},
	
	/**
	 *  Checks the containment and connection rules for the selected shapes.
	 */
	checkRules : function(options) {
		var event = options.event;
		var underlyingNodes = options.underlyingNodes;
		var checkIfAttachable = options.checkIfAttachable;
		var noEdges = options.noEdges;
		
		if (this.facade.getRules().isContainable(this.toMoveShapes[0])){
			// get underlying node that is not the same than one of the currently selected shapes or
			// a child of one of the selected shapes with the highest z Order.
			// The result is a shape or the canvas
			this.containmentParentNode = underlyingNodes.reverse().find((function(node) {
				return (node instanceof ORYX.Core.Canvas) || 
						(((node instanceof ORYX.Core.Node) || ((node instanceof ORYX.Core.Edge) && !noEdges)) 
						&& (!(this.currentShapes.member(node) || 
								this.currentShapes.any(function(shape) {
									return (shape.children.length > 0 && shape.getChildNodes(true).member(node));
								})))
						&& this.facade.getRules().isContainable(node));
			}).bind(this));
		}  else {
			this.containmentParentNode = underlyingNodes.first(); // Use the canvas
		}
		
		if (!this.containmentParentNode){
			return;
		}
		
		/**
		 * Check for attaching
		 */ 			
		if( checkIfAttachable ){
				
			this.isAttachingAllowed	= this.facade.getRules().canConnect({
												sourceShape:	this.containmentParentNode, 
												edgeShape:		this.toMoveShapes[0], 
												targetShape:	this.toMoveShapes[0]
												});						
			
			if ( this.isAttachingAllowed	) {
				var point = this.facade.eventCoordinates(event);
				this.isAttachingAllowed	= this.containmentParentNode.isPointOverOffset( point.x, point.y );
			}						
		}
		
		/**
		 * Check for adding
		 */ 
		if( !this.isAttachingAllowed ){
			//check all selected shapes, if they can be added to containmentParentNode
			this.isAddingAllowed = this.toMoveShapes.all((function(currentShape) {
				if(currentShape instanceof ORYX.Core.Edge ||
					currentShape instanceof ORYX.Core.Controls.Docker ||
					this.containmentParentNode === currentShape.parent) {
					return true;
				} else if(this.containmentParentNode !== currentShape) {
					
					if(!(this.containmentParentNode instanceof ORYX.Core.Edge) || !noEdges) {
					
						if(this.facade.getRules().canContain({containingShape:this.containmentParentNode,
															  containedShape:currentShape})) {	  	
							return true;
						}
					}
				}
				return false;
			}).bind(this));				
		}

		/**
		 * Check for connecting between
		 */ 
		if (!this.isAttachingAllowed&&!this.isAddingAllowed&&
			this.toMoveShapes.length===1&&
			(this.containmentParentNode instanceof ORYX.Core.Edge)&&
			!this.toMoveShapes[0].getAllDockedShapes().include(this.containmentParentNode)&&
			(![this.containmentParentNode.getTarget(), this.containmentParentNode.getSource()].compact().any(function(e){ return e.isParent(this.toMoveShapes[0])}.bind(this)))){
				var unode = [this.containmentParentNode].concat(options.underlyingNodes).uniq();
				this.isConnectingAllowed = ORYX.Core.DragZone.prototype.canConnectBetween.call(this, unode, this.toMoveShapes[0].getStencil());
				this.isConnectingAllowedParent = unode[1];
		} else {
			delete this.isConnectingAllowed;
		}
		
		if(!this.isAttachingAllowed && !this.isAddingAllowed && !this.isConnectingAllowed &&
				(this.containmentParentNode instanceof ORYX.Core.Edge)) {
			options.noEdges = true;
			options.underlyingNodes.reverse();
			this.checkRules(options);			
		}
	},
	
	setAllowed : function() {
		this.facade.raiseEvent({
			type		: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
			highlightId	: "dragdropresize.contain"
		});
		this.facade.raiseEvent({
			type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
			highlightId:"dragdropresize.attached"
		});
		this.isAttachingAllowed = true;
	},
	
	setNotAllowed : function() {
		this.facade.raiseEvent({
			type		: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
			highlightId	: "dragdropresize.contain"
		});
		this.facade.raiseEvent({
			type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
			highlightId:"dragdropresize.attached"
		});
		this.isAttachingAllowed = false;
	},
	
	getScale : function() {
		return this.faktorXY;
	},
	
	/**
	 * Redraw the selected Shapes.
	 *
	 */
	refreshSelectedShapes: function() {
		// If the selection bounds not initialized, return
		if(!this.dragBounds) {return}

		// Calculate the offset between the bounds and the old bounds
		var upL = this.dragBounds.upperLeft();
		var oldUpL = this.oldDragBounds.upperLeft();
		var offset = {
			x: upL.x - oldUpL.x,
			y: upL.y - oldUpL.y };

		// Instanciate the dragCommand
		var commands = [
						new ORYX.Core.Command.Move(this.toMoveShapes, offset, this.containmentParentNode, this.currentShapes, this), 
						new ORYX.Core.EnsureChildCommand(this.facade, this.toMoveShapes)
						];
		// If the undocked edges command is setted, add this command
		if( this._undockedEdgesCommand instanceof ORYX.Core.Command ){
			commands.unshift( this._undockedEdgesCommand );
		}
		
		// Execute the commands			
		this.facade.executeCommands( commands );	

		// copy the bounds to the old bounds
		if( this.dragBounds )
			this.oldDragBounds = this.dragBounds.clone();

	},
	
	/**
	 * Callback for Resize
	 *
	 */
	onResize: function(bounds) {
		// If the selection bounds not initialized, return
		if(!this.dragBounds) {return}
		
		this.dragBounds = bounds;
		this.isResizing = true;

		// Update the rectangle 
		this.resizeRectangle(this.dragBounds);
	},
	
	onResizeStart: function() {
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_RESIZE_START});
	},

	onResizeEnd: function(direction) {
		
		if (!(this.currentShapes instanceof Array)||this.currentShapes.length<=0) {
			return;
		}
		
		// If Resizing finished, the Shapes will be resize
		if(this.isResizing) {
			
			var commandClass = ORYX.Core.Command.extend({
				construct: function(shape, newBounds, direction, plugin){
					this.shape = shape;
					this.oldBounds = shape.bounds.clone();
					this.newBounds = newBounds;
					this.plugin = plugin;
					this.direction = direction;
				},			
				execute: function(){
					this.shape.bounds.set(this.newBounds);
					this.update(this.getOffset(this.oldBounds, this.newBounds));
					this.firstExcecution = true;
				},
				rollback: function(){					
					this.shape.bounds.set(this.oldBounds);
					this.update(this.getOffset(this.newBounds, this.oldBounds));
				},
				
				getOffset:function(b1, b2){
					return {
						x: b2.a.x - b1.a.x,
						y: b2.a.y - b1.a.y,
						xs: b2.width()/b1.width(),
						ys: b2.height()/b1.height()
					}
				},
				update:function(offset){
					this.shape.getLabels().each(function(label) {
						label.changed();
					});
					
					if (this.direction == "northwest"){
						this.shape.getChildNodes().each(function(shape){
							shape.bounds.moveBy(-offset.x, -offset.y);
						})
					}
					
					if (!this.firstExcecution){
						// REMOVED LAYOUTING BECAUSE OF THE
						// POSITION OF CHILD ELEMENTS WONT CHANGE
						var allEdges = [].concat(this.shape.getIncomingShapes())
							.concat(this.shape.getOutgoingShapes())
							// Remove all edges which are included in the selection from the list
							.findAll(function(r){ return r instanceof ORYX.Core.Edge }.bind(this))
													
						this.plugin.layoutEdges(this.shape, allEdges, offset);
					}
					
					this.plugin.facade.setSelection([this.shape]);
					this.plugin.facade.getCanvas().update();
					this.plugin.facade.updateSelection();
				}
			});
			
			var bounds = this.dragBounds.clone();
			var shape = this.currentShapes[0];
			
			if(shape.parent) {
				var parentPosition = shape.parent.absoluteXY();
				bounds.moveBy(-parentPosition.x, -parentPosition.y);
			}
				
			var command = new commandClass(shape, bounds, direction, this);
			var ensure = new ORYX.Core.EnsureChildCommand(this.facade, shape, true);
			this.facade.executeCommands([command, ensure]);
			
			this.isResizing = false;
			
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_RESIZE_END});
		}
	},
	

	/**
	 * Prepare the Dragging
	 *
	 */
	beforeDrag: function(){

		var undockEdgeCommand = ORYX.Core.Command.extend({
			construct: function(moveShapes){
				this.dockers = moveShapes.collect(function(shape){ return shape instanceof ORYX.Core.Controls.Docker ? {docker:shape, dockedShape:shape.getDockedShape(), refPoint:shape.referencePoint} : undefined }).compact();
			},			
			execute: function(){
				this.dockers.each(function(el){
					el.docker.setDockedShape(undefined);
				})
			},
			rollback: function(){
				this.dockers.each(function(el){
					el.docker.setDockedShape(el.dockedShape);
					el.docker.setReferencePoint(el.refPoint);
					//el.docker.update();
				})
			}
		});
		
		this._undockedEdgesCommand = new undockEdgeCommand( this.toMoveShapes );
		this._undockedEdgesCommand.execute();	
		
	},

	hideAllLabels: function(shape) {
			
			// Hide all labels from the shape
			shape.getLabels().each(function(label) {
				label.hide();
			});
			// Hide all labels from docked shapes
			shape.getAllDockedShapes().each(function(dockedShape) {
				var labels = dockedShape.getLabels();
				if(labels.length > 0) {
					labels.each(function(label) {
						label.hide();
					});
				}
			});

			// Do this recursive for all child shapes
			// EXP-NICO use getShapes
			shape.getChildren().each((function(value) {
				if(value instanceof ORYX.Core.Shape)
					this.hideAllLabels(value);
			}).bind(this));
	},

	/** Execute Callbacks before drag */
	beforeDrag : function() {
		(this.beforeDragStack||[]).each(function(options, clb) {
			clb.apply(this, (options||[]));
		}.bind(this, arguments));
	},
	
	/** Execute Callbacks on drag over */
	dragOver : function() {
		(this.dragOverStack||[]).each(function(options, clb) {
			clb.apply(this, (options||[]));
		}.bind(this, arguments));
	},
	
	/** Execute Callbacks after drag */
	dragDrop : function() {
		(this.dragDropStack||[]).each(function(options, clb) {
			clb.apply(this, (options||[]));
		}.bind(this, arguments));
	},

	/** Execute Callbacks after drag drop */
	afterDragDrop : function() {
		(this.afterDragDropStack||[]).each(function(options, clb) {
			clb.apply(this, (options||[]));
		}.bind(this, arguments));
	},
	
	/**
	 * Show all Labels at these shape
	 * 
	 */
	showAllLabels: function(shape) {

			// Show the label of these shape
			//shape.getLabels().each(function(label) {
			for(var i=0; i<shape.length ;i++){
				var label = shape[i];
				label.show();
			}//);
			// Show all labels at docked shapes
			//shape.getAllDockedShapes().each(function(dockedShape) {
			var allDockedShapes = shape.getAllDockedShapes()
			for(var i=0; i<allDockedShapes.length ;i++){
				var dockedShape = allDockedShapes[i];				
				var labels = dockedShape.getLabels();
				if(labels.length > 0) {
					labels.each(function(label) {
						label.show();
					});
				}
			}//);

			// Do this recursive
			//shape.children.each((function(value) {
			for(var i=0; i<shape.children.length ;i++){
				var value = shape.children[i];	
				if(value instanceof ORYX.Core.Shape)
					this.showAllLabels(value);
			}//).bind(this));
	},

	/**
	 * Intialize Method, if there are new Plugins
	 *
	 */
	registryChanged: function(offers) {
		// Save all new Plugin, sorted by group and index
		this.pluginsData = (offers||[]).findAll(function(offer){
			return offer && offer.target && offer.target === ORYX.Plugins.DragDropResize;
		});
		
		if (this.pluginsData.length > 0) {
			this.pluginsData.each(function(plugin) {
				// Get all before drag callbacks
				if (plugin.beforeDragClb instanceof Function) {
					if (!this.beforeDragStack) this.beforeDragStack = [];
					this.beforeDragStack.push(plugin.beforeDragClb);
				}
				// Get all drag over callbacks
				if (plugin.dragOverClb instanceof Function) {
					if (!this.dragOverStack) this.dragOverStack = [];
					this.dragOverStack.push(plugin.dragOverClb);
				}
				// Get all drag drop call backs
				if (plugin.dragDropClb instanceof Function) {
					if (!this.dragDropStack) this.dragDropStack = [];
					this.dragDropStack.push(plugin.dragDropClb);
				}
				// Get all after drag drop callbacks
				if (plugin.afterDragDropClb instanceof Function) {
					if (!this.afterDragDropStack) this.afterDragDropStack = [];
					this.afterDragDropStack.push(plugin.afterDragDropClb);
				}
			}.bind(this));
		}
	},

	/**
	 * On the Selection-Changed
	 *
	 */
	onSelectionChanged: function(event) {
		var elements = event.elements;
		
		// Reset the drag-variables
		this.dragEnable = false;
		this.dragIntialized = false;
		this.resizerSE.hide();
		this.resizerNW.hide();

		// If there is no elements
		if(!elements || elements.length == 0) {
			// Hide all things and reset all variables
			this.selectedRect.hide();
			this.currentShapes = [];
			this.toMoveShapes = [];
			this.dragBounds = undefined;
			this.oldDragBounds = undefined;
		} else {

			// Set the current Shapes
			this.currentShapes = elements;

			// Get all shapes with the highest parent in object hierarchy (canvas is the top most parent)
			var topLevelElements = this.facade.getCanvas().getShapesWithSharedParent(elements);
			this.toMoveShapes = topLevelElements;
			
			this.toMoveShapes = this.toMoveShapes.findAll( function(shape) { return shape instanceof ORYX.Core.Node && 
																			(shape.dockers.length === 0 || !elements.member(shape.dockers.first().getDockedShape()))});		
																			
			elements.each((function(shape){
				if(!(shape instanceof ORYX.Core.Edge)) {return}
				
				var dks = shape.getDockers() 
								
				var hasF = elements.member(dks.first().getDockedShape());
				var hasL = elements.member(dks.last().getDockedShape());	
						
//				if(!hasL) {
//					this.toMoveShapes.push(dks.last());
//				}
//				if(!hasF){
//					this.toMoveShapes.push(dks.first())
//				} 
				/* Enable movement of undocked edges */
				if(!hasF && !hasL) {
					var isUndocked = !dks.first().getDockedShape() && !dks.last().getDockedShape()
					if(isUndocked) {
						this.toMoveShapes = this.toMoveShapes.concat(dks);
					}
				}
				
				if( shape.dockers.length > 2 && hasF && hasL){
					//this.toMoveShapes = this.toMoveShapes.concat(dks.findAll(function(el,index){ return index > 0 && index < dks.length-1}))
				}
				
			}).bind(this));
			
			// Calculate the new area-bounds of the selection
			var newBounds = undefined;
			this.toMoveShapes.each(function(value) {
				var shape = value;
				if(value instanceof ORYX.Core.Controls.Docker) {
					/* Get the Shape */
					shape = value.parent;
				}
				
				if(!newBounds){
					newBounds = shape.absoluteBounds();
				}
				else {
					newBounds.include(shape.absoluteBounds());
				}
			}.bind(this));
			
			if(!newBounds){
				elements.each(function(value){
					if(!newBounds) {
						newBounds = value.absoluteBounds();
					} else {
						newBounds.include(value.absoluteBounds());
					}
				});
			}
			
			// Set the new bounds
			this.dragBounds = newBounds;
			this.oldDragBounds = newBounds.clone();

			// Update and show the rectangle
			this.resizeRectangle(newBounds);
			this.selectedRect.show();
			
			// Show the resize button, if there is only one element and this is resizeable
			if(elements.length == 1 && elements[0].isResizable) {
				var aspectRatio = elements[0].getStencil().fixedAspectRatio() ? elements[0].bounds.width() / elements[0].bounds.height() : undefined;
				this.resizerSE.setBounds(this.dragBounds, elements[0].minimumSize, elements[0].maximumSize, aspectRatio, elements[0]);
				this.resizerSE.show();
				this.resizerNW.setBounds(this.dragBounds, elements[0].minimumSize, elements[0].maximumSize, aspectRatio, elements[0]);
				this.resizerNW.show();
			} else {
				this.resizerSE.setBounds(undefined);
				this.resizerNW.setBounds(undefined);
			}

			// If Snap-To-Grid is enabled, the Snap-Point will be calculate
			if(ORYX.CONFIG.GRID_ENABLED) {

				this.snap.setReferenceShapes();

				if (this.distPointTimeout)
					window.clearTimeout(this.distPointTimeout);
				
				this.distPointTimeout = window.setTimeout(function(){
					// Get all the shapes, there will consider at snapping
					// Consider only those elements who shares the same parent element
					var distShapes = this.facade.getCanvas().getChildShapes(true).findAll(function(value){
						var parentShape = value.parent;
						while(parentShape){
							if(elements.member(parentShape)) return false;
							parentShape = parentShape.parent
						}
						return true;
					});
					
					this.snap.setReferenceShapes(distShapes);
					//this.resizerSE.setSnapShapes(distShapes);
					//this.resizerNW.setSnapShapes(distShapes);
					
				}.bind(this), 10);


			}
		}
	},

	/**
	 * Adjust an Point to the Snap Points
	 *
	 */
	snapToGrid: function(position) {
		
		var cThres 	= 16;
		
		this.vLines.concat(this.hLines).each(function(gl) { gl.hide(); });
		
		var canvasSize = {
			width: this.facade.getCanvas().bounds.width(),
			height: this.facade.getCanvas().bounds.height()
		};
		
		// determine the bounds to snap with (all bounds that lie at the border of the selection)
		var snapBounds = [];
		var minX, minY, maxX, maxY;
		var snapLeft = [];
		var snapRight = [];
		var snapTop = [];
		var snapBottom = [];
		this.toMoveShapes.each((function(value) {
			var shape = value;
			if(value instanceof ORYX.Core.Controls.Docker) 
				shape = value.parent;
			var b = shape.absoluteBounds();
			
			if(minX!=undefined && b.upperLeft().x<minX) snapLeft = []; // reset snap points at left side
			minX = (minX==undefined) ? b.upperLeft().x : ((b.upperLeft().x<minX) ? b.upperLeft().x : minX);
			if(minX == b.upperLeft().x) snapLeft.push(b); // include the center point in snapping
			
			if(minY!=undefined && b.upperLeft().y<minY) snapTop = []; // reset snap points at top side
			minY = (minY==undefined) ? b.upperLeft().y : ((b.upperLeft().y<minY) ? b.upperLeft().y : minY);
			if(minY == b.upperLeft().y) snapTop.push(b); // include the center point in snapping
			
			if(maxX!=undefined && b.lowerRight().x>maxX) snapRight = []; // reset snap points at right side
			maxX = (maxX==undefined) ? b.lowerRight().x : ((b.lowerRight().x>maxX) ? b.lowerRight().x : maxX);
			if(maxX == b.lowerRight().x) snapRight.push(b); // include the center point in snapping
			
			if(maxY!=undefined && b.lowerRight().y>maxY) snapBottom = []; // reset snap points at bottom side
			maxY = (maxY==undefined) ? b.lowerRight().y : ((b.lowerRight().y>maxY) ? b.lowerRight().y : maxY);
			if(maxY == b.lowerRight().y) snapBottom.push(b); // include the center point in snapping
			
		}).bind(this));
		snapBounds = snapLeft.concat(snapTop, snapRight, snapBottom).uniq();
	
		// determine the snap position (the position that has the smallest distance to the current position)
		// and determine all bounds that will snap in that position
		var minDistX, minDistY;
		var snapXCoords = [];
		var snapYCoords = [];
		var newPos = {};
		
		this.snap.setScale(this.vLine ? this.vLine.getScale() : 1);	

		snapBounds.each((function(b) {
			
			var offsetPos = {
				x: (b.upperLeft().x*this.faktorXY.x) + position.x - this.startPosition.x,
				y: (b.upperLeft().y*this.faktorXY.y) + position.y - this.startPosition.y
			}
			
			var snapX, snapY;
			this.snap.setReferenceBounds(b);
			var point = this.snap.adjustPoint(offsetPos, function(y){snapY=y;}, function(x){snapX=x;});
			
			if(snapX) {
				var distX = Math.abs(offsetPos.x-point.x);
				var px = point.x - (b.upperLeft().x*this.faktorXY.x) + this.startPosition.x;
				if((minDistX==undefined || distX<minDistX) &&
						(px >= 0 && (px+(this.dragBounds.width()*this.faktorXY.x))<=(canvasSize.width*this.faktorXY.x))) {
					snapXCoords = []; // reset snap x coords
					newPos.x = px;
					minDistX = distX;
				}
				if(newPos.x==px) snapXCoords.push(snapX);
			}
			
			if(snapY) {
				var distY = Math.abs(offsetPos.y-point.y);
				var py = point.y - (b.upperLeft().y*this.faktorXY.y) + this.startPosition.y;
				if((minDistY==undefined || distY<minDistY) &&
						(py >= 0 && (py+(this.dragBounds.height()*this.faktorXY.y))<=(canvasSize.height*this.faktorXY.y))) {
					snapYCoords = []; // reset snap y coords
					newPos.y = py;
					minDistY = distY;
				}
				if(newPos.y==py) snapYCoords.push(snapY);
			}
			
		}).bind(this));

		// snap selection bounds to grid, if no snapping to other shapes occured
		if(minDistX==undefined) {
			var gridX = (position.x - (position.x % (ORYX.CONFIG.GRID_DISTANCE/2)));
			newPos.x = gridX;
		}
		if(minDistY==undefined) {
			var gridY = (position.y - (position.y % (ORYX.CONFIG.GRID_DISTANCE/2)));
			newPos.y = gridY;
		}
		
		var distX = Math.abs(this.startPosition.x-position.x);
		var distY = Math.abs(this.startPosition.y-position.y);
		if((minDistX!=undefined && distX < minDistX) || (minDistX==undefined && distX < cThres)) {
			// distance to old position is lower than the distances to any snapping point
			// snap back to old position, don't show grid lines
			newPos.x = this.startPosition.x;
			snapXCoords = [];
		}
		if((minDistY!=undefined && distY < minDistY) || (minDistY==undefined && distY < cThres)) {
			// distance to old position is lower than the distances to any snapping point
			// snap back to old position, don't show grid lines
			newPos.y = this.startPosition.y;
			snapYCoords = [];
		}

		// display vertical grid lines
		var i=0;
		snapXCoords.each((function(x) {
			if(this.vLines.length>i) {
				// use one grid line of the pool if available
				var vLine = this.vLines[i];
			} else {
				// create new grid line and add it to the pool
				var vLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_VERTICAL);
				this.vLines.push(vLine);
			}
			vLine.update(x);
			i++;
		}).bind(this));
		
		// display horizontal grid lines
		i=0;
		snapYCoords.each((function(y) {
			if(this.hLines.length>i) {
				// use one grid line of the pool if available
				var hLine = this.hLines[i];
			} else {
				// create new grid line and add it to the pool
				var hLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_HORIZONTAL);
				this.hLines.push(hLine);
			}
			hLine.update(y);
			i++;
		}).bind(this));
		
		
		return newPos;

	},
	
	showGridLine: function(){
		
	},


	/**
	 * Redraw of the Rectangle of the SelectedArea
	 * @param {Object} bounds
	 */
	resizeRectangle: function(bounds) {
		// Resize the Rectangle
		this.selectedRect.resize(bounds);
	}

});



ORYX.Plugins.Resizer = Clazz.extend({

	construct: function(parentId, orientation, facade, snap) {

		this.parentId 		= parentId;
		this.orientation	= orientation;
		this.facade			= facade;
		this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", $(this.parentId),
			['div', {'class': 'resizer_'+ this.orientation, style:'left:0px; top:0px;'}]);

		this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this), true);
		
		this.handleMouseUpClb = this.handleMouseUp.bind(this);
		this.handleMouseMoveClb = this.handleMouseMove.bind(this);
		
		this.dragEnable = false;
		this.offSetPosition = {x: 0, y: 0};
		this.offsetScroll = {x: 0, y: 0};
		this.mousePosition = {x: 0, y: 0};
		this.bounds = undefined;
		this.startBounds = undefined;

		this.canvasNode = this.facade.getCanvas().node;

		this.minSize = undefined;
		this.maxSize = undefined;
		
		this.aspectRatio = undefined;
		this.widing = false;

		this.resizeCallbacks 		= [];
		this.resizeStartCallbacks 	= [];
		this.resizeEndCallbacks 	= [];
		this.hide();
		
		this.snap = snap;
		this.wGuides = new Hash();
		this.hGuides = new Hash();
		this.selectionWGuide = new ORYX.Core.SizeGuide(this.facade.getCanvas().getSvgContainer(), ORYX.Core.SizeGuide.DIR_HORIZONTAL);
		this.selectionHGuide = new ORYX.Core.SizeGuide(this.facade.getCanvas().getSvgContainer(), ORYX.Core.SizeGuide.DIR_VERTICAL);
		this.vLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_VERTICAL);
		this.hLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_HORIZONTAL);
		
		//this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
		//this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYUP);
		this.facade.registerOnEvent("key.event.down.shift.16", this.shiftDown.bind(this));
		this.facade.registerOnEvent("key.event.up.16", this.shiftUp.bind(this));
		this.facade.registerOnEvent("key.event.down.metactrl.17", this.ctrlDown.bind(this));
		this.facade.registerOnEvent("key.event.up.17", this.ctrlUp.bind(this));
		
		// Calculate the Offset
		this.scrollNode = this.node.parentNode.parentNode.parentNode;

	},

	handleMouseDown: function(event) {
		this.dragEnable = true;
		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, 	this.handleMouseUpClb, 		true);
		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, 	this.handleMouseMoveClb, 	false);
		
		this.startBounds = this.bounds.clone();
		
		this.offsetScroll	= {x:this.scrollNode.scrollLeft,y:this.scrollNode.scrollTop};
		
		this.faktorXY = this.getFactorXY();
		
		this.mousePosition = {x: Event.pointerX(event), y: Event.pointerY(event)};
		this.offSetPosition =  {
			x: this.mousePosition.x - this.position.x,
			y: this.mousePosition.y - this.position.y};
			
		this.resizeStartCallbacks.each((function(value) {
			value(this.bounds);
		}).bind(this));
		
		this.isResizing = true;
		
		// show shapes with same sizes
		// this.snapToGrid(this.bounds.clone());
	},
	
	getFactorXY: function(){
		var a = this.facade.getCanvas().node.getScreenCTM();
		return {x: a.a, y: a.d};
	},

	handleMouseUp: function(event) {
		document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEUP, 	this.handleMouseUpClb, 		true);
		document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, 	this.handleMouseMoveClb, 	false);
		this.dragEnable = false;
		this.containmentParentNode = null;
		this.resizeEndCallbacks.each((function(value) {
			value(this.orientation, this.bounds, this.widing);
		}).bind(this));
	    
	    this.wGuides.values().each(function(wg) { wg.hide(); wg.needsUpdate = true; });
        this.hGuides.values().each(function(hg) { hg.hide(); hg.needsUpdate = true; });
		this.vLine.hide();
		this.hLine.hide();
        this.selectionWGuide.hide();
        this.selectionHGuide.hide();
		this.isResizing = false;
	},

	handleMouseMove: function(event, fixedAspectRatio) {
		if(!this.dragEnable) { return }
		
		if(!this.modifierKeyPressed && event.altKey) {
			this.wGuides.values().each(function(wg) { wg.hide(); wg.needsUpdate = true; });
	        this.hGuides.values().each(function(hg) { hg.hide(); hg.needsUpdate = true; });
			this.vLine.hide();
			this.hLine.hide();
			this.selectionWGuide.hide();
	        this.selectionHGuide.hide();
		}
		this.modifierKeyPressed = event.altKey;
		
		this.mousePosition = {x: Event.pointerX(event), y: Event.pointerY(event)};
		
		if(event.shiftKey) {
			this.aspectRatio = this.startBounds.width() / this.startBounds.height();
		} else {
			this.aspectRatio = undefined;
		}
		if (!!event.ctrlKey !== this.widing){
			this["ctrl"+(!!event.ctrlKey?"Down":"Up")]();
		}
		
		var position = {
			x: this.mousePosition.x - this.offSetPosition.x,
			y: this.mousePosition.y - this.offSetPosition.y
		};
		
		var fXY = this.faktorXY || this.getFactorXY();
		
		position.x -= this.offsetScroll.x - this.scrollNode.scrollLeft; 
		position.y -= this.offsetScroll.y - this.scrollNode.scrollTop;
		position.x  = Math.min( position.x, this.facade.getCanvas().bounds.width()*fXY.x);
		position.y  = Math.min( position.y, this.facade.getCanvas().bounds.height()*fXY.y);
		position.x /= fXY.x;
		position.y /= fXY.y;
		this.doResize(position);
		Event.stop(event);
	},
	
	doResize: function(position) {
		if(!this.dragEnable) { return }
		
		var offset = {
			x: position.x - (this.position.x/this.faktorXY.x),
			y: position.y - (this.position.y/this.faktorXY.y)
		};
		
		if(this.widing) {
		    offset.x = offset.x * 2;
		    offset.y = offset.y * 2;
		}
		
		if(this.orientation==="northwest") {
			offset.x = -offset.x;
			offset.y = -offset.y;
		}
		
		if(this.aspectRatio) {
			offset.x = this.aspectRatio * (this.bounds.height()+offset.y) - this.bounds.width();
		}

		// respect minimum and maximum sizes of stencil
		if(this.bounds.width()+offset.x > this.maxSize.width) {
			offset.x = this.maxSize.width - this.bounds.width();
			if(this.aspectRatio)
				offset.y = offset.x / this.aspectRatio;
		}
		if(this.bounds.width()+offset.x < this.minSize.width) {
			offset.x = this.minSize.width - this.bounds.width();
			if(this.aspectRatio)
				offset.y = offset.x / this.aspectRatio;
		}
		if(this.bounds.height()+offset.y > this.maxSize.height) {
			offset.y = this.maxSize.height - this.bounds.height();
			if(this.aspectRatio)
				offset.x = this.aspectRatio * offset.y;
		}
		if(this.bounds.height()+offset.y < this.minSize.height) {
			offset.y = this.minSize.height - this.bounds.height();
			if(this.aspectRatio)
				offset.x = this.aspectRatio * offset.y;
		}
		
		var newBounds = this.bounds.clone();
		
		newBounds.extend({x:offset.x, y:offset.y});
		if(this.widing) newBounds.moveBy({x:-(offset.x/2), y:-(offset.y/2)});
		else if(this.orientation==="northwest") newBounds.moveBy({x:-(offset.x), y:-(offset.y)});

		// If the ALT-Key is not pressed, perform snapping on grid and to other shapes
		if(ORYX.CONFIG.GRID_ENABLED && !this.modifierKeyPressed) {
			// Snap the current size to the grid and other shape sizes
			newBounds = this.snapToGrid(newBounds);
		}

		offset = {x:0, y:0}; // reset offset
		
		// again respect minimum and maximum sizes of stencil after snapping
		if(newBounds.width() > this.maxSize.width) {
			offset.x = this.maxSize.width - newBounds.width();
			if(this.aspectRatio)
				offset.y = offset.x / this.aspectRatio;
		}
		if(newBounds.width() < this.minSize.width) {
			offset.x = this.minSize.width - newBounds.width();
			if(this.aspectRatio)
				offset.y = offset.x / this.aspectRatio;
		}
		if(newBounds.height() > this.maxSize.height) {
			offset.y = this.maxSize.height - newBounds.height();
			if(this.aspectRatio)
				offset.x = this.aspectRatio * offset.y;
		}
		if(newBounds.height() < this.minSize.height) {
			offset.y = this.minSize.height - newBounds.height();
			if(this.aspectRatio)
				offset.x = this.aspectRatio * offset.y;
		}
		newBounds.extend({x:offset.x, y:offset.y});
		if(this.widing) newBounds.moveBy({x:-(offset.x/2), y:-(offset.y/2)});
		else if(this.orientation==="northwest") newBounds.moveBy({x:-(offset.x), y:-(offset.y)});

		this.bounds.set(newBounds.upperLeft(), newBounds.lowerRight());
		this.update();

		this.resizeCallbacks.each((function(value) {
			value(this.bounds);
		}).bind(this));

	},
	
	/**
	 * Snap the bounds to other shape sizes / local grid
	 *
	 */
	snapToGrid: function(bounds) {

	    if(bounds.width()<this.minSize.width) bounds.extend({x:this.minSize.width-bounds.width(), y:0});
	 	if(bounds.width()>this.maxSize.width) bounds.extend({x:this.maxSize.width-bounds.width(), y:0});
		if(bounds.height()<this.minSize.height) bounds.extend({x:0, y:this.minSize.height-bounds.height()});
		if(bounds.height()>this.maxSize.height) bounds.extend({x:0, y:this.maxSize.height-bounds.height()});
		
		this.wGuides.values().each(function(wg) { wg.hide(); });
	    this.hGuides.values().each(function(hg) { hg.hide(); });
	    this.selectionWGuide.hide();
	    this.selectionHGuide.hide();
		this.vLine.hide();
		this.hLine.hide();
		
		var onW = function(adjBounds, shapes, x) {
		    if(adjBounds.width()<this.minSize.width || adjBounds.width()>this.maxSize.width) return;
			if(adjBounds.upperLeft().x == this.startBounds.upperLeft().x && adjBounds.lowerRight().x == this.startBounds.lowerRight().x) {
				return; // don't show size guides or grid lines for snapping back to old width
			}

		    // Show size guide if enabled
    		if (ORYX.CONFIG.SHOW_SIZEGUIDES && shapes) {
    		    shapes.each(function(shape) {
    		        if(shape==this.shape) return; // don't show size guide on the resized shape itself
    		        var wg = this.wGuides[shape];
    		        if (!wg) {
						wg = this.wGuides[shape] = new ORYX.Core.SizeGuide(this.facade.getCanvas().getSvgContainer(), ORYX.Core.SizeGuide.DIR_HORIZONTAL);
						wg.update(shape.absoluteBounds());
					} else if (wg.needsUpdate) {
						wg.update(shape.absoluteBounds());
						delete wg.needsUpdate;
					} else {
						wg.show();
					}
		        }.bind(this));
		        if(shapes.size()>1 || shapes[0]!=this.shape) // don't show size guide on the resized shape itself
		            this.selectionWGuide.update(adjBounds);
    		}
			
			if (ORYX.CONFIG.SHOW_GRIDLINE && x) {
				this.vLine.update(x);
			}
		}.bind(this);
					
		var onH = function(adjBounds, shapes, y) {
		    if(adjBounds.height()<this.minSize.height || adjBounds.height()>this.maxSize.height) return;
			if(adjBounds.upperLeft().y == this.startBounds.upperLeft().y && adjBounds.lowerRight().y == this.startBounds.lowerRight().y) {
				return; // don't show size guides or grid lines for snapping back to old height
			}
		    
		    if (ORYX.CONFIG.SHOW_SIZEGUIDES && shapes) {
		        shapes.each(function(shape) {
		            if(shape==this.shape) return; // don't show size guide on the resized shape itself
					var hg = this.hGuides[shape];
    		        if (!hg) {
						hg = this.hGuides[shape] = new ORYX.Core.SizeGuide(this.facade.getCanvas().getSvgContainer(), ORYX.Core.SizeGuide.DIR_VERTICAL);
						hg.update(shape.absoluteBounds());
					} else if (hg.needsUpdate) {
						hg.update(shape.absoluteBounds());
						delete hg.needsUpdate;
					} else {
						hg.show();
					}
		        }.bind(this));
		        if(shapes.size()>1 || shapes[0]!=this.shape) // don't show size guide on the resized shape itself
		            this.selectionHGuide.update(adjBounds);
    		}

			if (ORYX.CONFIG.SHOW_GRIDLINE && y) {
				this.hLine.update(y);
			}
		}.bind(this);
			
	//	this.snap.setScale(this.vLine ? this.vLine.getScale() : 1);								
		return this.snap.adjustBounds(bounds, this.orientation, this.aspectRatio, onW, onH, this.startBounds, this.widing);

	},
	
	shiftDown: function() {
		if(!this.startBounds) return;
		this.aspectRatio = this.startBounds.width() / this.startBounds.height();
		var fXY = this.faktorXY || this.getFactorXY();
		this.doResize({
				x: this.position.x/fXY.x,
				y: this.position.y/fXY.y
			});
	},
	
	shiftUp: function() {
		this.aspectRatio = undefined;
		var position = {
			x: this.mousePosition.x - this.offSetPosition.x,
			y: this.mousePosition.y - this.offSetPosition.y
		};
		
		var fXY = this.faktorXY || this.getFactorXY();
		
		position.x -= this.offsetScroll.x - this.scrollNode.scrollLeft; 
		position.y -= this.offsetScroll.y - this.scrollNode.scrollTop;
		position.x  = Math.min( position.x, this.facade.getCanvas().bounds.width()*fXY.x);
		position.y  = Math.min( position.y, this.facade.getCanvas().bounds.height()*fXY.y);
		position.x /= fXY.x;
		position.y /= fXY.y;
		this.doResize(position, false);
	},
	
	ctrlDown: function() {  // widen in all direction when CTRL key is pressed
		if(this.widing) return;
		
		this.widing = true;
		if(!this.bounds || !this.startBounds || !this.isResizing) return;

		var diff = { x: this.bounds.width() - this.startBounds.width(), y: this.bounds.height() - this.startBounds.height() };
	    this.bounds.extend(diff);
	    this.bounds.centerMoveTo(this.startBounds.center());

		var position = {
			x: this.mousePosition.x - this.offSetPosition.x,
			y: this.mousePosition.y - this.offSetPosition.y
		};

		var fXY = this.faktorXY || this.getFactorXY();
		
		position.x -= this.offsetScroll.x - this.scrollNode.scrollLeft; 
		position.y -= this.offsetScroll.y - this.scrollNode.scrollTop;
		position.x  = Math.min( position.x, this.facade.getCanvas().bounds.width()*fXY.x);
		position.y  = Math.min( position.y, this.facade.getCanvas().bounds.height()*fXY.y);
		position.x /= fXY.x;
		position.y /= fXY.y;

		this.doResize(position);
	},
	
	ctrlUp: function() { 
		// stop and revert widing
		this.widing = false;
		if(!this.bounds || !this.startBounds || !this.isResizing) return;
		if(this.orientation==="northwest") {
            this.bounds.set(this.bounds.upperLeft(), this.startBounds.lowerRight());
        } else { // defaults to southeast
            this.bounds.set(this.startBounds.upperLeft(), this.bounds.lowerRight());
        }
		this.update();
		
		var position = {
			x: this.mousePosition.x - this.offSetPosition.x,
			y: this.mousePosition.y - this.offSetPosition.y
		};
		
		var fXY = this.faktorXY || this.getFactorXY();
		
		position.x -= this.offsetScroll.x - this.scrollNode.scrollLeft; 
		position.y -= this.offsetScroll.y - this.scrollNode.scrollTop;
		position.x  = Math.min( position.x, this.facade.getCanvas().bounds.width()*fXY.x);
		position.y  = Math.min( position.y, this.facade.getCanvas().bounds.height()*fXY.y);
		position.x /= fXY.x;
		position.y /= fXY.y;

		this.doResize(position);
	},
	
	setSnapShapes: function(shapes) {
	    this.snap.setReferenceShapes(shapes);
	},
	
	registerOnResizeStart: function(callback) {
		if(!this.resizeStartCallbacks.member(callback)) {
			this.resizeStartCallbacks.push(callback);
		}
	},
	
	unregisterOnResizeStart: function(callback) {
		if(this.resizeStartCallbacks.member(callback)) {
			this.resizeStartCallbacks = this.resizeStartCallbacks.without(callback);
		}
	},

	registerOnResizeEnd: function(callback) {
		if(!this.resizeEndCallbacks.member(callback)) {
			this.resizeEndCallbacks.push(callback);
		}
	},
	
	unregisterOnResizeEnd: function(callback) {
		if(this.resizeEndCallbacks.member(callback)) {
			this.resizeEndCallbacks = this.resizeEndCallbacks.without(callback);
		}
	},
		
	registerOnResize: function(callback) {
		if(!this.resizeCallbacks.member(callback)) {
			this.resizeCallbacks.push(callback);
		}
	},

	unregisterOnResize: function(callback) {
		if(this.resizeCallbacks.member(callback)) {
			this.resizeCallbacks = this.resizeCallbacks.without(callback);
		}
	},

	hide: function() {
		this.node.style.display = "none";
	},

	show: function() {
		if(this.bounds)
			this.node.style.display = "";
	},

	setBounds: function(bounds, min, max, aspectRatio, shape) {
		this.bounds = bounds;
	    if(this.bounds) this.startBounds = this.bounds.clone();
		else this.startBounds = undefined;

		if(!min)
			min = {width: ORYX.CONFIG.MINIMUM_SIZE, height: ORYX.CONFIG.MINIMUM_SIZE};

		if(!max)
			max = {width: ORYX.CONFIG.MAXIMUM_SIZE, height: ORYX.CONFIG.MAXIMUM_SIZE};

		this.minSize = min;
		this.maxSize = max;
		this.aspectRatio = aspectRatio;
		this.shape = shape;

		this.update();
	},

	update: function() {
		if(!this.bounds) { return; }

		var upL = this.bounds.upperLeft();

		if(this.bounds.width() < this.minSize.width)	{ this.bounds.set(upL.x, upL.y, upL.x + this.minSize.width, upL.y + this.bounds.height())};
		if(this.bounds.height() < this.minSize.height)	{ this.bounds.set(upL.x, upL.y, upL.x + this.bounds.width(), upL.y + this.minSize.height)};
		if(this.bounds.width() > this.maxSize.width)	{ this.bounds.set(upL.x, upL.y, upL.x + this.maxSize.width, upL.y + this.bounds.height())};
		if(this.bounds.height() > this.maxSize.height)	{ this.bounds.set(upL.x, upL.y, upL.x + this.bounds.width(), upL.y + this.maxSize.height)};

		var a = this.canvasNode.getScreenCTM();
		
		upL.x *= a.a;
		upL.y *= a.d;
		
		if(this.orientation==="northwest") {
			upL.x -= 12;
			upL.y -= 26;
		} else { // defaults to southeast
			upL.x +=  (a.a * this.bounds.width()) + 0 ;
			upL.y +=  (a.d * this.bounds.height())  - 2;
		}
		
		this.position = upL;

		this.node.style.left = this.position.x + "px";
		this.node.style.top = this.position.y + "px";
	}
});



/**
 * Implements a Command to move shapes
 * 
 */ 
ORYX.Core.Command.Move = ORYX.Core.Command.extend({
	construct: function(moveShapes, offset, parent, selectedShapes, plugin){
		this.moveShapes = moveShapes;
		this.selectedShapes = selectedShapes;
		this.offset 	= offset;
		this.plugin		= plugin;
		this.parent		= parent;
		// Defines the old/new parents for the particular shape
		this.newParents	= moveShapes.collect(function(t){ 
			if (plugin.isConnectingAllowed) {
				return plugin.isConnectingAllowedParent || t.parent
			} else {
				return parent || t.parent
			} 
		});
		this.oldParents	= moveShapes.collect(function(shape){ return shape.parent });
		this.dockedNodes= moveShapes.findAll(function(shape){ return shape instanceof ORYX.Core.Node && shape.dockers.length == 1}).collect(function(shape){ return {docker:shape.dockers[0], dockedShape:shape.dockers[0].getDockedShape(), refPoint:shape.dockers[0].referencePoint} });
	},			
	execute: function(){
		this.dockAllShapes()				
		// Moves by the offset
		this.move( this.offset);
		// Addes to the new parents
		this.addShapeToParent( this.newParents ); 
		
		if (this.plugin.isConnectingAllowed) {
			this.connectTogether();
		}
		
		// Set the selection to the current selection
		this.selectCurrentShapes();
		this.plugin.facade.getCanvas().update();
		this.plugin.facade.updateSelection();
		
		this.firstExecution = true;
	},
	rollback: function(){
		// Moves by the inverted offset
		var offset = { x:-this.offset.x, y:-this.offset.y };
		this.move( offset );
		// Addes to the old parents
		this.addShapeToParent( this.oldParents ); 
		this.dockAllShapes(true)	
		this.rollbackConnectTogether();
		
		// Set the selection to the current selection
		this.selectCurrentShapes();
		this.plugin.facade.getCanvas().update();
		this.plugin.facade.updateSelection();
		
	},
	
	rollbackConnectTogether: function(){
		if (this.edge){
				
			// Reset the dockers
			this.removeAllDocker(this.parent);
			this.dockerPosition.each(function(pos, i){	
				if (i==0||i==this.dockerPosition.length-1){ return }					
				var docker = this.parent.createDocker(undefined, pos);
				docker.bounds.centerMoveTo(pos);
			}.bind(this));
			
			// Reset the last docker
			this.parent.getDockers().last().setDockedShape(this.edge.getTarget());
			this.parent.getDockers().last().setReferencePoint(this.edge.dockers.last().referencePoint);
			
			// Remove the new edge
			this.plugin.facade.deleteShape(this.edge);
		
		}
	},
	
	connectTogether: function(){
		var element	= this.moveShapes[0];
		var refEdge	= this.parent;
		var from 	= refEdge.getSource();
		var to 		= refEdge.getTarget();
		var edge;
		if (this.edge) {
			edge = this.edge;
			this.plugin.facade.getCanvas().add(this.edge);
		} else {
			edge = this.plugin.facade.createShape({
				namespace	: refEdge.getStencil().namespace(),
				type		: refEdge.getStencil().id()
			});
		}
		
		var layoutingRequired = false;
		refEdge.getDockers().each(function(docker) {
			var point = docker.getAbsoluteReferencePoint() || docker.bounds.center();
			if(element.bounds.isIncluded(point)) {
				layoutingRequired = true;
				throw $break;
			}
		}.bind(this));
		
		var mid 	= {x:element.bounds.width()/2,y:element.bounds.height()/2};
		var refTo 	= refEdge.getDockers().last().referencePoint;
		
		var segment = refEdge.findSegment(element.absoluteCenterXY());
		var dockers = refEdge.dockers.slice(refEdge.dockers.indexOf(segment.toDocker), refEdge.dockers.length-1);
		
		
		refEdge.getDockers().last().setDockedShape(element);
		refEdge.getDockers().last().setReferencePoint(mid);
		
		edge.getDockers().first().setDockedShape(element);
		edge.getDockers().first().setReferencePoint(mid);
		edge.getDockers().last().setDockedShape(to);
		edge.getDockers().last().setReferencePoint(refTo);

		this.dockerPosition = refEdge.getDockers().map(function(docker){ return docker.bounds.center() });
		
		// Remove dockers from the old shape
		var count = 0;
		dockers.each(function(docker){
			refEdge.removeDocker(docker);
			if(!layoutingRequired && !this.edge) edge.createDocker(1+count, docker.bounds.center());
			count++;
		}.bind(this));
		
		if(layoutingRequired) {
			// Layout edges
			this.plugin.doLayout(refEdge);
			this.plugin.doLayout(edge);
		}
		
		this.edge = edge;
	},
	
	removeAllDocker: function(edge){
		edge.dockers.slice(1, edge.dockers.length-1).each(function(docker){
			edge.removeDocker(docker);
		})
	},
	
	move:function(offset, doLayout){
		
		// Move all Shapes by these offset
		for(var i=0; i<this.moveShapes.length ;i++){
			var value = this.moveShapes[i];					
			value.bounds.moveBy(offset);
			
			if (value instanceof ORYX.Core.Node) {
				
				(value.dockers||[]).each(function(d){
					d.bounds.moveBy(offset);
				})
				
				// Update all Dockers of Child shapes
				/*var childShapesNodes = value.getChildShapes(true).findAll(function(shape){ return shape instanceof ORYX.Core.Node });							
				var childDockedShapes = childShapesNodes.collect(function(shape){ return shape.getAllDockedShapes() }).flatten().uniq();							
				var childDockedEdge = childDockedShapes.findAll(function(shape){ return shape instanceof ORYX.Core.Edge });							
				childDockedEdge = childDockedEdge.findAll(function(shape){ return shape.getAllDockedShapes().all(function(dsh){ return childShapesNodes.include(dsh) }) });							
				var childDockedDockers = childDockedEdge.collect(function(shape){ return shape.dockers }).flatten();
				
				for (var j = 0; j < childDockedDockers.length; j++) {
					var docker = childDockedDockers[j];
					if (!docker.getDockedShape() && !this.moveShapes.include(docker)) {
						//docker.bounds.moveBy(offset);
						//docker.update();
					}
				}*/
				
				if (!this.firstExecution){				
					var allEdges = [].concat(value.getIncomingShapes())
						.concat(value.getOutgoingShapes())
						// Remove all edges which are included in the selection from the list
						.findAll(function(r){ return	r instanceof ORYX.Core.Edge && !this.moveShapes.any(function(d){ return d == r || (d instanceof ORYX.Core.Controls.Docker && d.parent == r)}) }.bind(this))
						// Remove all edges which are between the node and a node contained in the selection from the list
						.findAll(function(r){ return 	(r.dockers.first().getDockedShape() == value || !this.moveShapes.include(r.dockers.first().getDockedShape())) &&  
														(r.dockers.last().getDockedShape() == value || !this.moveShapes.include(r.dockers.last().getDockedShape()))}.bind(this))
														
					// Layout all outgoing/incoming edges
					this.plugin.layoutEdges(value, allEdges, offset);
				}

				
				
				var allSameEdges = [].concat(value.getIncomingShapes())
					.concat(value.getOutgoingShapes())
					.uniq()
					// Remove all edges which are included in the selection from the list
					.findAll(function(r){ return r instanceof ORYX.Core.Edge && r.dockers.first().isDocked() && r.dockers.last().isDocked() && !this.moveShapes.include(r) && !this.moveShapes.any(function(d){ return d == r || (d instanceof ORYX.Core.Controls.Docker && d.parent == r)}) }.bind(this))
					// Remove all edges which are included in the selection from the list
					.findAll(function(r){ return this.moveShapes.indexOf(r.dockers.first().getDockedShape()) > i ||  this.moveShapes.indexOf(r.dockers.last().getDockedShape()) > i}.bind(this))

				for (var j = 0; j < allSameEdges.length; j++) {
					for (var k = 1; k < allSameEdges[j].dockers.length-1; k++) {
						var docker = allSameEdges[j].dockers[k];
						if (!docker.getDockedShape() && !this.moveShapes.include(docker) && !this.moveShapes.include(docker.parent)) {
							docker.bounds.moveBy(offset);
						}
					}
				}	
			}
		}
										
	},
	dockAllShapes: function(shouldDocked){
		// Undock all Nodes
		for (var i = 0; i < this.dockedNodes.length; i++) {
			var docker = this.dockedNodes[i].docker;
			
			docker.setDockedShape( shouldDocked ? this.dockedNodes[i].dockedShape : undefined )
			if (docker.getDockedShape()) {
				docker.setReferencePoint(this.dockedNodes[i].refPoint);
				//docker.update();
			}
		}
	},
	
	addShapeToParent:function( parents ){
		
		// For every Shape, add this and reset the position		
		for(var i=0; i<this.moveShapes.length ;i++){
			var currentShape = this.moveShapes[i];
			if(currentShape instanceof ORYX.Core.Node &&
			   currentShape.parent !== parents[i]) {
				
				// Calc the new position
				var unul = parents[i].absoluteXY();
				var csul = currentShape.absoluteXY();
				var x = csul.x - unul.x;
				var y = csul.y - unul.y;

				// Add the shape to the new contained shape
				parents[i].add(currentShape);
				// Add all attached shapes as well
				currentShape.getOutgoingShapes((function(shape) {
					if(shape instanceof ORYX.Core.Node && !this.moveShapes.member(shape)) {
						parents[i].add(shape);
					}
				}).bind(this));

				// Set the new position
				if(currentShape instanceof ORYX.Core.Node && currentShape.dockers.length == 1){
					var b = currentShape.bounds;
					x += b.width()/2;y += b.height()/2
					currentShape.dockers.first().bounds.centerMoveTo(x, y);
				} else {
					currentShape.bounds.moveTo(x, y);
				}
				
			} 
			
			// Update the shape
			//currentShape.update();
			
		}
	},
	selectCurrentShapes:function(){
		this.plugin.facade.setSelection( this.selectedShapes );
	}
});
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object(); 

ORYX.Plugins.ShapeHighlighting = Clazz.extend({

	construct: function(facade) {
		
		this.parentNode = facade.getCanvas().getSvgContainer();
		
		// The parent Node
		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parentNode,
					['g']);

		this.highlightNodes = {};
		
		facade.registerOnEvent(ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, this.setHighlight.bind(this));
		facade.registerOnEvent(ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, this.hideHighlight.bind(this));		

	},

	setHighlight: function(options) {
		if(options && options.highlightId){
			var node = this.highlightNodes[options.highlightId];
			
			if(!node){
				node= ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,
					['path', {
						"stroke-width": 2.0, "fill":"none"
						}]);	
			
				this.highlightNodes[options.highlightId] = node;
			}

			if(options.elements && options.elements.length > 0) {
				
				this.setAttributesByStyle( node, options );
				this.show(node);
			
			} else {
			
				this.hide(node);			
			
			}
			
		}
	},
	
	hideHighlight: function(options) {
		if(options && options.highlightId && this.highlightNodes[options.highlightId]){
			this.hide(this.highlightNodes[options.highlightId]);
		}		
	},
	
	hide: function(node) {
		node.setAttributeNS(null, 'display', 'none');
	},

	show: function(node) {
		node.setAttributeNS(null, 'display', '');
	},
	
	setAttributesByStyle: function( node, options ){
		
		// If the style say, that it should look like a rectangle
		if( options.style && options.style == ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE ){
			
			// Set like this
			var bo = options.elements[0].absoluteBounds();
			
			var strWidth = options.strokewidth ? options.strokewidth 	: ORYX.CONFIG.BORDER_OFFSET
			
			node.setAttributeNS(null, "d", this.getPathRectangle( bo.a, bo.b , strWidth ) );
			node.setAttributeNS(null, "stroke", 		options.color 		? options.color 		: ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);
			node.setAttributeNS(null, "stroke-opacity", options.opacity 	? options.opacity 		: 0.2);
			node.setAttributeNS(null, "stroke-width", 	strWidth);
						
		} else if(options.elements.length == 1 
					&& options.elements[0] instanceof ORYX.Core.Edge &&
					options.highlightId != "selection") {
			
			/* Highlight containment of edge's childs */
			node.setAttributeNS(null, "d", this.getPathEdge(options.elements[0].dockers));
			node.setAttributeNS(null, "stroke", options.color ? options.color : ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);
			node.setAttributeNS(null, "stroke-opacity", options.opacity ? options.opacity : 0.2);
			node.setAttributeNS(null, "stroke-width", 	ORYX.CONFIG.OFFSET_EDGE_BOUNDS);
			
		}else {
			// If not, set just the corners
			node.setAttributeNS(null, "d", this.getPathByElements(options.elements));
			node.setAttributeNS(null, "stroke", options.color ? options.color : ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);
			node.setAttributeNS(null, "stroke-opacity", options.opacity ? options.opacity : 1.0);
			node.setAttributeNS(null, "stroke-width", 	options.strokewidth ? options.strokewidth 	: 2.0);
						
		}
	},
	
	getPathByElements: function(elements){
		if(!elements || elements.length <= 0) {return undefined}
		
		// Get the padding and the size
		var padding = ORYX.CONFIG.SELECTED_AREA_PADDING;
		
		var path = ""
		
		// Get thru all Elements
		elements.each((function(element) {
			if(!element) {return}
			// Get the absolute Bounds and the two Points
			var bounds = element.absoluteBounds();
			bounds.widen(padding)
			var a = bounds.upperLeft();
			var b = bounds.lowerRight();
			
			path = path + this.getPath(a ,b);
												
		}).bind(this));

		return path;
		
	},

	getPath: function(a, b){
				
		return this.getPathCorners(a, b);
	
	},
			
	getPathCorners: function(a, b){

		var size = ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE;
				
		var path = ""

		// Set: Upper left 
		path = path + "M" + a.x + " " + (a.y + size) + " l0 -" + size + " l" + size + " 0 ";
		// Set: Lower left
		path = path + "M" + a.x + " " + (b.y - size) + " l0 " + size + " l" + size + " 0 ";
		// Set: Lower right
		path = path + "M" + b.x + " " + (b.y - size) + " l0 " + size + " l-" + size + " 0 ";
		// Set: Upper right
		path = path + "M" + b.x + " " + (a.y + size) + " l0 -" + size + " l-" + size + " 0 ";
		
		return path;
	},
	
	getPathRectangle: function(a, b, strokeWidth){

		var size = ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE;

		var path 	= ""
		var offset 	= strokeWidth / 2.0;
		 
		// Set: Upper left 
		path = path + "M" + (a.x + offset) + " " + (a.y);
		path = path + " L" + (a.x + offset) + " " + (b.y - offset);
		path = path + " L" + (b.x - offset) + " " + (b.y - offset);
		path = path + " L" + (b.x - offset) + " " + (a.y + offset);
		path = path + " L" + (a.x + offset) + " " + (a.y + offset);

		return path;
	},
	
	getPathEdge: function(edgeDockers) {
		var length = edgeDockers.length;
		var path = "M" + edgeDockers[0].bounds.center().x + " " 
					+  edgeDockers[0].bounds.center().y;
		
		for(i=1; i<length; i++) {
			var dockerPoint = edgeDockers[i].bounds.center();
			path = path + " L" + dockerPoint.x + " " +  dockerPoint.y;
		}
		
		return path;
	}
	
});

 
ORYX.Plugins.HighlightingSelectedShapes = Clazz.extend({

	construct: function(facade) {
		this.facade = facade;
		this.opacityFull = 0.9;
		this.opacityLow = 0.4;

		// Register on Dragging-Events for show/hide of ShapeMenu
		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_START, this.hide.bind(this));
		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_END,  this.show.bind(this));		
	},

	/**
	 * On the Selection-Changed
	 *
	 */
	onSelectionChanged: function(event) {
		if(event.elements && event.elements.length > 1) {
			this.facade.raiseEvent({
										type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 
										highlightId:'selection',
										elements:	event.elements.without(event.subSelection),
										color:		ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR,
										opacity: 	!event.subSelection ? this.opacityFull : this.opacityLow
									});

			if(event.subSelection){
				this.facade.raiseEvent({
											type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 
											highlightId:'subselection',
											elements:	[event.subSelection],
											color:		ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR,
											opacity: 	this.opacityFull
										});	
			} else {
				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'subselection'});				
			}						
			
		} else {
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'selection'});
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'subselection'});
		}		
	}
});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.DragDocker = Clazz.extend({

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;
		
		// Set the valid and invalid color
		this.VALIDCOLOR 	= ORYX.CONFIG.SELECTION_VALID_COLOR;
		this.INVALIDCOLOR 	= ORYX.CONFIG.SELECTION_INVALID_COLOR;
		
		// Define Variables 
		this.shapeSelection = undefined;
		this.docker 		= undefined;
		this.dockerParent   = undefined;
		this.dockerSource 	= undefined;
		this.dockerTarget 	= undefined;
		this.lastUIObj 		= undefined;
		this.isStartDocker 	= undefined;
		this.isEndDocker 	= undefined;
		this.undockTreshold	= 10;
		this.initialDockerPosition = undefined;
		this.outerDockerNotMoved = undefined;
		this.isValid 		= false;
		this.scrollRect		= new ORYX.Core.SelectedRect(this.facade.getCanvas().getSvgContainer(), {});
		
		// For the Drag and Drop
		// Register on MouseDown-Event on a Docker
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DOCKERDRAG, this.handleDockerDrag.bind(this));

		// Register on over/out to show / hide a docker
		if (!Ext.isIPad){
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOVER, this.handleMouseOver.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOUT, this.handleMouseOut.bind(this));		
		}
		
		this.selectedDockers = [];
	},
	
	/**
	 * Show the docker permanent if selected
	 *
	 */
	onSelectionChanged: function(selection){
		
		// Dont do anything while dragging
		if (this.docker){ return; }
		
		// Get the selected dockers
		var selectedDockers = this.facade.getSelection().map(function(node){ return node instanceof ORYX.Core.Edge ? node.dockers : [] }).flatten();
		
		
		// Hide/show the (none)selected dockers 
		this.selectedDockers.invoke("preventHiding", false);
		selectedDockers.invoke("preventHiding", true);
		selectedDockers.invoke("show");
		this.selectedDockers.invoke("hide");
		this.selectedDockers = selectedDockers;
	},
	
	/**
	 * MouseOut Handler
	 *
	 */
	handleMouseOut: function(event, uiObj) {
		// If there is a Docker, hide this
		if(!this.docker && uiObj instanceof ORYX.Core.Controls.Docker) {
			uiObj.hide()	
		} else if(!this.docker && uiObj instanceof ORYX.Core.Edge) {
			uiObj.dockers.invoke("hide");
		}
	},

	/**
	 * MouseOver Handler
	 *
	 */
	handleMouseOver: function(event, uiObj) {
		// If there is a Docker, show this		
		if(!this.docker && uiObj instanceof ORYX.Core.Controls.Docker) {
			uiObj.show()	
		} else if(!this.docker && uiObj instanceof ORYX.Core.Edge) {
			uiObj.dockers.each(function(docker){
				docker.show();
			})
		}
	},
	/**
	 * DockerDrag Handler
	 * delegates the uiEvent of the drag event to the mouseDown function
	 */
	handleDockerDrag: function(event, uiObj) {
		this.handleMouseDown(event.uiEvent, uiObj);
	},
	
	/**
	 * MouseDown Handler
	 *
	 */	
	handleMouseDown: function(event, uiObj) {
		// If there is a Docker
		if(uiObj instanceof ORYX.Core.Controls.Docker && uiObj.isMovable) {
			
			/* Buffering shape selection and clear selection*/
			this.shapeSelection = this.facade.getSelection();
			this.facade.setSelection(this.shapeSelection.without(uiObj.parent));
			
			this.docker = uiObj;
			this.initialDockerPosition = this.docker.bounds.center();
			this.outerDockerNotMoved = false;			
			this.dockerParent = uiObj.parent;
			
			// Define command arguments
			this._commandArg = {docker:uiObj, dockedShape:uiObj.getDockedShape(), refPoint:uiObj.referencePoint || uiObj.bounds.center()};

			// Show the Docker
			this.docker.show();
			
			// If the Dockers Parent is an Edge, 
			//  and the Docker is either the first or last Docker of the Edge
			if(uiObj.parent instanceof ORYX.Core.Edge && 
			   	(uiObj.parent.dockers.first() == uiObj || uiObj.parent.dockers.last() == uiObj)) {
				
				// Get the Edge Source or Target
				if(uiObj.parent.dockers.first() == uiObj && uiObj.parent.dockers.last().getDockedShape()) {
					this.dockerTarget = uiObj.parent.dockers.last().getDockedShape()
				} else if(uiObj.parent.dockers.last() == uiObj && uiObj.parent.dockers.first().getDockedShape()) {
					this.dockerSource = uiObj.parent.dockers.first().getDockedShape()
				}
				
			} else {
				// If there parent is not an Edge, undefined the Source and Target
				this.dockerSource = undefined;
				this.dockerTarget = undefined;				
			}
		
			this.isStartDocker = this.docker.parent.dockers.first() === this.docker
			this.isEndDocker = this.docker.parent.dockers.last() === this.docker
					
			// add to canvas while dragging
			this.facade.getCanvas().add(this.docker.parent);
			
			// Hide all Labels from Docker
			this.docker.parent.getLabels().each(function(label) {
				label.hide();
			});
			
			// Undocked the Docker from current Shape
			if ((!this.isStartDocker && !this.isEndDocker) || !this.docker.isDocked()) {
				
				this.docker.setDockedShape(undefined)
				// Set the Docker to the center of the mouse pointer
				var evPos = this.facade.eventCoordinates(event);
				
				this.docker.bounds.centerMoveTo(evPos);
				//this.docker.update()
				//this.facade.getCanvas().update();
				this.dockerParent._update();
			} else {
				this.outerDockerNotMoved = true;
			}
			
			var option = {movedCallback: this.dockerMoved.bind(this, this.facade.getCanvas()), upCallback: this.dockerMovedFinished.bind(this)}
				
			// Enable the Docker for Drag'n'Drop, give the mouseMove and mouseUp-Callback with
			ORYX.Core.UIEnableDrag(event, uiObj, option);
		}
	},
	
	/**
	 * Docker MouseMove Handler
	 *
	 */
	dockerMoved: function(canvas, event) {
		this.outerDockerNotMoved = false;
		var snapToMagnet = undefined;
		
		if (!this.docker){ return; }
		
		if (this.docker.parent) {
			if (this.isStartDocker || this.isEndDocker) {
			
				// Get the EventPosition and all Shapes on these point
				var evPos = this.facade.eventCoordinates(event);
								
				if(this.docker.isDocked()) {
					/* Only consider start/end dockers if they are moved over a treshold */
					var distanceDockerPointer = 
						ORYX.Core.Math.getDistancePointToPoint(evPos, this.initialDockerPosition);
					if(distanceDockerPointer < this.undockTreshold) {
						this.outerDockerNotMoved = true;
						return;
					}
					
					/* Undock the docker */
					this.docker.setDockedShape(undefined)
					// Set the Docker to the center of the mouse pointer
					//this.docker.bounds.centerMoveTo(evPos);
					this.dockerParent._update();
				}
				
				var shapes = this.facade.getCanvas().getAbstractShapesAtPosition(evPos), 
					rules = this.facade.getRules();
				
				// Get the top level Shape on these, but not the same as Dockers parent
				var uiObj = shapes.pop();
				if (this.docker.parent === uiObj) {
					uiObj = shapes.pop();
				}
				
				
				while (shapes.length > 0 && 
						
						// Don't use uiObj which is not a container
						(!rules.isContainable(uiObj) || 
						
						/* Check if the source or target shape is the 
						 * child of the found shape, than use the canvas
						 * instead. Connecting to a parent shape doesn't
						 * make any sense.
						 */
						 //zhaofx	允许从自己连线到自己
						(this.dockerSource!==uiObj && this.dockerSource && this.dockerSource.isParent(uiObj)) ||
						(this.dockerTarget!==uiObj && this.dockerTarget && this.dockerTarget.isParent(uiObj)))){
					
					uiObj = shapes.pop();
				}
				
				
				
				
				// If the top level Shape the same as the last Shape, then return
				if (this.lastUIObj == uiObj) {
				//return;
				
				// If the top level uiObj instance of Shape and this isn't the parent of the docker 
				}
				else 
					if (uiObj instanceof ORYX.Core.Shape) {
					
						// Get the StencilSet of the Edge
						var sset = this.docker.parent.getStencil().stencilSet();
						
						// Ask by the StencilSet if the source, the edge and the target valid connections.
						if (this.docker.parent instanceof ORYX.Core.Edge) {
							
							var highestParent = this.getHighestParentBeforeCanvas(uiObj);
							/* Ensure that the shape to dock is not a child shape 
							 * of the same edge.
							 */
							if(highestParent instanceof ORYX.Core.Edge 
									&& this.docker.parent === highestParent) {
								this.isValid = false;
								this.dockerParent._update();
								return;
							}
							this.isValid = false;
													
							var curObj = uiObj, orgObj = uiObj;
							while(!this.isValid && curObj && !(curObj instanceof ORYX.Core.Canvas)){
								uiObj = curObj;
								this.isValid = this.facade.getRules().canConnect({
											sourceShape: this.dockerSource ? // Is there a docked source 
															this.dockerSource : // than set this
															(this.isStartDocker ? // if not and if the Docker is the start docker
																uiObj : // take the last uiObj
																undefined), // if not set it to undefined;
											edgeShape: this.docker.parent,
											targetShape: this.dockerTarget ? // Is there a docked target 
											this.dockerTarget : // than set this
														(this.isEndDocker ? // if not and if the Docker is not the start docker
															uiObj : // take the last uiObj
															undefined) // if not set it to undefined;
										});
								curObj = curObj.parent;
							}
							
							// Reset uiObj if no 
							// valid parent is found
							if (!this.isValid){
								uiObj = orgObj;
							}

						}
						else {
							this.isValid = this.facade.getRules().canConnect({
								sourceShape: uiObj,
								edgeShape: this.docker.parent,
								targetShape: this.docker.parent
							});
						}
						
						// If there is a lastUIObj, hide the magnets
						if (this.lastUIObj) {
							this.hideMagnets(this.lastUIObj)
						}
						
						// If there is a valid connection, show the magnets
						if (this.isValid) {
							this.showMagnets(uiObj)
						}
						
						// Set the Highlight Rectangle by these value
						this.showHighlight(uiObj, this.isValid ? this.VALIDCOLOR : this.INVALIDCOLOR);
						
						// Buffer the current Shape
						this.lastUIObj = uiObj;
					}
					else {
						// If there is no top level Shape, then hide the highligting of the last Shape
						this.hideHighlight();
						this.lastUIObj ? this.hideMagnets(this.lastUIObj) : null;
						this.lastUIObj = undefined;
						this.isValid = false;
					}
				
				// Snap to the nearest Magnet
				if (this.lastUIObj && this.isValid && !(event.shiftKey || event.ctrlKey)) {
					snapToMagnet = this.lastUIObj.magnets.find(function(magnet){
						return magnet.absoluteBounds().isIncluded(evPos)
					});
					
					if (snapToMagnet) {
						this.docker.bounds.centerMoveTo(snapToMagnet.absoluteCenterXY());
					//this.docker.update()
					}
				}
			}
		}
		// Snap to on the nearest Docker of the same parent
		if(!(event.shiftKey || event.ctrlKey) && !snapToMagnet) {
			var minOffset = ORYX.CONFIG.DOCKER_SNAP_OFFSET;
			var nearestX = minOffset + 1;
			var nearestY = minOffset + 1;
			
			var dockerCenter = this.docker.bounds.center();
			
			if (this.docker.parent) {
				
				this.docker.parent.dockers.each((function(docker){
					if (this.docker == docker) {
						return
					};
					
					var center = docker.referencePoint ? docker.getAbsoluteReferencePoint() : docker.bounds.center();
					
					nearestX = Math.abs(nearestX) > Math.abs(center.x - dockerCenter.x) ? center.x - dockerCenter.x : nearestX;
					nearestY = Math.abs(nearestY) > Math.abs(center.y - dockerCenter.y) ? center.y - dockerCenter.y : nearestY;
					
					
				}).bind(this));
				
				if (Math.abs(nearestX) < minOffset || Math.abs(nearestY) < minOffset) {
					nearestX = Math.abs(nearestX) < minOffset ? nearestX : 0;
					nearestY = Math.abs(nearestY) < minOffset ? nearestY : 0;
					
					this.docker.bounds.centerMoveTo(dockerCenter.x + nearestX, dockerCenter.y + nearestY);
					//this.docker.update()
				} else {
					
					
					
					var previous = this.docker.parent.dockers[Math.max(this.docker.parent.dockers.indexOf(this.docker)-1, 0)]
					var next = this.docker.parent.dockers[Math.min(this.docker.parent.dockers.indexOf(this.docker)+1, this.docker.parent.dockers.length-1)]
					
					if (previous && next && previous !== this.docker && next !== this.docker){
						var cp = previous.bounds.center();
						var cn = next.bounds.center();
						var cd = this.docker.bounds.center();
						
						// Checks if the point is on the line between previous and next
						if (ORYX.Core.Math.isPointInLine(cd.x, cd.y, cp.x, cp.y, cn.x, cn.y, 10)) {
							// Get the rise
							var raise = (Number(cn.y)-Number(cp.y))/(Number(cn.x)-Number(cp.x));
							// Calculate the intersection point
							var intersecX = ((cp.y-(cp.x*raise))-(cd.y-(cd.x*(-Math.pow(raise,-1)))))/((-Math.pow(raise,-1))-raise);
							var intersecY = (cp.y-(cp.x*raise))+(raise*intersecX);
							
							if(isNaN(intersecX) || isNaN(intersecY)) {return;}
							
							this.docker.bounds.centerMoveTo(intersecX, intersecY);
						}
					}
					
				}
			}
		}
		
		var dockerCenter = this.docker.bounds.center();
		var canvasHeight = canvas.bounds.height();
		var canvasWidth = canvas.bounds.width();
		var offset = 7,x = dockerCenter.x,y = dockerCenter.y;
	
		//correct position if docker is moved out of the canvas
		if (dockerCenter.x < offset || dockerCenter.x > canvasWidth - offset){
			x = dockerCenter.x < offset ? offset : canvasWidth - offset
		}
		if (dockerCenter.y < offset || dockerCenter.y > canvasHeight - offset){
			y = dockerCenter.y < offset ? offset : canvasHeight - offset;
		}
		
		this.docker.bounds.centerMoveTo(x, y);

		//this.facade.getCanvas().update();
		this.dockerParent._update();
		
				
		// Scroll docker into the view
		// Use the implementation of the selected rect
		this.scrollRect.scrollIntoView(event);
	},

	/**
	 * Docker MouseUp Handler
	 *
	 */
	dockerMovedFinished: function(event) {
		
		// Check if all is still available
		if (!this.dockerParent){ return; }
		
		/* Reset to buffered shape selection */
		this.facade.setSelection(this.shapeSelection);
		
		// Hide the border
		this.hideHighlight();
		
		// Show all Labels from Docker
		this.dockerParent.getLabels().each(function(label){
			label.show();
			//label.update();
		});
	
		// If there is a last top level Shape
		if(this.lastUIObj && (this.isStartDocker || this.isEndDocker)){				
			// If there is a valid connection, the set as a docked Shape to them
			if(this.isValid) {
				
				this.docker.setDockedShape(this.lastUIObj);	
				
				this.facade.raiseEvent({
					type 	: ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, 
					docker	: this.docker,
					parent	: this.docker.parent,
					target	: this.lastUIObj
				});
			}
			
			this.hideMagnets(this.lastUIObj)
		}
		
		// Hide the Docker
		if (!this.selectedDockers.include(this.docker))
			this.docker.hide();
		
		if(this.outerDockerNotMoved) {
			// Get the EventPosition and all Shapes on these point
			var evPos = this.facade.eventCoordinates(event);
			
			var shapes = this.facade.getCanvas().getAbstractShapesAtPosition(evPos);
			
			/* Remove edges from selection */
			var shapeWithoutEdges = shapes.findAll(function(node) {
				return node instanceof ORYX.Core.Node;
			});
			shapes = shapeWithoutEdges.length ? shapeWithoutEdges : shapes;
			this.facade.setSelection([shapes.last()]);
		} else {
			//Command-Pattern for dragging one docker
			var dragDockerCommand = ORYX.Core.Command.extend({
				construct: function(docker, newPos, oldPos, newDockedShape, oldDockedShape, facade){
					this.docker 		= docker;
					this.index			= docker.parent.dockers.indexOf(docker);
					this.newPosition	= newPos;
					this.newDockedShape = newDockedShape;
					this.oldPosition	= oldPos;
					this.oldDockedShape	= oldDockedShape;
					this.facade			= facade;
					this.index			= docker.parent.dockers.indexOf(docker);
					this.shape			= docker.parent;
					
				},			
				execute: function(){
					if (!this.docker.parent){
						this.docker = this.shape.dockers[this.index];
					}
					this.removedDockers = this.shape.removeUnusedDockers();
					this.dock( this.newDockedShape, this.newPosition );
					this.facade.updateSelection();
				},
				rollback: function(){
					(this.removedDockers||$H({})).each(function(d){
						this.shape.add(d.value, Number(d.key));
						this.shape._update(true);
					}.bind(this))
					this.dock( this.oldDockedShape, this.oldPosition );
					this.facade.updateSelection();
				},
				dock:function( toDockShape, pos ){			
					// Set the Docker to the new Shape
					this.docker.setDockedShape( undefined );
					if( toDockShape ){			
						this.docker.setDockedShape( toDockShape );	
						this.docker.setReferencePoint( pos );
						this.docker.bounds.centerMoveTo( pos );
						this.shape._update(true);
					} else {
						this.docker.bounds.centerMoveTo( pos );
					}
					//this.facade.getCanvas().update();		
				}
			});
			
			
			if (this.docker.parent){
				// Instanziate the dockCommand
				var command = new dragDockerCommand(this.docker, this.docker.getDockedShape() ? this.docker.referencePoint : this.docker.bounds.center(), this._commandArg.refPoint, this.docker.getDockedShape(), this._commandArg.dockedShape, this.facade);
				this.facade.executeCommands( [command] );	
			}
		}
		
	

		

		// Update all Shapes
		//this.facade.updateSelection();
			
		// Undefined all variables
		this.docker 		= undefined;
		this.dockerParent   = undefined;
		this.dockerSource 	= undefined;
		this.dockerTarget 	= undefined;	
		this.lastUIObj 		= undefined;		
	},
	
	/**
	 * Hide the highlighting
	 */
	hideHighlight: function() {
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'validDockedShape'});
	},

	/**
	 * Show the highlighting
	 *
	 */
	showHighlight: function(uiObj, color) {
		
		this.facade.raiseEvent({
										type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 
										highlightId:'validDockedShape',
										elements:	[uiObj],
										color:		color
									});
	},
	
	showMagnets: function(uiObj){
		uiObj.magnets.each(function(magnet) {
			magnet.show();
		});
	},
	
	hideMagnets: function(uiObj){
		uiObj.magnets.each(function(magnet) {
			magnet.hide();
		});
	},
	
	getHighestParentBeforeCanvas: function(shape) {
		if(!(shape instanceof ORYX.Core.Shape)) {return undefined;}
		
		var parent = shape.parent;
		while(parent && !(parent.parent instanceof ORYX.Core.Canvas)) {
			parent = parent.parent;
		}	
		
		return parent;		
	}	

});

/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

 ORYX.Plugins.SelectionFrame = Clazz.extend({

	construct: function(facade) {
		this.facade = facade;

		// Register on MouseEvents
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));
		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.handleMouseUp.bind(this), true);

		// Some initiale variables
		this.position 		= {x:0, y:0};
		this.size 			= {width:0, height:0};
		this.offsetPosition = {x: 0, y: 0}
		
		this.scrollRect		= new ORYX.Core.SelectedRect(this.facade.getCanvas().getSvgContainer(), {});
		
		// (Un)Register Mouse-Move Event
		this.moveCallback 	= undefined;
		this.offsetScroll	= {x:0,y:0}
		// HTML-Node of Selection-Frame
		this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.facade.getCanvas().getHTMLContainer(),
			['div', {'class':'Oryx_SelectionFrame'}]);

		this.hide();
	},

	handleMouseDown: function(event, uiObj) {
		// If there is the Canvas
		if( uiObj instanceof ORYX.Core.Canvas ) {
			// Calculate the Offset
			var scrollNode = uiObj.rootNode.parentNode.parentNode;
						
			var a = this.facade.getCanvas().node.getScreenCTM();
			if (Ext.isIE9){ // Workaround for IE9, it doesnt get those values correctly
				var sn = Ext.fly(this.facade.getCanvas().getScrollNode().firstChild);
				a.e = sn.getLeft()+4;
				a.f = sn.getTop()+4;
			}
			
			this.offsetPosition = {
				x: a.e,
				y: a.f
			}

			// Set the new Position
			this.setPos({x: Event.pointerX(event)-this.offsetPosition.x, y:Event.pointerY(event)-this.offsetPosition.y});
			// Reset the size
			this.resize({width:0, height:0});
			this.moveCallback = this.handleMouseMove.bind(this);
		
			// Register Mouse-Move Event
			document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.moveCallback, false);

			this.offsetScroll		= {x:scrollNode.scrollLeft,y:scrollNode.scrollTop};
			
			// Show the Frame
			this.show();
			
			

		}

		Event.stop(event);
	},

	handleMouseUp: function(event) {
		// If there was an MouseMoving
		if(this.moveCallback) {
			// Hide the Frame
			this.hide();

			// Unregister Mouse-Move
			document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.moveCallback, false);			
		
			this.moveCallback = undefined;

			var corrSVG = this.facade.getCanvas().node.getScreenCTM();

			// Calculate the positions of the Frame
			var a = {
				x: this.size.width > 0 ? this.position.x : this.position.x + this.size.width,
				y: this.size.height > 0 ? this.position.y : this.position.y + this.size.height
			}

			var b = {
				x: a.x + Math.abs(this.size.width),
				y: a.y + Math.abs(this.size.height)
			}

			// Fit to SVG-Coordinates
			a.x /= corrSVG.a; a.y /= corrSVG.d;
			b.x /= corrSVG.a; b.y /= corrSVG.d;


			// Calculate the elements from the childs of the canvas
			var elements = this.facade.getCanvas().getChildShapes(true).findAll(function(value) {
				var absBounds = value.absoluteBounds();
				var bA = absBounds.upperLeft();
				var bB = absBounds.lowerRight();
				if(bA.x > a.x && bA.y > a.y && bB.x < b.x && bB.y < b.y)
					return true;
				return false
			});

			// Set the selection
			this.facade.setSelection(elements);
		}
	},

	handleMouseMove: function(event) {
		// Calculate the size
		var size = {
			width	: Event.pointerX(event) - this.position.x - this.offsetPosition.x,
			height	: Event.pointerY(event) - this.position.y - this.offsetPosition.y
		}

		var scrollNode 	= this.facade.getCanvas().rootNode.parentNode.parentNode;
		size.width 		-= this.offsetScroll.x - scrollNode.scrollLeft; 
		size.height 	-= this.offsetScroll.y - scrollNode.scrollTop;
						
		// Set the size
		this.resize(size);
		
		// Scroll docker into the view
		// Use the implementation of the selected rect
		this.scrollRect.scrollIntoView(event);
		
		Event.stop(event);
	},

	hide: function() {
		this.node.style.display = "none";
	},

	show: function() {
		this.node.style.display = "";
	},

	setPos: function(pos) {
		// Set the Position
		this.node.style.top  = Math.max(pos.y, 0) + "px";
		this.node.style.left = Math.max(pos.x, 0) + "px";
		this.position = pos;
	},

	resize: function(size) {

		var pos = this.position;
		
		this.setPos(Object.clone(pos));
		this.size = Object.clone(size);

		// Calculate the negative offset
		if(size.width < 0) {
			pos.x = pos.x + size.width;
			this.node.style.left = pos.x + "px";
			size.width = - size.width;
		}
		if(size.height < 0) {
			pos.y = pos.y + size.height;
			this.node.style.top = pos.y + "px";
			size.height = - size.height;
		}

		var scrollNode 	= this.facade.getCanvas().rootNode.parentNode,
			wi = scrollNode.offsetWidth,
			hi = scrollNode.offsetHeight;
		
		// Set the size
		this.node.style.width  = Math.min(wi-pos.x, size.width)  + "px";
		this.node.style.height = Math.min(hi-pos.y, size.height) + "px";
	}

});


/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object(); 

ORYX.Plugins.ShapeHighlighting = Clazz.extend({

	construct: function(facade) {
		
		this.parentNode = facade.getCanvas().getSvgContainer();
		
		// The parent Node
		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parentNode,
					['g']);

		this.highlightNodes = {};
		
		facade.registerOnEvent(ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, this.setHighlight.bind(this));
		facade.registerOnEvent(ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, this.hideHighlight.bind(this));		

	},

	setHighlight: function(options) {
		if(options && options.highlightId){
			var node = this.highlightNodes[options.highlightId];
			
			if(!node){
				node= ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,
					['path', {
						"stroke-width": 2.0, "fill":"none"
						}]);	
			
				this.highlightNodes[options.highlightId] = node;
			}

			if(options.elements && options.elements.length > 0) {
				
				this.setAttributesByStyle( node, options );
				this.show(node);
			
			} else {
			
				this.hide(node);			
			
			}
			
		}
	},
	
	hideHighlight: function(options) {
		if(options && options.highlightId && this.highlightNodes[options.highlightId]){
			this.hide(this.highlightNodes[options.highlightId]);
		}		
	},
	
	hide: function(node) {
		node.setAttributeNS(null, 'display', 'none');
	},

	show: function(node) {
		node.setAttributeNS(null, 'display', '');
	},
	
	setAttributesByStyle: function( node, options ){
		
		// If the style say, that it should look like a rectangle
		if( options.style && options.style == ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE ){
			
			// Set like this
			var bo = options.elements[0].absoluteBounds();
			
			var strWidth = options.strokewidth ? options.strokewidth 	: ORYX.CONFIG.BORDER_OFFSET
			
			node.setAttributeNS(null, "d", this.getPathRectangle( bo.a, bo.b , strWidth ) );
			node.setAttributeNS(null, "stroke", 		options.color 		? options.color 		: ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);
			node.setAttributeNS(null, "stroke-opacity", options.opacity 	? options.opacity 		: 0.2);
			node.setAttributeNS(null, "stroke-width", 	strWidth);
						
		} else if(options.elements.length == 1 
					&& options.elements[0] instanceof ORYX.Core.Edge &&
					options.highlightId != "selection") {
			
			/* Highlight containment of edge's childs */
			node.setAttributeNS(null, "d", this.getPathEdge(options.elements[0].dockers));
			node.setAttributeNS(null, "stroke", options.color ? options.color : ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);
			node.setAttributeNS(null, "stroke-opacity", options.opacity ? options.opacity : 0.2);
			node.setAttributeNS(null, "stroke-width", 	ORYX.CONFIG.OFFSET_EDGE_BOUNDS);
			
		}else {
			// If not, set just the corners
			node.setAttributeNS(null, "d", this.getPathByElements(options.elements));
			node.setAttributeNS(null, "stroke", options.color ? options.color : ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);
			node.setAttributeNS(null, "stroke-opacity", options.opacity ? options.opacity : 1.0);
			node.setAttributeNS(null, "stroke-width", 	options.strokewidth ? options.strokewidth 	: 2.0);
						
		}
	},
	
	getPathByElements: function(elements){
		if(!elements || elements.length <= 0) {return undefined}
		
		// Get the padding and the size
		var padding = ORYX.CONFIG.SELECTED_AREA_PADDING;
		
		var path = ""
		
		// Get thru all Elements
		elements.each((function(element) {
			if(!element) {return}
			// Get the absolute Bounds and the two Points
			var bounds = element.absoluteBounds();
			bounds.widen(padding)
			var a = bounds.upperLeft();
			var b = bounds.lowerRight();
			
			path = path + this.getPath(a ,b);
												
		}).bind(this));

		return path;
		
	},

	getPath: function(a, b){
				
		return this.getPathCorners(a, b);
	
	},
			
	getPathCorners: function(a, b){

		var size = ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE;
				
		var path = ""

		// Set: Upper left 
		path = path + "M" + a.x + " " + (a.y + size) + " l0 -" + size + " l" + size + " 0 ";
		// Set: Lower left
		path = path + "M" + a.x + " " + (b.y - size) + " l0 " + size + " l" + size + " 0 ";
		// Set: Lower right
		path = path + "M" + b.x + " " + (b.y - size) + " l0 " + size + " l-" + size + " 0 ";
		// Set: Upper right
		path = path + "M" + b.x + " " + (a.y + size) + " l0 -" + size + " l-" + size + " 0 ";
		
		return path;
	},
	
	getPathRectangle: function(a, b, strokeWidth){

		var size = ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE;

		var path 	= ""
		var offset 	= strokeWidth / 2.0;
		 
		// Set: Upper left 
		path = path + "M" + (a.x + offset) + " " + (a.y);
		path = path + " L" + (a.x + offset) + " " + (b.y - offset);
		path = path + " L" + (b.x - offset) + " " + (b.y - offset);
		path = path + " L" + (b.x - offset) + " " + (a.y + offset);
		path = path + " L" + (a.x + offset) + " " + (a.y + offset);

		return path;
	},
	
	getPathEdge: function(edgeDockers) {
		var length = edgeDockers.length;
		var path = "M" + edgeDockers[0].bounds.center().x + " " 
					+  edgeDockers[0].bounds.center().y;
		
		for(i=1; i<length; i++) {
			var dockerPoint = edgeDockers[i].bounds.center();
			path = path + " L" + dockerPoint.x + " " +  dockerPoint.y;
		}
		
		return path;
	}
	
});

 
ORYX.Plugins.HighlightingSelectedShapes = Clazz.extend({

	construct: function(facade) {
		this.facade = facade;
		this.opacityFull = 0.9;
		this.opacityLow = 0.4;

		// Register on Dragging-Events for show/hide of ShapeMenu
		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_START, this.hide.bind(this));
		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_END,  this.show.bind(this));		
	},

	/**
	 * On the Selection-Changed
	 *
	 */
	onSelectionChanged: function(event) {
		if(event.elements && event.elements.length > 1) {
			this.facade.raiseEvent({
										type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 
										highlightId:'selection',
										elements:	event.elements.without(event.subSelection),
										color:		ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR,
										opacity: 	!event.subSelection ? this.opacityFull : this.opacityLow
									});

			if(event.subSelection){
				this.facade.raiseEvent({
											type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 
											highlightId:'subselection',
											elements:	[event.subSelection],
											color:		ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR,
											opacity: 	this.opacityFull
										});	
			} else {
				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'subselection'});				
			}						
			
		} else {
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'selection'});
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'subselection'});
		}		
	}
});/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * 
 * HOW to USE the OVERLAY PLUGIN:
 * 	You can use it via the event mechanism from the editor
 * 	by using facade.raiseEvent( <option> )
 * 
 * 	As an example please have a look in the overlayexample.js
 * 
 * 	The option object should/have to have following attributes:
 * 
 * 	Key				Value-Type							Description
 * 	================================================================
 * 
 *	type 			ORYX.CONFIG.EVENT_OVERLAY_SHOW | ORYX.CONFIG.EVENT_OVERLAY_HIDE		This is the type of the event	
 *	id				<String>							You have to use an unified id for later on hiding this overlay
 *	shapes 			<ORYX.Core.Shape[]>					The Shapes where the attributes should be changed
 *	attributes 		<Object>							An object with svg-style attributes as key-value pair
 *	node			<SVGElement>						An SVG-Element could be specified for adding this to the Shape
 *	nodePosition	"N"|"NE"|"E"|"SE"|"S"|"SW"|"W"|"NW"|"START"|"END"	The position for the SVG-Element relative to the 
 *														specified Shape. "START" and "END" are just using for a Edges, then
 *														the relation is the start or ending Docker of this edge.
 *	
 * 
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Overlay = Clazz.extend({

    facade: undefined,
	
	styleNode: undefined,
    
    construct: function(facade){
		
        this.facade = facade;

		this.changes = [];

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_OVERLAY_SHOW, this.show.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_OVERLAY_HIDE, this.hide.bind(this));	

		this.styleNode = document.createElement('style')
		this.styleNode.setAttributeNS(null, 'type', 'text/css')
		
		document.getElementsByTagName('head')[0].appendChild( this.styleNode )

    },
	
	/**
	 * Show the overlay for specific nodes
	 * @param {Object} options
	 * 
	 * 	String				options.id		- MUST - Define the id of the overlay (is needed for the hiding of this overlay)		
	 *	ORYX.Core.Shape[] 	options.shapes 	- MUST - Define the Shapes for the changes
	 * 	attr-name:value		options.changes	- Defines all the changes which should be shown
	 * 
	 * 
	 */
	show: function( options ){
		
		// Checks if all arguments are available
		if( 	!options || 
				!options.shapes || !options.shapes instanceof Array ||
				!options.id	|| !options.id instanceof String || options.id.length == 0) { 
				
					return
					
		}
		
		//if( this.changes[options.id]){
		//	this.hide( options )
		//}
			

		// Checked if attributes are setted
		if( options.attributes ){
			
			// FOR EACH - Shape
			options.shapes.each(function(el){
				
				// Checks if the node is a Shape
				if( !el instanceof ORYX.Core.Shape){ return }
				
				this.setAttributes( el.node , options.attributes )
				
			}.bind(this))

		}	
		
		var isSVG = true
		try {
			isSVG = options.node && options.node instanceof SVGElement;
		} catch(e){}
		
		// Checks if node is setted and if this is an SVGElement		
		if ( options.node && isSVG) {
			
			options["_temps"] = []
						
			// FOR EACH - Node
			options.shapes.each(function(el, index){
				
				// Checks if the node is a Shape
				if( !el instanceof ORYX.Core.Shape){ return }
				
				var _temp = {}
				_temp.svg = options.dontCloneNode ? options.node : options.node.cloneNode( true );
				
				// Add the svg node to the ORYX-Shape
				el.node.firstChild.appendChild( _temp.svg )		
				
				// If
				if (el instanceof ORYX.Core.Edge && !options.nodePosition) {
					options['nodePosition'] = "START"
				}
						
				// If the node position is setted, it has to be transformed
				if( options.nodePosition ){
					
					var b = el.bounds;
					var p = options.nodePosition.toUpperCase();
					
					// Check the values of START and END
					if( el instanceof ORYX.Core.Node && p == "START"){
						p = "NW";
					} else if(el instanceof ORYX.Core.Node && p == "END"){
						p = "SE";
					} else if(el instanceof ORYX.Core.Edge && p == "START"){
						b = el.getDockers().first().bounds
					} else if(el instanceof ORYX.Core.Edge && p == "END"){
						b = el.getDockers().last().bounds
					}

					// Create a callback for the changing the position 
					// depending on the position string
					_temp.callback = function(){
						
						var x = 0; var y = 0;
						
						if( p == "NW" ){
							// Do Nothing
						} else if( p == "N" ) {
							x = b.width() / 2;
						} else if( p == "NE" ) {
							x = b.width();
						} else if( p == "E" ) {
							x = b.width(); y = b.height() / 2;
						} else if( p == "SE" ) {
							x = b.width(); y = b.height();
						} else if( p == "S" ) {
							x = b.width() / 2; y = b.height();
						} else if( p == "SW" ) {
							y = b.height();
						} else if( p == "W" ) {
							y = b.height() / 2;
						} else if( p == "START" || p == "END") {
							x = b.width() / 2; y = b.height() / 2;
						} else {
							return
						}
						
						if( el instanceof ORYX.Core.Edge){
							x  += b.upperLeft().x ; y  += b.upperLeft().y ;
						}
						
						if ("object" === typeof options["adjustment"]) {
							var t = options["adjustment"];
							x += (t.x && Number(t.x) ? Number(t.x) : 0);
							y += (t.y && Number(t.y) ? Number(t.y) : 0);
						}
						
						_temp.svg.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")");
					
					}.bind(this)
					
					_temp.element = el;
					_temp.callback();
					
					b.registerCallback( _temp.callback );
					
				}
				
				
				options._temps.push( _temp )	
				
			}.bind(this))
			
			
			
		}		
	

		// Store the changes
		if( !this.changes[options.id] ){
			this.changes[options.id] = [];
		}
		
		this.changes[options.id].push( options );
				
	},
	
	/**
	 * Hide the overlay with the spefic id
	 * @param {Object} options
	 */
	hide: function( options ){
		
		// Checks if all arguments are available
		if( 	!options || 
				!options.id	|| !options.id instanceof String || options.id.length == 0 ||
				!this.changes[options.id]) { 
				
					return
					
		}		
		
		
		// Delete all added attributes
		// FOR EACH - Shape
		this.changes[options.id].each(function(option){
			
			option.shapes.each(function(el, index){
				
				// Checks if the node is a Shape
				if( !el instanceof ORYX.Core.Shape){ return }
				
				this.deleteAttributes( el.node )
							
			}.bind(this));

	
			if( option._temps ){
				
				option._temps.each(function(tmp){
					// Delete the added Node, if there is one
					if( tmp.svg && tmp.svg.parentNode ){
						tmp.svg.parentNode.removeChild( tmp.svg )		
						
					}
		
					// If 
					if( tmp.callback && tmp.element){
						// It has to be unregistered from the edge
						tmp.element.bounds.unregisterCallback( tmp.callback )
					}
							
				}.bind(this))
				
			}
		
			
		}.bind(this));

		
		this.changes[options.id] = null;
		
		
	},
	
	
	/**
	 * Set the given css attributes to that node
	 * @param {HTMLElement} node
	 * @param {Object} attributes
	 */
	setAttributes: function( node, attributes ) {
		
		
		// Get all the childs from ME
		var childs = this.getAllChilds( node.firstChild.firstChild )
		
		var ids = []
		
		// Add all Attributes which have relation to another node in this document and concate the pure id out of it
		// This is for example important for the markers of a edge
		childs.each(function(e){ ids.push( $A(e.attributes).findAll(function(attr){ return attr.nodeValue.startsWith('url(#')}) )})
		ids = ids.flatten().compact();
		ids = ids.collect(function(s){return s.nodeValue}).uniq();
		ids = ids.collect(function(s){return s.slice(5, s.length-1)})
		
		// Add the node ID to the id
		ids.unshift( node.id + ' .me')
		
		var attr				= $H(attributes);
        var attrValue			= attr.toJSON().gsub(',', ';').gsub('"', '');
        var attrMarkerValue		= attributes.stroke ? attrValue.slice(0, attrValue.length-1) + "; fill:" + attributes.stroke + ";}" : attrValue;
        var attrTextValue;
        if( attributes.fill ){
            var copyAttr        = Object.clone(attributes);
        	copyAttr.fill		= "black";
        	attrTextValue		= $H(copyAttr).toJSON().gsub(',', ';').gsub('"', '');
        }
                	
        // Create the CSS-Tags Style out of the ids and the attributes
        csstags = ids.collect(function(s, i){return "#" + s + " * " + (!i? attrValue : attrMarkerValue) + "" + (attrTextValue ? " #" + s + " text * " + attrTextValue : "") })
		
		// Join all the tags
		var s = csstags.join(" ") + "\n" 
		
		// And add to the end of the style tag
		this.styleNode.appendChild(document.createTextNode(s));
		
		
	},
	
	/**
	 * Deletes all attributes which are
	 * added in a special style sheet for that node
	 * @param {HTMLElement} node 
	 */
	deleteAttributes: function( node ) {
				
		// Get all children which contains the node id		
		var delEl = $A(this.styleNode.childNodes)
					 .findAll(function(e){ return e.textContent.include( '#' + node.id ) });
		
		// Remove all of them
		delEl.each(function(el){
			el.parentNode.removeChild(el);
		});		
	},
	
	getAllChilds: function( node ){
		
		var childs = $A(node.childNodes)
		
		$A(node.childNodes).each(function( e ){ 
		        childs.push( this.getAllChilds( e ) )
		}.bind(this))

    	return childs.flatten();
	}

    
});
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Edit = Clazz.extend({
    
    construct: function(facade){
    
        this.facade = facade;

		// Create a new clipboard
		//zhaofx	使用本地的剪贴板
		//this.clipboard = new ORYX.Plugins.Edit.AsyncClipBoard(this.facade.getCanvas().getStencil().stencilSet().namespace(), this.facade);
		this.clipboard = new ORYX.Plugins.Edit.ClipBoard(this.facade.getCanvas().getStencil().stencilSet().namespace());
		
		// Grid snaping
		this.snap = new ORYX.Core.SnapToGrid(this.facade);
		this.snap.cThres = 48;
		
		// Mouse Event Callbacks
		this.callbackMouseMove	= this.handleMouseMove.bind(this);
		this.callbackMouseOut	= this.handleMouseOut.bind(this);
		this.registerOnMouseEvents();
		
		// The mouse position and event
		this.lastMouseMoveEvent = undefined;
		this.currentMousePos = undefined;
		this.currentCopyBounds = undefined;
		
		// Canvas resizing
		this.canvasResizeFn = this.resizeCanvas.bind(this);
		
        //this.facade.registerOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keyHandler.bind(this));
        
		// CUT
        this.facade.offer({
			name: ORYX.I18N.Edit.cut,
			description: ORYX.I18N.Edit.cutDesc,
			icon: ORYX.PATH + "images/cut.png",
			keyCodes: [{
				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: 88,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
			}],
			functionality: this.callEdit.bind(this, this.editCut),
			group: ORYX.I18N.Edit.group,
			index: 1,
			minShape: 1
		});
         
		 // COPY
        this.facade.offer({
			name: ORYX.I18N.Edit.copy,
			description: ORYX.I18N.Edit.copyDesc,
			icon: ORYX.PATH + "images/page_copy.png",
			keyCodes: [{
				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: 67,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
			}],
			functionality: this.callEdit.bind(this, this.editCopy, [true, false]),
			group: ORYX.I18N.Edit.group,
			index: 2,
			minShape: 1
		});
        
		// PASTE
		var paste = {
			name: ORYX.I18N.Edit.paste,
			description: ORYX.I18N.Edit.pasteDesc,
			icon: ORYX.PATH + "images/page_paste.png",
			keyCodes: [{
				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: 86,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
			}],
			functionality: this.callEdit.bind(this, this.editPaste),
			isEnabled: this.clipboard.isOccupied.bind(this.clipboard),
			group: ORYX.I18N.Edit.group,
			index: 3,
			minShape: 0,
			maxShape: 0
		}
        this.facade.offer(paste);
        
		// DELETE
        this.facade.offer({
			name: ORYX.I18N.Edit.del,
			description: ORYX.I18N.Edit.delDesc,
			icon: ORYX.PATH + "images/cross.png",
			keyCodes: [{
				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: 8,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
			}, {
				keyCode: 46,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN
			}],
			functionality: this.callEdit.bind(this, this.editDelete),
			group: ORYX.I18N.Edit.group,
			index: 4,
			minShape: 1
		});
		
		// Register on changes
        this.clipboard.onChange(function(changes){
			if (paste&&paste.buttonInstance&&changes)
				paste.buttonInstance.enable();
		})
    },
	
	callEdit: function(fn, args){
		window.setTimeout(function(){
			fn.apply(this, (args instanceof Array ? args : []));
		}.bind(this), 1);
	},
	
	/**
	 * Handles the mouse down event and starts the copy-move-paste action, if
	 * control or meta key is pressed.
	 */
	handleMouseDown: function(event) {
		if(this._controlPressed) {
			this._controlPressed = false;
			this.editCopy();
			this.editPaste();
			event.forceExecution = true;
			this.facade.raiseEvent(event, this.clipboard.shapesAsJson);
			
		}
	},
    
    /**
     * The key handler for this plugin. Every action from the set of cut, copy,
     * paste and delete should be accessible trough simple keyboard shortcuts.
     * This method checks whether any event triggers one of those actions.
     *
     * @param {Object} event The keyboard event that should be analysed for
     *     triggering of this plugin.
     */
//    keyHandler: function(event){
//        //TODO document what event.which is.
//        
//        ORYX.Log.debug("edit.js handles a keyEvent.");
//        
//        // assure we have the current event.
//        if (!event) 
//            event = window.event;
//        
//        
//        // get the currently pressed key and state of control key.
//        var pressedKey = event.which || event.keyCode;
//        var ctrlPressed = event.ctrlKey;
//        
//        // if the object is to be deleted, do so, and return immediately.
//        if ((pressedKey == ORYX.CONFIG.KEY_CODE_DELETE) ||
//        ((pressedKey == ORYX.CONFIG.KEY_CODE_BACKSPACE) &&
//        (event.metaKey || event.appleMetaKey))) {
//        
//            ORYX.Log.debug("edit.js deletes the shape.");
//            this.editDelete();
//            return;
//        }
//        
//         // if control key is not pressed, we're not interested anymore.
//         if (!ctrlPressed)
//         return;
//         
//         // when ctrl is pressed, switch trough the possibilities.
//         switch (pressedKey) {
//         
//	         // cut.
//	         case ORYX.CONFIG.KEY_CODE_X:
//	         this.editCut();
//	         break;
//	         
//	         // copy.
//	         case ORYX.CONFIG.KEY_CODE_C:
//	         this.editCopy();
//	         break;
//	         
//	         // paste.
//	         case ORYX.CONFIG.KEY_CODE_V:
//	         this.editPaste();
//	         break;
//         }
//    },
	
    /**
     * Returns a list of shapes which should be considered while copying.
     * Besides the shapes of given ones, edges and attached nodes are added to the result set.
     * If one of the given shape is a child of another given shape, it is not put into the result. 
     */
    getAllShapesToConsider: function(shapes){
        var shapesToConsider = []; // only top-level shapes
        var childShapesToConsider = []; // all child shapes of top-level shapes
        
        shapes.each(function(shape){
            //Throw away these shapes which have a parent in given shapes
            isChildShapeOfAnother = shapes.any(function(s2){
                return s2.hasChildShape(shape);
            });
			/*
			 * since deleting the parent of a shape no longer
			 * means that all child shapes are deleted as
			 * well, we have to consider them for deletion
			 */
            //if(isChildShapeOfAnother) return;
            
            // This shape should be considered
            shapesToConsider.push(shape);
            // Consider attached nodes (e.g. intermediate events)
            if (shape instanceof ORYX.Core.Node) {
				var attached = shape.getOutgoingNodes();
				attached = attached.findAll(function(a){ return !shapes.include(a) });
                shapesToConsider = shapesToConsider.concat(attached);
            }
            
			// Append all shapes which don't fit to any parent
            shapesToConsider = [].concat(shapesToConsider, shape.getChildShapes(false).findAll(function(cshape){
				var dc = ORYX.Plugins.Edit.DeleteCommand.prototype;
				return !dc.findParent.call({facade:this.facade, findParent:dc.findParent}, cshape, shape.parent) && !shapesToConsider.include(cshape);
			}.bind(this)));
        }.bind(this));
        
        // All edges between considered child shapes should be considered
        // Look for these edges having incoming and outgoing in childShapesToConsider
        var edgesToConsider = this.facade.getCanvas().getChildEdges().select(function(edge){
            // Ignore if already added
            if(shapesToConsider.include(edge)) return false;
            // Ignore if there are no docked shapes
            if(edge.getAllDockedShapes().size() === 0) return false; 
            // True if all docked shapes are in considered child shapes
            return edge.getAllDockedShapes().all(function(shape){
                // Remember: Edges can have other edges on outgoing, that is why edges must not be included in childShapesToConsider
                //return shape instanceof ORYX.Core.Edge || childShapesToConsider.include(shape);
				// Edges will only be removed if manually selected
				// or if the target or the source no longer exist
				return false;
            });
        });
        shapesToConsider = [].concat(shapesToConsider, edgesToConsider).uniq();
        
        return shapesToConsider;
    },
    
    /**
     * Performs the cut operation by first copy-ing and then deleting the
     * current selection.
     */
    editCut: function(){
        //TODO document why this returns false.
        //TODO document what the magic boolean parameters are supposed to do.
		
		// Check if an selection exits
		if(this.facade.getSelection().length == 0) {
			return;
		}
		
		this.facade.getSelection()
        this.editCopy(false, true);
        this.editDelete(true);
        return false;
    },
    
    /**
     * Performs the copy operation.
     * @param {Object} will_not_update ??
     */
    editCopy: function( will_update, useNoOffset ){
		
		var selection = this.facade.getSelection();
        
        //if the selection is empty, do not remove the previously copied elements
        if(selection.length == 0) return;

		//zhaofx 改为本地剪贴板，不用提示发送请求
/* 		
		this.facade.raiseEvent({
        	type:ORYX.CONFIG.EVENT_LOADING_ENABLE,
        	text:Signavio.I18N.CopyPaste.CopyWait
        });
 */        
        
		try {
	        this.clipboard.refresh(selection, this.getAllShapesToConsider(selection), useNoOffset);
		} catch(err) {
			
			this.facade.raiseEvent({
	        	type:ORYX.CONFIG.EVENT_LOADING_STATUS,
				text:Signavio.I18N.CopyPaste.CopyFail,
				timeout:3000
	        });
		}		

		
        if( will_update ) this.facade.updateSelection();
    },
    
    /**
     * Performs the paste operation.
     */
    editPaste: function(){
		
		this.facade.raiseEvent({
        	type:ORYX.CONFIG.EVENT_LOADING_ENABLE,
        	text:Signavio.I18N.CopyPaste.PasteWait
        });
		
		this.clipboard.getClip(function(clip){
			this.doEditPaste(clip);
		}.bind(this));
		
		// Clear Info-Box
//		this.facade.raiseEvent({
//        	type:ORYX.CONFIG.EVENT_LOADING_DISABLE
//        });
	},
	
	doEditPaste: function(canvas) {
        /* Check if the namespaces fit to each other */
		if(!(this.facade.getCanvas().getStencil().namespace() === canvas.stencilset.namespace)) {
			
			//Ext.Msg.alert(Signavio.I18N.CopyPaste.Note, Signavio.I18N.CopyPaste.WrongNamespace);
			Ext.MessageBox.show({
	           title: Signavio.I18N.CopyPaste.Note,
	           msg: Signavio.I18N.CopyPaste.WrongNamespace,
	           buttons: Ext.MessageBox.OK,
	           icon: Ext.MessageBox.INFO
	       });
			
			this.facade.raiseEvent({
	        	type:ORYX.CONFIG.EVENT_LOADING_DISABLE
	        });
			
			return;		
		}
		
		/* Check if there is anything to paste */
		if(canvas.childShapes.length == 0) {
			
			this.facade.raiseEvent({
	        	type:ORYX.CONFIG.EVENT_LOADING_DISABLE
	        });
			
			return;		
		}
		
		/* Remove shapes which stencils are not in the current perspective */
		
		var cleanedShapeList = canvas.childShapes.findAll(function(shape) {
			return this.getTypeOfSerializedShape(shape, canvas) && !this.isStencilHidden(shape);
		}.bind(this));
		
		var oldChildShapes = canvas.childShapes;
		
//		// Show hint in case some shapes where removed
//		if(cleanedShapeList.length != canvas.childShapes.length) {
//			Ext.MessageBox.show({
//	           title: Signavio.I18N.CopyPaste.Note,
//	           msg: Signavio.I18N.CopyPaste.SkipedShapes,
//	           buttons: Ext.MessageBox.OK,
//	           icon: Ext.MessageBox.INFO
//	       });
//		}
		
		// Check whether there is anything to paste
		if(cleanedShapeList.length == 0) {
			this.facade.raiseEvent({
	        	type:ORYX.CONFIG.EVENT_LOADING_DISABLE
	        });
			
			return;
		}
		
		canvas.childShapes = cleanedShapeList;
		
		
		// Apply json helper to iterate over json object
        Ext.apply(canvas, ORYX.Core.AbstractShape.JSONHelper);
        
        var childShapeResourceIds =  canvas.getChildShapes(true).pluck("resourceId");
        var outgoings = {};
        
		// remove the parent reference (serialization), if mouse position is used
		var removeParent = false; 
		
		// Include the current mouse position if applicable
		if(canvas.getChildShapes()) {
			var pasteMeta = this.getOffsetToMouse(canvas.getChildShapes(), canvas);
			
			var offset = (pasteMeta ? pasteMeta.offset : undefined);
			removeParent = (pasteMeta ? true : false);
		}
		
		// Iterate over all shapes
        canvas.eachChild(function(shape, parent){
            // Throw away these references where referenced shape isn't copied
            shape.outgoing = shape.outgoing.select(function(out){
                return childShapeResourceIds.include(out.resourceId);
            });
			shape.outgoing.each(function(out){
				if (!outgoings[out.resourceId]){ outgoings[out.resourceId] = [] }
				outgoings[out.resourceId].push(shape)
			});
			
            return shape;
        }.bind(this), true, true);
        

        // Iterate over all shapes
        canvas.eachChild(function(shape, parent){	
            
        	// Check if there has a valid target
            /*if((shape.target && !(childShapeResourceIds.include(shape.target.resourceId)))
				||
				(shape.targetId && !(childShapeResourceIds.include(shape.targetId)))){*/
			if((!shape.targetId) || (shape.targetId && !(childShapeResourceIds.include(shape.targetId)))) {
				shape.target = undefined;
                shape.targetRemoved = true;
            }
    		
    		// Check if the first docker is removed
//    		if(	shape.dockers && 
//    			shape.dockers.length >= 1 && 
//    			shape.dockers[0].getDocker &&
//	    		(	(shape.dockers[0].getDocker().getDockedShape() &&
//	    			!childShapeResourceIds.include(shape.dockers[0].getDocker().getDockedShape().resourceId)) 
//	    			|| !shape.getShape().dockers[0].getDockedShape()
//					|| (shape.sourceId && !childShapeResourceIds.include(shape.sourceId))
//					|| !shape.sourceId 
//					&&!outgoings[shape.resourceId]
//				)) {
			if(shape.dockers
				&& (
					(shape.sourceId && !childShapeResourceIds.include(shape.sourceId))
					|| (!shape.sourceId)
				)
				&& (
					shape.dockers.length > 1 
					||
						(shape.dockers.length == 1 
						&& this.getTypeOfSerializedShape(shape, canvas) === "node"
						&& shape.attachedTo
						&& !childShapeResourceIds.include(shape.attachedTo))
				)
			) {
    				
    			shape.sourceRemoved = true;
    		}
			
            return shape;
        }.bind(this), true, true);

		
        // Iterate over top-level shapes
        var childsToImport = canvas.childShapes.findAll(function(shape, parent){
            // All top-level shapes should get an offset in their bounds
            // Move the shape occording to COPY_MOVE_OFFSET
			var useOffset = this.clipboard.useOffset;
        	if (/*this.clipboard.useOffset&&*/!this.isParentInShapesToJSON(shape)) {
	            if(removeParent) {
					var parentShape = this.getParentShapeFromList((pasteMeta ? pasteMeta.shapesAtPosition : undefined), shape, canvas);
					
					// Remove shape if no reasonable parent was found
					if(!parentShape && this.getTypeOfSerializedShape(shape, canvas) === "node") {
						return false;
					}
					
					if(parentShape && shape.oldParent) {
						shape.parent = {
							resourceId: parentShape.resourceId
						};
					} else {
						shape.parent = undefined;
					}
					
					//New shape bounds calculation: + offset derived from mouse position
					shape.bounds = {
		                lowerRight: {
		                    x: shape.absBounds.lowerRight.x + (offset?offset.x : (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0)),
		                    y: shape.absBounds.lowerRight.y + (offset?offset.y : (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0))
		                },
		                upperLeft: {
		                    x: shape.absBounds.upperLeft.x + (offset?offset.x : (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0)),
		                    y: shape.absBounds.upperLeft.y + (offset?offset.y : (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0))
		                }
		            };
					
					// - offset all including bounds ul, if paste into canvas child element
					if(pasteMeta && parentShape) {
						var xOffset = parentShape.absoluteBounds().upperLeft().x
						var yOffset = parentShape.absoluteBounds().upperLeft().y
						
						shape.bounds.lowerRight.x -= xOffset;
						shape.bounds.lowerRight.y -= yOffset;
						shape.bounds.upperLeft.x -= xOffset;
						shape.bounds.upperLeft.y -= yOffset;
					}
				} 
				
				// Child shape of a container was copied and is pasted into the
				// same container shape -> use the relative bounds
				else {
					shape.bounds = {
		                lowerRight: {
		                    x: shape.relBounds.lowerRight.x + (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0),
		                    y: shape.relBounds.lowerRight.y + (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0)
		                },
		                upperLeft: {
		                    x: shape.relBounds.upperLeft.x + (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0),
		                    y: shape.relBounds.upperLeft.y + (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0)
		                }
		            };
				}
				
        	}
        	
			//zhaofx 20120504 触发粘贴图形的事件
			this.facade.raiseEvent({
				type: SMARTDOT.CONFIG.EVENT_ON_PASTE_SHAPE,
				shape: shape
			});
					
            // Only apply offset to shapes with a target
			var type = this.getTypeOfSerializedShape(shape, canvas);
            if (shape.dockers && type === "edge"){
                shape.dockers = shape.oldDockers.map(function(docker, i){
                    // If shape had a target but the copied does not have anyone anymore,
                    // migrate the relative dockers to absolute ones.
                    if( (shape.targetRemoved === true && i == shape.dockers.length - 1/*&&docker.getDocker*/) ||
						(shape.sourceRemoved === true && i == 0/*&&docker.getDocker*/)){

                        //docker = docker.getDocker().bounds.center();
						docker = shape.absDockers[i];
                    }

					// If it is the first or last docker and it has a docked shape, 
					// just return the coordinates
				   	/*if ((i == 0 
							&& shape.sourceRemoved !== true 
							&& ((docker.getDocker instanceof Function && docker.getDocker().getDockedShape()) 
								|| ((outgoings[shape.resourceId]||[]).length > 0 
									&& (!(shape.getShape() instanceof ORYX.Core.Node) 
										|| outgoings[shape.resourceId][0].getShape() instanceof ORYX.Core.Node)))) 
						|| (i == shape.dockers.length - 1 && shape.targetRemoved !== true 
							&& ((docker.getDocker instanceof Function && docker.getDocker().getDockedShape()) 
								|| shape.target))){
							
						return {
                        	x: docker.x, 
                        	y: docker.y,
                        	getDocker: docker.getDocker
						}
					} else*/ if ( (i != 0 || shape.sourceRemoved === true /*|| ((outgoings[shape.resourceId]||[]).length <= 0)*/)
								&& ((i != shape.dockers.length - 1) || shape.targetRemoved === true)
								&& !this.isParentInShapesToJSON(shape)) {
	                    return {
		                        x: docker.x + (offset?offset.x : (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0)), 
		                        y: docker.y + (offset?offset.y : (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0)),
	                        	getDocker: docker.getDocker
		                    };
				   	} else {
				   		return {
                        	x: docker.x, 
                        	y: docker.y,
                        	getDocker: docker.getDocker
						};
				   	}
                }.bind(this));

            } 
			
			// handles attachable, but not attached nodes (e.g. BPMN 2.0 Intermediate Events)
			else if (type === "node" 
					&& shape.dockers && shape.dockers.length == 1  
					&& !shape.attachedTo
					/*&& shape.sourceRemoved === true || !outgoings[shape.resourceId])*/){
            	
            	shape.dockers = shape.oldDockers.map(function(docker, i){
            		
                    if((shape.sourceRemoved === true && i == 0 && shape.absDockers/*&&docker.getDocker*/)){
                    	//docker = docker.getDocker().bounds.center();
						docker = shape.absDockers[0];
						return docker;
                    }
                    
					// This is maybe deprecated
//                    if (this.clipboard.useOffset) {
//						
	            		var bounds = new ORYX.Core.Bounds(shape.bounds.upperLeft, shape.bounds.lowerRight);
						var newDocker = bounds.center();
//						
//						return {
////	                        x: docker.x + (offset?offset.x : ORYX.CONFIG.COPY_MOVE_OFFSET), 
////	                        y: docker.y + (offset?offset.y : ORYX.CONFIG.COPY_MOVE_OFFSET),
////	                    	getDocker: docker.getDocker
//							x: newDocker.x,
//							y: newDocker.y,
//							getDocker: docker.getDocker
//	                    };
//                    } else {
	            		return {
//	                        x: docker.x, 
//	                        y: docker.y,
							x: newDocker.x,
							y: newDocker.y,
	                    	getDocker: docker.getDocker
	                    };
//                    }
            	}.bind(this));
            }
			
			// update label positions
			if(type === "edge" && shape.labels) {
				shape.labels.each(function(label) {
					if(label.x && label.y) {
						label.x = label.x + (offset?offset.x : (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0));
						label.y = label.y + (offset?offset.y : (useOffset ? ORYX.CONFIG.COPY_MOVE_OFFSET : 0));
					}
				});
			}
            
            //return shape;
			return true;
        }.bind(this)/*, false, true*/);
		
		
		if(childsToImport && childsToImport.length == 0 && canvas.childShapes.length > 0 ) {
			//Ext.Msg.alert(Signavio.I18N.CopyPaste.Note, Signavio.I18N.CopyPaste.NotPastable);
			Ext.MessageBox.show({
	           title: Signavio.I18N.CopyPaste.Note,
	           msg: Signavio.I18N.CopyPaste.NotPastable,
	           buttons: Ext.MessageBox.OK,
	           icon: Ext.MessageBox.INFO
	       });
		}
		
		// Show hint in case some shapes where removed
		else if(cleanedShapeList.length != canvas.childShapes.length) {
			Ext.MessageBox.show({
	           title: Signavio.I18N.CopyPaste.Note,
	           msg: Signavio.I18N.CopyPaste.SkipedShapes,
	           buttons: Ext.MessageBox.OK,
	           icon: Ext.MessageBox.INFO
	       });
		}
		
		canvas.childShapes = childsToImport;

        this.clipboard.useOffset = true;
        
        // enable canvas resizing
        this.currentMousePos = (pasteMeta ? pasteMeta.mousePosition : undefined);
        this.currentCopyBounds = (pasteMeta ? pasteMeta.includingBounds : undefined);
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAST_EXECUTE_COMMANDS, this.canvasResizeFn);
        
        this.facade.importJSON(canvas);
		
		this.facade.raiseEvent({
        	type:ORYX.CONFIG.EVENT_LOADING_DISABLE
        });
    },
    
    /**
     * Performs the delete operation. No more asking.
     */
    editDelete: function(){
        var selection = this.facade.getSelection();
        
        var clipboard = new ORYX.Plugins.Edit.ClipBoard();
        clipboard.refresh(selection, this.getAllShapesToConsider(selection));
        
        var event = {
        		type: ORYX.CONFIG.EVENT_BEFORE_REMOVE,
        		cancelled: false,
        		elements: selection
        };
        
        this.facade.raiseEvent(event);
        
        if(!event.cancelled) {
        	var command = new ORYX.Plugins.Edit.DeleteCommand(clipboard , this.facade);
                                       
        	this.facade.executeCommands([command]);
        }
    },
	
	
	/**
	 * Returns TRUE if one of the parent of the shape is
	 * in the array this.clipboard.shapesAsJson is included
	 * @param {ORYX.Core.Shape} shape
	 * @return {Boolean}
	 *
	 */
	isParentInShapesToJSON: function(shape){
		//VARs
		var me = this;
		var parent;
		
		if (!shape || !shape.parent){ return false; }
		
		parent = shape.parent.resourceId;
		
		return this.clipboard.shapesAsJson.any(function(js){ return js.resourceId === parent && !me.isStencilHidden.bind(me,shape.parent);}); 
	},
	
	/**
	 * Returns node or edge or undefined.
	 */
	getTypeOfSerializedShape: function(shape, root) {
		var stencilSet = this.facade.getStencilSets()[root.stencilset.namespace];
		if(!stencilSet) {
			return;
		}
		
		var stencil = stencilSet.stencil(root.stencilset.namespace + shape.stencil.id);
		if(!stencil) {
			return;
		}
				
		return stencil.type();		
	},
	
	/**
	 * Checks if the stencil of the shape to paste is hidden in the current
	 * shape repository view.
	 * 
	 * @param shape
	 * @param root
	 */
	isStencilHidden: function(shape) {
		// VARs
		var ssNs = this.clipboard.getStencilSet();
		var stencilSet = this.facade.getStencilSets()[ssNs];
		
		// Stencil set not available -> stencil not available as well.
		if(!stencilSet) {
			return true;
		}
		
		var stencil = stencilSet.stencil(ssNs + shape.stencil.id);
		
		return !stencil || stencil.hide();
	},
	
	/**
	 * Calculates the position of the mouse based on the last received
	 * mouse move event. If none was detected it returns null. This method 
	 * should only be called just before the past operation, due to 
	 * performance issues.
	 * 
	 */
	calculateMousePositon: function() {
		if(!this.lastMouseMoveEvent) {
			return null;
		}
		
		return this.facade.eventCoordinates(this.lastMouseMoveEvent);
	},
	
	handleMouseMove: function(event) {	
		//console.log("mousemove");
		this.lastMouseMoveEvent = event;
	}, 
	
	handleMouseOut: function(event) {
		// mark last recognized mouse move event as dirty
		//console.log("mouseout")
		this.lastMouseMoveEvent = undefined;
	},
	
	/**
	 * Adjust an Point to the Snap Points while pasting elements
	 *
	 */
	snapToGrid: function(position, shapeList, pasteBounds) {
		
		var cThres 	= this.snap.cThres;
		var zoomFactor = this.facade.getCanvas().getZoom();
		//var startPosition = pasteBounds.upperLeft();
		
		var canvasSize = {
			width: this.facade.getCanvas().bounds.width(),
			height: this.facade.getCanvas().bounds.height()
		};
		
		// determine the bounds to snap with (all bounds that lie at the border of the selection)
		var snapBounds = [];
		var minX, minY, maxX, maxY;
		var snapLeft = [];
		var snapRight = [];
		var snapTop = [];
		var snapBottom = [];
		shapeList.each((function(value) {
			var shape = value;
			
			var b = shape.absBounds;
			
			if(minX!=undefined && b.upperLeft.x<minX) snapLeft = []; // reset snap points at left side
			minX = (minX==undefined) ? b.upperLeft.x : ((b.upperLeft.x<minX) ? b.upperLeft.x : minX);
			if(minX == b.upperLeft.x) snapLeft.push(b); // include the center point in snapping
			
			if(minY!=undefined && b.upperLeft.y<minY) snapTop = []; // reset snap points at top side
			minY = (minY==undefined) ? b.upperLeft.y : ((b.upperLeft.y<minY) ? b.upperLeft.y : minY);
			if(minY == b.upperLeft.y) snapTop.push(b); // include the center point in snapping
			
			if(maxX!=undefined && b.lowerRight.x>maxX) snapRight = []; // reset snap points at right side
			maxX = (maxX==undefined) ? b.lowerRight.x : ((b.lowerRight.x>maxX) ? b.lowerRight.x : maxX);
			if(maxX == b.lowerRight.x) snapRight.push(b); // include the center point in snapping
			
			if(maxY!=undefined && b.lowerRight.y>maxY) snapBottom = []; // reset snap points at bottom side
			maxY = (maxY==undefined) ? b.lowerRight.y : ((b.lowerRight.y>maxY) ? b.lowerRight.y : maxY);
			if(maxY == b.lowerRight.y) snapBottom.push(b); // include the center point in snapping
			
		}).bind(this));
		snapBounds = snapLeft.concat(snapTop, snapRight, snapBottom).uniq();
	
		// determine the snap position (the position that has the smallest distance to the current position)
		// and determine all bounds that will snap in that position
		var minDistX, minDistY;
		var snapXCoords = [];
		var snapYCoords = [];
		var newPos = {};
		
		this.snap.setScale(zoomFactor);	

		snapBounds.each((function(b) {
			
			var bounds = new ORYX.Core.Bounds();
			bounds.set(b.upperLeft, b.lowerRight);
			
			// move to upper left of each snap bound, mind the zoom level
			var xOff = pasteBounds.width() / 2 - (bounds.upperLeft().x - pasteBounds.upperLeft().x);
			var yOff = pasteBounds.height() / 2 - (bounds.upperLeft().y - pasteBounds.upperLeft().y);
			
			var offsetPos = {
				//x: (b.upperLeft.x*this.factorXY.x) + position.x,
				//y: (b.upperLeft.y*this.factorXY.y) + position.y
				x: position.x - xOff * zoomFactor,
				y: position.y - yOff * zoomFactor 
			}
			
			var snapX, snapY;
			this.snap.setReferenceBounds(bounds);
			var point = this.snap.adjustPoint(offsetPos, function(y){snapY=y;}, function(x){snapX=x;});
			
			if(snapX) {
				var distX = Math.abs(offsetPos.x-point.x);
				var px = point.x + (xOff * zoomFactor);
				if((minDistX==undefined || distX<minDistX) &&
						(px >= 0 && (px + (pasteBounds.width() * zoomFactor))<=(canvasSize.width * zoomFactor))) {
					snapXCoords = []; // reset snap x coords
					newPos.x = px;
					minDistX = distX;
				}
				if(newPos.x==px) snapXCoords.push(snapX);
			}
			
			if(snapY) {
				var distY = Math.abs(offsetPos.y-point.y);
				var py = point.y + (yOff * zoomFactor); 
				if((minDistY==undefined || distY<minDistY) &&
						(py >= 0 && (py+(pasteBounds.height() / 2 * zoomFactor))<=(canvasSize.height *  zoomFactor))) {
					snapYCoords = []; // reset snap y coords
					newPos.y = py;
					minDistY = distY;
				}
				if(newPos.y==py) snapYCoords.push(snapY);
			}
			
		}).bind(this));

		// snap selection bounds to grid, if no snapping to other shapes occured
		if(minDistX==undefined) {
			var gridX = (position.x - (position.x % (ORYX.CONFIG.GRID_DISTANCE/2)));
			newPos.x = gridX;
		}
		if(minDistY==undefined) {
			var gridY = (position.y - (position.y % (ORYX.CONFIG.GRID_DISTANCE/2)));
			newPos.y = gridY;
		}
		
		return newPos;

	},
	
	getOffsetToMouse: function(shapeList, root) {
		var mousePosition = this.calculateMousePositon();
		
		var includingBounds = this.calculateClipBoardIncludingBounds(shapeList);
		
		if(!mousePosition || !includingBounds) {
			return;
		}
		
		var pasteMeta = new Object();
		pasteMeta.shapesAtPosition = this.facade.getCanvas().getAbstractShapesAtPosition(mousePosition);
		this.calculateReferenceShapes(pasteMeta.shapesAtPosition, shapeList, root);

		var newPos = this.snapToGrid(mousePosition, shapeList, includingBounds);
		mousePosition = newPos;
		
//		this.resizeCanvas(includingBounds, mousePosition);
		
//		var canvasBounds = this.facade.getCanvas().bounds;
//		// Ensure keeping all pasting object stay visible on canvas
//		// Check top
//		if(mousePosition.y - includingBounds.height() / 2 < 0) {
//			mousePosition.y -= mousePosition.y - includingBounds.height() / 2;
//		}
//		
//		// Check bottom
//		if(mousePosition.y + includingBounds.height() / 2  > canvasBounds.lowerRight().y) {
//			mousePosition.y -= mousePosition.y + includingBounds.height() / 2  - canvasBounds.lowerRight().y;
//		}	
//			
//		// Check left
//		if(mousePosition.x - includingBounds.width() / 2  < 0) {
//			mousePosition.x -= mousePosition.x - includingBounds.width() / 2;
//		}
//		
//		// Check right
//		if(mousePosition.x + includingBounds.width() / 2  > canvasBounds.lowerRight().x) {
//			mousePosition.x -= mousePosition.x + includingBounds.width() / 2  - canvasBounds.lowerRight().x;
//		}
		
		pasteMeta.includingBounds = includingBounds;
		pasteMeta.mousePosition = mousePosition;
		pasteMeta.offset = this.calculateMiddleOffsetToMousePointer(mousePosition, includingBounds);
		
		return pasteMeta;
	},
	
	/**
	 * Calculates the bounds including all shapes to paste.
	 */
	calculateClipBoardIncludingBounds: function(shapeList) {
		if(!shapeList || shapeList.size() <= 0) {
			return;
		}
		
		//Note: this is operating on the JSON serialization
		var b = new ORYX.Core.Bounds();
		var bJson = shapeList.first().absBounds;
		b.set(bJson.upperLeft, bJson.lowerRight);
		
		shapeList.each(function(shape) {
			if(!this.isParentInShapesToJSON(shape)) {
				bJson = shape.absBounds;
				var includeBounds = new ORYX.Core.Bounds();
				includeBounds.set(bJson.upperLeft, bJson.lowerRight);
				
				b.include(includeBounds);
			}
		}.bind(this));
		
		return b;
	},
	
	/**
	 * Calculates the offset of the current mouse pointer position to the 
	 * middle of the container bounds.
	 */
	calculateMiddleOffsetToMousePointer: function(mousePosition, containerBounds) {
//		var offset = {
//			x: 0,
//			y: 0
//		};
		
		if(!mousePosition || !containerBounds) {
			return;
		}
		
		var boundsCenter = containerBounds.center();
		
		var offset = {
			x: 0,
			y: 0
		};
		
		offset.x = mousePosition.x - boundsCenter.x;
		offset.y = mousePosition.y - boundsCenter.y;
		
		return offset;
	},
	
	/**
	 * Retrieves the parent shape from a list of shapes by checking the 
	 * containment rules. Shapes on a more top level (z-order) are preferred.
	 * 
	 * @param shape
	 * 		the shape to add
	 * 
	 * @param shapeList
	 * 		the List of shapes at a certain position ordered by z-order. 
	 * 		Last on top.
	 */
	getParentShapeFromList: function(shapes, childShapeJson, root) {
		if(!shapes || !childShapeJson || !root || shapes.length == 0)  {
			return;
		}
		
		var shapeList = shapes.clone();
		var stencilSet = this.facade.getStencilSets()[root.stencilset.namespace];
		var stencil = stencilSet.stencil(root.stencilset.namespace + childShapeJson.stencil.id);
		
		var parent = shapeList.pop();
		while(parent) {
			if(this.facade.getRules().canContain({containingShape:parent, containedStencil: stencil}) && childShapeJson.resourceId !== parent.resourceId) {
				return parent;
			}
			
			if(parent instanceof ORYX.Core.Canvas) {
				return false;
			}
			
			parent = shapeList.pop();
		}
	},
	
	/**
	 * MouseMove to determine the mouse position on the canvas
	 * MouseOut to determine whether the mouse on or off side the canvas element
	 */
	registerOnMouseEvents: function() {
		var canvasNode = this.facade.getCanvas().getRootNode();
		canvasNode.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.callbackMouseMove.bind(this), true);
		canvasNode.addEventListener(ORYX.CONFIG.EVENT_MOUSEOUT, this.callbackMouseOut.bind(this), true);
	},
	
	/**
     * Determines the reference shapes for the snapping tool.
     */ 	
	calculateReferenceShapes: function(shapeUnderMouse, shapesToPasteJson, root) {
		var elements = shapesToPasteJson;
		
		
		// If Snap-To-Grid is enabled, the Snap-Point will be calculate
		if(ORYX.CONFIG.GRID_ENABLED) {

			this.snap.setReferenceShapes();

//			if (this.distPointTimeout)
//				window.clearTimeout(this.distPointTimeout);
//			
//			this.distPointTimeout = window.setTimeout(function(){
//				// Get all the shapes, there will consider at snapping
//				// Consider only those elements who shares the same parent element
//				var distShapes = this.facade.getCanvas().getChildShapes(true).findAll(function(value){
//					var parentShape = value.parent;
//					while(parentShape){
//						if(parents.member(parentShape)) return true;
//						parentShape = parentShape.parent
//					}
//					return false;
//				}.bind(this));
//				
//				this.snap.setReferenceShapes(distShapes);
//				console.log(distShapes);
//				
//			}.bind(this), 10);

			
			// parent elements
//			var parents = [];
//			
//			// collect parent shapes
//			shapesToPasteJson.each(function(shapeJson) {
//				var parent = this.getParentShapeFromList(shapeUnderMouse, shapeJson, root);
//				if(!parent) {
//					var parent = this.facade.getCanvas();
//				}
//				
//				parents.push(parent);
//			}.bind(this));
//			
//			parents = parents.uniq();
//			
//			parents.each(function(shape) {
//				if(shape.parent) {
//					
//				}
//			})
//			
//			var distShapes = this.facade.getCanvas().getChildShapes(true).findAll(function(value){
//					var parentShape = value.parent;
//					while(parentShape){
//						if(parents.member(parentShape)) return true;
//						parentShape = parentShape.parent
//					}
//					return false;
//				}.bind(this));
				
			this.snap.setReferenceShapes(this.facade.getCanvas().getChildNodes(true), false, true);
		}
	},
	
	/**
	 * Checks if the bounds of the elements to paste fit into the current canvas
	 * and resizes the canvas if neccessary.
	 * 
	 * @param copybounds
	 * @param mousePos
	 * 
	 */
	resizeCanvas: function( event ){
		this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_LAST_EXECUTE_COMMANDS, this.canvasResizeFn);
		
		var copybounds = this.currentCopyBounds;
		var mousePos = this.currentMousePos;
		if(!copybounds || !mousePos) {
    		return;
    	}
    	
    	var canvasBounds = this.facade.getCanvas().bounds;
    	
    	// define resize offsets
    	var resN = 0;
    	var resE = 0;
    	var resS = 0;
    	var resW = 0;
		
    	// check top of canvas - north
    	if(mousePos.y - copybounds.height() / 2 < 0) {
			resN = mousePos.y - copybounds.height() / 2;
			resN *= -1;
		}
		
		// Check bottom - south
		if(mousePos.y + copybounds.height() / 2  > canvasBounds.lowerRight().y) {
			resS = mousePos.y + copybounds.height() / 2  - canvasBounds.lowerRight().y;
		}	
			
		// Check left - west
		if(mousePos.x - copybounds.width() / 2  < 0) {
			resW = mousePos.x - copybounds.width() / 2;
			resW *= -1;
		}
		
		// Check right - east
		if(mousePos.x + copybounds.width() / 2  > canvasBounds.lowerRight().x) {
			resE = mousePos.x + copybounds.width() / 2  - canvasBounds.lowerRight().x;
		}
    	
    	var resizeCanvas = function(resN, resS, resE, resW, facade) {
        	var canvas 		= facade.getCanvas();
    		var b 			= canvas.bounds;
    		var scrollNode 	= facade.getCanvas().getHTMLContainer().parentNode.parentNode;
    		
    		canvas.setSize({width: (b.width() + resE + resW) * canvas.zoomLevel, height: (b.height() + resN + resS) * canvas.zoomLevel})

    		if( resN || resW){
    			
    			var move = {x: resW, y: resN};

    			// Move all children
    			canvas.getChildNodes(false, function(shape){ shape.bounds.moveBy(move); });
    			// Move all dockers which are not docked
    			var edges = canvas.getChildEdges();
    			var dockers = edges.collect(function(edge){ 
    							return edge.dockers.findAll(function(docker){ 
    									return !docker.getDockedShape();
    								});
    							}).flatten();
    			dockers.each(function(docker){ 
    				docker.bounds.moveBy(move);
    			});
    		} /*else if( position == "S" ){
    			scrollNode.scrollTop += extentionSize;
    		} else if( position == "E" ){
    			scrollNode.scrollLeft += extentionSize;
    		}*/
        }
		
		var commandClass = ORYX.Core.Command.extend({
			construct: function( resN, resS, resE, resW, facade ){
				this.resN = resN;
				this.resE = resE;
				this.resS = resS;
				this.resW = resW;
				this.facade = facade;
			},			
			execute: function(){
				resizeCanvas(this.resN, this.resE, this.resS, this.resW, this.facade);
			},
			rollback: function(){
				resizeCanvas(-this.resN, -this.resE, -this.resS, -this.resW, this.facade);
			}
		});
	
		var command = new commandClass( resN, resS, resE, resW, this.facade );
		
		// execute command together with the paste command
		//return command;
		
		this.facade.executeCommands([command]);
	}
}); 

ORYX.Plugins.Edit.ClipBoard = Clazz.extend({
    construct: function(namespace, facade){
        this.shapesAsJson = [];
        this.selection = [];
		this.SSnamespace = namespace || "";
		this.useOffset=true;
		this.facade = facade;
    },
    isOccupied: function(){
        return this.shapesAsJson.length > 0;
    },
	getStencilSet: function(){
		return this.SSnamespace;
	},
	/**
	 * Returns the latest clip in the clipboard
	 * @return {Object}
	 */
	getClip: function(clb){
		var json = {
            childShapes	: this.shapesAsJson,
			useOffset	: this.useOffset,
			stencilset	: {
				namespace : this.SSnamespace
			}
        };
		if (clb instanceof Function){
			clb(json);
		}
		return json;
	},
    refresh: function(selection, shapes, useNoOffset){
        this.selection = selection;
		
        // Store outgoings, targets and parents to restore them later on
        this.outgoings = {};
        this.parents = {};
        this.targets = {};
        this.useOffset = useNoOffset !== true;
        
        this.shapesAsJson = shapes.sort(function(a,b) {
			var parent = a.parent;
			while(!(parent instanceof ORYX.Core.Canvas)) {
				if(parent === b) {
					return 1;
				} 
				
				parent = parent.parent;
			}
			
			parent = b.parent;
			while(!(parent instanceof ORYX.Core.Canvas)) {
				if(parent === a) {
					return -1;
				}
				
				parent = parent.parent;
			}
			
			return 0;
		}).map(function(shape){
			
            var s = shape.toJSON();
			
			// serialize the absolute bounds of the most parent elements to copy
			//if(!shapes.include(shape.parent)) {
				// include relative bounds as well
				s.relBounds = {};
				s.relBounds.upperLeft = shape.bounds.upperLeft();
				s.relBounds.lowerRight = shape.bounds.lowerRight();
				
				var absBounds = shape.absoluteBounds();
				s.absBounds = {}; 
				s.absBounds.upperLeft = absBounds.upperLeft();
				s.absBounds.lowerRight = absBounds.lowerRight();
				
				// Store reference to objects conected by the edge
				if(shape instanceof ORYX.Core.Edge) {
					s.targetId = (shape.getTarget()? shape.getTarget().resourceId : null);
					s.sourceId = (shape.getSource()? shape.getSource().resourceId : null);
				}
//			}
			
			// Store fix docker coordinates
			if(s.dockers) {
				s.oldDockers = s.dockers.clone();
				
				// Store all dockers in absolute coordinates
				var absDockers = [];
				shape.dockers.each(function(docker) {
					absDockers.push(docker.bounds.center());
				}) 
				
				s.absDockers = absDockers;
			}
			
			// handle nodes attached to nodes
			if(s.dockers.length == 1 
				&& shape instanceof ORYX.Core.Node
				&& shape.getIncomingNodes().length == 1) {
				
				s.attachedTo = shape.getIncomingNodes()[0].resourceId;
			}
			
			s.childShapes = [];
			s.oldParent = {resourceId : shape.getParentShape().resourceId};
            s.parent = {resourceId : shape.getParentShape().resourceId};
            s.parentIndex = shape.getParentShape().getChildShapes().indexOf(shape)
            return s;
        });
    }
});



ORYX.Plugins.Edit.AsyncClipBoard = ORYX.Plugins.Edit.ClipBoard.extend({
	events: ["focus"],
	changeClb:[],
	transactionId: null,
	construct: function(){
		arguments.callee.$.construct.apply(this,arguments);
		this.events.each(function(event){
			Ext.getDoc().on(event, this.checkForChanges, this)
		}.bind(this))
	},
	refresh: function(){
		arguments.callee.$.refresh.apply(this,arguments);
		
		Ext.Ajax.request({
			url		: '/p/clipboard',
			method	: 'POST',
			timeout : 300000,
			success	: function(response){
				if (response.status === 200){
					// Save last transaction id
					this.transactionId = (response.responseText||"{}").evalJSON().id;
				}
				
				// Disable spinner
				this.facade.raiseEvent({
		        	type:ORYX.CONFIG.EVENT_LOADING_DISABLE
		        });
				
			}.bind(this),
			failure : function() {
				// Disable spinner and show text
				
				this.facade.raiseEvent({
		        	type : ORYX.CONFIG.EVENT_LOADING_STATUS,
					text : Signavio.I18N.CopyPaste.CopyFail,
					timeout : 3000
		        });
//				Ext.MessageBox.show({
//		            title: Signavio.I18N.CopyPaste.Note,
//		            msg: Signavio.I18N.CopyPaste.CopyFail,
//		            buttons: Ext.MessageBox.OK,
//		            icon: Ext.MessageBox.INFO
//		        });
			}.bind(this),
			params: { value_json: Object.toJSON(this.getClip()), namespace:this.SSnamespace}
		});
	},
	onChange: function(clb){
		if (!this.changeClb.include(clb))
			this.changeClb.push(clb)
	},
	checkForChanges: function(event){
		//VARs
		var rtEditors, stopRequest;
		
		// check if there is any richtext editor open
		// in this case do not send a request to the server
		rtEditors = Ext.select('div.y-richtext-editor').elements;
		rtEditors.each(function(e) {
			if(e.visible()) {
				stopRequest = true;
			}
		});
		
		if(stopRequest) {
			return;
		}
		
		this.hasChanges(function(change){
			if (change){
				// Call changes
				this.changeClb.each(function(clb){clb(change)})
			}
		}.bind(this))
	},
	hasChanges: function(clb){
		// Set args
		clb = clb || Ext.emptyFn;
		// Check for changes
		Ext.Ajax.request({
			url		: '/p/clipboard',
			method	: 'GET',
			timeout : 3000,
			success	: function(response){
				var resp = response.responseText.evalJSON();
				clb(resp&&resp.id&&this.transactionId!==resp.id&&resp.namespace===this.SSnamespace, resp.namespace);
			}.bind(this),
			failure	: function(response){
				clb(false)
			},
			params:{head:true}
		});	
	},
	loadChanges: function(clb, respNamespace){
		Ext.Ajax.request({
			url		: '/p/clipboard',
			timeout : 300000,
			success	: function(response){
				var json = (response.responseText||"{}").evalJSON();
				
				// TODO: Check namespace 
				// -> namespace is checked in paste method
				if (json&&json.id&&json.value_json){
					json.value_json = json.value_json.evalJSON();
					// Overwrite new changes
					
					if (json.value_json.stencilset.namespace === this.SSnamespace){
						Ext.apply(this, {
							transactionId 	: json.id,
							useOffset 		: json.value_json.useOffset,
							shapesAsJson 	: json.value_json.childShapes,
							SSnamespace 	: json.value_json.stencilset.namespace
						});
					} 
				}
				var json = {
		            childShapes	: this.shapesAsJson,
					useOffset	: this.useOffset,
					stencilset	: {
						namespace : (respNamespace ? respNamespace : this.SSnamespace)
					}
		        };
				clb(json);
			}.bind(this),
			failure	: function(response){
				
				this.facade.raiseEvent({
		        	type : ORYX.CONFIG.EVENT_LOADING_STATUS,
					text : Signavio.I18N.CopyPaste.CopyFail,
					timeout : 3000
		        });
				
				var json = {
		            childShapes	: this.shapesAsJson,
					useOffset	: this.useOffset,
					stencilset	: {
						namespace : this.SSnamespace
					}
		        };
				clb(json);
			},
			params: {}
		});
	},	
	/**
	 * Returns the latest clip in the clipboard
	 * @param {Function} (Optional) If an callback is defined, there will be a lookup on the server for changes 
	 * @return {Object}
	 */
	getClip: function(clb){
		if (clb instanceof Function){
			this.hasChanges(function(has, namespace){
				if (has){
					this.loadChanges(clb, namespace);
				} else {
					var json = {
            			childShapes	: this.shapesAsJson,
						useOffset	: this.useOffset,
						stencilset	: {
							namespace : (namespace ? namespace : this.SSnamespace)
						}
       				};
					clb(json);
				}
			}.bind(this));
		} else {
			return arguments.callee.$.getClip.call(this)
		}

	}
});

ORYX.Plugins.Edit.DeleteCommand = ORYX.Plugins.AbstractPlugin.extend({
    construct: function(clipboard, facade){
        this.clipboard          = clipboard;
        this.shapesAsJson       = clipboard.shapesAsJson;
        this.facade             = facade;
		this.childBounds		= [];
		this.edgesToDelete		= [];
		this.newEdges			= [];
        this.size				= this.shapesAsJson.length;
		this.selection			= this.facade.getSelection().pluck("id");
        // Store dockers of deleted shapes to restore connections
        this.dockers            = this.findDockers().flatten();
        this.glossarProperties  = [];
    },          
	
    execute: function(){
		
		this.dockers = this.findDockers().flatten();	
		this.childShapes = {};	
			
        this.shapesAsJson.each(function(shapeAsJson){
            
			var shape = shapeAsJson.getShape();			
			var reconnect = this.searchForPossibleReconnect(shape);
			
			/*
			 * When a shape is being deleted all incoming and 
			 * outgoing flows become obsolete and can be
			 * deleted as well 
			 */ 
			this.deleteIncomings(shape);
			this.deleteOutgoings(shape);
			
			this.edgesToDelete.each(function(edge) {
				this.updateGlossaryEntries(edge);
				this.facade.deleteShape(edge);
			}.bind(this));
			
			if(reconnect.isPossible&&this.size === 1) {				
				/*
				 * After incoming and outgoing edges have been
				 * deleted a new edge can maybe be drawn
				 */
				reconnect.connections.each(function(cxn) {
					
					var edge = this.facade.createShape({
						namespace	: cxn.source.getStencil().namespace(),
						type		: cxn.type
					});
					
					cxn.template.properties.each(function(prop) {
						edge.setProperty(prop[0], prop[1]);
					});
					
					edge.dockers.first().setDockedShape(cxn.source);
					edge.dockers.last().setDockedShape(cxn.target);
					
					edge.dockers.first().setReferencePoint(cxn.source.bounds.midPoint());
					edge.dockers.last().setReferencePoint(cxn.target.bounds.midPoint());
					
					this.newEdges.push(edge);
					this.doLayout(edge);
					
				}.bind(this));
			}
			
			/*
			 * Deletes the DOM-Object and thus also all
			 * of its child Shapes. So if the shape is a
			 * container we will rescue all of its child-
			 * Shapes and add them to the next possible parent
			 * or delete them if they can not longer be a
			 * child of any parent shape.
			 */
			
			var parent = shape.getParentShape();
			var parentAbsBounds = shape.absoluteXY();
			
			this.updateGlossaryEntries(shape);
			this.facade.deleteShape(shape);		
			
			if (shape.parent){
				return;
			}
		
			if(this.facade.getRules().isContainer(shape)) {				
				this.deleteContainer(shape, parent, parentAbsBounds);
			}
					
        }.bind(this)); 
		
		this.facade.setSelection([]);
        //this.facade.getCanvas().update();		
		//this.facade.updateSelection();
        
    },
    
    rollback: function(){
        this.shapesAsJson.each(function(shapeAsJson) {
            var shape = shapeAsJson.getShape();
            var parent = this.facade.getCanvas().getChildShapeByResourceId(shapeAsJson.parent.resourceId) || this.facade.getCanvas();
								
			if(this.facade.getRules().isContainer(shape)) {
				this.restoreContainer(shape);
			}
			
			this.rollbackGlossaryEntryUpdate(shapeAsJson.resourceId);
			
            parent.add(shape, shapeAsJson.parentIndex);
        }.bind(this));

        //delete edges that have been
        //created
        this.newEdges.each(function(edge) {
        	this.facade.deleteShape(edge);
        }.bind(this));
        
        //reconnect shapes
        this.dockers.each(function(d) {
			if (d.dockedShape){
				d.object.setDockedShape(d.dockedShape);
            	d.object.setReferencePoint(d.referencePoint);
			}
        }.bind(this));
        
        this.facade.setSelection(this.shapesAsJson.map(function(s){ return s.getShape() }).findAll(function(shape){ return this.selection.include(shape.id) }.bind(this)));
        //this.facade.getCanvas().update();	
		//this.facade.updateSelection();
        
    },
    
    searchForPossibleReconnect: function(shape) {
    	// search in incoming shapes
    	var incomingEdges		= [];
    	var outgoingEdges		= [];
    	
    	var edgeTypes   = [];
    	
    	// Scan all incoming Edges for Type and Amount
    	shape.getIncomingShapes().each(function(each) {
    		if(each instanceof ORYX.Core.Edge) {
    			var type = each.getStencil().id();
    			
    			if(edgeTypes.indexOf(type) === -1) {
    				edgeTypes.push(type);
    			}
    			
    			if(incomingEdges[type]) {
    				incomingEdges[type].push(each);
    			} else {
    				incomingEdges[type] = [each];
    			}
    		}
    	});
    	
    	// Scan all outgoing Edges for Type and Amount
    	shape.getOutgoingShapes().each(function(each) {    		
			if(each instanceof ORYX.Core.Edge) {
    			var type = each.getStencil().id();
    			
    			if(edgeTypes.indexOf(type) === -1) {
    				edgeTypes.push(type);
    			}
    			    			    			
    			if(outgoingEdges[type]) {
    				outgoingEdges[type].push(each);
    			} else {
    				outgoingEdges[type] = [each];
    			}
    		}
    	});
    	
    	var connections = [];
    	
    	edgeTypes.each(function(type) {
    		if((incomingEdges[type] || []).length === 1 && (outgoingEdges[type] || []).length === 1) {
    			
    			// Check if connected
    			if (!incomingEdges[type][0].getSource() || !outgoingEdges[type][0].getTarget()){
    				return;
    			}
    			
    			var canConnect = this.facade.getRules().canConnect({
    				sourceShape: incomingEdges[type][0].getSource(),
    				targetShape: outgoingEdges[type][0].getTarget(),
    				edgeStencil: incomingEdges[type][0].getStencil()
    			});

    			// dhz 2012-12-12 删除时自动连线，如果1和3节点已经有同一种连线，则不自动增加连线
    			var node1 = incomingEdges[type][0].getSource();
    			var node3 = outgoingEdges[type][0].getTarget();
    			var shouldConnect = node1.getOutgoingShapes().every(function(each) {    		
					if(each instanceof ORYX.Core.Edge) {
		    			var node1Type = each.getStencil().id();
		    			if(each.getTarget() === node3 && type === node1Type){
		    				return false;
		    			}
		    		}
		    		return true;
		    	});

    		
    			if(shouldConnect && canConnect && incomingEdges[type][0].getSource() !== outgoingEdges[type][0].getTarget()) {
	    			connections.push({
	    				source: incomingEdges[type][0].getSource(),
	    				target: outgoingEdges[type][0].getTarget(),
	    				type: type,
						template: incomingEdges[type][0]
	    			});
    			}
    		}
    	}.bind(this));
    	
    	return {
    		isPossible: connections.length > 0,
    		connections: connections
    	};
    
    },
	
	findDockers: function() {
		return this.shapesAsJson.map(function(shapeAsJson){
            var shape = shapeAsJson.getShape();
            var incomingDockers = shape.getIncomingShapes().map(function(s){return [s.getDockers().first(), s.getDockers().last()] }).flatten();
            var outgoingDockers = shape.getOutgoingShapes().map(function(s){return [s.getDockers().first(), s.getDockers().last()] }).flatten();
            
        	var dockers = shape.getDockers().concat(incomingDockers, outgoingDockers).compact().map(function(docker){
			    return {
			        object			: docker,
			        referencePoint	: docker.referencePoint,
			        dockedShape		: docker.getDockedShape()
			    };
			});
        	
        	return dockers;
        });
	},
	
	restoreContainer: function(shape) {
		
		if (this.childShapes[shape.resourceId]) {
		
			this.childShapes[shape.resourceId].each(function(each){
							
				var childShape = each.shape;
				var bounds = each.bounds;
				
				this.rollbackGlossaryEntryUpdate(childShape.resourceId)

				if (this.facade.getRules().isContainer(childShape)) {
					this.restoreContainer(childShape);
				}
				
				childShape.bounds.set(bounds);
				
				shape.add(childShape);
				
				
			}.bind(this));
		}
	},
	
	deleteOutgoings: function(shape) {
			
		if (!(shape instanceof ORYX.Core.Edge)) {
			shape.getOutgoingShapes().each(function(each){
			
				if (each instanceof ORYX.Core.Node) {
					this.deleteOutgoings(each);
				}
				
				var shapeAsJSON = each.toJSON();
				
				shapeAsJSON.parent = {resourceId : each.getParentShape().resourceId};
            	shapeAsJSON.parentIndex = each.getParentShape().getChildShapes().indexOf(each);
				
				this.shapesAsJson.push(shapeAsJSON);
				this.edgesToDelete.push(each);
			}.bind(this));			
		}
		
	},
	
	deleteIncomings: function(shape) {
		
		// Don't remove releated edges if the current shape is an edge
		if (shape instanceof  ORYX.Core.Edge){
			return;
		}
		
		// Remove all incoming edges
		shape.getIncomingShapes().each(function(each) {
			
			if(each instanceof ORYX.Core.Edge) {
				var shapeAsJSON = each.toJSON();
				
				shapeAsJSON.parent = {resourceId : each.getParentShape().resourceId};
            	shapeAsJSON.parentIndex = each.getParentShape().getChildShapes().indexOf(each);
				
				this.shapesAsJson.push(shapeAsJSON);
				this.edgesToDelete.push(each);
			}
			
		}.bind(this));
	},
	
	deleteContainer: function(shape, parent, parentAbsoluteBounds) {
		
		// Only remove children once
		if (this.childShapes[shape.resourceId]){
			return;
		}
		
		var children = shape.getChildNodes();
		
		this.childShapes[shape.resourceId] = [];
		
		children.each(function(childShape) {
			
			var absolutePosChild = {
					x: parentAbsoluteBounds.x + childShape.bounds.a.x,
					y: parentAbsoluteBounds.y + childShape.bounds.a.y
			};
			
			var bounds = {
				a: {
					x: absolutePosChild.x - parentAbsoluteBounds.x,
					y: absolutePosChild.y - parentAbsoluteBounds.y
				},
				b: {
					x: absolutePosChild.x - parentAbsoluteBounds.x + childShape.bounds.width(),
					y: absolutePosChild.y - parentAbsoluteBounds.y + childShape.bounds.height()
				}
			};
			
			var restoreObject = {
				shape: childShape,
				bounds: bounds
			};
			
			// log all child shapes of the container
			this.childShapes[shape.resourceId].push(restoreObject);
								
			// find next parent that can contain the child shape
			var parentShape = this.findParent(childShape, parent);
			
			if(parentShape !== null) {
								
				var bounds = this.computeBounds(childShape, parentShape, absolutePosChild);
				childShape.bounds.set(bounds);
				
				parentShape.add(childShape);

			} else {
				this.updateGlossaryEntries(childShape);
				
				// if no parent was found delete the shape
				this.facade.deleteShape(childShape);
				
				if(this.facade.getRules().isContainer(childShape)) {
					this.deleteContainer(childShape, parent, absolutePosChild);
				} 
				
				
			}
		}.bind(this));
	},
	
	findParent: function(shape, parent) {		
		if(parent) {
						
			var args = {
				containingStencil:	parent.getStencil(),
				containedStencil: 	shape.getStencil(),
				containingShape:	parent,
				containedShape:		shape
			};
			
			if(this.facade.getRules().canContain(args)) {
				//console.log("can contain " + parent.getStencil().id() + " --> " + shape.getStencil().id());
				return parent
				
			} else if(parent.parent){
				//console.log("cannot contain "+ parent.getStencil().id() + " --> " + shape.getStencil().id())
				return this.findParent(shape, parent.getParentShape());
			}
		}
		
		return null;
	},
	
	computeBounds: function(shape, parentShape, absolutePosChild) {
				
		if (!(parentShape instanceof ORYX.Core.Canvas)) {
			
			var absolutePosParent = parentShape.absoluteXY();
			
			var bounds = {
				a: {
					x: absolutePosChild.x - absolutePosParent.x,
					y: absolutePosChild.y - absolutePosParent.y
				},
				b: {
					x: absolutePosChild.x - absolutePosParent.x + shape.bounds.width(),
					y: absolutePosChild.y - absolutePosParent.y + shape.bounds.height()
				}
			};
			
		} else {
						
			var bounds = {
				a: {
					x: absolutePosChild.x,
					y: absolutePosChild.y
				},
				b: {
					x: absolutePosChild.x + shape.bounds.width(),
					y: absolutePosChild.y + shape.bounds.height()
				}
			};
			
		}
		
		return bounds;
		
	},
	
	updateGlossaryEntries: function(shape) {
		// Check for glossary support
		if (this.facade.hasGlossaryExtension && this.facade.hasGlossary(shape)) {
			// delete glossary entries
			shape.getStencil().properties().each(function(prop){
				var gl = this.facade.getGlossary(shape, prop);
				if (gl) {
					// Force to be an array
					[].concat(gl).each(function(gl){
						var p = {};
						p.prop = prop;
						p.glossary = gl.glossary;
						p.text = gl.text;
						p.shape = gl.shape;
						
						// store value for rollback
						if(!this.glossarProperties[gl.shape.resourceId]) {
							this.glossarProperties[gl.shape.resourceId] = [];
						}
						this.glossarProperties[gl.shape.resourceId].push(p);		
						
						// delete entry
						this.facade.setGlossary(shape, prop);
					}.bind(this))
									
				}
			}.bind(this));
		}
	},
	
	rollbackGlossaryEntryUpdate: function(resourceId) {
		// update glossary entries
		if(this.facade.hasGlossaryExtension && this.glossarProperties[resourceId]) {
			this.glossarProperties[resourceId].each(function(p) {
				this.facade.setGlossary(p.shape, p.prop, p.glossary, p.text, false);
			}.bind(this));
		}
	}
});

/**
 * Copyright (c) 2009
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.KeysMove = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
    
        this.facade = facade;
        this.copyElements = [];
        
        //this.facade.registerOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keyHandler.bind(this));

		// SELECT ALL
		this.facade.offer({
		keyCodes: [{
		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: 65,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
			}
		 ],
         functionality: this.selectAll.bind(this)
         });
		 
		// MOVE LEFT SMALL		
		this.facade.offer({
		keyCodes: [{
		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: ORYX.CONFIG.KEY_CODE_LEFT,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
			}
		 ],
         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_LEFT, false)
         });
		 
		 // MOVE LEFT
		 this.facade.offer({
		 keyCodes: [{
				keyCode: ORYX.CONFIG.KEY_CODE_LEFT,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
			}
		 ],
         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_LEFT, true)
         });
		 
		// MOVE RIGHT SMALL	
		 this.facade.offer({
		 keyCodes: [{
		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: ORYX.CONFIG.KEY_CODE_RIGHT,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
			}
		 ],
         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_RIGHT, false)
         });
		 
		// MOVE RIGHT	
		 this.facade.offer({
		 keyCodes: [{
				keyCode: ORYX.CONFIG.KEY_CODE_RIGHT,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
			}
		 ],
         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_RIGHT, true)
         });
		 
		// MOVE UP SMALL	
		 this.facade.offer({
		 keyCodes: [{
		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: ORYX.CONFIG.KEY_CODE_UP,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
			}
		 ],
         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_UP, false)
         });
		 
		// MOVE UP	
		 this.facade.offer({
		 keyCodes: [{
				keyCode: ORYX.CONFIG.KEY_CODE_UP,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
			}
		 ],
         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_UP, true)
         });
		 
		// MOVE DOWN SMALL	
		 this.facade.offer({
		 keyCodes: [{
		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
				keyCode: ORYX.CONFIG.KEY_CODE_DOWN,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
			}
		 ],
         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_DOWN, false)
         });
		 
		// MOVE DOWN	
		 this.facade.offer({
		 keyCodes: [{
				keyCode: ORYX.CONFIG.KEY_CODE_DOWN,
				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 
			}
		 ],
         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_DOWN, true)
         });
		 
         
    },
    
	/**
	 * Select all shapes in the editor
	 *
	 */
	selectAll: function(e){
    	Event.stop(e.event);
		this.facade.setSelection(this.facade.getCanvas().getChildShapes(true))
	},
	
	move: function(key, far, e) {
		
    	Event.stop(e.event);

		// calculate the distance to move the objects and get the selection.
		var distance = far ? 20 : 1;
		var selection = this.facade.getSelection();
		var currentSelection = this.facade.getSelection();
		var p = {x: 0, y: 0};
		
		// switch on the key pressed and populate the point to move by.
		switch(key) {

			case ORYX.CONFIG.KEY_CODE_LEFT:
				p.x = -1*distance;
				break;
			case ORYX.CONFIG.KEY_CODE_RIGHT:
				p.x = distance;
				break;
			case ORYX.CONFIG.KEY_CODE_UP:
				p.y = -1*distance;
				break;
			case ORYX.CONFIG.KEY_CODE_DOWN:
				p.y = distance;
				break;
		}
		
		var violatedBoundaries = false;

		// Filter all bpmn2.0 lanes from the selection
		selection = selection.findAll(function(s) {
			// If the selected item is not a node
			if (!(s instanceof ORYX.Core.Node)) {
				return true;
			}
			// If the selected item is not bpmn2.0
			else if (s.getStencil().namespace() !== "http://b3mn.org/stencilset/bpmn2.0#") {
				return true;
			}
			// If the selected item is bpmn2.0 but not a lane
			else if (!s.getStencil().idWithoutNs().endsWith("Lane")) {
				return true;
			}
			// If the selected item is a bpmn2.0 lane
			return false;
		});
		// move each shape in the selection by the point calculated and update it.
		selection = selection.findAll(function(shape){ 

			// Check if this shape is docked to an shape in the selection
			if(shape instanceof ORYX.Core.Node && shape.dockers.length == 1 && shape.dockers.first().getDockedShape()){ 
				
				return false;
			}
			
			// Check if any of the parent shape is included in the selection and not a Lane (because they are unselected when moved)
			var s = shape.parent;
			do{ 
				if(selection.include(s)){ 
					return false;
				}
			}while(s = s.parent);	

			
			
			/* Check if the movement would violate the parent's boundaries if the parent is not the canvas */
			if (!(shape.parent instanceof ORYX.Core.Canvas)) {
				// the relative position of the parent
				var boundaries = shape.parent.bounds;
				var bul = boundaries.upperLeft();
				var blr = boundaries.lowerRight();
				
				var ul = shape.bounds.upperLeft();
				var lr = shape.bounds.lowerRight();
				var pam = {
						ul: {x: ul.x + p.x, y: ul.y + p.y},
						lr: {x: lr.x + p.x, y: lr.y + p.y}
				};
				
				if (pam.ul.x < 0 || pam.lr.x > boundaries.width() ||
					pam.ul.y < 0 || pam.lr.y > boundaries.height()) {
					violatedBoundaries = true;
					throw $break;
				}
			}
			
			// Otherwise, return true
			return true;
			
		});
		
		// Do not move the selected shapes when any boundaries are violated
		if (violatedBoundaries) {
			return;
		}
		
		/* Edges must not be movable, if only edges are selected and at least 
		 * one of them is docked.
		 */
		var edgesMovable = true;
		var onlyEdgesSelected = selection.all(function(shape) {
			if(shape instanceof ORYX.Core.Edge) {
				if(shape.isDocked()) {
					edgesMovable = false;
				}
				return true;	
			}
			return false;
		});
		
		if(onlyEdgesSelected && !edgesMovable) {
			/* Abort moving shapes */
			return;
		}
		
		selection = selection.map(function(shape){ 
			if( shape instanceof ORYX.Core.Node ){
				/*if( shape.dockers.length == 1 ){
					return shape.dockers.first()
				} else {*/
					return shape
				//}
			} else if( shape instanceof ORYX.Core.Edge ) {
				
				var dockers = shape.dockers;
				
				if( selection.include( shape.dockers.first().getDockedShape() ) ){
					dockers = dockers.without( shape.dockers.first() )
				}

				if( selection.include( shape.dockers.last().getDockedShape() ) ){
					dockers = dockers.without( shape.dockers.last() )
				}
				
				return dockers	
							
			} else {
				return null
			}
		
		}).flatten().compact();
		
		if (selection.size() > 0) {
			
			//Stop moving at canvas borders
			var selectionBounds = [ this.facade.getCanvas().bounds.lowerRight().x,
			                        this.facade.getCanvas().bounds.lowerRight().y,
			                        0,
			                        0 ];
			selection.each(function(s) {
				selectionBounds[0] = Math.min(selectionBounds[0], s.bounds.upperLeft().x);
				selectionBounds[1] = Math.min(selectionBounds[1], s.bounds.upperLeft().y);
				selectionBounds[2] = Math.max(selectionBounds[2], s.bounds.lowerRight().x);
				selectionBounds[3] = Math.max(selectionBounds[3], s.bounds.lowerRight().y);
			});
			if(selectionBounds[0]+p.x < 0)
				p.x = -selectionBounds[0];
			if(selectionBounds[1]+p.y < 0)
				p.y = -selectionBounds[1];
			if(selectionBounds[2]+p.x > this.facade.getCanvas().bounds.lowerRight().x)
				p.x = this.facade.getCanvas().bounds.lowerRight().x - selectionBounds[2];
			if(selectionBounds[3]+p.y > this.facade.getCanvas().bounds.lowerRight().y)
				p.y = this.facade.getCanvas().bounds.lowerRight().y - selectionBounds[3];
			
			if(p.x!=0 || p.y!=0) {
				// Instantiate the moveCommand
				var commands = [new ORYX.Core.Command.Move(selection, p, null, currentSelection, this)];
				// Execute the commands			
				this.facade.executeCommands(commands);
			}
			
		}
	},
	
	getUndockedCommant: function(shapes){

		var undockEdgeCommand = ORYX.Core.Command.extend({
			construct: function(moveShapes){
				this.dockers = moveShapes.collect(function(shape){ return shape instanceof ORYX.Core.Controls.Docker ? {docker:shape, dockedShape:shape.getDockedShape(), refPoint:shape.referencePoint} : undefined }).compact();
			},			
			execute: function(){
				this.dockers.each(function(el){
					el.docker.setDockedShape(undefined);
				})
			},
			rollback: function(){
				this.dockers.each(function(el){
					el.docker.setDockedShape(el.dockedShape);
					el.docker.setReferencePoint(el.refPoint);
					//el.docker.update();
				})
			}
		});
		
		command = new undockEdgeCommand( shapes );
		command.execute();	
		return command;
	}
	
//    /**
//     * The key handler for this plugin. Every action from the set of cut, copy,
//     * paste and delete should be accessible trough simple keyboard shortcuts.
//     * This method checks whether any event triggers one of those actions.
//     *
//     * @param {Object} event The keyboard event that should be analysed for
//     *     triggering of this plugin.
//     */
//    keyHandler: function(event){
//        //TODO document what event.which is.
//        
//        ORYX.Log.debug("keysMove.js handles a keyEvent.");
//        
//        // assure we have the current event.
//        if (!event) 
//            event = window.event;
//        
//        // get the currently pressed key and state of control key.
//        var pressedKey = event.which || event.keyCode;
//        var ctrlPressed = event.ctrlKey;
//
//		// if the key is one of the arrow keys, forward to move and return.
//		if ([ORYX.CONFIG.KEY_CODE_LEFT, ORYX.CONFIG.KEY_CODE_RIGHT,
//			ORYX.CONFIG.KEY_CODE_UP, ORYX.CONFIG.KEY_CODE_DOWN].include(pressedKey)) {
//			
//			this.move(pressedKey, !ctrlPressed);
//			return;
//		}
//		
//    }
	
});
/**
 * Copyright (c) 2009
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins) { ORYX.Plugins = {} }
if(!ORYX.Plugins.Layouter) { ORYX.Plugins.Layouter = {} }

new function(){
	
	/**
	 * Edge layouter is an implementation to layout an edge
	 * @class ORYX.Plugins.Layouter.EdgeLayouter
	 * @author Willi Tscheschner
	 */
	ORYX.Plugins.Layouter.EdgeLayouter = ORYX.Plugins.AbstractLayouter.extend({
		
		/**
		 * Layout only Edges
		 */
		layouted : [	"http://b3mn.org/stencilset/bpmn1.1#SequenceFlow", 
						"http://b3mn.org/stencilset/bpmn1.1#MessageFlow",
						"http://b3mn.org/stencilset/timjpdl3#SequenceFlow", 
						"http://b3mn.org/stencilset/jbpm4#SequenceFlow", 
						"http://b3mn.org/stencilset/bpmn2.0#MessageFlow",
						"http://b3mn.org/stencilset/bpmn2.0#SequenceFlow", 
						"http://b3mn.org/stencilset/bpmn2.0choreography#MessageFlow",
						"http://b3mn.org/stencilset/bpmn2.0choreography#SequenceFlow", 
						"http://b3mn.org/stencilset/bpmn2.0conversation#ConversationLink",
						"http://b3mn.org/stencilset/epc#ControlFlow",
						"http://www.signavio.com/stencilsets/processmap#ProcessLink",
						"http://www.signavio.com/stencilsets/organigram#connection",
						"http://b3mn.org/stencilset/UML2.2Class#"],
		
		/**
		 * Layout a set on edges
		 * @param {Object} edges
		 */
		layout: function(edges){
			edges.each(function(edge){
				this.doLayout(edge)
			}.bind(this))
		},
		
		/**
		 * Layout one edge
		 * @param {ORYX.Core.Edge} edge
		 */
		doLayout: function(edge){
			// Get from and to node

			var from 	= edge.getIncomingNodes()[0]; 
			var to 		= edge.getOutgoingNodes()[0];
			
			// Return if one is null
			if (!from || !to) { return; }
			
			var positions = this.getPositions(from, to, edge);
		
			if (positions.length > 0){
				this.setDockers(edge, positions[0].a, positions[0].b);
			}
				
		},
		
		/**
		 * Returns a set on positions which are not containt either 
		 * in the bounds in from or to.
		 * @param {ORYX.Core.Shape} from Shape where the edge is come from
		 * @param {ORYX.Core.Shape} to Shape where the edge is leading to
		 * @param {ORYX.Core.Edge} edge Edge between from and to
		 * @returns {Set} The new Positions
		 */
		getPositions : function(from, to, edge){

			// Get absolute bounds
			var ab = from.absoluteBounds();
			var bb = to.absoluteBounds();
			
			
			// Get center from and to
			var a = ab.center();
			var b = bb.center();
			
			var am = ab.midPoint();
			var bm = bb.midPoint();
			
			var isMessageflow = edge.getStencil().keepState();
			// Layout messageflows in a different, more static, way
			if (isMessageflow && edge.dockers.length <= 3) {
			
				// Get the overlapping area
				var overlap = from.getOverlap(to);
				
				if (overlap){
					var xOverlap = Math.round(Math.min(ab.lowerRight().x, bb.lowerRight().x) - Math.max(ab.upperLeft().x, bb.upperLeft().x));
					var yOverlap = Math.round(Math.min(ab.lowerRight().y, bb.lowerRight().y) - Math.max(ab.upperLeft().y, bb.upperLeft().y));
					
					var threshold = 12;
					// Compare with Threshold
					if (xOverlap > threshold || yOverlap > threshold) {
						/* If the edge is already inside the overlapping area, do nothing (reacts on changes
						 * made in the shapemenu.js: the newly created edge and it's parallel edges are already
						 * justified. 
						 */
						var firstRef = edge.dockers.first().getAbsoluteReferencePoint();
						var lastRef = edge.dockers.last().getAbsoluteReferencePoint();
						if (overlap.isIncluded({x: xOverlap > 0 ? firstRef.x:
																  overlap.center().x,
												y: xOverlap > 0 ? overlap.center().y:
													firstRef.y}) &&
							overlap.isIncluded({x: xOverlap > 0 ? lastRef.x:
																  overlap.center().x,
												y: xOverlap > 0 ? overlap.center().y:
													lastRef.y})) {
							return [];
						}
					} else {
						edge.dockers.first().setReferencePoint(am);
						edge.dockers.last().setReferencePoint(bm);
					}
				}
			}
		
			// Get first and last reference point
			var first = Object.clone(edge.dockers.first().referencePoint);
			var last = Object.clone(edge.dockers.last().referencePoint);
			// Get the absolute one
			var aFirst = edge.dockers.first().getAbsoluteReferencePoint();
			var aLast = edge.dockers.last().getAbsoluteReferencePoint(); 
		
			// IF ------>
			// or  |
			//     V
			// Do nothing
			if (Math.abs(aFirst.x-aLast.x) < 1 || Math.abs(aFirst.y-aLast.y) < 1) {
				return [];
			}
			
			// Calc center position, between a and b
			// depending on their weight
			var m = {};
			m.x = a.x < b.x ? 
					(((b.x - bb.width()/2) - (a.x + ab.width()/2))/2) + (a.x + ab.width()/2): 
					(((a.x - ab.width()/2) - (b.x + bb.width()/2))/2) + (b.x + bb.width()/2);

			m.y = a.y < b.y ? 
					(((b.y - bb.height()/2) - (a.y + ab.height()/2))/2) + (a.y + ab.height()/2): 
					(((a.y - ab.height()/2) - (b.y + bb.height()/2))/2) + (b.y + bb.height()/2);
								
								
			// Enlarge both bounds with 10
			ab.widen(5); // Wide the from less than 
			bb.widen(20);// the to because of the arrow from the edge
								
			var positions = [];
			var off = this.getOffset.bind(this);
			
			// Checks ----+
			//            |
			//            V
			if (!ab.isIncluded(b.x, a.y)&&!bb.isIncluded(b.x, a.y)) {
				positions.push({
					a : {x:b.x+off(last,bm,"x"),y:a.y+off(first,am,"y")},
					z : this.getWeight(from, a.x < b.x ? "r" : "l", to, a.y < b.y ? "t" : "b", edge) * (isMessageflow?2:1)
				});
			}
						
			// Checks | 
			//        +--->
			if (!ab.isIncluded(a.x, b.y)&&!bb.isIncluded(a.x, b.y)) {
				positions.push({
					a : {x:a.x+off(first,am,"x"),y:b.y+off(last,bm,"y")},
					z : this.getWeight(from, a.y < b.y ? "b" : "t", to, a.x < b.x ? "l" : "r", edge) * (isMessageflow?2:1)
						
				});
			}
						
			// Checks  --+
			//           |
			//           +--->
			if (!ab.isIncluded(m.x, a.y)&&!bb.isIncluded(m.x, b.y)) {
				positions.push({
					a : {x:m.x,y:a.y+off(first,am,"y")},
					b : {x:m.x,y:b.y+off(last,bm,"y")},
					z : this.getWeight(from, "r", to, "l", edge, a.x > b.x)
				});
			}
			
			// Checks | 
			//        +---+
			//            |
			//            V
			if (!ab.isIncluded(a.x, m.y)&&!bb.isIncluded(b.x, m.y)) {
				positions.push({
					a : {x:a.x+off(first,am,"x"),y:m.y},
					b : {x:b.x+off(last,bm,"x"),y:m.y},
					z : this.getWeight(from, "b", to, "t", edge, a.y > b.y)
				});
			}	
			
			// Sort DESC of weights
			return positions.sort(function(a,b){ return a.z < b.z ? 1 : (a.z == b.z ? 0 : -1); });
		},
		
		/**
		 * Returns a offset for the pos to the center of the bounds
		 * 
		 * @param {Object} val
		 * @param {Object} pos2
		 * @param {String} dir Direction x|y
		 */
		getOffset: function(pos, pos2, dir){
			return pos[dir] - pos2[dir];
		},
		
		/**
		 * Returns a value which shows the weight for this configuration
		 * 
		 * @param {Object} from Shape which is coming from
		 * @param {String} d1 Direction where is goes
		 * @param {Object} to Shape which goes to
		 * @param {String} d2 Direction where it comes to
		 * @param {Object} edge Edge between from and to
		 * @param {Boolean} reverse Reverse the direction (e.g. "r" -> "l")
		 */
		getWeight: function(from, d1, to, d2, edge, reverse){
			
			d1 = (d1||"").toLowerCase();
			d2 = (d2||"").toLowerCase();
			
			if (!["t","r","b","l"].include(d1)){ d1 = "r"}
			if (!["t","r","b","l"].include(d2)){ d1 = "l"}
			
			// If reverse is set
			if (reverse) {
				// Reverse d1 and d2
				d1 = d1=="t"?"b":(d1=="r"?"l":(d1=="b"?"t":(d1=="l"?"r":"r")))
				d2 = d2=="t"?"b":(d2=="r"?"l":(d2=="b"?"t":(d2=="l"?"r":"r")))
			}
			
					
			var weight = 0;
			// Get rules for from "out" and to "in"
			var canvasOrientation = this.facade.getCanvas().getOrientation();
			var dr1 = this.facade.getRules().getLayoutingRules(from, edge, canvasOrientation)["out"];
			var dr2 = this.facade.getRules().getLayoutingRules(to, edge, canvasOrientation)["in"];

			var fromWeight = dr1[d1];
			var toWeight = dr2[d2];


			/**
			 * Return a true if the center 1 is in the same direction than center 2
			 * @param {Object} direction
			 * @param {Object} center1
			 * @param {Object} center2
			 */
			var sameDirection = function(direction, center1, center2){
				switch(direction){
					case "t": return Math.abs(center1.x - center2.x) < 2 && center1.y < center2.y
					case "r": return center1.x > center2.x && Math.abs(center1.y - center2.y) < 2
					case "b": return Math.abs(center1.x - center2.x) < 2 && center1.y > center2.y
					case "l": return center1.x < center2.x && Math.abs(center1.y - center2.y) < 2
					default: return false;
				}
			}

			// Check if there are same incoming edges from 'from'
			var sameIncomingFrom = from
								.getIncomingShapes()
								.findAll(function(a){ return a instanceof ORYX.Core.Edge})
								.any(function(e){ 
									return sameDirection(d1, e.dockers[e.dockers.length-2].bounds.center(), e.dockers.last().bounds.center());
								});

			// Check if there are same outgoing edges from 'to'
			var sameOutgoingTo = to
								.getOutgoingShapes()
								.findAll(function(a){ return a instanceof ORYX.Core.Edge})
								.any(function(e){ 
									return sameDirection(d2, e.dockers[1].bounds.center(), e.dockers.first().bounds.center());
								});
			
			// If there are equivalent edges, set 0
			//fromWeight = sameIncomingFrom ? 0 : fromWeight;
			//toWeight = sameOutgoingTo ? 0 : toWeight;
			
			// Get the sum of "out" and the direction plus "in" and the direction 						
			return (sameIncomingFrom||sameOutgoingTo?0:fromWeight+toWeight);
		},
		
		/**
		 * Removes all current dockers from the node 
		 * (except the start and end) and adds two new
		 * dockers, on the position a and b.
		 * @param {Object} edge
		 * @param {Object} a
		 * @param {Object} b
		 */
		setDockers: function(edge, a, b){
			if (!edge){ return }
			
			// Remove all dockers (implicit,
			// start and end dockers will not removed)
			edge.dockers.each(function(r){
				edge.removeDocker(r);
			});
			
			// For a and b (if exists), create
			// a new docker and set position
			[a, b].compact().each(function(pos){
				var docker = edge.createDocker(undefined, pos);
				docker.bounds.centerMoveTo(pos);
			});
			
			// Update all dockers from the edge
			edge.dockers.each(function(docker){
				docker.update()
			})
			
			// Update edge
			//edge.refresh();
			edge._update(true);
			
		}
	});
	
	
}()
/**
 * Copyright (c) 2008, Gero Decker, refactored by Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

/**
   This plugin is a generic syntax checker for different diagram types.
   Needs server communication.
   @class ORYX.Plugins.SyntaxChecker
   @constructor Creates a new instance
   @extends ORYX.Plugins.AbstractPlugin
*/
ORYX.Plugins.SyntaxChecker = ORYX.Plugins.AbstractPlugin.extend({
    /**@private*/
    construct: function(){
        arguments.callee.$.construct.apply(this, arguments);
                
        this.active = false;
        this.raisedEventIds = [];
        
        this.facade.offer({
            'name': ORYX.I18N.SyntaxChecker.name,
            'functionality': this.perform.bind(this),
            'group': ORYX.I18N.SyntaxChecker.group,
            'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/chart_curve_error.png",
            'description': ORYX.I18N.SyntaxChecker.desc,
            'index': 0,
            'toggle': true,
            'minShape': 0,
            'maxShape': 0
        });
        
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT, this.checkForErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT, this.resetErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT, this.doShowErrors.bind(this));
    },
    
    perform: function(button, pressed){
        if (!pressed) {
            this.resetErrors();
        } else {
            this.checkForErrors({
                onNoErrors: function(){
                    this.setActivated(button, false);
                    this.facade.raiseEvent({
            			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
            			text:ORYX.I18N.SyntaxChecker.noErrors,
            			timeout:10000
            		});
                    //Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SyntaxChecker.noErrors);
                }.bind(this),
                onErrors: function(){
                    this.enableDeactivationHandler(button);
                }.bind(this),
                onFailure: function(){
                    this.setActivated(button, false);
                    Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SyntaxChecker.invalid);
                }.bind(this)
            });      
        }
    },
    
    /**
     * Registers handler for deactivating syntax checker as soon as somewhere is clicked...
     * @param {Ext.Button} Toolbar button
     */
    enableDeactivationHandler: function(button){
        var deactivate = function(){
            this.setActivated(button, false);
            this.resetErrors();
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate);
        };
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate.bind(this));
    },
    
    /**
     * Sets the activated state of the plugin
     * @param {Ext.Button} Toolbar button
     * @param {Object} activated
     */
    setActivated: function(button, activated){
        button.toggle(activated);
        if(activated === undefined){
            this.active = !this.active;
        } else {
            this.active = activated;
        }
    },
    
    /**
     * Performs request to server to check for errors on current model.
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Object} options Configuration hash
     * @param {String} context A context send to the syntax checker servlet
     * @param {Function} [options.onNoErrors] Raised when model has no errors.
     * @param {Function} [options.onErrors] Raised when model has errors.
     * @param {Function} [options.onFailure] Raised when server communcation failed.
     * @param {boolean} [options.showErrors=true] Display errors on nodes on canvas (by calling ORYX.Plugins.SyntaxChecker.prototype.showErrors)
     */
    checkForErrors: function(options){
        Ext.applyIf(options || {}, {
          showErrors: true,
          onErrors: Ext.emptyFn,
          onNoErrors: Ext.emptyFn,
          onFailure: Ext.emptyFn
        });
            
        Ext.Msg.wait(ORYX.I18N.SyntaxChecker.checkingMessage);

		var ss = this.facade.getStencilSets();
		var data = null;
		var url = ORYX.CONFIG.SYNTAXCHECKER_URL;
		var params = {
			resource: location.href,
            context: options.context,
			isJson: false	
		};
		
		if(ss.keys().include("http://b3mn.org/stencilset/bpmn2.0#") ||
			ss.keys().include("http://b3mn.org/stencilset/bpmn2.0choreography#") ||
				ss.keys().include("http://b3mn.org/stencilset/bpmn2.0conversation#")) {
			
			params.data_json = this.facade.getSerializedJSON();
			params.ns = "http://b3mn.org/stencilset/bpmn2.0#";
			params.isJson = true;
		} else if (ss.keys().include("http://b3mn.org/stencilset/epc#")) {
			params.data_json = this.facade.getSerializedJSON();
			params.ns = "http://b3mn.org/stencilset/epc#";
			params.isJson = true;
		} else {
			params.data = this.getRDFFromDOM();
		}
        
        // Send the request to the server.
        new Ajax.Request(url, {
            method: 'POST',
            asynchronous: false,
            parameters: params,
            onSuccess: function(request){
                var resp = (request&&request.responseText?request.responseText:"{}").evalJSON();
                
                Ext.Msg.hide();
                
                if (resp instanceof Object) {
                    resp = $H(resp)
                    if (resp.size() > 0) {
                        if(options.showErrors) this.showErrors(resp);
                 
                        options.onErrors();
                    }
                    else {
                        options.onNoErrors();
                    }
                }
                else {
                    options.onFailure();
                }
            }.bind(this),
            onFailure: function(){
                Ext.Msg.hide();
                options.onFailure();
            }
        });
    },
    
    /** Called on SHOW_ERRORS_EVENT.
     * 
     * @param {Object} event
     * @param {Object} args
     */
    doShowErrors: function(event, args){
        this.showErrors(event.errors);
    },
    
    /**
     * Shows overlays for each given error
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Hash|Object} errors
     * @example
     * showErrors({
     *     myShape1: "This has an error!",
     *     myShape2: "Another error!"
     * })
     */
    showErrors: function(errors){
        // If normal object is given, convert to hash
        if(!(errors instanceof Hash)){
            errors = new Hash(errors);
        }
        
        // Get all Valid ResourceIDs and collect all shapes
        errors.keys().each(function(value){
            var sh = this.facade.getCanvas().getChildShapeByResourceId(value);
            if (sh) {
                this.raiseOverlay(sh, this.parseCodeToMsg(errors[value]));
            }
        }.bind(this));
        this.active = !this.active;
        
        //show a status message with a hint to the error messages in the tooltip
        this.facade.raiseEvent({
			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
			text:ORYX.I18N.SyntaxChecker.notice,
			timeout:10000
		});
    },
    parseCodeToMsg: function(code){
    	var msg = code.replace(/: /g, "<br />").replace(/, /g, "<br />");
    	var codes = msg.split("<br />");
    	for (var i=0; i < codes.length; i++) {
    		var singleCode = codes[i];
    		var replacement = this.parseSingleCodeToMsg(singleCode);
    		if (singleCode != replacement) {
    			msg = msg.replace(singleCode, replacement);
    		}
    	}
		
		return msg;
	},
	
	parseSingleCodeToMsg: function(code){
		return ORYX.I18N.SyntaxChecker[code]||code;
	},
    /**
     * Resets all (displayed) errors
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     */
    resetErrors: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }.bind(this))
        
        this.raisedEventIds = [];
        this.active = false;
    },
    
    raiseOverlay: function(shape, errorMsg){
        var id = "syntaxchecker." + this.raisedEventIds.length;
        var crossId = ORYX.Editor.provideId();
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
            "id":crossId,
            "title":"",
            "stroke-width": 5.0,
            "stroke": "red",
            "d": "M20,-5 L5,-20 M5,-5 L20,-20",
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	html:errorMsg,
        	target:crossId
        });
        
        this.raisedEventIds.push(id);
        
        return cross;
    }
});

ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT = "checkForErrors";
ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT = "resetErrors";
ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT = "showErrors";

ORYX.Plugins.PetrinetSyntaxChecker = ORYX.Plugins.SyntaxChecker.extend({
    /*FIXME:: BPMN + EPC syntax checker needs rdf, but petri nets needs erdf.
     * So we override getRDFFromDOM from AbstractPlugin to return erdf.
     */
    getRDFFromDOM: function(){
        return this.facade.getERDF();
    }
});/**
 * Copyright (c) 2010
 * Willi Tscheschner, Jan-Felix Schwarz
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

/**
 * Define Namespace
 */
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();


new function(){
	
	// EXCLUDE_FROM_SHORTEN_CONTAINER: an array of stencil id's (including the stecil set namespace) of container shapes
	// to exclude from shortening 
	var EXCLUDE_FROM_SHORTEN_CONTAINER = [];
	// INCLUDE_IN_SHORTEN_CONTAINER: an array of stencil id's (including the stecil set namespace) of non-container shapes
	// to include in shortening
	var INCLUDE_IN_SHORTEN_CONTAINER = [
	    "http://b3mn.org/stencilset/bpmn2.0#CollapsedPool", 
	    "http://b3mn.org/stencilset/bpmn2.0#CollapsedVerticalPool"
	];
	
	// Convient class for 
	var Position = function(x, y){
	    this.x = (arguments.length === 1 && arguments[0].x !== undefined ? arguments[0].x : arguments[0]) || 0;
	    this.y = (arguments.length === 1 && arguments[0].y !== undefined ? arguments[0].y : arguments[1]) || 0;
	}
		
	Position.prototype.moveBy = function(){
		return new Position(this.x + (arguments.length === 1 && arguments[0].x !== undefined ? arguments[0].x : arguments[0]) || 0, 
							this.y + (arguments.length === 1 && arguments[0].y !== undefined ? arguments[0].y : arguments[1]) || 0);
	}
	
	Position.prototype.castToInts = function(){
		return new Position(Math.round(this.x), Math.round(this.y));
	}
	
	/**
	 * Provides a snapper to shorten/enlarge edges in one direction
	 * 
	 * @class ORYX.Plugins.Shorten
	 */
	ORYX.Plugins.Shorten = ORYX.Plugins.AbstractPlugin.extend({
	
		construct: function(facade){
			this.facade = facade;
			
			// Offer functionality
			this.facade.offer({
				name: ORYX.I18N.Functionality.shortenTitle,
				description: ORYX.I18N.Functionality.shortenDescription,
				icon: ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/transform_selection.png",
				functionality: function(button, pressed){
					if (!pressed){
						this.disableShorten();
					} else {
						this.enableShorten();
					}
					if (button){
						this.toggleButton = button;
					}
				}.bind(this),
				group: ORYX.I18N.Arrangement.groupA,
				index: 9,
				toggle: true,
				keyCodes: [{
				 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],
						keyCode: 77, // m-Keycode
						keyAction: ORYX.CONFIG.KEY_ACTION_UP 
					}
				 ]
			});
			
			// Disable shorten with ESC
			Ext.getDoc().on("keyup", function(e){
				if (e.keyCode === 27 && this.enabled){
					this.disableShorten();
					this.toggleButton.toggle(false);
				}
			}.bind(this))
					
			// Create Lines
			this.initLines();
			// Canvas
			this.canvas = Ext.get(this.facade.getCanvas().node.parentNode.parentNode);
		},
		
		initLines: function(){

			this.vLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_VERTICAL);
			this.hLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_HORIZONTAL);

			this.dLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_VERTICAL);
			this.dLine.line.setAttributeNS(null, "stroke", "black");
			
		},
		
		/**
		 * Disable selection change 
		 * if shorten is enabled
		 *
		 */
		onSelectionChanged: function(){
			if (this.enabled && this.facade.getSelection().length > 0){
				this.facade.setSelection([]);
			}
		},
		
		/**
		 * Enables the possibility 
		 * to shorten/enhance edges
		 *
		 */
		enableShorten: function(){
			
			if (this.enabled){
				return;
			}
			
			// Register events
			Ext.getDoc().on("mousemove", this.handleMouseMove, this);
			Ext.getDoc().on("mouseup", this.deactivateShorten, this);
			this.canvas.on("mousedown", this.activateShorten, this);
			this.disableEditorEvents();
			
			
			// Disable selection
			this.facade.setSelection([]);
			
			// Set flag
			this.enabled = true;
			//this.keyDown.disable();
			//this.keyUp.enable();
			
			// Set style
			this.canvas.setStyle({"cursor":"move"});
			
			// TODO: Show lines at enabled

		},
		
		/**
		 * Disables shorten function
		 *
		 */
		disableShorten: function(){
			if (!this.enabled){
				return;
			}
			
			this.deactivateShorten();
			// Delete flags
			delete this.enabled;
			delete this.lastEvent;
			//this.keyDown.enable();
			//this.keyUp.disable();
			
			// Hide lines
			this.vLine.hide();
			this.hLine.hide();
			this.dLine.hide();
			
			// Unregister on events
			Ext.getDoc().un("mousemove", this.handleMouseMove);
			Ext.getDoc().un("mouseup", this.deactivateShorten);
			this.canvas.un("mousedown", this.activateShorten);
			this.enableEditorEvents();
			
			this.canvas.setStyle({"cursor":"default"});
			
			if (this.toggleButton)
				this.toggleButton.toggle(false);
		},
		
		snapOffset: function(offset){

			if (!this.elements || !this.elementsPositions){
				return offset;
			}

			var snap 	= 8;
			var space 	= 45;
			
			this.elements.each(function(shape){
				var sUpL = this.elementsPositions[shape].abs;
				var nUpL = sUpL.moveBy(offset);
				
				var positions = this.cachedPositions[shape];
				if (positions){
					positions.each(function(pos){
						// Lower with upper-Position
						if (Math.abs(nUpL.y-pos.lo.y-space) < snap){
							offset.y = -(sUpL.y-pos.lo.y-space);
						// Center
						} else if (Math.abs((nUpL.y+shape.bounds.height()/2)-pos.ce.y) < snap){
							offset.y = -((sUpL.y+shape.bounds.height()/2)-pos.ce.y);
						}
						
						// Right with left-Position
						if (Math.abs(nUpL.x-pos.lo.x-space) < snap){
							offset.x = -(sUpL.x-pos.lo.x-space);
						// Center
						} else if (Math.abs((nUpL.x+shape.bounds.width()/2)-pos.ce.x) < snap){
							offset.x = -((sUpL.x+shape.bounds.width()/2)-pos.ce.x);
						}
					})
				}
			}.bind(this))
			
			// Snap to the origin position
			offset.x = Math.abs(offset.x) < snap ? 0 : offset.x;
			offset.y = Math.abs(offset.y) < snap ? 0 : offset.y;
			
			return offset;
		},
		
		getOffset: function(pos){
			
			// Define the offset
			var offset = {x: 0, y: 0};
			if (this.activate === ORYX.Core.GridLine.DIR_VERTICAL){
				offset.x = pos.x - this.startPosition.x;
			} else if (this.activate === ORYX.Core.GridLine.DIR_HORIZONTAL){
				offset.y = pos.y - this.startPosition.y;
			}
			return this.snapOffset(offset);
		},
		
		/**
		 * Moves a shape (node or docker)
		 * @return {boolean} Return true if the shape has to be updated or false otherwise
		 */
		moveAbstractShape: function(node, offset, sUpL, max){
			var upL 	= node.bounds.upperLeft();
			var rOffset = {
				//x : Math.max(0, Math.min(sUpL.x + offset.x, max.x - node.bounds.width())),
				//y : Math.max(0, Math.min(sUpL.y + offset.y, max.y - node.bounds.height()))
				x: sUpL.x + offset.x,
				y: sUpL.y + offset.y
			}
			
			// Only update changed nodes
			if (upL.x !== rOffset.x || upL.y !== rOffset.y) {
				node.bounds.moveTo(rOffset);
				return true;
			}
			return false;
		},
		
		moveElements: function(offset){
			if (!this.activate || !this.startPosition || !this.elements){
				return;
			}	
			
			// Define max area
			var max = this.facade.getCanvas().bounds.lowerRight();
			var needsUpdated = false;
			
			// Move every element				
			this.elements.each(function(node){
				
				var moveOffset = {
					x: this.elementsPositions[node].rel.x + offset.x - node.bounds.upperLeft().x,
					y: this.elementsPositions[node].rel.y + offset.y - node.bounds.upperLeft().y
				};
				if(node.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#Lane") {
					// special handling for BPMN 2.0 Lanes:
					// don't move any further if min height of parent shape is reached
					if(moveOffset.y<0) {
						var parent = node.getParentShape();
						var minHeightOffset = (this.getPoolLaneMinSize(parent).height-parent.bounds.height());
						moveOffset.y = Math.max(minHeightOffset, moveOffset.y);
					}
			    } else if(node.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#VerticalLane") {
					if(moveOffset.x<0) {
						var parent = node.getParentShape();
						var minWidthOffset = (this.getPoolLaneMinSize(parent).width-parent.bounds.width());
						moveOffset.x = Math.max(minWidthOffset, moveOffset.x);
					}
				}
				var adjustedOffset = {
					x: moveOffset.x - this.elementsPositions[node].rel.x + node.bounds.upperLeft().x,
					y: moveOffset.y - this.elementsPositions[node].rel.y + node.bounds.upperLeft().y
				};
				
				if (this.moveAbstractShape(node, adjustedOffset, this.elementsPositions[node].rel, max)){
					node._update();
					needsUpdated = true;
				}
			}.bind(this))
			
			
			// INFO: To update directly use this implementation
			// Move middle dockers
			//this.dockersPositions.each(function(pair){
			//	this.moveAbstractShape(pair.key, offset, pair.value, max);
			//}.bind(this))
			
			// Update all edges as well.
			//if (needsUpdated)
			//	this.edges.invoke("optimizedUpdate");

		},
		
		/**
		 *	SPECIFIC METHOD FOR BPMN 2.0 Stencil Set
		 *	This method computes the minimum size for Pool and Lane nodes under consideration of the contained
		 *	lane sizes and of the sizes of lanes on the same level
		 */
		getPoolLaneMinSize: function(node) {
		    
		    var parent = node.getParentShape();
		    if(parent.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#Pool" || parent.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#Lane") {
		        var aggregatedMinSize = this.getAggregatedMinSize(node);
		        var parentAggregatedMinSize = this.getAggregatedMinSize(parent);
		        return { 
		            width: parentAggregatedMinSize.width - node.bounds.upperLeft().x, 
		            height: aggregatedMinSize.height
		        };
		    } else if(parent.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#VerticalPool" || parent.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#VerticalLane") {
		        var aggregatedMinSize = this.getAggregatedMinSize(node);
		        var parentAggregatedMinSize = this.getAggregatedMinSize(parent);
		        return { 
		            width: aggregatedMinSize.width, 
		            height: parentAggregatedMinSize.height - node.bounds.upperLeft().y 
		        };
			} else {
			    
			    return this.getAggregatedMinSize(node);
			}
		    
		},
		
		/**
		 *	SPECIFIC METHOD FOR BPMN 2.0 Stencil Set
		 *	Recursive method to compute the minimum size for Pool and Lane nodes under consideration of the contained
		 *	lane sizes (called by getPoolLaneMinSize())
		 *
		 *  TODO: cache min sizes if there are any performance issues
		 */
		getAggregatedMinSize: function(node) {
			var minSize = node.minimumSize || { width: ORYX.CONFIG.MINIMUM_SIZE, height: ORYX.CONFIG.MINIMUM_SIZE };
			
			var aggregatedWidth = 0;
			var aggregatedHeight = 0;
			var minWidth = 0;
			var minHeight = 0;
			
			node.getChildNodes(false).each((function(child) { 
			    
			    if(child.getStencil().id() == "http://b3mn.org/stencilset/bpmn2.0#Lane") {
			        
			        if(!this.containers.include(child)) {
    					aggregatedHeight += child.bounds.height();
    				} else {
    					var childMinSize = this.getAggregatedMinSize(child)
    					aggregatedHeight += childMinSize.height;
    					var newMinWidth = child.bounds.upperLeft().x + childMinSize.width;
    					if(newMinWidth > minWidth) minWidth = newMinWidth;
    				}
			        
			    } else if(child.getStencil().id() == "http://b3mn.org/stencilset/bpmn2.0#VerticalLane") {
			        
			        if(!this.containers.include(child)) {
    					aggregatedWidth += child.bounds.width();
    				} else {
    					var childMinSize = this.getAggregatedMinSize(child)
    					aggregatedWidth += childMinSize.width;
    					var newMinHeight = child.bounds.upperLeft().y + childMinSize.height;
    					if(newMinHeight > minHeight) minHeight = newMinHeight;
    				}
			        
			    }
				
			}).bind(this));
			
			minSize.width = Math.max(minWidth, aggregatedWidth, minSize.width);
			minSize.height = Math.max(minHeight, aggregatedHeight, minSize.height);
			return minSize;
		},
		
		resizeContainers: function(offset) {
		
			if (!this.activate || !this.containers){
				return;
			}
			
			// Rersize every container	
			this.containers.each(function(node){
				
				var sSize = this.containersSizes[node];

				var minSize = node.minimumSize || { width: ORYX.CONFIG.MINIMUM_SIZE, height: ORYX.CONFIG.MINIMUM_SIZE };
				var maxSize = node.maximumSize || { width: ORYX.CONFIG.MAXIMUM_SIZE, height: ORYX.CONFIG.MAXIMUM_SIZE };
				
				if(node.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#Pool" || node.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#Lane"
					|| node.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#VerticalPool" || node.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#VerticalLane") {
					// special handling for BPMN 2.0 Pools and Lanes
					minSize = this.getPoolLaneMinSize(node);
				}

				var mmOffset = {
					x: (sSize.width + offset.x > maxSize.width) ? (maxSize.width - sSize.width) : 
						 ((sSize.width + offset.x < minSize.width) ? (minSize.width - sSize.width) : offset.x),
					y: (sSize.height + offset.y > maxSize.height) ? (maxSize.height - sSize.height) : 
						 ((sSize.height + offset.y < minSize.height) ? (minSize.height - sSize.height) : offset.y)
				};
				
				var extendOffset = {
					x: sSize.width + mmOffset.x - node.bounds.width(),
					y: sSize.height + mmOffset.y - node.bounds.height()
				};
				
				node.bounds.extend(extendOffset);
				this.moveContainersDockers(node, this.containersDockers, mmOffset, this.containersDockersPositions);
                
				node._update();
				node.outgoing.each(function(outgoing) {
					if(outgoing instanceof ORYX.Core.Node) outgoing._update();
				});
				
			}.bind(this));
			
		},

		moveContainersDockers: function(node, dockersToMove, offset, oldRefPoints) {
			
			var dockers = node.incoming.map(function(incoming) { return incoming.dockers.last(); }).concat(
					node.outgoing.map(function(outgoing) { return outgoing.dockers.first(); }));
			
			dockers.each(function(docker) { 
				var refPoint = oldRefPoints.find(function(pair) { return pair.key == docker}).value;
				if(dockersToMove.include(docker)) {
					// move the reference point by the extend offset
					var newRefPoint = {
						x: refPoint.x + offset.x,
						y: refPoint.y + offset.y
					};
					docker.setDockedShape(node);
					docker.setReferencePoint(newRefPoint);
				} else {
					// set the docked shape, so that the reference point will not be moved during update
					docker.setDockedShape(node);
					docker.setReferencePoint({x:refPoint.x, y:refPoint.y});
					// ensure that the reference point is inside the shape bounds
					if(docker.referencePoint.x>node.bounds.width())
						docker.setReferencePoint({ x: node.bounds.width(), y: docker.referencePoint.y });
					if(docker.referencePoint.y>node.bounds.height())
						docker.setReferencePoint({ x: docker.referencePoint.x, y: node.bounds.height() });
				}
			});

		},
		
		handleMouseMove: function(evt){
			
			// Get the current position
			var pos = this.getNormalizedXY(evt);
			this.lastEvent = evt;
			
			// If activate, move all elements and snap the position
			if (this.activate && this.startPosition && this.elements) {
				var offset = this.getOffset(pos);
				this.moveElements(offset);
				this.resizeContainers(offset);
				
				if (this.activate !== true) {
					if (this.activate === ORYX.Core.GridLine.DIR_VERTICAL) 
						this.dLine.update(this.startPosition.x + offset.x);
					else if (this.activate === ORYX.Core.GridLine.DIR_HORIZONTAL) 
						this.dLine.update(this.startPosition.y + offset.y);
				}
				
			} else {
				// Update line positions
				if (!this.activate || this.activate === ORYX.Core.GridLine.DIR_VERTICAL) 
					this.vLine.update(pos.x);
				if (!this.activate || this.activate === ORYX.Core.GridLine.DIR_HORIZONTAL) 
					this.hLine.update(pos.y);
			}
		},
		
		
		/**
		 * Listener on mouse move to
		 * decide if the shorten is vertical or horizontal.
		 *
		 */
		handleMouseMoveToDecideDirection: function(evt){
			
			var pos = this.getNormalizedXY(evt);
			var offset = 5;
			
			var distX = Math.abs(pos.x - this.startPosition.x);
			var distY = Math.abs(pos.y - this.startPosition.y);
			var dist  = ORYX.Core.Math.getDistancePointToPoint(pos, this.startPosition)
			if (dist > offset){
				
				if (distX >= distY){
					this.activateVerticalShorten();
				} else {
					this.activateHorizontalShorten();
				}
				this.beforeShorten();
				Ext.getDoc().un("mousemove", this.handleMouseMoveToDecideDirection);
			}
		},
		
		activateShorten: function(evt){
			Event.stop(evt);
			
			if (this.activate){
				return;
			}
			
			// Define vars
			this.activate = true;
			this.startPosition = this.getNormalizedXY(evt);
			
			// Register mouse move listener, to decide wether is horizontal or vertical
			Ext.getDoc().on("mousemove", this.handleMouseMoveToDecideDirection, this);
		},
				
		deactivateShorten: function(evt){
			
			if (this.activate && (evt || this.lastEvent)){
				this.afterShorten(this.getNormalizedXY(evt || this.lastEvent));
			}
			
			// Remove unused vars
			delete this.activate;
			delete this.elements;
			delete this.elementsPositions;
			delete this.cachedPositions;
			delete this.edges;
			delete this.dockersPositions;
			
			// Remove mouse listeners
			Ext.getDoc().un("mousemove", this.handleMouseMoveToDecideDirection);
			this.canvas.setStyle({"cursor":"move"});
			this.dLine.hide();
			
			// Update
			//this.facade.getCanvas().update();
			
			// Update mouse position
			if (evt)
				this.handleMouseMove(evt);
		},
		
		beforeShorten: function(){
			
			// Performance: Hide all edges
			if (this.edges)
				this.edges.invoke("hide");
			
			// Performance: Hide all labels and show nodes with opacity
			if (this.elements) {
				this.elements.each(function(shape){
					shape.hideLabels();
					shape.setOpacity(0.4);
				});
				this.containers.each(function(shape){
					shape.hideLabels();
					shape.setOpacity(0.4);
					// also make attached events opaque
					shape.outgoing.each(function(outgoing) {
						if(outgoing instanceof ORYX.Core.Node) {
							outgoing.hideLabels();
							outgoing.setOpacity(0.4);
						}
					});
				});
				
			}
		},
		
		afterShorten: function(pos){
			
			var offset = this.getOffset(pos);
			//offset.x = -offset.x;
			//offset.y = -offset.y;
			// Performance: Show all edges
			if (this.edges)
				this.edges.each(function(edge){
					edge.show();
					edge.dockers.invoke("hide");
					edge.getChildShapes().each(function(child) {
						child.magnets.invoke("hide");
					});
				});
				
			// Performance: Show all labels and show nodes with opacity
			if (this.elements) {

				this.elements.each(function(shape){
					shape.showLabels();
					shape.setOpacity();
				});
				this.containers.each(function(shape){
					shape.showLabels();
					shape.setOpacity();
					shape.outgoing.each(function(outgoing) {
						if(outgoing instanceof ORYX.Core.Node) {
							outgoing.showLabels();
							outgoing.setOpacity();
						}
					});
				});
							
				var UpdatePosition = ORYX.Core.Command.extend({
					construct: function(shapes, shapesStartPositions, dockers, containers, offset, containersSizes, containersDockers, containersDockersPositions, plugin){
						this.shapes		= shapes;
						this.shapesOffsets = {};
						shapes.each((function(shape) { 
							var absXY = shape.absoluteXY();
							this.shapesOffsets[shape] = {
								x: absXY.x - shapesStartPositions[shape].abs.x, 
								y: absXY.y - shapesStartPositions[shape].abs.y
							};
						}).bind(this));
						this.dockers	= dockers.pluck("key").map(function(r){ return {edge: r.parent, index:r.parent.dockers.indexOf(r)}});
						this.edges		= shapes.map(function(shape){ return shape.getAllDockedShapes() }).flatten().findAll(function(r){ return r instanceof ORYX.Core.Edge }).uniq();
						this.containers = containers;
						this.offset		= offset;
						this.containersSizes = containersSizes;
						this.containersDockers = containersDockers;
						this.containersDockersPositions = containersDockersPositions;
						this.facade		= plugin.facade;
						this.plugin	 	= plugin;
					},			
					execute: function(){
						if (this.executedOnce) {
							
							// Move nodes
							this.shapes.each(function(shape){
								shape.bounds.moveBy(this.shapesOffsets[shape]);
							}.bind(this));
							
							// Resize containers
							this.containers.each((function(container){
								var bounds = container.bounds;
								var minSize = container.minimumSize || { width: ORYX.CONFIG.MINIMUM_SIZE, height: ORYX.CONFIG.MINIMUM_SIZE };
								var maxSize = container.maximumSize || { width: ORYX.CONFIG.MAXIMUM_SIZE, height: ORYX.CONFIG.MAXIMUM_SIZE };
								
								if(container.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#Pool" || container.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#Lane"
									|| container.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#VerticalPool" || container.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#VerticalLane") {
									// special handling for BPMN 2.0 Pools and Lanes
									minSize = this.plugin.getPoolLaneMinSize(container);
								}
								
								var mmOffset = {
									x: (bounds.width() + this.offset.x > maxSize.width) ? (maxSize.width - bounds.width()) : 
										 ((bounds.width() + this.offset.x < minSize.width) ? (minSize.width - bounds.width()) : this.offset.x),
									y: (bounds.height() + this.offset.y > maxSize.height) ? (maxSize.height - bounds.height()) : 
										 ((bounds.height() + this.offset.y < minSize.height) ? (minSize.height - bounds.height()) : this.offset.y)
								};
								bounds.extend(mmOffset);
								this.plugin.moveContainersDockers(container, this.containersDockers, mmOffset, this.containersDockersPositions);
							}).bind(this));
							this.facade.getCanvas().update();
							
						}
						
						// Move the dockers
						this.dockers.each(function(docker){
							if (!docker.edge||!docker.edge.dockers[docker.index]){ return; }
							docker.edge.dockers[docker.index].bounds.moveBy(this.offset.x, this.offset.y);
						}.bind(this));
						// Remove dockers which are on the line between two other dockers
						this.removeDockers = this.edges.map(function(edge){
							return edge.removeUnusedDockers();
						});
						
						// Update
						this.facade.getCanvas().update();
						this.facade.updateSelection();
						this.executedOnce = true;
					},
					rollback: function(){
						// Move shapes
						this.shapes.each(function(shape) {
							var shapeOffset = this.shapesOffsets[shape];
							shape.bounds.moveBy(-shapeOffset.x, -shapeOffset.y);
						}.bind(this));
						
						// Restore old container sizes
						this.containers.each((function(container) {
							var oldSize = this.containersSizes[container];
							var offset = { x: oldSize.width - container.bounds.width(), y: oldSize.height - container.bounds.height() };
							container.bounds.extend(offset);	
						}).bind(this));

						// Add all removed dockers
						this.removeDockers.each(function(docker, i){
							docker.each(function(pair){
								this.edges[i].add(pair.value, pair.key)
							}.bind(this))
						}.bind(this));
						// Move the dockers
						this.dockers.each(function(docker){
							if (!docker.edge||!docker.edge.dockers[docker.index]){ return; }
							docker.edge.dockers[docker.index].bounds.moveBy(-this.offset.x, -this.offset.y);
						}.bind(this));
						
						// Restore old container docker positions
						this.containersDockersPositions.each(function(pair) {
							var docker = pair.key;
							var refPoint = pair.value;
							docker.setDockedShape(docker.getDockedShape());
							docker.setReferencePoint({x:refPoint.x, y:refPoint.y});
						});
						
						// Update
						this.facade.getCanvas().update();
						this.facade.updateSelection();
					}
				});
				
				// Execute the command
				this.facade.executeCommands([
					new UpdatePosition(this.elements, this.elementsPositions, this.dockersPositions, this.containers, offset, this.containersSizes, this.containersDockers, this.containersDockersPositions, this),
					new ORYX.Core.EnsureChildCommand(this.facade, this.elements.concat(this.containers), true)
				]);
			}
		},
		
		isIncludedInShortenContainer: function(node) {
			var stencilId = node.getStencil().id();
			if(!this.facade.getRules().isContainer(node) && !INCLUDE_IN_SHORTEN_CONTAINER.include(stencilId)) return false;
			if(EXCLUDE_FROM_SHORTEN_CONTAINER.include(stencilId)) return false;
			return true;
		},
		
		activateVerticalShorten: function(){
			this.activate = ORYX.Core.GridLine.DIR_VERTICAL;
			this.hLine.hide();
			this.dLine.direction = ORYX.Core.GridLine.DIR_VERTICAL;
			
			var x = this.startPosition.x;
			
			var allNodes = this.facade.getCanvas().getChildNodes(true);
			var nodes = allNodes.findAll(function(node){
				return node.absoluteXY().x >= x;
			});
			
			var containerNodes = allNodes.findAll((function(node){
				if( !this.isIncludedInShortenContainer(node) ) return false;
				var absBounds = node.absoluteBounds();
				return (absBounds.upperLeft().x <= x) && (absBounds.lowerRight().x >= x);
			}).bind(this));
			
			this.excludeAttachedNodesFromMoving(nodes, containerNodes);
			this.selectLanesToBeResized(nodes, containerNodes);

			var containersDockers = [];
			containerNodes.each((function(container) {
				this.fixReferencePoints(container, nodes);
				
				var dockers = container.incoming.map(function(incoming) { return incoming.dockers.last(); }).concat(
						container.outgoing.map(function(outgoing) { return outgoing.dockers.first(); }));
				dockers.each(function(docker){
					var ref = docker.getAbsoluteReferencePoint();
					if(ref.x >= x) containersDockers.push(docker);
				});
			}).bind(this));

			this.canvas.setStyle({"cursor":"e-resize"});
			this.setElements(nodes, containerNodes, containersDockers, allNodes);
		},
		
		activateHorizontalShorten: function(){
			this.activate = ORYX.Core.GridLine.DIR_HORIZONTAL;
			this.vLine.hide();
			this.dLine.direction = ORYX.Core.GridLine.DIR_HORIZONTAL;
			
			var y = this.startPosition.y;
			
			var allNodes = this.facade.getCanvas().getChildNodes(true);
			var nodes = allNodes.findAll(function(node){
				return node.absoluteXY().y >= y;
			});
			
			var containerNodes = allNodes.findAll((function(node){
				if( !this.isIncludedInShortenContainer(node) ) return false;
				var absBounds = node.absoluteBounds();
				return (absBounds.upperLeft().y <= y) && (absBounds.lowerRight().y >= y);
			}).bind(this));
			
			
			this.excludeAttachedNodesFromMoving(nodes, containerNodes);
			this.selectVerticalLanesToBeResized(nodes, containerNodes);

			var containersDockers = [];
			containerNodes.each((function(container) {
				this.fixReferencePoints(container, nodes);
				
				// store dockers in container shapes
				var dockers = container.incoming.map(function(incoming) { return incoming.dockers.last(); }).concat(
						container.outgoing.map(function(outgoing) { return outgoing.dockers.first(); }));
				dockers.each(function(docker){
					var ref = docker.getAbsoluteReferencePoint();
					if(ref.y >= y) containersDockers.push(docker);
				});
			}).bind(this));

			this.canvas.setStyle({"cursor":"s-resize"});
			this.setElements(nodes, containerNodes, containersDockers, allNodes);
		},
		
		/* 
		  special handling for BPMN pools and lanes:
		  when a pool or lane is resized also resize children pools and lanes instead of moving them
		*/
		selectLanesToBeResized: function(nodes, containerNodes) {
			var containerNodesCopy = containerNodes.clone();
			containerNodesCopy.each(function(container) {
			    if(container.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#Pool" || container.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#Lane") {
			        container.getChildShapes(true).each(function(child) {
			            if(child.getStencil().id()!="http://b3mn.org/stencilset/bpmn2.0#Lane") return;
			            if(nodes.include(child)) {
			                nodes.splice(nodes.indexOf(child), 1);
			                containerNodes.push(child);
			            }
			        });
			    }
			});
		},
		
		/* 
		  special handling for BPMN vertical pools and lanes:
		  when a pool or lane is resized also resize children pools and lanes instead of moving them
		*/
		selectVerticalLanesToBeResized: function(nodes, containerNodes) {
			var containerNodesCopy = containerNodes.clone();
			containerNodesCopy.each(function(container) {
			    if(container.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#VerticalPool" || container.getStencil().id()=="http://b3mn.org/stencilset/bpmn2.0#VerticalLane") {
			        container.getChildShapes(true).each(function(child) {
			            if(child.getStencil().id()!="http://b3mn.org/stencilset/bpmn2.0#VerticalLane") return;
			            if(nodes.include(child)) {
			                nodes.splice(nodes.indexOf(child), 1);
			                containerNodes.push(child);
			            }
			        });
			    }
			});
		},
		
		/*
		  throw out attached events of non-container nodes that are not moved
		 */
		excludeAttachedNodesFromMoving: function(nodes, containerNodes) {
		    var allNodes = this.facade.getCanvas().getChildNodes(true);
			allNodes.each(function(node) {
				if(nodes.include(node)) return;
				if(containerNodes.include(node)) return;
				node.outgoing.each(function(outgoing) {
					if(outgoing instanceof ORYX.Core.Node) {
						if(nodes.include(outgoing))
							nodes.splice(nodes.indexOf(outgoing), 1);
					}
				});
			});
			return nodes;
		},
		
		fixReferencePoints: function(container, nodes) {
		    container.outgoing.each(function(outgoing) {
				var containerBounds = undefined;
				if(outgoing instanceof ORYX.Core.Node) {
					// exclude attached events from the nodes array
					if(nodes.include(outgoing)) nodes.splice(nodes.indexOf(outgoing), 1);
					// set the reference point to the event's bounds center
					// (otherwise shifting the reference point will lead to 
					// unexpected positioning of the attached event)
					var docker = outgoing.dockers.first();
					var centerPoint = docker.bounds.center();
					if(!containerBounds) containerBounds = container.bounds;
				
					docker.setReferencePoint({
						x: centerPoint.x - containerBounds.upperLeft().x,
						y: centerPoint.y - containerBounds.upperLeft().y
					});
				}
			});
		},

		
		/**
		 * 
		 */
		setElements: function(nodes, containers, containersDockers, all){
			
			// Cache current elements
			this.elements = this.facade.getCanvas().getShapesWithSharedParent(nodes);
			
			// cache container nodes and their bounds
			this.containers = containers;
			
			var shapesAndContainers = this.elements.concat(this.containers);
			
			// Cache current elements and containers positions
			this.elementsPositions = {};
			shapesAndContainers.each(function(node){
				this.elementsPositions[node] = {
					rel: new Position(node.bounds.upperLeft()),
					abs: new Position(node.absoluteXY())
				}
			}.bind(this));
			
			// Cache sizes of container elements
			this.containersSizes = {};
			this.containers.each((function(node) {
				this.containersSizes[node] = {
					width: node.bounds.width(),
					height: node.bounds.height()
				}
			}).bind(this));
			
			// Store dockers of containers which have to be moved
			this.containersDockers = containersDockers;
			
			// Cache positions of all container dockers to be able to restore them on undo
			this.containersDockersPositions = [];
			var allDockers = this.containers.map(function(container) {
				return container.outgoing.map(function(outgoing) { return outgoing.dockers.first(); }).concat(
					container.incoming.map(function(incoming) { return incoming.dockers.last(); }));
			}).flatten();
			allDockers.each(function(docker){
				this.containersDockersPositions.push({
					key: docker,
					value: { x:docker.referencePoint.x, y:docker.referencePoint.y }
				});
			}.bind(this));
			
			// Store connected shapes
			this.edges = shapesAndContainers.map(function(node){
				return [].concat(node, node.getChildNodes(true)).map(function(child){
					return child.getAllDockedShapes();
				})
			}).flatten().uniq().findAll(function(shape){
				return shape instanceof ORYX.Core.Edge;
			});
						
			// Cache other elements
			this.cachedPositions = {};
			this.edges.each(function(edge){
				var source = edge.getSource();
				var target = edge.getTarget();
				if (!source || !target){
					return;
				}
				var isSource = source && shapesAndContainers.include(source);
				var isTarget = target && shapesAndContainers.include(target);
				
				if (!isSource || !isTarget){
					var rel = isSource ? target : source;
					var xy = rel.absoluteXY();
					if (!this.cachedPositions[isSource ? source : target]){
						this.cachedPositions[isSource ? source : target] = [];
					}
					this.cachedPositions[isSource ? source : target].push({
						up : xy,
						lo : {
							x: xy.x + rel.bounds.width(),
							y: xy.y + rel.bounds.height()
						},
						ce : {
							x: xy.x + (rel.bounds.width() / 2),
							y: xy.y + (rel.bounds.height() / 2)
						}
					})
				}
				
			}.bind(this));
			
			
			// Cache middle dockers positions to move them later
			this.dockersPositions = [];
			var vertical 	= this.activate == ORYX.Core.GridLine.DIR_VERTICAL;
			var sp 			= this.startPosition;
			this.edges.each(function(edge){
				var dockersToMove = (edge.getSource() && edge.getTarget()) ? edge.dockers.slice(1, edge.dockers.length-1) :
										(edge.getSource() ? edge.dockers.slice(1, edge.dockers.length) : edge.dockers.slice(0, edge.dockers.length-1));
				dockersToMove.each(function(docker){
					var select = false;
					var center = docker.bounds.center();
					if (vertical && center.x >= sp.x)
						select = true;
					else if (!vertical && center.y >= sp.y)
						select = true;
					if (select)
						this.dockersPositions.push({
							key: docker,
							value: docker.bounds.upperLeft()
						});
				}.bind(this))
			}.bind(this));
			
		},
		
		/**
		 * Returns a normalized x/y coordinate regarding the canvas.
		 * @param {Object} evt
		 * @return {Object}
		 */
		getNormalizedXY: function(evt){
			
			var xy = evt.getXY();
			var pos = {x: xy[0], y: xy[1]};
			
			var a = this.facade.getCanvas().node.getScreenCTM();
			
			if (Ext.isIE9){ // IE9 Workaround: Adjust translation matrix
				var sn = Ext.fly(this.facade.getCanvas().getScrollNode().firstChild);
				a.e = sn.getLeft()+4;
				a.f = sn.getTop()+4;
			}
			
			// Correcting the UpperLeft-Offset
			pos.x -= a.e; pos.y -= a.f;
			// Correcting the Zoom-Faktor
			pos.x /= a.a; pos.y /= a.d;
			
			
			var scale = this.vLine.getScale();
			
			var mid = {x:0, y:0};
			
			// Set that the position is not lower than zero
			//pos.x = Math.max( mid.x*scale , pos.x );
			//pos.y = Math.max( mid.y*scale , pos.y );
	
			// Set that the position is not bigger than the canvas
			var c = this.facade.getCanvas();
			pos.x = Math.min( (c.bounds.width() - mid.x), 	pos.x);
			pos.y = Math.min( (c.bounds.height() - mid.y), 	pos.y);

			return pos;
		},
		
		// Editor-Events
		editorEvents: [ORYX.CONFIG.EVENT_MOUSEOVER, ORYX.CONFIG.EVENT_MOUSEOUT, ORYX.CONFIG.EVENT_MOUSEDOWN],
		
		/**
		 * Disable all editor events
		 *
		 */
		disableEditorEvents: function(){
			this.editorEvents.each(function(event){
				this.facade.disableEvent(event)
			}.bind(this));
		},
		
		/**
		 * Enable all events in the editor
		 * 
		 */
		enableEditorEvents: function(){
			this.editorEvents.each(function(event){
				this.facade.enableEvent(event)
			}.bind(this));			
		}
		
	});
	
}()
/**
 * Copyright (c) 2009 Signavio
 * @author Nicolas Peters
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Help = Clazz.extend({
	
    facade: undefined,
	
    construct: function(facade){
		this.facade = facade;
		
		this.facade.offer({
			'name': ORYX.I18N.Help.help,
			'functionality': this.help.bind(this),
			'group': ORYX.I18N.Help.group,
			'icon': ORYX.PATH + "images/book_open.png",
			'description': ORYX.I18N.Help.helpDesc,
			'index': 2,
			'minShape': 0,
			'maxShape': 0
		});
	},
    
    /**
     * Opens a window with an iframe that shows the help page.
     */
    help: function(){
		var url = (ORYX.I18N.Language === "de_DE")?ORYX.CONFIG.HELP_START_URL_DE:ORYX.CONFIG.HELP_START_URL;
		
		if (Ext.isIPad){
			window.open(url);
			return;
		}
		
		var html = "<iframe src='" + url + "' class='x-help-iframe'></iframe>";
		html += '<br/><a class="x-help-a" target="_blank" href="' + url + '">' + ORYX.I18N.Help.openUGNewWindow + '</a>';
		var panel = new Ext.Panel({height: "100%",width: "100%",'html':html});
		var win = new Ext.Window({
										cls		: "x-help",
										modal	: true,
										title	: ORYX.I18N.Help.help,
										items	: [panel],
										resizable : false,
										header  : true,
										shadow	: false,
										draggable : false
									});
		win.show();
    }	
});/**
 * Copyright (c) 2009
 * Willi Tscheschner
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 **/

// Init namespace
if (!Signavio) { var Signavio = new Object(); }
if (!Signavio.Plugins) { Signavio.Plugins = new Object(); }


new function(){
	
	var CONST = {};
	CONST.VALID_TARGET_STENCILSETS = {		
		"http://b3mn.org/stencilset/bpmn1.1#" : ["http://b3mn.org/stencilset/bpmn1.1#", "http://b3mn.org/stencilset/bpmn2.0#", "http://b3mn.org/stencilset/epc#", "http://www.signavio.com/stencilsets/processmap#", "http://b3mn.org/stencilset/jbpm4#"],
		"http://b3mn.org/stencilset/epc#" : ["http://b3mn.org/stencilset/epc#", "http://b3mn.org/stencilset/bpmn1.1#", "http://b3mn.org/stencilset/bpmn2.0#", "http://www.signavio.com/stencilsets/processmap#"],
		"http://b3mn.org/stencilset/bpmn2.0#" : ["http://b3mn.org/stencilset/bpmn2.0#", "http://b3mn.org/stencilset/bpmn1.1#", "http://b3mn.org/stencilset/epc#", "http://www.signavio.com/stencilsets/processmap#", "http://b3mn.org/stencilset/jbpm4#"],
		"http://b3mn.org/stencilset/bpmn2.0conversation#" : ["http://b3mn.org/stencilset/bpmn2.0#", "http://b3mn.org/stencilset/bpmn2.0choreography#", "http://b3mn.org/stencilset/bpmn2.0conversation#", "http://b3mn.org/stencilset/jbpm4#"],
		"http://b3mn.org/stencilset/bpmn2.0choreography#" : ["http://b3mn.org/stencilset/bpmn2.0#", "http://b3mn.org/stencilset/bpmn2.0choreography#", "http://b3mn.org/stencilset/bpmn2.0conversation#", "http://b3mn.org/stencilset/jbpm4#"],
		"http://www.signavio.com/stencilsets/processmap#" : ["http://www.signavio.com/stencilsets/processmap#", "http://b3mn.org/stencilset/bpmn1.1#", "http://b3mn.org/stencilset/bpmn2.0#", "http://b3mn.org/stencilset/bpmn2.0choreography#", "http://b3mn.org/stencilset/bpmn2.0conversation#", "http://b3mn.org/stencilset/epc#"],
		"http://www.signavio.com/stencilsets/organigram#" : ["http://www.signavio.com/stencilsets/organigram#"],
		"http://www.signavio.com/stencilsets/UMLUseCase#" : ["http://b3mn.org/stencilset/bpmn2.0#","http://www.signavio.com/stencilsets/processmap#","http://www.signavio.com/stencilsets/UMLUseCase#","http://b3mn.org/stencilset/UML2.2Class#"]
	}
					
					
	CONST.DUMMY_SVG = 	'<svg xmlns="http://www.w3.org/2000/svg" xmlns:oryx="http://oryx-editor.org" '
 						+ 'width="1" height="1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000'
 						+ '/svg"><defs/><g stroke="black" font-family="Verdana, sans-serif" font-size-adjust="none" font-style="normal"'
 						+ ' font-variant="normal" font-weight="normal" line-heigth="normal" font-size="12"><g class="stencils" transform'
 						+ '="translate(0)"><g class="me"/><g class="children"/><g class="edge"/></g></g></svg>';
	
	
	var Request = {};
	Request.execute = function(url, callback, params, method, async){
		
		var successcallback = callback instanceof Array ? callback[0] : callback; 
		var failedcallback = callback instanceof Array ? callback[1] : undefined;
		
		new Ajax.Request(url, {
				method		: method || 'get',
				parameters	: params, 
				requestHeaders : {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
				asynchronous: async === true,
				onSuccess: function(transport){
					var json;
					try {
						json = transport.responseText.evalJSON();	
					} catch(e){
						json = transport.responseText;
					}
					
					if (successcallback instanceof Function)
						successcallback(json, transport);
				},
				onFailure: function(transport){
					if (failedcallback instanceof Function)
						failedcallback( transport);
				}
			});
	}
		
	
	// Variable to hash alread
	// initialized nodes
	var initializedNodes = {};
			
						
	/**
	 * Linking realizes the linking behaviour between nodes 
	 * and diagrams.
	 * 
	 * @param {Object} facade
	 * @class
	 * @author Willi Tscheschner
	 */								
	Signavio.Plugins.Linking = {
	
		facade: undefined,
		/**
		 * Construtor
		 * @param {Object} facade
		 */
		construct: function(facade) {
			this.facade = facade;
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.onLoaded.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, this.initLinking.bind(this));
			this.facade.registerOnEvent("showlinkingwindow", function(e){
				this.showWindow(e.shape, e.shape.getStencil().property(e.property))
			}.bind(this));
			
			var ns = this.getStencilSetNamespace();
						
			if(ns === "http://b3mn.org/stencilset/epc#"
				|| ns === "http://b3mn.org/stencilset/bpmn2.0#"
				|| ns === "http://b3mn.org/stencilset/bpmn2.0choreography#") {
			
				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.propertyChanged.bind(this) );			
			}
			
			// Overwrite the current ToolTips
			Ext.apply(Ext.QuickTips.getQuickTip(), {
			    showDelay : 500,
			    dismissDelay : false
			});
		},
		
		/**
		 * Implements the initial loading of already loaded shapes
		 */
		onLoaded: function(){
			this.facade.getCanvas().getChildNodes(true).each(function(node){
				this.initLinking({shape:node});
			}.bind(this));
		},
		
		/**
		 * Initialize the linking to perform show popup
		 * @param {Object} event
		 */
		initLinking: function(event){
			
			var shape = event.shape;
			
			// Check if the shape is a node
			if (!(shape instanceof ORYX.Core.Node)) {
				return;
			}
			
			// Hash all nodes which are already initialized;
			if (initializedNodes[shape.resourceId]) {
				return;
			} else {
				initializedNodes[shape.resourceId] = true;
			}
			
			// Iterate over every property
			shape.getStencil().properties().each(function(p){

				// If the property is a diagram link
				if (p.type() === ORYX.CONFIG.TYPE_DIAGRAM_LINK) {
					// Get all a's
					var svgA = $A(shape.node.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'a'));

					// Iterate over every reference to the views
					p.refToView().each(function(ref) {
						// Try to find the related a reference
						var a = svgA.find(function(a) {
							return a.getAttributeNS(null, 'id') === shape.id+ref;
						});
						
						if(shape.getStencil().id().indexOf("LinkEvent") !== -1) {							
							
							
							this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ABOUT_TO_SAVE, function() {
								try {
									var link = Element.getElementsByClassName($(shape.node), "link")[0];
									var bbox = link.parentNode.getBBox();
									// store position of process link before saving the diagram to place the overlay in the MOVI API		
									shape.setHiddenProperty("oryx-processlink_bounds", bbox.x + "," + bbox.y + " " + (bbox.x + bbox.width) + "," + (bbox.y + bbox.height));		
								} catch(e){}
							});
												
						}

						// If there is one
						if (a) { 
							// Init all event for the a
							this.initEvents(a, shape, p)
					 	} 
					}.bind(this));
									
					throw $break;
				}
			}.bind(this))
		},
		
		/**
		 * Initialize all event for a given a
		 * @param {Object} a
		 * @param {Object} shape
		 * @param {Object} property
		 */
		initEvents: function(a, shape, property) {
			
			Element.observe(a, "click", function(evt){
				Event.stop(evt);
				this.showWindow(shape, property);
			}.bind(this))			
		},
		
		/**
		 * Returns the value from the property regarding to the shape
		 * @param {Object} shape
		 * @param {Object} property
		 */
		getValue: function(shape, property){
			return shape.properties[property.prefix()+"-"+property.id()]||"";
		},
		
		/**
		 * Show a dialog depending if the property has a value or not
		 * @param {Object} shape
		 * @param {Object} property
		 */
		showWindow: function(shape, property){
			var url = this.getValue(shape, property).trim();
			var dialog, dialogDisplayed = false;
			if (url) {
				dialog = this.getPreviewDialog(shape, url, property);
			} else {
				dialog = this.getNewDialog(shape, property);
			}
			
			// Extension for T!M
			if(this.checkToShowTaskList(shape)) {
				dialogDisplayed = this.showTaskListDialog();
			}
			// End Extension for T!M
			
			// Only show up dialog if no other dialog is already shown
			if(!dialogDisplayed) {
				dialog.show();
			}
		},
		
		/**
		 * Returns the value for an objects attribute regarding to the current language
		 * @param {Object} obj
		 * @param {Object} attr
		 */
		getI18NValueForProperty: function(obj, attr){
			var lang = ORYX.I18N.Language.toLowerCase().split("_").first();
			return obj[attr+"_"+lang] || obj[attr] || "";
		},
		
		getStencilSetNamespace: function(){
			try {
				return this.facade.getModelMetaData().model.stencilset.namespace;
			}catch(e){
				return this.facade.getStencilSets().keys()[0];
			}
		},
		
		selectCurrentFolder: function(grid){
			
			var parentFolder = this.facade.getModelMetaData().parent;
			Request.execute("/p"+parentFolder+"/parents", function(response){
				var parents = [].concat(response.pluck("href").reverse(), parentFolder);
				
				var root = grid.root;
				var expand = function(node){
					var child = node.findChild("identifier", parents.shift());
					if (child){
						child.expand(false, true, expand.bind(this, child));
					} else {
						node.select();
					}
				};				
				expand(grid.root);
			}, {}, false, true);
		},
		
		/**
		 * Returns a dialog which is used to create a new link 
		 * @param {Object} shape
		 * @param {Object} url
		 * @param {Object} property
		 */
		getNewDialog: function(shape, property, url){
			
			// Get the stencil set definitions
			var ssd = this.getStencilSetsDefinitions();
			
			// Check if there are valid ssd defined
			var validSsd = CONST.VALID_TARGET_STENCILSETS[this.getStencilSetNamespace()];
			if (validSsd && validSsd instanceof Array) {
				ssd = ssd.findAll(function(s){ return validSsd.include(s.namespace) && s.visible !== false; });
				ssd = ssd.sort(function(a,b){ return validSsd.indexOf(a.namespace) < validSsd.indexOf(b.namespace) ? -1 : (validSsd.indexOf(a.namespace) > validSsd.indexOf(b.namespace) ? 1 : 0 )})
			}

			// Generate a form for all valid ssd
			var ssdPanel = new Ext.form.FormPanel({
				hideLabels 	: true,
				bodyStyle	: "padding:0px 0px 10px 20px;",
				border		: false,
				items		: ssd.map(function(s, i){
					return new Ext.form.Radio({
						boxLabel 	: this.getI18NValueForProperty(s, "title"),
						stencilset	: s,
						checked		: i == 0,
						name		: "x-establish-link-new-model"
					});
				}.bind(this))
			});
			
			
			// Define variables
			var form, win;
			
			// Generate a root node for the tree panel
			var root = new Ext.tree.TreeNode({
				identifier 	: "/directory",
				text		: "Root",
				leaf		: false,
				cls			: "folder",
		        draggable	: false,
		        expanded 	: true,
				dontSort	: true
			});
			
			// Generate a panel where all existing models/directories are included
			var existingPanel = new Ext.Panel({
				bodyStyle	: "padding:5px 0px 0px 20px;",
				border		: false,
				anchor		: "100%",
				disabled	: true,   
				layout		: 'column',
				items		: [
					// Generate the tree view where the models are in
					new Ext.tree.TreePanel({
							style		: "margin-right:5px;",
							height		: 150,
							width		: 200,
							x			: 20,
							y			: 0,
							loader		: new TreeLoader(),
							root		: root,
    						animate		: true,
							autoScroll	: true,
							useArrows	: true,
							rootVisible : false,
							columnWidth	: 0.5,
							listeners	: {
								render	: function(){
									this.getLoader().requestData(this.root);
									this.getSelectionModel().on("selectionchange", function(sel, node){
										if (node && node.attributes.data && node.attributes.data.rel == "mod") {
											existingPanel.items.get(1).setImg(ORYX.CONFIG.SERVER_HANDLER_ROOT + node.attributes.data.href + "/svg", node.attributes.data.rep.name);
											win.buttons[0].enable();
										} else {
											existingPanel.items.get(1).setImg();
											win.buttons[0].disable();
										}

									})
								}
							}
					}),
					// Generate an Image panel where a preview is shown
					new ImgPanel({
						width	: 200,
						height	: 150,
						columnWidth	: 0.5
					})
				]
			});
			
			/**
			 * Returns TRUE if the currently selected element in the tree panel is a model
			 */
			var isModel = function(){
				return existingPanel.items.get(0).getSelectionModel().getSelectedNode() &&  
					   existingPanel.items.get(0).getSelectionModel().getSelectedNode().attributes.data.rel === "mod";
			};
			
			var input, checked = !(shape.properties["oryx-name"]||shape.properties["oryx-title"]);
			
			// Number of item positions the t!m extensions moves the other
			// entries.
			var timoffset = 0;
			
			var formItems = [
				new Ext.form.Radio({
					boxLabel 	: Signavio.I18N.Editor.Linking.CreateDiagram + " " + "<input class='x-link-title x-form-text' style='margin:2px;padding:1px;height:14px;' value='"+Signavio.Utils.escapeHTML((shape.properties["oryx-name"]||shape.properties["oryx-title"]||ORYX.I18N.Save.newProcess).gsub("'", ""))+"'/>",
					checked		: !url,
					name		: "x-establish-link",
					listeners	: {
						check: function(t, checked){
							ssdPanel.setDisabled(!checked);
							form.items.get(1 + timoffset).setDisabled(!checked);
						},
						render: function(){
							input = this.wrap.query("input.x-link-title")[0];
							if (input) {
								$(input).observe("click", function(e){
									Event.stop(e);
									// enable/disable radio box
									form.items.get(0).setValue(false);
									form.items.get(0 + timoffset).setValue(true);
									form.items.get(3 + timoffset).setValue(false);
									form.items.get(6 + timoffset).setValue(false);
									// enable checkbox
									//form.items.get(1).setValue(true);
								})
							}
						}
					}
				}),
				new Ext.form.Checkbox({
					style		: "margin-left:40px;margin-bottom:10px;",
					boxLabel 	: Signavio.I18N.Editor.Linking.UseName + ' <img src="' + ORYX.CONFIG.EXPLORER_PATH + '/src/img/famfamfam/information.png" ext:qtip="' + new Ext.XTemplate(Signavio.I18N.Editor.Linking.UseNameHint).apply({type:shape.getStencil().title()}) + '"/>',
					checked		: checked,
					listeners	: {
						disable	: function(){ this.wrap ? this.wrap.addClass("x-item-disabled") : null},
						enable	: function(){ this.wrap ? this.wrap.removeClass("x-item-disabled") : null}
					}
				}),
				ssdPanel,
				new Ext.form.Radio({
					boxLabel 	: Signavio.I18N.Editor.Linking.UseDiagram,
					name		: "x-establish-link",
					listeners	: {
						check: function(t, checked){
							existingPanel.setDisabled(!checked);
							form.items.get(5 + timoffset).setDisabled(!checked);
							win.buttons[0].setDisabled(checked && !isModel());
							if (checked && !existingPanel.firstSelected){
								this.selectCurrentFolder(existingPanel.items.get(0));
								existingPanel.firstSelected = true;
							}
						}.bind(this)
					}
				}),
				existingPanel, 
				new Ext.form.Checkbox({
					style		: "margin-bottom:15px;margin-left:20px;",
					checked		: checked,
					disabled	: true,
					boxLabel 	: Signavio.I18N.Editor.Linking.UseName + ' <img src="' + ORYX.CONFIG.EXPLORER_PATH + '/src/img/famfamfam/information.png" ext:qtip="' + new Ext.XTemplate(Signavio.I18N.Editor.Linking.UseNameHint).apply({type:shape.getStencil().title()}) + '"/>',
					listeners	: {
						disable	: function(){ this.wrap ? this.wrap.addClass("x-item-disabled") : null},
						enable	: function(){ this.wrap ? this.wrap.removeClass("x-item-disabled") : null}
					}
				}),
				new Ext.form.Radio({
					boxLabel 	: Signavio.I18N.Editor.Linking.UseLink,
					name		: "x-establish-link",
					checked		: !!url,
					listeners	: {
						check: function(t, checked){
							form.items.get(7 + timoffset).setDisabled(!checked);
						}
					}
				}),
				new Ext.form.TextField({
					emptyText 	: "URL",
					anchor		: "-20",
					value		: url ? url : "",
					disabled	: true,
					style		: "margin-left:20px;width:398px;",
					enableKeyEvents : true,
					prefixFileLocal: Ext.ux.form.UrlLinkFieldList.prototype.prefixFileLocal,
					prefixFileNetwork: Ext.ux.form.UrlLinkFieldList.prototype.prefixFileNetwork,
					prefixHTTP: Ext.ux.form.UrlLinkFieldList.prototype.prefixHTTP,
					getValue: function(){
						var url = Ext.form.TextField.prototype.getRawValue.call(this);
						if (Ext.ux.form.UrlLinkFieldList.prototype.isURL.call(this, url)){
							url = this.prefixHTTP + url;
						}
						return url;
					},
					listeners : {
						render : function(t) {
							t.el.on('keyup',function(event) {
								Ext.ux.form.UrlLinkFieldList.prototype.evaluateLokalURL.call(this);
							}.bind(this));
						}
					}
				})
			];
			
			//Extension for T!M
			var timPanel, me = this;
			
			// Check if T!M extension is loaded
			if(this.isTimExtensionLoaded()) {
				timoffset = 1;
				timPanel = new Ext.form.Radio({
					boxLabel 	: Signavio.I18N.Editor.Linking.TimTaskList + ": " + "<a class='x-link-opence x-item-disabled' href=''>" + Signavio.I18N.Editor.Linking.TimTaskListLink + "</a>",
					checked		: false,
					name		: "x-establish-link",
					listeners	: {
						check: function(t, checked){
							ssdPanel.setDisabled(!checked);
							form.items.get(2).setDisabled(!checked);
							
							// Enable/Disable complex editor link
							var a = this.wrap.query("a.x-link-opence")[0];
							if(a && checked) {
								a.removeClassName("x-item-disabled");
							} else if(a && !checked) {
								a.addClassName("x-item-disabled");
							}
							
						},
						render: function(){
							var a = this.wrap.query("a.x-link-opence")[0];
							if (a) {
								$(a).observe("click", function(e){
									Event.stop(e);
									
									// Open complex type editor to edit
									// task lists for T!M
									if(timPanel.checked) {
										me.facade.raiseEvent({type: ORYX.CONFIG.EVENT_SHOW_PROPERTYWINDOW_DIALOG, propertyKey: "oryx-tasks"});
										form.ownerCt.close();
									}
									
								});
								
							}
						}
					}
				});
				
				formItems = [timPanel].concat(formItems);
			}
			// End Extension for T!M
			
			// Define the main panel for the dialog
			form = new Ext.form.FormPanel({
				hideLabels 	: true,
				border		: false,
				bodyStyle	: "padding:10px;overflow-x:hidden;overflow-y:auto;",
				layout		: "anchor",
				anchor		: "100% 100%",
				items		: formItems
			});
			
			var updateHeight = function(){
				if (!ssdPanel||!ssdPanel.body){
					return;
				}
				var h = win.el.getHeight();
				
				// Apply the same height for all T!M extension fields
				var elCount = timoffset;
				while(elCount) {
					form.items.get(elCount - 1).setHeight(22);
					elCount--;
				}
				
				form.items.get(0 + timoffset).setHeight(22); // Height of new process radio button
				
				// Adjust height of the tree panel
				var height = ssdPanel.body.getHeight() + 233;
				existingPanel.items.get(0).setHeight(Math.max(200, h-height));
				existingPanel.items.get(1).setHeight(Math.max(200, h-height));
				form.syncSize();
			};
			
			win = new Ext.Window({
				title		: Signavio.I18N.Editor.Linking.CreateTitle,
				cls			: "x-window-linking-establish",
				items		: [form],
				//resizable	: false,
				width		: Math.max((window.innerWidth || document.body.offsetWidth || 0) * 0.5, 460),
				height		: Math.max((window.innerHeight || document.body.offsetHeight || 0) * 0.85, 420+50),
				minWidth	: 460, 
				minHeight	: 420,
				layout		: "anchor",
				modal		: true,
				listeners	: { resize:updateHeight, show:updateHeight },
				buttons: [{
					text: Signavio.I18N.Editor.Linking.ButtonLink,
					handler: function(b){
						// Disable button
						b.disable();
						
						// CREATE NEW MODEL
						if (form.items.get(0 + timoffset).checked) {
							var ssd = (form.items.get(2  + timoffset).items.items.find(function(c){ return c.checked})||{}).stencilset;
							if (ssd) {
								this.createNewModelAndLink(shape, property, ssd, (input||{}).value || "", form.items.get(1  + timoffset).checked)
							}
							
						// SET EXTISTING MODEL
						} else if (form.items.get(3 + timoffset).checked){
							if (!isModel()) {
								Ext.Msg.alert(ORYX.I18N.Oryx.title, Signavio.I18N.Editor.Linking.AlertSelectModel);
								return;
							}
							this.createLinkWithAvailableModel(shape, property, existingPanel.items.get(0).getSelectionModel().getSelectedNode().attributes.data, form.items.get(5 + timoffset).checked)
							
						// SET JUST THE LINK
						} else if (form.items.get(6 + timoffset).checked){
							this.setLink(shape, property, form.items.get(7 + timoffset).getValue());
							
						// OTHER, raise error
						} else {
							throw new Error("Something has to be selected");
						}
						b.ownerCt.close();
					}.bind(this)
				},{
					text: Signavio.I18N.Editor.Linking.Cancel,
					handler: function(){
						this.ownerCt.close();
					}
				}]	
			});
			
			return win;
			
		},
	
		/**
		 * Creates a new model and opens it
		 * @param {Object} shape
		 * @param {Object} property
		 * @param {Object} ssd
		 */
		createNewModelAndLink: function(shape, property, ssd, title, shouldRename){
			
			var namespace = ssd.stencilset || ssd.namespace;
			var extensions = ssd.extensions || [];
			
			// Get the parent directory
			var parent = this.facade.getModelMetaData().parent;
			// Define the editor url 
			var url = ORYX.CONFIG.SERVER_EDITOR_CREATE_HANDLER + "?stencilset="+namespace.replace(/#/g, "%23")+"&directory="+parent;
			var modelId;
			
			// Get a new model id (done with a request to the editor url)
			this.doRequest(url, function(c,a){
				modelId = a.getResponseHeader("Location").split("=").last();
			});
			
			if (!modelId) {
				Ext.Msg.alert("Signavio", "Request went wrong!");
				return;
			}

			// Define initial POST values to store the new model
			var params 		= {};
			params.name 	= (title||"").trim() || (shape.properties["oryx-name"]||shape.properties["oryx-title"]||"").trim() || ORYX.I18N.Save.newProcess;
			params.parent 	= "/directory/"+parent;
			params.svg_xml 	= CONST.DUMMY_SVG;
			params.json_xml = '{"stencilset":{"namespace":"'+namespace+'"},"ssextensions":'+extensions.toJSON()+', "id":"canvas","resourceId":"canvas","properties":{}}';
			params.id 		= modelId;
			params.type 	= ssd.title;
			params.description = "";
			params.comment 	= "";
			params.namespace= namespace;

			// Store the new model
			this.doRequest(ORYX.CONFIG.SERVER_MODEL_HANDLER, function(){}, params, "post");
			
			// Define the model url like /p/model/<id>
			var modelURL = window.location.protocol +"//"+ window.location.host + "/" + ORYX.CONFIG.SERVER_MODEL_HANDLER.replace("\.\./", "") + "/" + modelId;
			// Set the property with this model url
			this.setLink(shape, property, modelURL, shouldRename ? params.name || undefined : undefined)
			
			// Open the new model
			window.setTimeout(function(){
				window.open(ORYX.CONFIG.SERVER_EDITOR_HANDLER + "?id=" + modelId)
			}, 100);
			
		},
		
		/**
		 * Creates a link to a model by the model data
		 * @param {Object} shape
		 * @param {Object} property
		 * @param {Object} data
		 */
		createLinkWithAvailableModel: function(shape, property, data, shouldRename){
			var url = window.location.protocol +"//"+ window.location.host + "/" + ORYX.CONFIG.SERVER_HANDLER_ROOT.replace("\.\./", "") + data.href
			this.setLink(shape, property, url, shouldRename ? Signavio.Utils.unescapeHTML(Signavio.Utils.escapeHTML(data.rep.name||data.rep.title||""))||undefined : undefined);
		},
		
		/**
		 * Set the property link to the shape.
		 * Implements the command pattern to support undo/redo
		 * @param {Object} shape
		 * @param {Object} property
		 * @param {Object} link
		 */
		setLink: function(shape, property, link, rename){
			
			// Implement the specific command for property change
			var commandClass = ORYX.Core.Command.extend({
				construct: function(newVal, oldVal, rename, shape, property, selection, facade){
					this.shape = shape;
					this.newVal = newVal;
					this.oldVal = oldVal;
					this.property = property;
					this.selection = selection;
					this.facade = facade;
					this.oldName = rename !== undefined ? this.shape.properties["oryx-name"]||this.shape.properties["oryx-title"]||"" : undefined;
					this.newName = rename;
				},
				execute: function(){
					
					this.shape.setProperty(property.prefix()+"-"+property.id(), this.newVal+"");
					// Rename shape
					if (this.newName) {
						if (this.shape.getStencil().property("oryx-name") !== undefined) {
							this.shape.setProperty("oryx-name", this.newName);
						} else if (this.shape.getStencil().property("oryx-title") !== undefined){
							this.shape.setProperty("oryx-title", this.newName);
						}
					}	
					this.shape.setProperty(property.prefix()+"-"+property.id(), this.newVal+"");

					this.facade.setSelection(this.selection);
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
				},
				rollback: function(){
					
					this.shape.setProperty(property.prefix()+"-"+property.id(), this.oldVal+"");
					// Rename shape
					if (this.oldName !== undefined) {
						if (this.shape.getStencil().property("oryx-name") !== undefined) {
							this.shape.setProperty("oryx-name", this.oldName);
						} else if (this.shape.getStencil().property("oryx-title") !== undefined){
							this.shape.setProperty("oryx-title", this.oldName);
						}
					}	
					
					this.facade.setSelection(this.selection);
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
				}
			})
			// Instanciated the class
			var command = new commandClass(link, this.getValue(shape, property), rename, shape, property, this.facade.getSelection(), this.facade);
			
			// Execute the command
			this.facade.executeCommands([command]);
		},
		
		/**
		 * Returns a dialog which will present a preview of the 
		 * linked model
		 * @param {Object} shape
		 * @param {Object} url
		 * @param {Object} property
		 */
		getPreviewDialog: function(shape, url, property){
			
			var text;
			var panel;
			
			switch(this.evaluateLink(url)){
				case 1:
					 
					var data;
					var status = 200;
					this.doRequest(url, [function(r){ data = r; }, function(t){ status = t.status; }])
					var info = (data||[]).find(function(r){ return r.rel === "info"})
					
					if (403 === status) {
						text = Signavio.I18N.Editor.Linking.LinkNoAccess + " (<a href='#' class='x-link-delete'>"+Signavio.I18N.Editor.Linking.RemoveLink+"</a>, <a href='#' class='x-link-edit'>"+Signavio.I18N.Editor.Linking.EditLink+"</a>)";
					} else if (!data||!info){
						text = Signavio.I18N.Editor.Linking.LinkUnavailable + " (<a href='#' class='x-link-delete'>"+Signavio.I18N.Editor.Linking.RemoveLink+"</a>, <a href='#' class='x-link-edit'>"+Signavio.I18N.Editor.Linking.EditLink+"</a>)";
					} else {
						var id = info.href.split("/")[2];
						text = Signavio.Utils.escapeHTML(info.rep.name) + " <i><small>"+info.rep.type+"</small></i>"+ " (<a href='"+ORYX.CONFIG.SERVER_EDITOR_HANDLER+"?id="+id+"' class='x-link-open' target='_blank'>"+Signavio.I18N.Editor.Linking.OpenLink+"</a>, <a href='#' class='x-link-delete'>"+Signavio.I18N.Editor.Linking.RemoveLink+"</a>, <a href='#' class='x-link-edit'>"+Signavio.I18N.Editor.Linking.EditLink+"</a>)";
						panel = new ImgPanel({
							style	: "margin-top:10px;",
							src		: url + "/svg",
							imgTitle: info.rep.name,
							anchor	: "100% -25"
						})
					}
					break;
				case 2:
					url = Signavio.Utils.escapeHTML(url);
					text = url + " (<a href='"+url+"' class='x-link-open' target='_blank'>"+Signavio.I18N.Editor.Linking.OpenLink+"</a>, <a href='#' class='x-link-delete'>"+Signavio.I18N.Editor.Linking.RemoveLink+"</a>, <a href='#' class='x-link-edit'>"+Signavio.I18N.Editor.Linking.EditLink+"</a>)";
					panel = new Ext.Panel({
						border	: false,
						style	: "margin-top:10px;",
						html 	: "<iframe src='"+url+"' style='width:100%;height:100%;border:1px solid silver;'/>",
						anchor	: "100% -25"
					})
					break;
				case 0:
				default:
					text = Signavio.I18N.Editor.Linking.BrokenLink = " (<a href='#' class='x-link-delete'>"+Signavio.I18N.Editor.Linking.RemoveLink+"</a>, <a href='#' class='x-link-edit'>"+Signavio.I18N.Editor.Linking.EditLink+"</a>)";
					break;
			}
			var self = this;
			
			return new Ext.Window({
				title		: Signavio.I18N.Editor.Linking.PreviewTitle,
				cls			: "x-window-linking-establish",
				bodyStyle	: "padding:10px;background:white;",
				layout		: "anchor",
				items		: [
					new Ext.Panel({
						border	: false,
						html	: text,
						afterRender: function(w) {
							Ext.Panel.prototype.afterRender.apply(this, arguments)
							// Set all links for deleting
							$A(this.body.query("a.x-link-delete")).each(function(a){
								Element.observe(a, "click", function(evt){
									Event.stop(evt);
									self.setLink(shape, property, "");
									this.ownerCt.close();
								}.bind(this))	
							}.bind(this));
							// Set all links for editings
							$A(this.body.query("a.x-link-edit")).each(function(a){
								Element.observe(a, "click", function(evt){
									Event.stop(evt);
									this.ownerCt.close();
									self.getNewDialog(shape, property, self.getValue(shape, property)).show();
								}.bind(this))	
							}.bind(this));
							
						}
						
					}), panel].compact(),
				//resizable	: false,
				minWidth	: 460,
				width		: 460,
				height		: !!panel ? 400 : undefined,
				minHeight	: !!panel ? 300 : undefined,
				buttons: [{
					text: Signavio.I18N.Editor.Linking.Close,
					handler: function(){
						this.ownerCt.close();
					}
				}]	
			});
		},
		
		/**
		 * Returns 0 if the link is no link, 
		 * returns 1 if the link is a process model
		 * returns 2 if it is some other link
		 * @param {String} link 
		 */
		evaluateLink: function(link) {
			
			if (!(link||"").trim()) {
				return 0;
			} else if (link.include(ORYX.CONFIG.SERVER_HANDLER_ROOT.replace("../", "/") + "/model/")) {
				return 1;
			} else {
				return 2;
			}
		},
		
		/**
		 * Returns an array of all available stencil sets
		 * (uses caching tp improve performance)
		 */
		getStencilSetsDefinitions: function(){
			
			if (!this.stencilsetDefinitions) {
				var ssd;
				this.doRequest(ORYX.CONFIG.STENCIL_SETS_URL, function(s){
					ssd = s;
				});
				
				this.stencilsetDefinitions = ssd;
			}
			
			return this.stencilsetDefinitions;
		},
		
		doRequest: function(url, callback, params, method){
			Request.execute(url, callback, params, method)
		},
		
		
		/**
		 * 
		 * @param {Object} option
		 */
		propertyChanged: function( option, node){

			if( option.name !== "oryx-entry" || !node instanceof ORYX.Core.Node){ return }
				
			var ns = this.getStencilSetNamespace();
			var isAllowed = this.facade.getStencilSets().keys().include(ns);
			
			/*
			 * This is specific for the IntermediateLinkEvent of BPMN 2.0.
			 * The marker indicating the link will be colored in green if
			 * the link is set and remains white otherwise.
			 * 
			 * THIS FUNCTION NEEDS TO BE CHECKED FOR PERFOMANCE REASONS 
			 */
			if(isAllowed && ( ns === "http://b3mn.org/stencilset/bpmn2.0#" || ns === "http://b3mn.org/stencilset/bpmn2.0choreography#" )) {
								
				this.adjustLinkColor(option.value, node);

			}
			
			// If it is an EPC, show instead the link in another linking symbol
			if (isAllowed && ns === "http://b3mn.org/stencilset/epc#"){
				if( option.value && option.value.length > 0 && option.value != "undefined"){
					
					this.show( node, option.value, function(){
						this.showWindow(node, node.getStencil().property(option.name));
					}.bind(this) );
							
				} else {
	
					this.hide( node );
	
				}		
			}

		},
		
		/**
		 * Switches the color of the link marker of an
		 * Intermediate Link Event
		 * 
		 * @param {ORYX.Core.Node} shape
		 */
		adjustLinkColor: function(prop, shape) {
			
			if(shape.getStencil().id().indexOf("LinkEvent") !== -1) {
				try {
					var link = Element.getElementsByClassName($(shape.node), "link")[0];
					
					if(link) {			
						if(prop) {
							link.setAttribute("fill", "#99FF00");
						} else {
							link.setAttribute("fill", "#FFFFFF");
						}
					}
				} catch(e){}
			}
			
		},
		
		/**
		 * Shows the Link for a particular shape with a specific url
		 * 
		 * @param {Object} shape
		 * @param {Object} url
		 */
		show: function( shape, url, callback){

			
			// Generate the svg-representation of a link

			var linkContainer  = ORYX.Editor.graft("http://www.w3.org/2000/svg", null ,		
						['g',{},	
							[ 'a',
								{'target': '_blank'},
								['path', { "style": "fill:white;stroke:grey;stroke-linecap:round;stroke-linejoin:round;stroke-width:0.72", "d": "M0 1.44 L0 15.05 L11.91 15.05 L11.91 5.98 L7.37 1.44 L0 1.44 Z"}],
								['path', { "style": "stroke:grey;stroke-linecap:round;stroke-linejoin:round;stroke-width:0.72;fill:#EEEEEE;", "transform": "translate(7.5, -8.5)", "d": "M0 10.51 L0 15.05 L4.54 15.05"}],
								['path', { "style": "fill:silver;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-width:0.72", "transform": "translate(-3, -1)", "d": "M0 8.81 L0 13.06 L5.95 13.06 L5.95 15.05 A50.2313 50.2313 -175.57 0 0 10.77 11.08 A49.9128 49.9128 -1.28 0 0 5.95 6.54 L5.95 8.81 L0 8.81 Z"}]
							]
						]);

			var link = linkContainer.childNodes[0];
			
			// Set the link with the special namespace
			link.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", url);
			
			link.addEventListener("click", function(e){
				if (callback) {
					Event.stop(e);
					callback(shape, url);
				}
			}, true);
			
			// Shows the link in the overlay					
			this.facade.raiseEvent({
						type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
						id: 			"arissupport.urlref_" + shape.id,
						shapes: 		[shape],
						node:			linkContainer,
						dontCloneNode: 	true,
						nodePosition:	"SE"
					});	
					
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ABOUT_TO_SAVE, function() {
				// store position of process link before saving the diagram to place the overlay in the MOVI API		
				shape.setHiddenProperty("oryx-processlink_bounds", shape.bounds.width() + ","+ shape.bounds.height() + " " + 
						(shape.bounds.width()+12) + "," + (shape.bounds.height()+13));
			});				
		},	

		/**
		 * Hides the Link for a particular shape
		 * 
		 * @param {Object} shape
		 */
		hide: function( shape ){

			this.facade.raiseEvent({
						type: 			ORYX.CONFIG.EVENT_OVERLAY_HIDE,
						id: 			"arissupport.urlref_" + shape.id
					});	
								
		},
		
		// Extension for T!M
		
		/**
		 * Check if a task list is defined to prevent displaying of the
		 * linking dialog.
		 */
		checkToShowTaskList: function(shape) {
			// VARs
			var taskList;
			
			if(!shape) {return false;}
			
			if(!this.isTimExtensionLoaded()) {return false;}
			
			taskList = shape.properties["oryx-tasks"];
			if(taskList && taskList.length > 0) {
				// try to eval as JSON
				try {
					taskList = taskList.evalJSON();
					if(taskList && taskList.totalCount > 0) {
						return true;
					}
				} catch(e) {
					return false;
				}
			} 
			
			// Default behavior
			return false;
		},
		
		/**
		 * Triggers event to popup the list dialog to edit the list of tasks.
		 */
		showTaskListDialog: function() {
			if(!this.isTimExtensionLoaded()) {return false;}
			
			this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_SHOW_PROPERTYWINDOW_DIALOG, propertyKey: "oryx-tasks", forceExecution: true});
			
			return true;
		},
		
		/**
		 * Returns true if the tim perspective is enabled and selected
		 */
		isTimExtensionLoaded: function() {
			return this.facade.getStencilSets()["http://b3mn.org/stencilset/bpmn2.0#"]
				&& this.facade.getStencilSets()["http://b3mn.org/stencilset/bpmn2.0#"].extensions().keys().include("http://oryx-editor.org/stencilsets/extensions/bpmn2.0tim#");
		}
		
		// End Extension for T!M
	};
	
	Signavio.Plugins.Linking = ORYX.Plugins.AbstractPlugin.extend(Signavio.Plugins.Linking);
	
	/**
	 * Implementation of a panel which shows an image
	 * @class
	 * @author Willi Tscheschner
	 *
	 */
	var ImgPanel = function(){
		ImgPanel.superclass.constructor.apply(this, arguments);
	}
	
	
	Ext.extend(ImgPanel, Ext.Panel, {
		
		/**
		 * Specifies an url which should be loaded at render time
		 */
		src	: undefined,
		cls : "x-img-panel",
		
		onRender: function(){
					
			ImgPanel.superclass.onRender.apply(this, arguments);
			
			ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.body.dom, ["div", {"class": "x-info-model", style:"position:relative;width:100%;height:100%;overflow:hidden;"}, ["img", {"class":'x-msg-loading', style:'display:none;', src: ORYX.CONFIG.LIBS_PATH+"/ext-2.0.2/resources/images/default/tree/s.gif"}]]);
			
			this.img 		= this.body.last();
			
			//this.img.setVisibilityMode(Ext.Element.DISPLAY);
			
			/**
			 * BUGFIXING for IE7 - Image preview wasn't shown correctly.
			 * It seems that the css-selection doesn't worked.
			 */
			this.img.setWidth("100%");
			this.img.dom.style.position = "relative";
			this.img.dom.style.overflow = "auto";
			
			var sameSize = function(n){
				return 	n && n.dom.naturalWidth && n.dom.naturalHeight && 
						n.dom.naturalWidth === n.dom.width && n.dom.width <= n.dom.parentNode.offsetWidth && 
						n.dom.naturalHeight === n.dom.height && n.dom.height <= n.dom.parentNode.offsetHeight; 
			}
			
			this.img.waiting 	= this.img.last();
			this.img.imgs 		= {};
			this.img.showImg = function(src){
				if (!this.img.imgs[src]){
					
					// Define parameters and add security parameter
					var params = "inline&_dc="+parseInt(Math.random()*10000000);
					params += "&" + $H(Ext.Ajax.getSecurityParameter()).map(function(r){ return r.key+"="+r.value; }).join("&");
					
					//var img = Ext.get(ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.img, ["img", {"src": src+"?_dc="+parseInt(Math.random()*10000000), style:"display:none;background:white;"}]));
					var img = Ext.get(ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.img, ["iframe", {"src": src+"?"+params, style:"width:100%;height:100%;background:white;display:none;"}]));

					this.img.waiting.show(true);
					img.on("load", function(){ 
						
						var w = img.dom.contentDocument.childNodes[0].width.baseVal.value;
						var h = img.dom.contentDocument.childNodes[0].height.baseVal.value;
						img.dom.contentDocument.childNodes[0].setAttribute("viewBox", "0 0 "+w+" "+h);
						img.dom.contentDocument.childNodes[0].setAttribute("preserveAspectRatio", "xMidYMid");
						img.dom.contentDocument.childNodes[0].style.width = img.dom.contentDocument.childNodes[0].style.height = "100%";
						
						this.img.hideImg();
						img.show(true);
						this.img.shownImg = img;
						//this.img[sameSize(this.img.shownImg)?"removeClass":"addClass"]("x-scrollenable");
						this.img.waiting.hide({useDisplay:true})
					}.bind(this));
					img.setVisibilityMode(Ext.Element.DISPLAY);
					this.img.imgs[src] = img;
				} else if (this.img.shownImg === this.img.imgs[src]){
					return;
				} else {
					this.img.hideImg();
					this.img.imgs[src].show(true);
					this.img.shownImg = this.img.imgs[src];
					this.img[sameSize(this.img.shownImg)?"removeClass":"addClass"]("x-scrollenable");
				}
			}.bind(this);

			this.img.hideImg = function(){
				if (this.img.shownImg) {
					this.img.shownImg.hide(true);
					delete this.img.shownImg;
				}
			}.bind(this);
			
			
			this.img.on("click", function(){
				if (this.img.hasClass("x-scrollenable"))
					this.img.toggleClass("x-scrollable")
			}.bind(this));
			
			
			// If there is already a link, set it
			if (this.src) {
				this.setImg(this.src, this.imgTitle);
			}
			
			
		},
		
		setImg	: function(src, title){
			
			if (src === undefined) {
				this.img.hideImg();
			} else {
			
				this.img.showImg(src);
				//this.img.dom.setAttribute("title", title||"");
			}
	
		}
						
	});
	
	/**
	 * Implementation of a loaded which loads synchronouse the directories, models
	 * @class
	 * @author Willi Tscheschner
	 */
	var TreeLoader = function(){
		TreeLoader.superclass.constructor.apply(this, arguments);
	}
	Ext.extend(TreeLoader, Ext.tree.TreeLoader, {
		/**
		 * Enable requesting
		 */
		dataUrl:true,
		
		requestData: function(node, callback){
			if( node.attributes.identifier ){	
				Request.execute(ORYX.CONFIG.SERVER_HANDLER_ROOT + node.attributes.identifier, function(response){
					window.setTimeout(this.doResponse.bind(this, node, callback, response), 10);
				}.bind(this), {q:Math.random().toFixed(10)})
			}
		},
		
		/**
		 * Generate the data for the nodes depending on the records
		 * @param {Object} records
		 */
		generateNodeData: function(node, data){

			if (node.attributes.dontSort !== true){
				// Sort by title/name
				data = data.sort(Signavio.Helper.BusinessObjectSortingFunction);
			}

			
			// For every record in the store, append a new child
			return data.map(function(r){
						if ((r.rel !== "mod" && r.rel !== "dir") || (r.rel === "dir" && (r.rep.type === "trash" || r.rep.type === "internal"))) {
							return null;
						}
						var attr = node.attributes;
						return {
							text		: Signavio.Utils.escapeHTML(Signavio.I18N.Repository.Folder[r.rep.type] || r.rep.name || attr.value),
							cls			: r.rel === "mod" ? "model" : "folder",
							leaf		: r.rel !== "dir",
							singleClickExpand : attr.singleClickExpand || false,
							identifier	: r.href,
							data		: r
						}
					}).compact();
		},
		/**
		 * Callback when loading the new data from the store
		 * @param {Object} store Store where the new data comes from
		 * @param {Object} node Node where the data should append
		 * @param {Object} callback Callback when ready loading
		 * @param {Object} records New records of the store
		 */
		doResponse: function(node, callback, data){
	
			// Get the new items
			var items = this.generateNodeData( node, data );
			
			// Check if there are changes
			if( node.childNodes.length > 0 && node.childNodes.length === items.length && 
				node.childNodes.all(function(n){ return items.any(function(i){ return n.attributes.identifier === i.identifier && n.attributes.text === i.text }) })){
				return;
			}	
			
			// Hide all childs
			node.collapse();
			
			// Remove all children
			var index = node.childNodes.length-1;
			for(; index>=0; index--){
				node.childNodes[index].remove();
			}
			
			// BEGIN
	        node.beginUpdate();
			// For every record in the store, append a new child
			items.each(function(d){		
				node.appendChild(this.createNode(d));
			}.bind(this))
			// END	
			node.endUpdate();
			
			window.setTimeout(function(){
				node.expand()
			}, 500);
			
			this.fireEvent("update", this, items);
			this.fireEvent("load", this, node);
				
			if(typeof callback == "function"){
	            callback(this, node);
	        }
		}
		
	})

}()

/**
 * Copyright (c) 2008-2009
 * Sven Wagner-Boysen, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

new function(){
	
	ORYX.Plugins.BPMN11 = {
	
		/**
		 *	Constructor
		 *	@param {Object} Facade: The Facade of the Editor
		 */
		construct: function(facade){
			this.facade = facade;
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, this.handleDockerDocked.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
			this.facade.registerOnEvent('layout.bpmn11.pool', this.handleLayoutPool.bind(this));
			this.facade.registerOnEvent('layout.bpmn11.subprocess', this.handleSubProcess.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEREMOVED, this.handleShapeRemove.bind(this));
			
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.afterLoad.bind(this));
			
			//this.facade.registerOnEvent('layout.bpmn11.lane', this.handleLayoutLane.bind(this));
			this.stencilsetNs = facade.getStencilSets().entries()[0][0];
		},
		
		/**
		 * Force to update every pool
		 */
		afterLoad: function(){
			this.facade.getCanvas().getChildNodes().each(function(shape){
				if (shape.getStencil().id().endsWith("Pool")) {
					this.handleLayoutPool({
						shape: shape
					});
				}
			}.bind(this))
		},
		
		/**
		 * If a pool is selected and contains no lane,
		 * a lane is created automagically
		 */
		onSelectionChanged: function(event) {
			
			var selection = event.elements;
			
			if(selection && selection.length === 1) {
				var shape = selection[0];
				if(shape.getStencil().idWithoutNs() === "Pool") {
					if(shape.getChildNodes().length === 0) {
						// create a lane inside the selected pool
						var option = {
								type:this.stencilsetNs + "Lane",
								position:{x:0,y:0},
								namespace:shape.getStencil().namespace(),
								parent:shape
						};
						this.facade.createShape(option);
						this.facade.getCanvas().update();
						this.facade.setSelection([shape]);
					}
				}
			}
			
			// Preventing selection of all lanes but not the pool
			if(selection.any(function(s){ return s instanceof ORYX.Core.Node && s.getStencil().id().endsWith("Lane")})){
				var lanes = selection.findAll(function(s){
					return s instanceof ORYX.Core.Node && s.getStencil().id().endsWith("Lane")
				});
				
				var pools = [];
				var unselectLanes = [];
				lanes.each(function(lane){
					pools.push(this.getParentPool(lane))
				}.bind(this));
				
				pools = pools.uniq().findAll(function(pool){
					var childLanes = this.getLanes(pool, true);
					if (childLanes.all(function(lane){ return lanes.include(lane)})){
						unselectLanes = unselectLanes.concat(childLanes);
						return true;
					} else if (selection.include(pool) && childLanes.any(function(lane){ return lanes.include(lane)})) {
						unselectLanes = unselectLanes.concat(childLanes);
						return true;
					} else {
						return false;
					}
				}.bind(this))
				
				if (unselectLanes.length > 0 && pools.length > 0){
					selection = selection.without.apply(selection, unselectLanes);
					selection = selection.concat(pools);
					this.facade.setSelection(selection.uniq());
				}
			}
		},
		
		handleShapeRemove: function(option) {
			
			var sh 				= option.shape;
			var parent 			= option.parent;
						
			if (sh instanceof ORYX.Core.Node && sh.getStencil().idWithoutNs() === "Lane" && this.facade.isExecutingCommands()) {
			
				var pool = this.getParentPool(parent);
				if (pool&&pool.parent){		
				
					var isLeafFn = function(leaf){
						return !leaf.getChildNodes().any(function(r){ return r.getStencil().idWithoutNs() === "Lane"});
					}
					
					var isLeaf = isLeafFn(sh);
					var parentHasMoreLanes = parent.getChildNodes().any(function(r){ return r.getStencil().idWithoutNs() === "Lane"});
					
					if (isLeaf && parentHasMoreLanes){
						
						var command = new ResizeLanesCommandBPMN11(sh, parent, pool, this);
						this.facade.executeCommands([command]);
						
					} else if(	!isLeaf &&
								!this.facade.getSelection().any(function(select){ // Find one of the selection, which is a lane and child of "sh" and is a leaf lane
										return 	select instanceof ORYX.Core.Node && select.getStencil().idWithoutNs() === "Lane" &&
												select.isParent(sh) && isLeafFn(select);})) {
													
						var Command = ORYX.Core.Command.extend({
							construct: function(shape, facade) {
								this.children = shape.getChildNodes(true);
								this.facade = facade;
							},
							execute: function() {
								this.children.each(function(child){
									child.bounds.moveBy(30,0)
								});
								this.facade.getCanvas().update();
							},
							rollback: function() {
								this.children.each(function(child){
									child.bounds.moveBy(-30,0)
								})
								this.facade.getCanvas().update();
							}
						});
						this.facade.executeCommands([new Command(sh, this.facade)]);
						
					} else if (isLeaf&&!parentHasMoreLanes&&parent == pool){
						parent.add(sh);
					}
				}
			
			}
			
		},
		
		hashedSubProcesses: {},
		
		hashChildShapes: function(shape){
			var children = shape.getChildNodes();
			children.each(function(child){
				if (this.hashedSubProcesses[child.id]){
					this.hashedSubProcesses[child.id] = child.absoluteXY();
					this.hashedSubProcesses[child.id].width 	= child.bounds.width();
					this.hashedSubProcesses[child.id].height 	= child.bounds.height();
					this.hashChildShapes(child);
				}
			}.bind(this));
		},
	
		/**
		 * Handle the layouting of a sub process.
		 * Mainly to adjust the child dockers of a sub process. 
		 *
		 */
		handleSubProcess : function(option) {
			
			var sh = option.shape;
			
			if (!this.hashedSubProcesses[sh.id]) {
				this.hashedSubProcesses[sh.id] = sh.absoluteXY();
				this.hashedSubProcesses[sh.id].width 	= sh.bounds.width();
				this.hashedSubProcesses[sh.id].height 	= sh.bounds.height();
				return;
			}
			
			var offset = sh.absoluteXY();
			offset.x -= this.hashedSubProcesses[sh.id].x;
			offset.y -= this.hashedSubProcesses[sh.id].y;
			
			var resized = this.hashedSubProcesses[sh.id].width !== sh.bounds.width() || this.hashedSubProcesses[sh.id].height !== sh.bounds.height();
			
			this.hashedSubProcesses[sh.id] = sh.absoluteXY();
			this.hashedSubProcesses[sh.id].width 	= sh.bounds.width();
			this.hashedSubProcesses[sh.id].height 	= sh.bounds.height();
			this.hashChildShapes(sh);
			
			
			// Move dockers only if currently is not resizing
			if (this.facade.isExecutingCommands()&&!resized) {
				this.moveChildDockers(sh, offset);
			}
		},
		
		moveChildDockers: function(shape, offset){
			
			if (!offset.x && !offset.y) {
				return;
			} 
			
			var children = shape.getChildNodes(true);
			
			// Get all nodes
			var dockers = children
				// Get all incoming and outgoing edges
				.map(function(node){
					return [].concat(node.getIncomingShapes())
							.concat(node.getOutgoingShapes())
				})
				// Flatten all including arrays into one
				.flatten()
				// Get every edge only once
				.uniq()
				// Get all dockers
				.map(function(edge){
					return edge.dockers.length > 2 ? 
							edge.dockers.slice(1, edge.dockers.length-1) : 
							[];
				})
				// Flatten the dockers lists
				.flatten();
	
			var abs = shape.absoluteBounds();
			abs.moveBy(-offset.x, -offset.y)
			var obj = {};
			dockers.each(function(docker){
				
				if (docker.isChanged){
					return;
				}
				
				var off = Object.clone(offset);
				
				if (!abs.isIncluded(docker.bounds.center())){
					var index 	= docker.parent.dockers.indexOf(docker);
					var size	= docker.parent.dockers.length;
					var from 	= docker.parent.getSource();
					var to 		= docker.parent.getTarget();
					
					var bothAreIncluded = children.include(from) && children.include(to);
					
					if (!bothAreIncluded){
						var previousIsOver = index !== 0 ? abs.isIncluded(docker.parent.dockers[index-1].bounds.center()) : false;
						var nextIsOver = index !== size-1 ? abs.isIncluded(docker.parent.dockers[index+1].bounds.center()) : false;
						
						if (!previousIsOver && !nextIsOver){ return; }
						
						var ref = docker.parent.dockers[previousIsOver ? index-1 : index+1];
						if (Math.abs(-Math.abs(ref.bounds.center().x-docker.bounds.center().x)) < 2){
							off.y = 0;
						} else if(Math.abs(-Math.abs(ref.bounds.center().y-docker.bounds.center().y)) < 2){
							off.x = 0;
						} else {
							return;
						}
					}
					
				}
				
				obj[docker.getId()] = {
					docker:docker,
					offset:off
				}
			})
			
			// Set dockers
			this.facade.executeCommands([new ORYX.Core.MoveDockersCommand(obj)]);
				
		},
		
		/**
		 * DragDocker.Docked Handler
		 *
		 */	
		handleDockerDocked: function(options) {
			var edge = options.parent;
			var edgeSource = options.target;
			
			if(edge.getStencil().id() === this.stencilsetNs + "SequenceFlow") {
				var isGateway = edgeSource.getStencil().groups().find(function(group) {
						if(group == "Gateways") 
							return group;
					});
				if(!isGateway && (edge.properties["oryx-conditiontype"] == "Expression"))
					// show diamond on edge source
					edge.setProperty("oryx-showdiamondmarker", true);
				else 
					// do not show diamond on edge source
					edge.setProperty("oryx-showdiamondmarker", false);
				
				// update edge rendering
				//edge.update();
				
				this.facade.getCanvas().update();
			}
		},
		
		/**
		 * PropertyWindow.PropertyChanged Handler
		 */
		handlePropertyChanged: function(option) {
			
			var shapes = option.elements;
			var propertyKey = option.key;
			var propertyValue = option.value;
			
			var changed = false;
			shapes.each(function(shape){
				if((shape.getStencil().id() === this.stencilsetNs + "SequenceFlow") &&
					(propertyKey === "oryx-conditiontype")) {
					
					if(propertyValue != "Expression")
						// Do not show the Diamond
						shape.setProperty("oryx-showdiamondmarker", false);
					else {
						var incomingShapes = shape.getIncomingShapes();
						
						if(!incomingShapes) {
							shape.setProperty("oryx-showdiamondmarker", true);
						}
						
						var incomingGateway = incomingShapes.find(function(aShape) {
							var foundGateway = aShape.getStencil().groups().find(function(group) {
								if(group == "Gateways") 
									return group;
							});
							if(foundGateway)
								return foundGateway;
						});
						
						if(!incomingGateway) 
							// show diamond on edge source
							shape.setProperty("oryx-showdiamondmarker", true);
						else
							// do not show diamond
							shape.setProperty("oryx-showdiamondmarker", false);
					}
					
					changed = true;
				}
			}.bind(this));
			
			if(changed) {this.facade.getCanvas().update();}
			
		},
		
		hashedPoolPositions : {},
		hashedLaneDepth : {},
		hashedBounds : {},
		
		/**
		 * Handler for layouting event 'layout.bpmn11.pool'
		 * @param {Object} event
		 */
		handleLayoutPool: function(event){
			
			
			var pool = event.shape;
			var selection = this.facade.getSelection(); 
			var currentShape = selection.include(pool) ? pool : selection.first();
			
			// Check if the current shape is one of the children of the pool
			if (currentShape instanceof ORYX.Core.UIObject){
				currentShape = currentShape.isParent(pool) ? currentShape : pool;
			} else {
				currentShape = pool;
			}
			
			// Check if it is a pool or a lane
			if (!(currentShape.getStencil().id().endsWith("Pool") || currentShape.getStencil().id().endsWith("Lane"))) {
				return;
			}
			
			if (!this.hashedBounds[pool.id]) {
				this.hashedBounds[pool.id] = {};
			}
	
			this.currentPool = pool;
			
			// Find all child lanes
			var lanes = this.getLanes(pool);
			
			if (lanes.length <= 0) {
				return
			}
			
			
			var allLanes = this.getLanes(pool, true);
			var considerForDockers = allLanes.clone();
			
			// Show/hide caption regarding the number of lanes
			if (lanes.length === 1 && this.getLanes(lanes.first()).length <= 0) {
				// TRUE if there is a caption
				lanes.first().setProperty("oryx-showcaption", lanes.first().properties["oryx-name"].trim().length > 0);
			} else {
				allLanes.invoke("setProperty", "oryx-showcaption", true);
			}
			
			var deletedLanes = [];
			var addedLanes = [];
			
			// Get all new lanes
			var i=-1;
			while (++i<allLanes.length) {
				if (!this.hashedBounds[pool.id][allLanes[i].id]){
					addedLanes.push(allLanes[i])
				}
			}
			
			if (addedLanes.length > 0){
				currentShape = addedLanes.first();
			}
			
			
			// Get all deleted lanes
			var resourceIds = $H(this.hashedBounds[pool.id]).keys();
			var i=-1;
			while (++i<resourceIds.length) {
				if (!allLanes.any(function(lane){ return lane.id == resourceIds[i]})){
					deletedLanes.push(this.hashedBounds[pool.id][resourceIds[i]]);
					selection = selection.without(function(r){ return r.id == resourceIds[i] });
				}
			}		
			
			var height, width, x, y;
			
			if (deletedLanes.length > 0 || addedLanes.length > 0) {
				
				if (addedLanes.length === 1 && this.getLanes(addedLanes[0].parent).length === 1){
					// Set height from the pool
					height = this.adjustHeight(lanes, addedLanes[0].parent);
				} else {
					// Set height from the pool
					height = this.updateHeight(pool);
				}
				// Set width from the pool
				width = this.adjustWidth(lanes, pool.bounds.width());	
				
				pool.update();
			}
			
			/**
			 * Set width/height depending on the pool
			 */
			else if (pool == currentShape) {
				
				if (selection.length === 1 && this.isResized(pool, this.hashedPoolPositions[pool.id])) {
					var oldXY = this.hashedPoolPositions[pool.id].upperLeft();
					var xy = pool.bounds.upperLeft();
					var scale = 0;
					if (this.shouldScale(pool)){
						var old = this.hashedPoolPositions[pool.id];
						scale = old.height()/pool.bounds.height();
					}
				
					this.adjustLanes(pool, allLanes, oldXY.x - xy.x, oldXY.y - xy.y, scale);
				}
				
				// Set height from the pool
				height = this.adjustHeight(lanes, undefined, pool.bounds.height());
				// Set width from the pool
				width = this.adjustWidth(lanes, pool.bounds.width());		
			}
			
			/**?
			 * Set width/height depending on containing lanes
			 */		
			else {
				
				// Reposition the pool if one shape is selected and the upperleft has changed
				if (selection.length === 1 && this.isResized(currentShape, this.hashedBounds[pool.id][currentShape.id])){
					var oldXY = this.hashedBounds[pool.id][currentShape.id].upperLeft();
					var xy = currentShape.absoluteXY();
					x = oldXY.x - xy.x;
					y = oldXY.y - xy.y;
					
					// Adjust all other lanes beneath this lane
					if (x||y){
						considerForDockers = considerForDockers.without(currentShape);
						this.adjustLanes(pool, this.getAllExcludedLanes(pool, currentShape), x, 0);
					}
					
					// Adjust all child lanes
					var childLanes = this.getLanes(currentShape, true);
					if (childLanes.length > 0){
						if (this.shouldScale(currentShape)){
							var old = this.hashedBounds[pool.id][currentShape.id];
							var scale = old.height()/currentShape.bounds.height();
							this.adjustLanes(pool, childLanes, x, y, scale);
						} else {
							this.adjustLanes(pool, childLanes, x, y, 0);
						}
					}
				}
				
				// Get height and adjust child heights
				height = this.adjustHeight(lanes, currentShape);
				// Set width from the current shape
				width = this.adjustWidth(lanes, currentShape.bounds.width()+(this.getDepth(currentShape,pool)*30));
			}
			
			this.setDimensions(pool, width, height, x, y);
			
			
			if (this.facade.isExecutingCommands() && (deletedLanes.length === 0 || addedLanes.length !== 0)){ 
				// Update all dockers
				this.updateDockers(considerForDockers, pool);
			}
			
			this.hashedBounds[pool.id] = {};
			
			var i=-1;
			while (++i < allLanes.length) {
				// Cache positions
				this.hashedBounds[pool.id][allLanes[i].id] = allLanes[i].absoluteBounds();
				
				// Cache also the bounds of child shapes, mainly for child subprocesses
				this.hashChildShapes(allLanes[i]);
			
				this.hashedLaneDepth[allLanes[i].id] = this.getDepth(allLanes[i], pool);
				
				this.forceToUpdateLane(allLanes[i]);
			}
			
			this.hashedPoolPositions[pool.id] = pool.bounds.clone();
			
			
			// Update selection
			//this.facade.setSelection(selection);		
		},
		
		shouldScale: function(element){
			var childLanes = element.getChildNodes().findAll(function(shape){ return shape.getStencil().id().endsWith("Lane") })
			return childLanes.length > 1 || childLanes.any(function(lane){ return this.shouldScale(lane) }.bind(this)) 
		},
		
		isResized: function(shape, bounds){
			
			if (!bounds||!shape){
				return false;
			}
			
			var oldB = bounds;
			//var oldXY = oldB.upperLeft();
			//var xy = shape.absoluteXY();
			
			return Math.round(oldB.width() - shape.bounds.width()) !== 0 || Math.round(oldB.height() - shape.bounds.height()) !== 0
			
		},
		
		adjustLanes: function(pool, lanes, x, y, scale){
			
			scale = scale || 0;
	
			// For every lane, adjust the child nodes with the offset
			lanes.each(function(l){
				l.getChildNodes().each(function(child){
					if (!child.getStencil().id().endsWith("Lane")){
						var cy = scale ? child.bounds.center().y - (child.bounds.center().y/scale) : -y;
						child.bounds.moveBy((x||0), -cy);
						
						if (scale&&child.getStencil().id().endsWith("Subprocess")) {
							this.moveChildDockers(child, {x:(0), y:-cy});
						}
					
					}
				}.bind(this));
				this.hashedBounds[pool.id][l.id].moveBy(-(x||0), !scale?-y:0);
				if (scale) {
					l.isScaled = true;
				}
			}.bind(this))
			
		},
		
		getAllExcludedLanes: function(parent, lane){
			var lanes = [];
			parent.getChildNodes().each(function(shape){
				if ((!lane || shape !== lane) && shape.getStencil().id().endsWith("Lane")){
					lanes.push(shape);
					lanes = lanes.concat(this.getAllExcludedLanes(shape, lane));
				}
			}.bind(this));
			return lanes;
		},
		
		
		forceToUpdateLane: function(lane){
			
			if (lane.bounds.height() !== lane._svgShapes[0].height) {	
				lane.isChanged = true;
				lane.isResized = true;
				lane._update();
			}
		},
		
		getDepth: function(child, parent){
			
			var i=0;
			while(child && child.parent && child !== parent){
				child = child.parent;
				++i
			}
			return i;
		},
		
		updateDepth: function(lane, fromDepth, toDepth){
			
			var xOffset = (fromDepth - toDepth) * 30;
			
			lane.getChildNodes().each(function(shape){
				shape.bounds.moveBy(xOffset, 0);
				
				[].concat(children[j].getIncomingShapes())
						.concat(children[j].getOutgoingShapes())
						
			})
			
		},
		
		setDimensions: function(shape, width, height, x, y){
			var isLane = shape.getStencil().id().endsWith("Lane");
			// Set the bounds
			shape.bounds.set(
					isLane 	? 30 : (shape.bounds.a.x - (x || 0)), 
					isLane 	? shape.bounds.a.y : (shape.bounds.a.y - (y || 0)), 
					width	? shape.bounds.a.x + width - (isLane?30:(x||0)) : shape.bounds.b.x, 
					height 	? shape.bounds.a.y + height - (isLane?0:(y||0)) : shape.bounds.b.y
				);
		},
	
		setLanePosition: function(shape, y){
			
			shape.bounds.moveTo(30, y);
		
		},
			
		adjustWidth: function(lanes, width) {
			
			// Set width to each lane
			(lanes||[]).each(function(lane){
				this.setDimensions(lane, width);
				this.adjustWidth(this.getLanes(lane), width-30);
			}.bind(this));
			
			return width;
		},
		
		
		adjustHeight: function(lanes, changedLane, propagateHeight){
			
			var oldHeight = 0;
			if (!changedLane && propagateHeight){
				var i=-1;
				while (++i<lanes.length){	
					oldHeight += lanes[i].bounds.height();		
				}
			}
			
			var i=-1;
			var height = 0;
			
			// Iterate trough every lane
			while (++i<lanes.length){
				
				if (lanes[i] === changedLane) {
					// Propagate new height down to the children
					this.adjustHeight(this.getLanes(lanes[i]), undefined, lanes[i].bounds.height());
					
					lanes[i].bounds.set({x:30, y:height}, {x:lanes[i].bounds.width()+30, y:lanes[i].bounds.height()+height})
									
				} else if (!changedLane && propagateHeight) {
					
					var tempHeight = (lanes[i].bounds.height() * propagateHeight) / oldHeight;
					// Propagate height
					this.adjustHeight(this.getLanes(lanes[i]), undefined, tempHeight);
					// Set height propotional to the propagated and old height
					this.setDimensions(lanes[i], null, tempHeight);
					this.setLanePosition(lanes[i], height);
				} else {
					// Get height from children
					var tempHeight = this.adjustHeight(this.getLanes(lanes[i]), changedLane, propagateHeight);
					if (!tempHeight) {
						tempHeight = lanes[i].bounds.height();
					}
					this.setDimensions(lanes[i], null, tempHeight);
					this.setLanePosition(lanes[i], height);
				}
				
				height += lanes[i].bounds.height();
			}
			
			return height;
			
		},
		
		
		updateHeight: function(root){
			
			var lanes = this.getLanes(root);
			
			if (lanes.length == 0){
				return root.bounds.height();
			}
			
			var height = 0;
			var i=-1;
			while (++i < lanes.length) {
				this.setLanePosition(lanes[i], height);
				height += this.updateHeight(lanes[i]);
			}
			
			this.setDimensions(root, null, height);
			
			return height;
		},
		
		getOffset: function(lane, includePool, pool){
			
			var offset = {x:0,y:0};
			
			
			/*var parent = lane; 
			 while(parent) {
			 				
				
				var offParent = this.hashedBounds[pool.id][parent.id] ||(includePool === true ? this.hashedPoolPositions[parent.id] : undefined);
				if (offParent){
					var ul = parent.bounds.upperLeft();
					var ulo = offParent.upperLeft();
					offset.x += ul.x-ulo.x;
					offset.y += ul.y-ulo.y;
				}
				
				if (parent.getStencil().id().endsWith("Pool")) {
					break;
				}
				
				parent = parent.parent;
			}	*/
			
			var offset = lane.absoluteXY();
			
			var hashed = this.hashedBounds[pool.id][lane.id] ||(includePool === true ? this.hashedPoolPositions[lane.id] : undefined);
			if (hashed) {
				offset.x -= hashed.upperLeft().x; 	
				offset.y -= hashed.upperLeft().y;		
			} else {
				return {x:0,y:0}
			}		
			return offset;
		},
		
		getNextLane: function(shape){
			while(shape && !shape.getStencil().id().endsWith("Lane")){
				if (shape instanceof ORYX.Core.Canvas) {
					return null;
				}
				shape = shape.parent;
			}
			return shape;
		},
		
		getParentPool: function(shape){
			while(shape && !shape.getStencil().id().endsWith("Pool")){
				if (shape instanceof ORYX.Core.Canvas) {
					return null;
				}
				shape = shape.parent;
			}
			return shape;
		},
		
		updateDockers: function(lanes, pool){
			
			var absPool = pool.absoluteBounds();
			var oldPool = (this.hashedPoolPositions[pool.id]||absPool).clone();
			
			var i=-1, j=-1, k=-1, l=-1, docker;
			var dockers = {};
			
			while (++i < lanes.length) {
				
				if (!this.hashedBounds[pool.id][lanes[i].id]) {
					continue;
				}
				
				var isScaled = lanes[i].isScaled;
				delete lanes[i].isScaled;
				var children = lanes[i].getChildNodes();
				var absBounds = lanes[i].absoluteBounds();
				var oldBounds = (this.hashedBounds[pool.id][lanes[i].id]||absBounds);
				//oldBounds.moveBy((absBounds.upperLeft().x-lanes[i].bounds.upperLeft().x), (absBounds.upperLeft().y-lanes[i].bounds.upperLeft().y));
				var offset = this.getOffset(lanes[i], true, pool);
				var xOffsetDepth = 0;
	
				var depth = this.getDepth(lanes[i], pool);
				if ( this.hashedLaneDepth[lanes[i].id] !== undefined &&  this.hashedLaneDepth[lanes[i].id] !== depth) {
					xOffsetDepth = (this.hashedLaneDepth[lanes[i].id] - depth) * 30;
					offset.x += xOffsetDepth;
				}
				
				j=-1;
				
				while (++j < children.length) {
					
					if (xOffsetDepth && !children[j].getStencil().id().endsWith("Lane")) {
						children[j].bounds.moveBy(xOffsetDepth, 0);
					}
					
					if (children[j].getStencil().id().endsWith("Subprocess")) {
						this.moveChildDockers(children[j], offset);
					}
					
					var edges = [].concat(children[j].getIncomingShapes())
						.concat(children[j].getOutgoingShapes())
						// Remove all edges which are included in the selection from the list
						.findAll(function(r){ return r instanceof ORYX.Core.Edge })
						.uniq();
	
					k=-1;
					while (++k < edges.length) {			
						
						if (edges[k].getStencil().id().endsWith("MessageFlow")) {
							this.layoutEdges(children[j], [edges[k]], offset);
							continue;
						}
						
						l=-1;
						while (++l < edges[k].dockers.length) {
							
							docker = edges[k].dockers[l];
							
							if (docker.getDockedShape()||docker.isChanged){
								continue;
							}
						
						
							pos = docker.bounds.center();
							
							// Check if the modified center included the new position
							var isOverLane = oldBounds.isIncluded(pos);
							// Check if the original center is over the pool
							var isOutSidePool = !oldPool.isIncluded(pos);
							var previousIsOverLane = l == 0 ? isOverLane : oldBounds.isIncluded(edges[k].dockers[l-1].bounds.center());
							var nextIsOverLane = l == edges[k].dockers.length-1 ? isOverLane : oldBounds.isIncluded(edges[k].dockers[l+1].bounds.center());
							var off = Object.clone(offset);
							
							// If the 
							if (isScaled && isOverLane && this.isResized(lanes[i], this.hashedBounds[pool.id][lanes[i].id])){
								var relY = (pos.y - absBounds.upperLeft().y + off.y);
								off.y -= (relY - (relY * (absBounds.height()/oldBounds.height()))); 
							}
							
							// Check if the previous dockers docked shape is from this lane
							// Otherwise, check if the docker is over the lane OR is outside the lane 
							// but the previous/next was over this lane
							if (isOverLane){
								dockers[docker.id] = {docker: docker, offset:off};
							} 
							/*else if (l == 1 && edges[k].dockers.length>2 && edges[k].dockers[l-1].isDocked()){
								var dockedLane = this.getNextLane(edges[k].dockers[l-1].getDockedShape());
								if (dockedLane != lanes[i])
									continue;
								dockers[docker.id] = {docker: docker, offset:offset};
							}
							// Check if the next dockers docked shape is from this lane
							else if (l == edges[k].dockers.length-2 && edges[k].dockers.length>2 && edges[k].dockers[l+1].isDocked()){
								var dockedLane = this.getNextLane(edges[k].dockers[l+1].getDockedShape());
								if (dockedLane != lanes[i])
									continue;
								dockers[docker.id] = {docker: docker, offset:offset};
							}
													
							else if (isOutSidePool) {
								dockers[docker.id] = {docker: docker, offset:this.getOffset(lanes[i], true, pool)};
							}*/
							
						
						}
					}
							
				}
			}
			
			// Set dockers
			this.facade.executeCommands([new ORYX.Core.MoveDockersCommand(dockers)]);
	
		},
		
		moveBy: function(pos, offset){
			pos.x += offset.x;
			pos.y += offset.y;
			return pos;
		},
		
		getHashedBounds: function(shape){
			return this.currentPool && this.hashedBounds[this.currentPool.id][shape.id] ? this.hashedBounds[this.currentPool.id][shape.id] : shape.bounds.clone();
		},
		
		/**
		 * Returns a set on all child lanes for the given Shape. If recursive is TRUE, also indirect children will be returned (default is FALSE)
		 * The set is sorted with first child the lowest y-coordinate and the last one the highest.
		 * @param {ORYX.Core.Shape} shape
		 * @param {boolean} recursive
		 */
		getLanes: function(shape, recursive){
			
			// Get all the child lanes
			var lanes = shape.getChildNodes(recursive||false).findAll(function(node) { return (node.getStencil().id() === this.stencilsetNs + "Lane"); }.bind(this));
			
			// Sort all lanes by there y coordinate
			lanes = lanes.sort(function(a, b){
				
						// Get y coordinates for upper left and lower right
						var auy = Math.round(a.bounds.upperLeft().y);
						var buy = Math.round(b.bounds.upperLeft().y);
						var aly = Math.round(a.bounds.lowerRight().y);
						var bly = Math.round(b.bounds.lowerRight().y);
						
						var ha	= this.getHashedBounds(a);
						var hb	= this.getHashedBounds(b);
						
						// Get the old y coordinates
						var oauy = Math.round(ha.upperLeft().y);
						var obuy = Math.round(hb.upperLeft().y);
						var oaly = Math.round(ha.lowerRight().y);
						var obly = Math.round(hb.lowerRight().y);
						
						// If equal, than use the old one
						if (auy == buy && aly == bly) {
							auy = oauy; buy = obuy; aly = oaly; bly = obly;
						}
						
						if (Math.round(a.bounds.height()-ha.height()) === 0 && Math.round(b.bounds.height()-hb.height()) === 0){
							return auy < buy ? -1 : (auy > buy ? 1: 0);
						}
						
						// Check if upper left and lower right is completely above/below
						var above = auy < buy && aly < bly;
						var below = auy > buy && aly > bly;
						// Check if a is above b including the old values
						var slightlyAboveBottom = auy < buy && aly >= bly && oaly < obly;
						var slightlyAboveTop = auy >= buy && aly < bly && oauy < obuy;
						// Check if a is below b including the old values
						var slightlyBelowBottom = auy > buy && aly <= bly && oaly > obly;
						var slightlyBelowTop = auy <= buy && aly > bly && oauy > obuy;
						
						// Return -1 if a is above b, 1 if b is above a, or 0 otherwise
						return  (above || slightlyAboveBottom || slightlyAboveTop ? -1 : (below || slightlyBelowBottom || slightlyBelowTop ? 1 : 0))
					}.bind(this));
					
			// Return lanes
			return lanes;
		}
		
	};
	
	var ResizeLanesCommandBPMN11 = ORYX.Core.Command.extend({
	
		construct: function(shape, parent, pool, plugin) {
		
			this.facade  = plugin.facade;
			this.plugin  = plugin;
			this.shape	 = shape;
			this.changes;
			
			this.pool	= pool;
			
			this.parent	= parent;
			
			
			this.shapeChildren = [];
			
			/*
			 * The Bounds have to be stored 
			 * separate because they would
			 * otherwise also be influenced 
			 */
			this.shape.getChildShapes().each(function(childShape) {
				this.shapeChildren.push({
					shape: childShape,
					bounds: {
						a: {
							x: childShape.bounds.a.x,
							y: childShape.bounds.a.y
						},
						b: {
							x: childShape.bounds.b.x,
							y: childShape.bounds.b.y
						}
					}
				});
			}.bind(this));
	
			this.shapeUpperLeft = this.shape.absoluteXY();
			this.parentHeight 	= this.parent.bounds.height(); 
	
		},
		
		getLeafLanes: function(lane){
			var childLanes = this.plugin.getLanes(lane).map(function(child){
				return this.getLeafLanes(child);
			}.bind(this)).flatten();
			return childLanes.length > 0 ? childLanes : [lane];
		},
		
		findNewLane: function(){
			
			var lanes = this.plugin.getLanes(this.parent);
	
			var leafLanes = this.getLeafLanes(this.parent);
			leafLanes = leafLanes.sort(function(a,b){
				var aupl = a.absoluteXY().y;
				var bupl = b.absoluteXY().y;
				return aupl < bupl ? -1 : (aupl > bupl ? 1 : 0)
			})
			this.lane 	= leafLanes.find(function(l,i){ return i == leafLanes.length-1 || l.absoluteXY().y >= this.shapeUpperLeft.y }.bind(this));
			
			this.laneUppperLeft = this.lane.absoluteXY();	
		},
		
		execute: function() {
			
			if(this.changes) {
				this.executeAgain();
				return;
			}
	
			/* 
			 * Rescue all ChildShapes of the deleted
			 * Shape into the lane that takes its 
			 * place 
			 */
			
			if (!this.lane){
				this.findNewLane();
			}
			
			if(this.lane) {			
				
				var laUpL = this.laneUppperLeft;
				var shUpL = this.shapeUpperLeft;
				
				var depthChange = this.plugin.getDepth(this.lane, this.parent)-1;
							
				this.changes = $H({});
				
				// Selected lane is BELOW the removed lane
				if(laUpL.y > shUpL.y) {				
					this.lane.getChildShapes().each(function(childShape) {
						
						/*
						 * Cache the changes for rollback
						 */
						if(!this.changes[childShape.getId()]) {
							this.changes[childShape.getId()] = this.computeChanges(childShape, this.lane, this.lane, this.shape.bounds.height());
						}
						
						childShape.bounds.moveBy(0, this.shape.bounds.height());
					}.bind(this));
					
					this.plugin.hashChildShapes(this.lane);
					
					this.shapeChildren.each(function(shapeChild) {
						shapeChild.shape.bounds.set(shapeChild.bounds);
						shapeChild.shape.bounds.moveBy((shUpL.x-30)-(depthChange*30), 0);
						
						/*
						 * Cache the changes for rollback
						 */
						if(!this.changes[shapeChild.shape.getId()]) {
							this.changes[shapeChild.shape.getId()] = this.computeChanges(shapeChild.shape, this.shape, this.lane, 0);
						}
						
						this.lane.add(shapeChild.shape);
						
					}.bind(this));		
				
					this.lane.bounds.moveBy(0, shUpL.y-laUpL.y);
				
				// Selected lane is ABOVE the removed lane	
				} else if(shUpL.y > laUpL.y){
					
					this.shapeChildren.each(function(shapeChild) {
						shapeChild.shape.bounds.set(shapeChild.bounds);		
						shapeChild.shape.bounds.moveBy((shUpL.x-30)-(depthChange*30), this.lane.bounds.height());			
						
						/*
						 * Cache the changes for rollback
						 */
						if(!this.changes[shapeChild.shape.getId()]) {
							this.changes[shapeChild.shape.getId()] = this.computeChanges(shapeChild.shape, this.shape, this.lane, 0);
						}
						
						this.lane.add(shapeChild.shape);
						
					}.bind(this));
				}
			}
					
			/*
			 * Adjust the height of the lanes
			 */
			// Get the height values
			var oldHeight	= this.lane.bounds.height();				
			var newHeight	= this.lane.length === 1 ? this.parentHeight : this.lane.bounds.height() + this.shape.bounds.height();
	
			// Set height
			this.setHeight(newHeight, oldHeight, this.parent, this.parentHeight, true);
			
			// Update
			this.update();
		},
		
		setHeight: function(newHeight, oldHeight, parent, parentHeight, store){
			
			// Set heigh of the lane
			this.plugin.setDimensions(this.lane, this.lane.bounds.width(), newHeight);
			this.plugin.hashedBounds[this.pool.id][this.lane.id] = this.lane.absoluteBounds();
			
			// Adjust child lanes
			this.plugin.adjustHeight(this.plugin.getLanes(parent), this.lane);
			
			if (store === true){
				// Store changes
				this.changes[this.shape.getId()] = this.computeChanges(this.shape, parent, parent, 0, oldHeight, newHeight);	
			}
			
			// Set parents height
			this.plugin.setDimensions(parent, parent.bounds.width(), parentHeight);
			
			if (parent !== this.pool){
				this.plugin.setDimensions(this.pool, this.pool.bounds.width(), this.pool.bounds.height() + (newHeight-oldHeight));
			}
		},
		
		update: function(){
			
			// Hack to prevent the updating of the dockers
			this.plugin.hashedBounds[this.pool.id]["REMOVED"] = true;
			// Update
			this.facade.getCanvas().update();
		},
		
		rollback: function() {
			
			var laUpL = this.laneUppperLeft;
			var shUpL = this.shapeUpperLeft;
				
			this.changes.each(function(pair) {
				
				var parent 	  		= pair.value.oldParent;
				var shape  	  		= pair.value.shape;
				var parentHeight 	= pair.value.parentHeight;
				var oldHeight 		= pair.value.oldHeight;
				var newHeight 		= pair.value.newHeight;
				
				// If lane
				if(oldHeight) {
					this.setHeight(oldHeight, newHeight, parent, parent.bounds.height() + (oldHeight - newHeight));
					if (laUpL.y > shUpL.y) {
						this.lane.bounds.moveBy(0, this.shape.bounds.height());
					}
				} else {
					parent.add(shape);
					shape.bounds.moveTo(pair.value.oldPosition);	
				}
				
				
			}.bind(this));
			
			// Update
			//this.update();
			
		},
		
		executeAgain: function() {
			
			this.changes.each(function(pair) {
				var parent 	  = pair.value.newParent;
				var shape  	  = pair.value.shape;
				var newHeight = pair.value.newHeight;
				var oldHeight = pair.value.oldHeight;
				
				// If lane
				if(newHeight) {
					var laUpL = this.laneUppperLeft.y;
					var shUpL = this.shapeUpperLeft.y;
				
					if (laUpL > shUpL) {
						this.lane.bounds.moveBy(0, shUpL - laUpL);
					}
					this.setHeight(newHeight, oldHeight, parent, parent.bounds.height() + (newHeight-oldHeight));
				} else {
					parent.add(shape);
					shape.bounds.moveTo(pair.value.newPosition);
				}
				
			}.bind(this));
			
			// Update
			this.update();
		},
		
		computeChanges: function(shape, oldParent, parent, yOffset, oldHeight, newHeight) {
			
			oldParent = this.changes[shape.getId()] ? this.changes[shape.getId()].oldParent : oldParent;
			var oldPosition = this.changes[shape.getId()] ? this.changes[shape.getId()].oldPosition : shape.bounds.upperLeft();
			
			var sUl = shape.bounds.upperLeft();
			
			var pos = {x: sUl.x, y: sUl.y + yOffset};
			
			var changes = {
				shape		: shape,
				parentHeight: oldParent.bounds.height(),
				oldParent	: oldParent,
				oldPosition	: oldPosition,
				oldHeight	: oldHeight,
				newParent	: parent,
				newPosition : pos,
				newHeight	: newHeight
			};
				
			return changes;
		}
		
	});
	
	ORYX.Plugins.BPMN11 = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN11);
	
}()
/**
 * Copyright (c) 2009, Stefan Krumnow, Signavio GmbH
 *
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

/**
   This plugin is a generic syntax checker for different diagram types.
   Needs server communication.
   @class ORYX.Plugins.SyntaxChecker
   @constructor Creates a new instance
   @extends ORYX.Plugins.AbstractPlugin
*/
ORYX.Plugins.PlausibilityChecker = ORYX.Plugins.AbstractPlugin.extend({
    /**@private*/
    construct: function(){
	
		arguments.callee.$.construct.apply(this, arguments);
	
		//var ns = this.facade.getStencilSets().values()[0].namespace();
		var description = Signavio.I18N.PlausibilityChecker.desc;
		
//		if (ns ==="http://b3mn.org/stencilset/timjpdl3#")
//			description = Signavio.I18N.PlausibilityChecker.desctimjpdl3;
//		else if (this.isStencilSetExtensionLoaded("http://oryx-editor.org/stencilsets/extensions/carestation#")) 
//			description = Signavio.I18N.PlausibilityChecker.desccarestation;
//		else 
//			description = Signavio.I18N.PlausibilityChecker.desc;
		
        this.active = false;
        this.raisedEventIds = [];
        
        this.facade.offer({
            'name': Signavio.I18N.PlausibilityChecker.name,
            'functionality': this.perform.bind(this),
            'group': Signavio.I18N.PlausibilityChecker.group,
            'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/book_error.png",
            'description': description,
            'index': 0,
            'toggle': true,
            'minShape': 0,
            'maxShape': 0,
            'isEnabled': this._isRequiredSSELoaded.bind(this)
        });
        
        this.facade.registerOnEvent(ORYX.Plugins.PlausibilityChecker.CHECK_FOR_ERRORS_EVENT, this.checkForErrors.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ABOUT_TO_SAVE, this.resetErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.PlausibilityChecker.RESET_ERRORS_EVENT, this.resetErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.PlausibilityChecker.SHOW_ERRORS_EVENT, this.doShowErrors.bind(this));
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this._checkEnabledState.bind(this));
    },
    
    _checkEnabledState: function() {
    	 this.facade.updateSelection();
    },
    
    /**
	 * Checks if the jPDL stencil set is loaded right now.
	 */
    _isRequiredSSELoaded: function() {
        var stencilSet = this.facade.getStencilSets().values()[0];       
        for (var i = 0; i <ORYX.CONFIG.PLAUSIBILITYCHECKER_REQ.length; i++) {
        	var req = ORYX.CONFIG.PLAUSIBILITYCHECKER_REQ[i];
			if (req.stencilSet == stencilSet.namespace()) {
				if (req.requiredExtension && !this.isStencilSetExtensionLoaded(req.requiredExtension)) {
					return false;
				}
			}
		}
		return true;
	},
	
    
    perform: function(button, pressed){
        if (!pressed) {
            this.resetErrors();
        } else {
            this.checkForErrors({
            	onAbort: function() {
            		this.setActivated(button, false);
            		
            	}.bind(this),
                onNoErrors: function(){
                    this.setActivated(button, false);
                    this.facade.raiseEvent({
            			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
            			text:Signavio.I18N.PlausibilityChecker.noErrors,
            			timeout:10000
            		});
                    //Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SyntaxChecker.noErrors);
                }.bind(this),
                onErrors: function(){
                    this.enableDeactivationHandler(button);
                }.bind(this),
                onFailure: function(){
                    this.setActivated(button, false);
                    Ext.Msg.alert(ORYX.I18N.Oryx.title, Signavio.I18N.PlausibilityChecker.invalid);
                }.bind(this)
            });      
        }
    },
    
    /**
     * Registers handler for deactivating syntax checker as soon as somewhere is clicked...
     * @param {Ext.Button} Toolbar button
     */
    enableDeactivationHandler: function(button){
        var deactivate = function(){
            this.setActivated(button, false);
            this.resetErrors();
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate);
        };
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate.bind(this));
    },
    
    /**
     * Sets the activated state of the plugin
     * @param {Ext.Button} Toolbar button
     * @param {Object} activated
     */
    setActivated: function(button, activated){
        button.toggle(activated);
        if(activated === undefined){
            this.active = !this.active;
        } else {
            this.active = activated;
        }
    },
    
    /**
     * Performs request to server to check for errors on current model.
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Object} options Configuration hash
     * @param {String} context A context send to the syntax checker servlet
     * @param {Function} [options.onNoErrors] Raised when model has no errors.
     * @param {Function} [options.onErrors] Raised when model has errors.
     * @param {Function} [options.onFailure] Raised when server communcation failed.
     * @param {boolean} [options.showErrors=true] Display errors on nodes on canvas (by calling ORYX.Plugins.SyntaxChecker.prototype.showErrors)
     */
    checkForErrors: function(options){
        Ext.applyIf(options || {}, {
          showErrors: true,
          onAbort:	Ext.emptyFn,
          onErrors: Ext.emptyFn,
          onNoErrors: Ext.emptyFn,
          onFailure: Ext.emptyFn
        });
            
//        Ext.Msg.wait(Signavio.I18N.PlausibilityChecker.checkingMessage);
        
        var chancelBtn= new Ext.Button({
            text: "Abbruch",
            style: "margin-left:110px"
        	
        }); 

        var progressbar = new Ext.ProgressBar({
                style: "height:25px; width:160px; margin:12px", 
                test:"test"
                });

        progressbar.wait({interval:200, increment:15});


            w = new Ext.Window({	
        	        title		: Signavio.I18N.PlausibilityChecker.checkingMessage,
        	        background : "white",					
        	        layout		: "anchor",
        	        width		: 250,
        	        height		: 100,
        	        items       : [progressbar, new Ext.Button({
            text: "Abbruch",
        	style: "margin-left:160px",
        	handler: function(){							
        		w.close();
        	}.bind(this)
        })]
        	    });
                
        w.show();	
        
        
        // Send the request to the server.
        new Ajax.Request(ORYX.CONFIG.PLAUSIBILITYCHECKER_URL, {
            method: 'POST',
            asynchronous: true,
            parameters: {
                model_xml: Ext.encode(this.facade.getJSON()),
                id: this.facade.getModelMetaData().modelId
            },
            onSuccess: function(request){
                var resp = request.responseText.evalJSON().rep;
                
//                Ext.Msg.hide();
                if (w.hidden) {
                	options.onAbort();
                	return;
                }
                w.hide();
                if (resp instanceof Object) {
                    errors = $H(resp.errors)
					warnings = $H(resp.warnings)
                    if (errors.size() + warnings.size() > 0) {
                        if (options.showErrors) {
							this.showFeedback(errors, warnings);
						}
                 
                        options.onErrors();
                    }
                    else {
                        options.onNoErrors();
                    }
                }
                else {
                    options.onFailure();
                }
            }.bind(this),
            onFailure: function(){
                Ext.Msg.hide();
                options.onFailure();
            }
        });
    },
    
    /** Called on SHOW_ERRORS_EVENT.
     * 
     * @param {Object} event
     * @param {Object} args
     */
    doShowErrors: function(event, args){
        this.showFeedback(event.errors, {});
    },
    
    /**
     * Shows overlays for each given error
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Hash|Object} errors
     * @example
     * showFeedback({
     *     myShape1: "This has an error!",
     *     myShape2: "Another error!"
     * },{
     *   myShape2: "This a warning!"
     * })
     */
    showFeedback: function(errors, warnings){
        // If normal object is given, convert to hash
        if(!(errors instanceof Hash)){
            errors = new Hash(errors);
        }
		if(!(warnings instanceof Hash)){
            warnings = new Hash(warnings);
        }
        
        // Get all Valid ResourceIDs and collect all shapes
        errors.keys().each(function(value){
            var sh = this.facade.getCanvas().getChildShapeByResourceId(value);
            if (sh) {
                this.raiseErrorOverlay(sh, this.parseCodeToMsg(errors[value]));
            } else if (value == "canvas") {
            	this.raiseErrorOverlay(this.facade.getCanvas(), this.parseCodeToMsg(errors[value]));
            }
        }.bind(this));

		// Get all Valid ResourceIDs and collect all shapes
        warnings.keys().each(function(value){
            var sh = this.facade.getCanvas().getChildShapeByResourceId(value);
            if (sh) {
                this.raiseWarningOverlay(sh, this.parseCodeToMsg(warnings[value]), errors[value]);
            } else if (value == "canvas") {
            	this.raiseWarningOverlay(this.facade.getCanvas(), this.parseCodeToMsg(warnings[value]), errors[value]);
            }
        }.bind(this));
        this.active = !this.active;
        
        //show a status message with a hint to the error messages in the tooltip
        this.facade.raiseEvent({
			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
			text:Signavio.I18N.PlausibilityChecker.notice,
			timeout:10000
		});
    },
    
    parseCodeToMsg: function(code){
    	var msg = code.replace(/: /g, "<br />").replace(/, /g, "<br />");
    	var codes = msg.split("<br />");
    	for (var i=0; i < codes.length; i++) {
    		var singleCode = codes[i];
    		var replacement = this.parseSingleCodeToMsg(singleCode);
    		if (singleCode != replacement) {
    			msg = msg.replace(singleCode, replacement);
    		}
    	}
		return msg;
	},
	
	parseSingleCodeToMsg: function(code){
		return Signavio.I18N.PlausibilityChecker[code]||ORYX.I18N.SyntaxChecker[code]||code;
	},
	
    /**
     * Resets all (displayed) errors
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     */
    resetErrors: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }.bind(this))
        
        this.raisedEventIds = [];
        this.active = false;
    },
	
	raiseErrorOverlay: function(shape, errorMsg){
        var id = "syntaxchecker." + this.raisedEventIds.length;
        var stencilId = shape.getStencil().id();
        var path = "";
        if (stencilId.endsWith("Lane") || stencilId.endsWith("Pool") || stencilId.endsWith("Diagram") ) {
        	path = "M20,20 L5,5 M5,20 L20,5";
        } else {
        	path = "M20,-5 L5,-20 M5,-5 L20,-20";
        }
        var crossId = ORYX.Editor.provideId();
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
            "id":crossId,
            "title":"",
            "stroke-width": 5.0,
            "stroke": "red",
            "d": path,
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	html:errorMsg,
        	target:crossId
        });
        
        this.raisedEventIds.push(id);
        
        return cross;
    },
    
    raiseWarningOverlay: function(shape, errorMsg, nextToError){
        var id = "syntaxchecker." + this.raisedEventIds.length;
        var stencilId = shape.getStencil().id();
        var path = "";
		var x = 10;
		var y = -7;
		if (nextToError) {
			if (stencilId.endsWith("Lane") || stencilId.endsWith("Pool") || stencilId.endsWith("#BPMNDiagram")) {
				path = "M21 40 L12.5 25 L4 40 Z";
				y = 38;
			}
			else {
				path = "M41 -5 L32.5 -20 L24 -5 Z";
				x = 30;
			}
		}
		else {
			if (stencilId.endsWith("Lane") || stencilId.endsWith("Pool") || stencilId.endsWith("#BPMNDiagram")) {
				path = "M21 20 L12.5 5 L4 20 Z";
				y = 18;
			}
			else {
				path = "M21 -5 L12.5 -20 L4 -5 Z";
			}
		}
        var triangleId = ORYX.Editor.provideId();
		var triangle = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['g', {"id":triangleId}, ['path', {
            "stroke-width": 2.0,
            "stroke": "orange",
			"fill":"yellow",
            "d": path,
            "line-captions": "round"
        }],['text' , {
			"x":x,
			"y":y,
            "stroke-width": 0,
            "fill": "#666666",
			"font-size":9,
			"font-weight":"bold",
            "line-captions": "round"
		}, "!"]]);
		
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: triangle,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	html:errorMsg,
        	target:triangleId
        });
        
        this.raisedEventIds.push(id);
        
        return triangle;
    }
	
	
});

ORYX.Plugins.PlausibilityChecker.CHECK_FOR_ERRORS_EVENT = "checkForErrors";
ORYX.Plugins.PlausibilityChecker.RESET_ERRORS_EVENT = "resetErrors";
ORYX.Plugins.PlausibilityChecker.SHOW_ERRORS_EVENT = "showErrors";
/**
 * Copyright (c) 2009 Signavio
 * @author Philipp Giese
 **/

if(!window.ORYX) { window.ORYX = {}; }
if(!ORYX.Plugins) { ORYX.Plugins = {}; } 

(function() {
	
	var ALIGNMENT = {
	   HORIZONTAL: "horizontal",
	   VERTICAL: "vertical"
	};
	
	var ORIENTATION = {
	   LEFT_TO_RIGHT: "left-to-right",
	   RIGHT_TO_LEFT: "right-to-left",
	   BOTTOM_UP: "bottom-up",
	   TOP_DOWN: "top-down",
	   BLOCK: "block"
	};
	
	var ARROW_ANGLE_RATIO = 18/56;
	var ANGLE_TRESHOLD = 0.9;
	
	var NAMESPACE = "http://www.signavio.com/stencilsets/processmap#";
	
    ORYX.Plugins.ProcessmapSupport = Clazz.extend({
    
        facade: undefined,
        
        construct: function(facade){
            this.facade = facade;
    
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, this.onAdd.bind(this));
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.onPropertyChange.bind(this));
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.onFinish.bind(this));
            
            // Check if the process map is loaded
            if (this.facade.getStencilSets().keys().include(NAMESPACE)) {
                // ENABLE THAT A SHAPE, CREATED FROM THE SHAPE MENU,
                // DOES NOT CREATE AN EDGE
                ORYX.CONFIG.SHAPEMENU_DISABLE_CONNECTED_EDGE = true;
                
                // RESET THE OFFSET OF CREATED SHAPES OUT OF THE SHAPEMENU
                ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET = 0;
            }
        },
        
        onFinish: function(){
    
            this.facade.getCanvas().getChildShapes(true).each(function(shape){
                if (!(shape instanceof ORYX.Core.Node)){
                    return;
                }
                
                this.onAdd({shape:shape});
                this.onPropertyChange({name:"oryx-orientation", value:shape.properties["oryx-orientation"]}, shape);
                this.onPropertyChange({name:"oryx-textdirection", value:shape.properties["oryx-textdirection"]||"0"}, shape);
                
                var labels = shape.getLabels();
                 
                 // For performance reasons, return first label if only 
                 // one is defined (~90% of all shapes), otherwise return
                 // the first label with a property which has a 
                 // ref to view defined.
                 var label = labels.find(function(label) {
                     var allRefToViews = shape.getStencil().properties().invoke("refToView").flatten();
                     return allRefToViews.any(function(ref){
                         return label.id == shape.id+ref;
                     });
                 });
                 if (label){
                     label.update(true);
                 }           
            }.bind(this));
            
            this.finished = true;
        },
        
        addedShapes: {},
        
        onAdd: function(event) {
            
            var shape = event.shape;
            if (shape instanceof ORYX.Core.Node && !this.addedShapes[shape.id] &&
                (this.isProcess(shape) ||
                shape.getStencil().id() === NAMESPACE + "TextNote")) {
                    
                    // show the gradient
                    var poly = Element.getElementsByClassName(shape.getMeContainer(), "front")[0];
                    if(poly) {
                        poly.setAttribute("fill", "url(#" + shape.getId() + "gradient)");
                    }
    
                    // Show the shadow (only FF)
                    $A(Element.getElementsByClassName(shape.getMeContainer(), "shadow")).each(function(shadow){
                        
                        // If FF with the a version of at least 3.5
                        if (Ext.isGecko && Signavio.Plugins.Utils.getFFVersion() > 3.0) {
                            
                            shadow.setAttribute("filter", "url(#" + shape.getId() + "filter)");
                        
                        // If chrome or other browser
                        } else {
                            
                            shadow.removeAttribute("filter");
    
                            $H({
                                "stroke-opacity": "0.2",
                                "fill-opacity"  : "0.5",
                                "stroke-width"  : "2",
                                "stroke-linejoin" : "bevel",
                                "stroke"        : "grey",
                                "fill"          : "grey", 
                                "transform"     : "translate(1.5, 3)"
                            }).each(function(v){
                                    shadow.setAttribute(v.key, v.value);
                                })
                        
                        }
                    });
                    
//                    shape.bounds.registerCallback(this.onChange.bind(this, shape));
//                    //this.onChange(shape, true);
//                    var me = this;
//                    this.addedShapes[shape.id] = true;
//                    
//                    shape._labels.values().each(function(label){
//                    	var callOnChange = function(){
//                    		me.onChange(shape);
//                    		label.unregisterOnChange(callOnChange);                    		
//                    	};
//                    	label.registerOnChange(callOnChange);
//                    });
//            }
//        },
//        
//        onChange: function(shape, dontUpdate) {    
//        
//        	if (dontUpdate !== true){
////        		if (this.addedShapes[shape.id] === false){
////        			this.addedShapes[shape.id] = true;
////
////        		} else {
//	        		shape.bounds.suspendChange = true;
//	        		shape._update();
//	        		shape.bounds.suspendChange = false;
////        		}
//        	} else {
//        		//shape._labels.values().invoke("update");
//        	}

        	
		            shape.bounds.registerCallback(this.onChange.bind(this, shape));
		            this.onChange(shape);
		            this.addedShapes[shape.id] = true;

		            
		            if (this.finished){
			            var me = this;
			            shape._labels.values().each(function(label){
	                    	var callOnChange = function(){
	                    		label.unregisterOnChange(callOnChange); 
	                    		window.setTimeout(function(){
	                    			if (!label.isUpdating()){
	                    				label.update(true);
	                    			}
	                    		}, 0);                   		
	                    		
	                    	};
	                    	label.registerOnChange(callOnChange);
	                    });
		            }
		    }
		},
		
		onChange: function(shape) {    
		
		    shape.bounds.suspendChange = true;
		    shape._update();
		    shape.bounds.suspendChange = false;
		    
		    
		    
            var height = shape.bounds.height();         
            var width = shape.bounds.width();                        
            var offset = 15;
            
            // Addopt resolution of filter
            var filter = $(shape.getMeContainer()).getElementsByTagName("filter")[0];
            if (filter) {
                filter.setAttribute("filterRes", Math.max(100, Math.min(1000, parseInt(Math.max(height, width)/2) )))
            }
    
            // Adopt blurry value (small shape should have smaller blurry values)
            var gaussian = $(shape.getMeContainer()).getElementsByTagName("feGaussianBlur")[0]||$(shape.getMeContainer()).getElementsByTagName("fegaussianblur")[0];
            if (gaussian) {
                gaussian.setAttribute("stdDeviation", Math.max(1.0, Math.min(3.0, Math.max(height, width)/50 )))
            }       
            
            // IF Text Node
            if (shape.getStencil().id() === NAMESPACE + "TextNote"){
                // Reset upper left corner points
            	this.updateSVG(shape.getMeContainer(), "figure", "0,0 "+(width-offset)+",0 "+(width)+","+(offset)+" "+(width)+","+(height)+" 0,"+(height)+" 0,0")

            	return;
            }
            
            // gradient has to be set manually to the new width
            var gradient = Element.getElementsByClassName(shape.getMeContainer(), "gradient")[0];
            if (gradient) { gradient.setAttribute("x2", width); }
            
            var arrow = this.getMainArrow(shape);
            if (!arrow){ return }
            
            var points    = null;
            var shapeInfo = this.parseShape(this.getPoints(arrow));
            
            shapeInfo.minimumSize = shape.minimumSize || null;
            
            this.moveLink(shape, shapeInfo);
            
            var xOffset = height * ARROW_ANGLE_RATIO;
            var yOffset = width * ARROW_ANGLE_RATIO;
            
            this.updateLabelPosition(shape.getLabels(), width/2, height/2);
            
            // BEHOLD!
            // these magical numbers 3 and 2.5 are the result of an
            // absolutely scientific research. seriously. 
            
            // plus, they move the label to a position not quite in
            // the middle, but on that position it LOOKS like
            // it is in the middle of the shape.. optical illusion and stuff.
            
            if(shapeInfo.orientation == ORIENTATION.LEFT_TO_RIGHT) {
                
                if(width/height < ANGLE_TRESHOLD) {
                    xOffset = xOffset * width/height;
                    
                    this.updateLabelPosition(shape.getLabels(), (width/2) + (xOffset/2.5), height/2);
                } else {
                	this.updateLabelPosition(shape.getLabels(), (width/2) + (xOffset/3), height/2);
                }
                
                points = this.orientLeftToRight(width, height, xOffset);
                
            } else if(shapeInfo.orientation == ORIENTATION.RIGHT_TO_LEFT) {
            	
                if(width/height < ANGLE_TRESHOLD) {
                    xOffset = xOffset * width/height;
                    
                    this.updateLabelPosition(shape.getLabels(), (width/2) - (xOffset/2.5), height/2);
                } else {
                	this.updateLabelPosition(shape.getLabels(), (width/2) - (xOffset/3), height/2);
                }
                
                points = this.orientRightToLeft(width, height, xOffset);
                
            } else if(shapeInfo.orientation == ORIENTATION.TOP_DOWN) {
                
                if(height/width < ANGLE_TRESHOLD) {
                    yOffset = yOffset * height/width;
                }
    
                points = this.orientTopDown(width, height, yOffset);
                
            } else if(shapeInfo.orientation == ORIENTATION.BOTTOM_UP) {
                
                if(height/width < ANGLE_TRESHOLD) {
                    yOffset = yOffset * height/width;
                }
    
                points = this.orientBottomUp(width, height, yOffset);
            } else {
                return;
            }
                
            this.updateSVG(shape.getMeContainer(), "arrow", points);
        },
        
        updateLabelPosition: function(labels, x, y) {
            labels.each(function(label) {
            	if (label.getPosition()){ return; } // Don't set the label position if the user has defined one 
            	var setLabel = function(label, x, y){
            		label.unregisterOnChange(setLabel);
            		label.setX(x);
            		label.setY(y);
            		window.setTimeout(label.update.bind(label, true), 0);
            	}.bind(this, label, x, y);
            	if (label.isUpdating()){
            		label.registerOnChange(setLabel);
            	} else {
            		setLabel();
            	}
            });
        },
        
        getMainArrow: function(shape){
            return $A(Element.getElementsByClassName(shape.getMeContainer(), "arrow")).find(function(node){ return node.getAttribute("class").include("front")})
        },
        
        moveLink: function(shape, shapeInfo) {
            
            var link = Element.getElementsByClassName(shape.getMeContainer(), "diagramLink")[0];
            var arrow = this.getMainArrow(shape)
            
            if(link && arrow) {
    
                var points = this.getPoints(arrow);         
                var cornerLLX = parseInt(points[2].split(",")[0]);
                var cornerLRX = parseInt(points[3].split(",")[0]);
                var offsetX = cornerLLX + (cornerLRX - cornerLLX)/2;
                var height = parseInt(points[2].split(",")[1]);
                
                var BBOX_HEIGHT = 14;
                
                var x = Math.round((shapeInfo.width / 2) - (BBOX_HEIGHT / 2));
                var y = height - BBOX_HEIGHT;
                
                if( shapeInfo.orientation === ORIENTATION.TOP_DOWN) {
                    
                    y = 0;
                    
                } else if(shapeInfo.orientation === ORIENTATION.LEFT_TO_RIGHT) {
    
                    x = offsetX - 4;
                    
                } else if (shapeInfo.orientation === ORIENTATION.RIGHT_TO_LEFT) {
                
                    x = offsetX - 10;
                    
                } 
                    
                for(var i = 0; i < link.childNodes.length; i++) {
                    var node = link.childNodes[i];
                    if (node.nodeName === "rect") {
                        node.setAttribute("x", x);
                        node.setAttribute("y", y);
                    }
                    else if (node.nodeName === "path") {
                        node.setAttribute("d", "M" + (x + 7) + "," + (y + 2) + "v10 M" + (x + 2) + "," + (y + 7) + "h10");
                    }
                }
                
                
                // store position of process link to place the overlay in the MOVI API
                var setBounding = function(link, shape){
                    if (link.parentNode.parentNode.nearestViewportElement){ // Check if the parent is part of the current DOM
                        var bbox = link.parentNode.getBBox();
                        shape.setHiddenProperty("oryx-processlink_bounds", bbox.x + ","+ bbox.y + " " + 
                                (bbox.x+bbox.width) + "," + (bbox.y+bbox.height));
                    }
                }.bind(this, link, shape);
                
    //          try {
    //              setBounding()
    //          } catch(e){
                    window.setTimeout(setBounding, 10);
    //          }
    
            }
            
        },
        
        isProcess: function() {
            var stencils = [NAMESPACE + "Process",
                            NAMESPACE + "ProcessCollapsed"];
                            
            return function(shape) {
                return stencils.include(shape.getStencil().id());
            };
        }(),
        
        onPropertyChange: function(option, shape){
            if (this.isProcess(shape) && option.name === "oryx-orientation") {
                var shapeInfo = {};
                
                var arrow = this.getMainArrow(shape);
                if (!arrow){ return }
                
                var newShape;
                var shapeInfo = this.parseShape(this.getPoints(arrow));
                
                shapeInfo.minimumSize = shape.minimumSize || null;
                
                // IF THE DESIRED ORIENTATION IS A BLOCK, CLEAR THE OFFSET
                if (option.value === ORIENTATION.BLOCK) {
                    shapeInfo.offset = 0;
                } else {
                    shapeInfo.offset = (shapeInfo.offset || ORYX.CONFIG.PROCESSMAP_DEFAULT_ARROW_WIDTH);
                }
                
                /* 
                 * The shape will only be rotated if that ends up
                 * with any visual result
                 */
                if (option.value !== shapeInfo.orientation) {
                    // Morph to block
                    if (option.value === ORIENTATION.BLOCK) {

                        if (shapeInfo.alignment === ALIGNMENT.HORIZONTAL) {
                            newShape = this.rotateHorizontal(option.value, shapeInfo, false);
                        } else {
                            newShape = this.rotateHorizontal(option.value, shapeInfo, true);
                        }
                    }
                    // Morph to horizontal
                    else if (option.value == ORIENTATION.LEFT_TO_RIGHT || option.value == ORIENTATION.RIGHT_TO_LEFT) {
                        
                        if (shapeInfo.alignment === ALIGNMENT.HORIZONTAL) {
                            newShape = this.rotateHorizontal(option.value, shapeInfo, false);
                        } else {
                            newShape = this.rotateHorizontal(option.value, shapeInfo, true);
                        }
                    }
                    // Morph to vertical
                    else if (option.value === ORIENTATION.TOP_DOWN || option.value === ORIENTATION.BOTTOM_UP) {
                    
                        if (shapeInfo.alignment === ALIGNMENT.VERTICAL) {
                            newShape = this.rotateVertical(option.value, shapeInfo, false);
                        } else {
                            newShape = this.rotateVertical(option.value, shapeInfo, true);
                        }
                    }
                    
                    if (newShape.resetBounds || newShape.linkMoved) {
                    
                        var bounds = {
                            a: {
                                x: shape.bounds.a.x,
                                y: shape.bounds.a.y
                            },
                            b: {
                                x: shape.bounds.a.x + newShape.width,
                                y: shape.bounds.a.y + newShape.height
                            }
                        };
                        
                        shape.bounds.set(bounds);
                        
                        var gradient = Element.getElementsByClassName(shape.getMeContainer(), "gradient")[0];
                        gradient.setAttribute("x2", newShape.width);
                        
                        this.facade.updateSelection();
                    }
                    
                    this.updateSVG(shape.getMeContainer(), "arrow", newShape.points);
                    
                    this.onChange(shape);
                    
                    /* if the process has a link, move it! */
                    this.moveLink(shape, newShape);
                
                }
            }
            
            /**
             * Set the rotation to all labels regarding the text direction value
             */
            if (this.isProcess(shape) && option.name === "oryx-textdirection") {
            	var value = parseInt(option.value || "0");
            	if ([0,90,180,270].include(value)){
            		shape.getLabels().each(function(label){
            			label.rotate(value);
            			label.update();
            		});
            	}
            }
        },
        
        updateSVG: function(node, selector, points) {
            $A(Element.getElementsByClassName(node, selector)).each(function(poly) {
                poly.setAttribute("points", points);
            });
        },
            
        rotateHorizontal: function(orientation, shapeInfo, fromVertical) {
        
            var shape   = {};
            var width   = shapeInfo.width;
            var height  = shapeInfo.height;
        
            /*
             * because we are rotating the shape the width
             * of the horizontal aligned shape becomes the
             * height of the vertical aligned one and the height
             * of the old shape becomes the width of new one.
             */
            
            if(fromVertical) {
                if(shapeInfo.minimumSize === null) {
                    shapeInfo.minimumSize = {
                            width: 48,
                            height: 48
                    };
                }
                
                width  = Math.max(shapeInfo.height, shapeInfo.minimumSize.width);
                height = Math.max(shapeInfo.width, shapeInfo.minimumSize.height);
            }
            
            var xOffset = shapeInfo.offset;
            
            shape.width  = width;
            shape.height = height;      
            
            shape.alignment = ALIGNMENT.HORIZONTAL;
            shape.offset    = xOffset;
            
            if(!(shape.resetBounds = fromVertical)) {
                
                if(shapeInfo.orientation === ORIENTATION.LEFT_TO_RIGHT || (shapeInfo.orientation === ORIENTATION.BLOCK && orientation === ORIENTATION.RIGHT_TO_LEFT)) {
                    
                    // change orientation to right-to-left
                    shape.points        = this.orientRightToLeft(width, height, xOffset); 
                    shape.orientation   = ORIENTATION.RIGHT_TO_LEFT;
                    
                } else {
                    
                    // change orientation to left-to-right 
                    shape.points        = this.orientLeftToRight(width, height, xOffset);                   
                    shape.orientation   = ORIENTATION.LEFT_TO_RIGHT;
                }   
                
            } else {
                
                if(orientation === ORIENTATION.LEFT_TO_RIGHT) {
                    
                    // change orientation to left-to-right 
                    shape.points        = this.orientLeftToRight(width, height, xOffset);   
                    shape.orientation   = ORIENTATION.LEFT_TO_RIGHT;              
                    
                } else {
                    
                    // change orientation to right-to-left
                    shape.points        = this.orientRightToLeft(width, height, xOffset); 
                    shape.orientation   = ORIENTATION.RIGHT_TO_LEFT;
                    
                }
                
            }
            
            return shape;
        },
            
        /* 
         *   _______
         *  /      /
         * /      /     Changes the orientation of the shape
         * \      \     to right-to-left.
         *  \______\
         *  
         */
        orientRightToLeft: function(width, height, offset) {
            var points = offset + ",0 0," + (height / 2) + " " + offset + "," + height;
            points    += " " + width + "," + height + " " + (width - offset) + "," + (height / 2) + " " + width + ",0"; 
            
            return points;
        },
        
        /*
         *  _______
         *  \      \        
         *   \      \   Changes the orientation of the shape
         *   /      /   to left-to-right.
         *  /______/
         * 
         */
        orientLeftToRight: function(width, height, offset) {
            var points   = "0,0 " + offset + ","+ (height / 2) + " 0," + height;
            points      += " " + (width - offset) + "," + height + " " + width + "," + (height / 2) + " " + (width - offset) + ",0";            
            
            return points;  
        },
        
        rotateVertical: function(orientation, shapeInfo, fromHorizontal) {
            
            var shape   = {};
            var width   = shapeInfo.width;
            var height  = shapeInfo.height;
            
            /*
             * because we are rotating the shape the width
             * of the horizontal aligned shape becomes the
             * height of the vertical aligned one and the height
             * of the old shape becomes the width of new one.
             */
    
            if(fromHorizontal) {
                if(shapeInfo.minimumSize === null) {
                    shapeInfo.minimumSize = {
                        width: 48,
                        height: 48
                    };
                }
                
                width  = Math.max(shapeInfo.height, shapeInfo.minimumSize.width);
                height = Math.max(shapeInfo.width, shapeInfo.minimumSize.height);
            }
    
            var yOffset = shapeInfo.offset; 
            
            shape.width  = width;
            shape.height = height;
            
            shape.linkMoved = true;
            shape.alignment = ALIGNMENT.VERTICAL;
            shape.offset    = yOffset;
            
            if (!(shape.resetBounds = fromHorizontal)) {
            
                if (shapeInfo.orientation === ORIENTATION.TOP_DOWN || (shapeInfo.orientation === ORIENTATION.BLOCK && orientation === ORIENTATION.BOTTOM_UP)) {
                
                    // change orientation to bottom-up
                    shape.points        = this.orientBottomUp(width, height, yOffset);
                    shape.orientation   = ORIENTATION.BOTTOM_UP;
                                    
                }
                else {
                
                    // change orientation to top-down
                    shape.points        = this.orientTopDown(width, height, yOffset); 
                    shape.orientation   = ORIENTATION.TOP_DOWN;
                }
                
            } else {
                
                if(orientation === ORIENTATION.TOP_DOWN) {
                    
                    // change orientation to top-down
                    shape.points        = this.orientTopDown(width, height, yOffset); 
                    shape.orientation   = ORIENTATION.TOP_DOWN;
                    
                } else {
                    
                    // change orientation to bottom-up
                    shape.points        = this.orientBottomUp(width, height, yOffset);
                    shape.orientation   = ORIENTATION.BOTTOM_UP;
                    
                }
                
            }
        
            return shape;
        },
        
        /*
         *    /\
         *   /  \
         *  |    |      Changes the orientation of the shape
         *  |    |      to bottom-up
         *  |____|
         */
        orientBottomUp: function(width, height, offset) {
            var points = "0," + offset + " 0," + height + " " + width + "," + height;
            points    += " " + " " + width + "," + offset + " " + (width / 2) + ",0";
            
            return points;
        },
        
        /*
         *   ____
         *  |    |
         *  |    |      Changes the orientation of the shape
         *  |    |      to top-down.
         *   \  /
         *    \/
         */
        orientTopDown: function(width, height, offset) {
            var points = "0,0 0," + (height - offset) + " " + (width / 2) + "," + height;
            points    += " " + width + "," + (height - offset) + " " + width + ",0"; 
    
            return points;      
        },
        
        /**
         * Returns an array where string with the followed shema are included "<x>,<y>"
         * @param {Object} svgNode
         * @return {Array}
         */
        getPoints: function(svgNode){
    
            var points = svgNode.getAttribute("points").split(/\s+/g);
    
            
            // WORKAROUND FOR WRONG POINTS INTERPRETATION
            // Sometimes chrome interpret x,y as x y schema
            if (!points.first().include(",")){
                points = points.inGroupsOf(2).invoke("join", ",")
            }
            
            return points;
        },
            
        parseShape: function(pointsArray) {
            
            var shape = {};
            
            /* 
             * ----- EXAMPLE
             * 
             * To get the orientation i'm testing the following 
             * values:
             * 
             *  ________            |      ________
             *  \       \           |     /       /
             *   \       \ x-value  |    /       / x-value
             *   /       /          |    \       \
             *  /_______/ x-value   |     \_______\ x-value
             *  
             *  if both x-values aren't equal the shape is
             *  oriented horizontal. otherwise it would look
             *  like this:
             *   ____      
             *  |    | x-value      |     /\
             *  |    |              |    /  \
             *  |    | x-value /    |   |    | x-value
             *   \  /     y-value   |   |    |
             *    \/ y-value        |   |____| x-value / y-value
             *    
             *  To determine the height of the object if 
             *  oriented vertically, we also need to check
             *  the y-value of to points.
             */ 
            
            /* first point (orientation-check) */
            var helper1 = pointsArray[4].split(",");
            
            /* second point (orientation-check / height-check) */
            var helper2 = pointsArray[3].split(",");
            
            /* third point (height-check) */
            var helper3 = pointsArray[2].split(",");
    
            
            /* --------------- EVIL HACK: DETECT BLOCKS ---------------- */
            /* If the count of different x coordinates of the points is  */
            /* 2, it must be a block, since no arrow exists.             */
            
            if (pointsArray.invoke("split", ",").pluck("0").uniq().findAll(function(v) {return !!v;}).length === 2 || pointsArray.invoke("split", ",").pluck("1").uniq().findAll(function(v) {return !!v;}).length === 2) {
                var lr = pointsArray[3].split(",");
                var width = parseInt(lr[0]);
                var height = parseInt(lr[1]);
                
                shape.alignment     = (width > height ? ALIGNMENT.HORIZONTAL : ALIGNMENT.VERTICAL);
                shape.orientation   = ORIENTATION.BLOCK;
                shape.height        = height;
                shape.width         = width;
                shape.offset        = 0;
                
                return shape;
                
            }
            /* -------------------  END EVIL HACK ---------------------- */
            
            if(helper1[0] == helper2[0] || helper2[0] == helper3[0]) {
            
                shape.alignment = ALIGNMENT.VERTICAL;
            
                if(parseInt(helper2[0]) !== parseInt(helper3[0])) {
                
                    shape.orientation = ORIENTATION.TOP_DOWN;
                    shape.height      = parseInt(helper3[1]);
                    shape.offset      = shape.height - parseInt(pointsArray[1].split(",")[1]);
                
                } else {
                    
                    shape.orientation = ORIENTATION.BOTTOM_UP;
                    shape.height      = parseInt(helper3[1]);
                    shape.offset      = parseInt(pointsArray[0].split(",")[1]);
                    
                }           
                
                shape.width = parseInt(helper2[0]);
                
            } else {
                
                shape.alignment = ALIGNMENT.HORIZONTAL;
                        
                if(parseInt(helper1[0]) > parseInt(helper2[0])) {
                    
                    shape.orientation = ORIENTATION.LEFT_TO_RIGHT;
                    shape.width       = parseInt(helper1[0]);
                    shape.offset      = parseInt(pointsArray[1].split(",")[0]);
                    
                } else {
                    
                    shape.orientation = ORIENTATION.RIGHT_TO_LEFT;
                    shape.width       = parseInt(helper2[0]);
                    shape.offset      = parseInt(pointsArray[0].split(",")[0]);
                    
                }
                
                shape.height = parseInt(helper2[1]);
            }       
            
            return shape;
        }
    });
}());
/**
 * Copyright (c) 2011
 * Signavio GmbH
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 * @author Adrian Klinger
 * 
 * 
 **/

if (!Signavio) { var Signavio = {}; }
if (!Signavio.Plugins) { Signavio.Plugins = {}; }

 
new function(){ 
	
	Signavio.Plugins.RotateProcessMap = ORYX.Plugins.AbstractPlugin.extend({		
		/**
		* Offers the plugin functionality:
		* this plugin is speacially for shapes with types of Process and ProcessCollapsed in the set of ProcessMap
		* and shows the possible values of changing the orientation of the selected shape
		*/
		construct: function(facade){
			this.facade = facade;			
			this.rotateMenuIsShown = false;			
			this.button = {
					target 			: ORYX.Plugins.ShapeMenuPlugin,
					functionality	: function(){
						this.toggleRotateMenu();
					}.bind(this),
					icon			: ORYX.CONFIG.EXPLORER_PATH+"/src/img/fugue/icons/arrow-circle.png",
		            description		: Signavio.I18N.RotateProcessmap.description,
		            align			: ORYX.CONFIG.SHAPEMENU_BOTTOM,
		            minShape		: 1,
		            maxShape		: 1,
		            isEnabled		: function(){
		            	// show orientation-button only, if the selected shape is a type of Process or ProccesCollapsed
		            	if ("undefined" != typeof this.facade && this.facade.getSelection().length == 1)
		    			{	
		    				var stencilset = this.facade.getSelection()[0].getStencil();				
		    				if (stencilset.id() === "http://www.signavio.com/stencilsets/processmap#Process" ||
		    					stencilset.id() === "http://www.signavio.com/stencilsets/processmap#ProcessCollapsed")
		    						return true;
		    			}
		            	return false;
		           }.bind(this)};
			this.facade.offer(this.button);				
		},		
		/**
		 * create the possible menuitems for changing orientation
		 * the current value will be disabled
		 */
		createRotateMenuItems:function(){
			
			if ("undefined" != typeof this.facade && this.facade.getSelection().length == 1)
			{	
					var stencilset = this.facade.getSelection()[0].getStencil();				
					// only for shape with the type Process or ProccesCollapsed
					if (stencilset.id() === "http://www.signavio.com/stencilsets/processmap#Process" ||
						stencilset.id() === "http://www.signavio.com/stencilsets/processmap#ProcessCollapsed")
					{
						var items = stencilset.property("oryx-orientation").items();	
						// read the current value of orientation to disable it later
						this.facade.getSelection()[0].properties.each(function(prop){
						    if (prop.key == "oryx-orientation")
						        currentvalue = prop.value;
						}.bind(this));
						// iterate over all orientationpossibilities and add one button per posibility
						items.each(function(item){						
							var button = new Ext.menu.Item({
								text	: item.title(),
								icon	: ORYX.CONFIG.ROOT_PATH + "/" + item.icon(),
								iconCls	: "x-small-icon",
								handler	: (function() {									
									var orientationShapeCommand = this.orientationShape(currentvalue, item.value(), this.facade.getSelection()[0]);
									this.facade.executeCommands([orientationShapeCommand]);
								}).bind(this) 
							});									
							// disable button for the current value
							if (currentvalue == item.value())
								button.disabled = true;
							this.rotateMenu.addItem(button);						
						}.bind(this));
					}			
			}
		
		},
		/**
		 * Create the Orientation-Command with rollback- and executefunction 
		 * @param oldOrientation This is the Orientation-Value which is restored, if the command is rollbacked
		 * @param newOrientation This is the Orientation-Value which would be set, if the command is executed
		 * @param shape The shape which would change the value of orientation
		 */
		orientationShape: function(oldOrientation, newOrientation, shape){
			
			var OrientationShape = ORYX.Core.Command.extend({
				construct: function(oldOrientation,newOrientation, shape, facade){
					this.shape = shape;
					this.oldOrientation = oldOrientation;
					this.newOrientation = newOrientation;
					this.facade = facade;
				},
				execute: function(){
					this.shape.setProperty("oryx-orientation", newOrientation);
					this.updateSelection();
				},
				rollback: function() {
					this.shape.setProperty("oryx-orientation", oldOrientation);
					this.updateSelection();
				},
				updateSelection: function(){
					var sel = this.facade.getSelection();
					this.facade.setSelection([]); 
					this.facade.setSelection(sel); 
				}
			});
			
			return new OrientationShape(oldOrientation, newOrientation, shape, this.facade);
		},
		/**
		 * Create the menu of the orientation-offerbutton
		 * only for shapes with type of Process or ProcessCollapsed
		 */
		createRotateMenu:function(){
			this.rotateMenu = new Ext.menu.Menu();			
			this.createRotateMenuItems();			
		},
		/**
		 * Show the menu for the pluginbutton
		 * Create the menu if is nessesary
		 */
		showRotateMenu:function(){		
			this.createRotateMenu();
			this.rotateMenuIsShown = true;
			this.rotateMenu.show(this.button.button.node);			
		},
		
		/**
		 * hide the menu, if another shape was selected
		 * @param event
		 */
		onSelectionChanged: function(event) {				
			if (this.rotateMenu != undefined && this.rotateMenuIsShown == true)
			{
				this.hideRotateMenu();
			}
		},
		/**
		 * Hide the menu of the orientation-offerbutton
		 */
		hideRotateMenu:function(){
			this.rotateMenuIsShown = false;
			this.rotateMenu.destroy();
		},
		/**
		 * Toogle the menu of the orientation-offerbutton
		 * if the menu is visible, hide the menu
		 * if the menu is unvisible, show the menu
		 */
		toggleRotateMenu:function(){
			if (this.rotateMenuIsShown == true){				
				this.hideRotateMenu();
			}
			else {
				this.showRotateMenu();					
			}
		}			
	});		
}();/**
 * Copyright (c) 2009 Signavio
 * @author Philipp Giese
 **/

if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.OrganigramSupport = Clazz.extend({
	
	facade: undefined,
	
    construct: function(facade){
		this.facade = facade;

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, this.onAdd.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.onPropertyChange.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.onFinish.bind(this));
		
	},
	
	onFinish: function(){
		
		this.facade.getCanvas().getChildShapes(true).each(function(shape){
			this.onAdd({shape:shape});
			this.onPropertyChange({name:"oryx-color", value:shape.properties["oryx-color"]}, shape);
		}.bind(this))
	
	},

	addedShapes: {},
	
	onAdd: function(event) {
		
		var shape = event.shape;
		
		if (shape instanceof ORYX.Core.Node && !this.addedShapes[shape.id] &&
			(shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#Manager" ||
			shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#HierarchicOrgUnit" ||
			shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#position"||
			shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#freejob"||
			shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#TextNote")) {
				
				// show the gradient
				var front = Element.getElementsByClassName(shape.node, "front")[0]; // Use function on Element and not on node because of IE9
				if(front) {
					front.setAttribute("fill", "url(#" + shape.getId() + "gradient)");
				}

				// Show the shadow (only FF)
				$A(Element.getElementsByClassName(shape.node, "shadow")).each(function(shadow){
					// If FF with the a version of at least 3.5
					if (Ext.isGecko && Signavio.Plugins.Utils.getFFVersion() > 3.0) {
						
						shadow.setAttribute("filter", "url(#" + shape.getId() + "filter)");
					
					// If chrome or other browser
					} else {
						
						shadow.removeAttribute("filter");

						$H({
							"stroke-opacity": "0.2",
							"fill-opacity"	: "0.5",
							"stroke-width"	: "2",
							"stroke-linejoin" : "bevel",
							"stroke"		: "grey",
							"fill"			: "grey", 
							"transform"		: "translate(1.5, 3)"
						}).each(function(v){
								shadow.setAttribute(v.key, v.value);
							})
					
					}
				});
				
				shape.bounds.registerCallback(this.onChange.bind(this, shape));
				this.onChange(shape);
				this.addedShapes[shape.id] = true;
		}
	},
	
	onChange : function(shape) {	
		
	    shape._update();

		var height = shape.bounds.height();			
		var width = shape.bounds.width();				 
		var offset = 15;
		
		
		// Addopt resolution of filter
		var filter = $(shape.node).getElementsByTagName("filter")[0];
		if (filter) {
			filter.setAttribute("filterRes", Math.max(100, Math.min(1000, parseInt(Math.max(height, width)/2) )))
		}

		// IF Text Node
		if (shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#TextNote"){
			// Reset upper left corner points
			$A(Element.getElementsByClassName(shape.node, "figure")).each(function(poly) {
				poly.setAttribute('points', "0,0 "+(width-offset)+",0 "+(width)+","+(offset)+" "+(width)+","+(height)+" 0,"+(height)+" 0,0");
			});
			return;
		}
		
		// Adopt blurry value (small shape should have smaller blurry values)
		var gaussian = $(shape.node).getElementsByTagName("feGaussianBlur")[0]||$(shape.node).getElementsByTagName("fegaussianblur")[0];
		if (gaussian) {
			gaussian.setAttribute("stdDeviation", Math.max(1.0, Math.min(3.0, Math.max(height, width)/50 )))
		}
		
		// gradient has to be set manually to the new width
		var gradient = Element.getElementsByClassName(shape.node, "gradient")[0];
		if (gradient) {	gradient.setAttribute("x2", width);	}
		
		// Update label positions
		this.updateLabelPosition(shape.getLabels());
	},
	
    updateLabelPosition: function(labels) {
        labels.each(function(label) {
        	if (label.getPosition()){ return; } // Don't set the label position if the user has defined one 
        	var setLabel = function(label, x, y){
        		label.unregisterOnChange(setLabel);
        		window.setTimeout(label.update.bind(label, true), 0);
        	}.bind(this, label);
        	if (label.isUpdating()){
        		label.registerOnChange(setLabel);
        	} else {
        		setLabel();
        	}
        });
    },
	
	onPropertyChange: function(option, shape){
		if (	option.name === "oryx-color" &&
				shape instanceof ORYX.Core.Node &&
				(shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#Manager" ||
			 	 shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#HierarchicOrgUnit" ||
				 shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#position"||
				 shape.getStencil().id() === "http://www.signavio.com/stencilsets/organigram#freejob")) {
			

			try {
				var radiant = $(shape.node).getElementsByTagName("stop")[1];
				if (radiant) {
					radiant.setAttribute("style", "stop-color: "+option.value+";")
				}

				$A(Element.getElementsByClassName(shape.node, "stroke")).each(function(poly){
					poly.setAttribute("stroke", option.value);
				});
				
			} catch(e){}
		}
	}
});/**
 * Copyright (c) 2009
 * Sven Wagner-Boysen, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

new function(){
	
	ORYX.Plugins.BPMN2_0 = {
	
		/**
		 *	Constructor
		 *	@param {Object} Facade: The Facade of the Editor
		 */
		construct: function(facade){
			this.facade = facade;
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, this.handleDockerDocked.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_BPMN20_HASHCHILD, this.handleHashChild.bind(this));
			this.facade.registerOnEvent('layout.bpmn2_0.subprocess', this.handleSubProcess.bind(this));

			this.namespace = undefined;
		},
		
		hashedSubProcesses: {},
		
		handleHashChild: function(event) {
			var shape = event.shape;
			if(shape) {
				this.hashChildShapes(shape);
			}
		},
		
		hashChildShapes: function(shape){
			var children = shape.getChildNodes();
			children.each(function(child){
				if (this.hashedSubProcesses[child.id]){
					this.hashedSubProcesses[child.id] = child.absoluteXY();
					this.hashedSubProcesses[child.id].width 	= child.bounds.width();
					this.hashedSubProcesses[child.id].height 	= child.bounds.height();
					this.hashChildShapes(child);
				}
			}.bind(this));
		},
	
		/**
		 * Handle the layouting of a sub process.
		 * Mainly to adjust the child dockers of a sub process. 
		 *
		 */
		handleSubProcess : function(option) {
			
			var sh = option.shape;
			
			if (!this.hashedSubProcesses[sh.id]) {
				this.hashedSubProcesses[sh.id] = sh.absoluteXY();
				this.hashedSubProcesses[sh.id].width 	= sh.bounds.width();
				this.hashedSubProcesses[sh.id].height 	= sh.bounds.height();
				return;
			}
			
			var offset = sh.absoluteXY();
			offset.x -= this.hashedSubProcesses[sh.id].x;
			offset.y -= this.hashedSubProcesses[sh.id].y;
			
			var threshold = 1;
			
			var resized = Math.abs(this.hashedSubProcesses[sh.id].width - sh.bounds.width()) > threshold
				|| Math.abs(this.hashedSubProcesses[sh.id].height !== sh.bounds.height()) > threshold;
			
			this.hashedSubProcesses[sh.id] = sh.absoluteXY();
			this.hashedSubProcesses[sh.id].width 	= sh.bounds.width();
			this.hashedSubProcesses[sh.id].height 	= sh.bounds.height();
			this.hashChildShapes(sh);
			
			
			// Move dockers only if currently is not resizing
			if (this.facade.isExecutingCommands()&&!resized) {
				this.moveChildDockers(sh, offset);
			}
		},
		
		moveChildDockers: function(shape, offset){
			
			if (!offset.x && !offset.y) {
				return;
			} 
			
			var children = shape.getChildNodes(true);
			
			// Get all nodes
			var dockers = children
				// Get all incoming and outgoing edges
				.map(function(node){
					return [].concat(node.getIncomingShapes())
							.concat(node.getOutgoingShapes())
				})
				// Flatten all including arrays into one
				.flatten()
				// Get every edge only once
				.uniq()
				// Get all dockers
				.map(function(edge){
					return edge.dockers.length > 2 ? 
							edge.dockers.slice(1, edge.dockers.length-1) : 
							[];
				})
				// Flatten the dockers lists
				.flatten();
	
			var abs = shape.absoluteBounds();
			abs.moveBy(-offset.x, -offset.y);
			var obj = {};
			dockers.each(function(docker){
				
				if (docker.isChanged){
					return;
				}
				
				var off = Object.clone(offset);
				
				if (!abs.isIncluded(docker.bounds.center())){
					var index 	= docker.parent.dockers.indexOf(docker);
					var size	= docker.parent.dockers.length;
					var from 	= docker.parent.getSource();
					var to 		= docker.parent.getTarget();
					
					var bothAreIncluded = children.include(from) && children.include(to);
					
					if (!bothAreIncluded){
						var previousIsOver = index !== 0 ? abs.isIncluded(docker.parent.dockers[index-1].bounds.center()) : false;
						var nextIsOver = index !== size-1 ? abs.isIncluded(docker.parent.dockers[index+1].bounds.center()) : false;
						
						if (!previousIsOver && !nextIsOver){ return; }
						
						var ref = docker.parent.dockers[previousIsOver ? index-1 : index+1];
						if (Math.abs(-Math.abs(ref.bounds.center().x-docker.bounds.center().x)) < 2){
							off.y = 0;
						} else if(Math.abs(-Math.abs(ref.bounds.center().y-docker.bounds.center().y)) < 2){
							off.x = 0;
						} else {
							return;
						}
					}
					
				}
				
				obj[docker.getId()] = {
					docker:docker,
					offset:off
				}
			})
			
			// Set dockers
			this.facade.executeCommands([new ORYX.Core.MoveDockersCommand(obj)]);
				
		},
		
		getNamespace: function() {
			if(!this.namespace) {
				var stencilsets = this.facade.getStencilSets();
				if(stencilsets.keys()) {
					this.namespace = stencilsets.keys()[0];
				} else {
					return undefined;
				}
			}
			return this.namespace;
		},
		
		/**
		 * DragDocker.Docked Handler
		 *
		 */	
		handleDockerDocked: function(options) {
			var namespace = this.getNamespace();
			
			var edge = options.parent;
			var edgeSource = options.target;
			
			if(edge.getStencil().id() === namespace + "SequenceFlow") {
				var isGateway = edgeSource.getStencil().groups().find(function(group) {
						if(group == "Gateways") 
							return group;
					});
				if(!isGateway && (edge.properties["oryx-conditiontype"] == "Expression"))
					// show diamond on edge source
					edge.setProperty("oryx-showdiamondmarker", true);
				else 
					// do not show diamond on edge source
					edge.setProperty("oryx-showdiamondmarker", false);
				
				// update edge rendering
				//edge.update();
				
				this.facade.getCanvas().update();
			}
		},
		
		/**
		 * PropertyWindow.PropertyChanged Handler
		 */
		handlePropertyChanged: function(option) {
			var namespace = this.getNamespace();
			
			var shapes = option.elements;
			var propertyKey = option.key;
			var propertyValues = option.values || option.value;
			var propertyValue;
			
			var changed = false;
			shapes.each(function(shape){
				if((shape.getStencil().id() === namespace + "SequenceFlow") &&
					(propertyKey === "oryx-conditiontype")) {
					
					propertyValue = propertyValues[shape.getId()] || propertyValues;
					
					if(propertyValue != "Expression")
						// Do not show the Diamond
						shape.setProperty("oryx-showdiamondmarker", false);
					else {
						var incomingShapes = shape.getIncomingShapes();
						
						if(!incomingShapes) {
							shape.setProperty("oryx-showdiamondmarker", true);
						}
						
						var incomingGateway = incomingShapes.find(function(aShape) {
							var foundGateway = aShape.getStencil().groups().find(function(group) {
								if(group == "Gateways") 
									return group;
							});
							if(foundGateway)
								return foundGateway;
						});
						
						if(!incomingGateway) 
							// show diamond on edge source
							shape.setProperty("oryx-showdiamondmarker", true);
						else
							// do not show diamond
							shape.setProperty("oryx-showdiamondmarker", false);
					}
					
//					changed = true;
				}
			}.bind(this));
			
//			if(changed) {this.facade.getCanvas().update();}
			
		}
		
	};
	
		
	ORYX.Plugins.BPMN2_0 = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN2_0);
	
}()	/**
   @namespace Oryx name space for plugins
   @name ORYX.Plugins
*/
if(!ORYX.Plugins)
	ORYX.Plugins = new Object();


new function() {
	/* Avoid multiple edge morphing in case of a concurrent executed
	 * command.
	 * Idea: 
	 *  1. register on execute commands event
	 *	2. collect all shapes provide by the incoming events
	 *  3. if the command stack is executed
	 *   3.1 process the collected shapes and check the msg/seq flow condition
	 *   3.2 add morph command to current command stack and force the execution
	 *  
	 *  4. create/release lock before/after undo/redo command, 
	 *     because checking is not necessary 
	 */
	

ORYX.Plugins.BPMN2_0MessageFlow = {

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade){
		this.facade = facade;
		
		/* Ensure message flow connection rule for connecting different pools */
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, this.handleShapeAdded.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, this.handleDragDockerDocked.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_END, this.handleDragDropEnd.bind(this));
		
//		this.facade.registerOnEvent('layout.bpmn2_0.messageflow', this.handleLayoutMessageFlow.bind(this));
//		this.facade.registerOnEvent('layout.bpmn2_0.sequenceflow', this.handleLayoutSequenceFlow.bind(this));
		
		/* Lock/Release Events */
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_BEFORE_EXECUTE, this.lockChecking.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_BEFORE_ROLLBACK, this.lockChecking.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_ROLLBACK, this.unlockChecking.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_EXECUTE, this.unlockChecking.bind(this));

		this.namespace = undefined;
		this.shape = undefined;
		this.stencil = undefined;
		this.removeEdge = [];
		this.reconnectedEdges = [];
		
		//this.executeMorphCommandFn = this.executeMorphCommand.bind(this);
		//this.unlockOnCommandExecutionFn = this.unlockOnCommandExecution.bind(this);
		this.executeCheckingFn = this.executeChecking.bind(this);
		
		this.isLocked = false;
		this.shapeList = [];
		this.morphCommands = [];
	},
	
	/* --------------- Locking functions ------------------- */
	lockChecking: function(event) {
		this.isLocked = true;
	},
	
	unlockChecking: function(event) {
		this.isLocked = false;
	},
	
	/* --------------- Processing Commands ------------------ */
	queueOnShapeList: function(shapeList) {
		if(this.isLocked 
			|| !shapeList) {
			
			return;
		}
		
		this.shapeList.push(shapeList);
	//	this.isLocked = true;
		
		//if(this.facade.isExecutingCommands()) {
			// Process the connection rule check just after the current
			// command has finished
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAST_EXECUTE_COMMANDS, this.executeCheckingFn);
//		} else {
//			// execute immediately
//			this.executeChecking();
//		}
	},
	
//	unifyShapeList: function(shapeList) {
//		if(!shapeList || shapeList.length == 0) {
//			return;
//		}
//		
//		var processedShapes = new Hash();
//		shapeList.reverse();
//		
//		shapeList.each(function(childShapeList) {
//			childShapeList.each(function(shape, index) {
//				if(processedShapes[shape.getId()]) {
//					childShapeList.splice(index,1);
//				} else {
//					processedShapes[shape.getId()] = true;
//				}
//			});
//		})
//		
//		shapeList.reverse();
//	},
	
	executeChecking: function(event) {
		this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_LAST_EXECUTE_COMMANDS, this.executeCheckingFn);
		
		
		// release lock
		//this.isLocked = false;
		
		if(!this.shapeList) {
			return;
		}
		
		// Remove duplicated event occurrences
		//this.unifyShapeList(this.shapeList);
		var shapeList = this.shapeList.flatten().uniq();
		
//		var shapeList = this.shapeList.pop();
//		if(!shapeList) {
//			return;
//		}
		
//		if(shapeList.first() && shapeList.first() instanceof ORYX.Core.Edge) {
//			// If the shape in question is an edge, take all other edges as well
//			this.shapeList.each(function(list) {
//				list.each(function(shape) {
//					if(shape instanceof ORYX.Core.Edge) {
//						shapeList.push(shape);
//					}
//				})
//			})
//		}
		
		
		
		shapeList.each(this.processSelection.bind(this));
		
		if(this.morphCommands && this.morphCommands.size() > 0) {
				this.facade.executeCommands(this.morphCommands);
		}
		
		this.morphCommands = [];
		this.shapeList = [];
	},
	
	
	/* --------------- Event Handler Start ------------------*/
	
	handleLayoutMessageFlow: function(event) {
		
		var shape = event.shape;
		this.queueOnShapeList([shape]);
	},
	
	handleLayoutSequenceFlow: function(event) {
		
		var shape = event.shape;
		this.queueOnShapeList([shape]);
	},
	
	handleShapeAdded: function(event) {
		
		var shape = event.shape;
		this.queueOnShapeList([shape]);
	},
	
	
	handleDragDockerDocked: function(event) {
		if(this.isLocked) {
			return;
		}
		
		// event.target; -> Task
		// event.parent; -> Sequenceflow
		if(event.parent instanceof ORYX.Core.Edge
			&& (event.parent.getStencil().idWithoutNs() === "SequenceFlow"
				|| event.parent.getStencil().idWithoutNs() === "MessageFlow")) {
			var source = event.parent.getSource();	
			var target = event.parent.getTarget();	
			this.ensureMessageFlowPoolConnectionRule(source, target, event.parent);
		}
	},
	
	handleDragDropEnd: function(event) {
		
		// get selection and check on sequence flows
		var selection = this.facade.getSelection();
		
		if(!selection) {
			return;
		}
		
		this.queueOnShapeList(selection);
	},

	/* ------------ Event Handler End ----------------- */
	
	/**
	 * Is scanning the shapeList on edge shapes and triggers the connection 
	 * rule checking procedure.
	 * 
	 * @param {Object} shapeList
	 */
	checkListOfShapes: function(shapeList) {
		if(!shapeList) {
			return;
		}
		
		shapeList.each(function(shape) {
			// only handle sequence and message flows
			if(shape.getStencil().idWithoutNs() === "SequenceFlow"
				|| shape.getStencil().idWithoutNs() === "MessageFlow") {
				var sourceShape = shape.getSource();
				var targetShape = shape.getTarget();
				this.ensureMessageFlowPoolConnectionRule(sourceShape, targetShape, shape);
			}
		}.bind(this));
	},
	
	
	processSelection: function(select){ 
		// Retrieve the selected sequence flows and check if morphing
		// to a message flow is required
		if(select instanceof ORYX.Core.Edge 
			&& (select.getStencil().idWithoutNs() === "SequenceFlow"
			|| select.getStencil().idWithoutNs() === "MessageFlow")) {
			
			var sourceShape = select.getSource();
			var targetShape = select.getTarget();
			this.ensureMessageFlowPoolConnectionRule(sourceShape, targetShape, select);
		} 
		// check if nodes outgoing or incoming edges
		else if(select instanceof ORYX.Core.Node) {
			this.checkListOfShapes(select.getIncomingShapes());
			this.checkListOfShapes(select.getOutgoingShapes());
		}
	},
	
	isPoolOrLane: function(shape) {
		if(shape.getStencil().idWithoutNs().endsWith("Pool")
			|| shape.getStencil().idWithoutNs().endsWith("Lane")) {
			
			return true;	
		}
		
		return false;	
	},
	
	/**
	 * Returns the proper pool this shape is contained.
	 * @param {Object} shape
	 */
	retrieveParentPool: function(shape) {
		if(!shape) {
			return;
		}
		
		var parent = shape;
		
		while(parent.getParentShape()) {
			parent = parent.getParentShape();
			if(!parent instanceof ORYX.Core.Node 
				|| parent instanceof ORYX.Core.Canvas) {
				return;
			}
			
			if(parent.getStencil().idWithoutNs() === "Pool"
				|| parent.getStencil().idWithoutNs() === "VerticalPool"
				|| parent.getStencil().idWithoutNs() === "CollapsedPool") {
				
				return parent;
			}
		}
	},
	
	/**
	 * Retrieves the container pools of the source and target shape 
	 * respectively. In case their parent containers are different, the 
	 * sequence flow is morphed to a message flow.
	 * 
	 */
	ensureMessageFlowPoolConnectionRule: function(sourceShape, targetShape, edgeShape) {
		if(!sourceShape || !targetShape || !edgeShape
			|| !sourceShape.parent || !targetShape.parent || !edgeShape.parent  
			|| this.isPoolOrLane(targetShape)
			|| this.isPoolOrLane(sourceShape)
			/*|| this.isLocked*/) {
			
			return;
		}
				
		
		
		
		
		// Sequence Flow to Message Flow
		if(edgeShape.getStencil().idWithoutNs() === "SequenceFlow") {
			var sourcePool = this.retrieveParentPool(sourceShape);
			var targetPool = this.retrieveParentPool(targetShape);
			
			// The message flow stencil
			var stencilSet = this.facade.getStencilSets();
			
			if(!stencilSet || (!sourcePool && !targetPool) || sourcePool == targetPool) {
				return;
			}
			
			var msgFlowStencil = stencilSet["http://b3mn.org/stencilset/bpmn2.0#"].stencil("http://b3mn.org/stencilset/bpmn2.0#MessageFlow");
			if(!this.facade.getRules().canConnect({
				sourceShape : sourceShape,
				edgeStencil : msgFlowStencil,
				targetShape : targetShape
			})) {
				return;
			}
			
			var morphCommand = this.morphShape(edgeShape, msgFlowStencil);
			this.morphCommands.push(morphCommand);
			return;
		} 
		
		// Message Flow to Sequence Flow
		else if(edgeShape.getStencil().idWithoutNs() === "MessageFlow") {
			var sourcePool = this.retrieveParentPool(sourceShape);
			var targetPool = this.retrieveParentPool(targetShape);
			
			// The sequence flow stencil
			var stencilSet = this.facade.getStencilSets();
			
			if((sourceShape.parent instanceof ORYX.Core.Canvas && targetShape.parent instanceof ORYX.Core.Canvas) 
				|| ((sourcePool || targetPool) 
				&& (!stencilSet || sourcePool != targetPool))) {
				return;
			}
			
			var seqFlowStencil = stencilSet["http://b3mn.org/stencilset/bpmn2.0#"].stencil("http://b3mn.org/stencilset/bpmn2.0#SequenceFlow");
			
			if(!this.facade.getRules().canConnect({
				sourceShape : sourceShape,
				edgeStencil : seqFlowStencil,
				targetShape : targetShape
			})) {
				return;
			}
			
			var morphCommand = this.morphShape(edgeShape, seqFlowStencil);
			this.morphCommands.push(morphCommand);
			return;
		}
		
	},
	
	
	/**
	 * {Command implemented}
	 * @param {Shape} shape
	 * @param {Stencil} stencil
	 */
	morphShape: function(shape, stencil){
	
		var MorphTo = ORYX.Core.Command.extend({
			construct: function(shape, stencil, facade){
				this.shape = shape;
				this.stencil = stencil;
				this.facade = facade;
				this.removeEdge = [];
				this.reconnectedEdges = [];
				
			},
			execute: function(){
				
					var shape = this.shape;
					
					if(!shape.parent) {return;}
					
					var stencil = this.stencil;
					var resourceId = shape.resourceId;
					shape._update();

					// Serialize all attributes
					var serialized = shape.serialize();
					stencil.properties().each((function(prop) {
						if(prop.readonly()) {
							serialized = serialized.reject(function(serProp) {
								return serProp.name==prop.id();
							});
						}
					}).bind(this));

					// Get shape if already created, otherwise create a new shape
					if (this.newShape){
						newShape = this.newShape;
						this.facade.getCanvas().add(newShape);
					} else {
						newShape = this.facade.createShape({
										type		: stencil.id(),
										namespace	: stencil.namespace(),
										resourceId	: resourceId,
										dontUpdateSelection : true
									});
					}

					// calculate new bounds using old shape's upperLeft and new shape's width/height
					var boundsObj = serialized.find(function(serProp){
						return (serProp.prefix === "oryx" && serProp.name === "bounds");
					});

					var changedBounds = null;

					if(!this.facade.getRules().preserveBounds(shape.getStencil())) {

						var bounds = boundsObj.value.split(",");
						if (parseInt(bounds[0], 10) > parseInt(bounds[2], 10)) { // if lowerRight comes first, swap array items
							var tmp = bounds[0];
							bounds[0] = bounds[2];
							bounds[2] = tmp;
							tmp = bounds[1];
							bounds[1] = bounds[3];
							bounds[3] = tmp;
						}
						bounds[2] = parseInt(bounds[0], 10) + newShape.bounds.width();
						bounds[3] = parseInt(bounds[1], 10) + newShape.bounds.height();
						boundsObj.value = bounds.join(",");

					}  else {

						var height = shape.bounds.height();
						var width  = shape.bounds.width();

						// consider the minimum and maximum size of
						// the new shape

						if (newShape.minimumSize) {
							if (shape.bounds.height() < newShape.minimumSize.height) {
								height = newShape.minimumSize.height;
							}


							if (shape.bounds.width() < newShape.minimumSize.width) {
								width = newShape.minimumSize.width;
							}
						}

						if(newShape.maximumSize) {
							if(shape.bounds.height() > newShape.maximumSize.height) {
								height = newShape.maximumSize.height;
							}	

							if(shape.bounds.width() > newShape.maximumSize.width) {
								width = newShape.maximumSize.width;
							}
						}

						changedBounds = {
							a : {
								x: shape.bounds.a.x,
								y: shape.bounds.a.y
							},
							b : {
								x: shape.bounds.a.x + width,
								y: shape.bounds.a.y + height
							}						
						};

					}

					var oPos = shape.bounds.center();
					if(changedBounds !== null) {
						newShape.bounds.set(changedBounds);
					}

					// Set all related dockers
					this.setRelatedDockers(shape, newShape);

					// store DOM position of old shape
					var parentNode = shape.node.parentNode;
					var nextSibling = shape.node.nextSibling;

					var childShapes = shape.getChildNodes();

					// Delete the old shape
					this.facade.deleteShape(shape);

					// Deserialize the new shape - Set all attributes
					newShape.deserialize(serialized);		
					if(changedBounds !== null) {
						newShape.bounds.set(changedBounds);
					}
					

					if(newShape.getStencil().type()==="edge" || (newShape.dockers.length==0 || !newShape.dockers[0].getDockedShape())) {
						newShape.bounds.centerMoveTo(oPos);
					} 

					if(newShape.getStencil().type()==="node" && (newShape.dockers.length==0 || !newShape.dockers[0].getDockedShape())) {
						this.setRelatedDockers(newShape, newShape);
					}
					
					// Try to append the children to the new shape
					this.resetAllChildShapes(childShapes, newShape);

					// place at the DOM position of the old shape
					if(nextSibling) parentNode.insertBefore(newShape.node, nextSibling);
					else parentNode.appendChild(newShape.node);

					// Set selection
					//this.facade.setSelection([newShape]);
					this.facade.updateSelection();
					newShape.isChanged = true;
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
					this.newShape = newShape;
					newShape._update();

				},
				rollback: function(){

					if (!this.shape || !this.newShape || !this.newShape.parent) {return}

					// Append shape to the parent
					this.newShape.parent.add(this.shape);
									
					// Add child shapes to the new one
					this.newShape.getChildNodes().each(function(s){
						if (this.facade.getRules().canContain({
								containingShape	: this.shape,
								containedShape	: s
							})){
							this.shape.add(s);
						}
					}.bind(this));
					
					
					// Rollback removed edges
					this.removeEdge.each(function(edge){
						this.facade.getCanvas().add(edge);
					}.bind(this));
					
					// Rollback reconnected shapes
					this.reconnectedEdges.each(function(obj){
						obj.docker.setDockedShape(obj.shape);
						obj.docker.setReferencePoint(obj.point);
					}.bind(this))
					
					// Set dockers
					this.setRelatedDockers(this.newShape, this.shape);
					// Delete new shape
					this.facade.deleteShape(this.newShape);
					// Set selection
					//this.facade.setSelection([this.shape]);
					// Update
					//this.facade.getCanvas().update();
					//this.facade.updateSelection();
					this.shape._update();
				},
				getValidChildren: function(children, shape){
					// Add child shapes to the new one
					return children.findAll(function(child){
						return this.facade.getRules().canContain({
								containingShape	: shape instanceof ORYX.Core.Shape ? shape : undefined,
								containingStencil: shape instanceof ORYX.Core.StencilSet.Stencil ? shape : undefined,
								containedShape	: child
							})
					}.bind(this))
				},

				resetAllChildShapes: function(children, newShape){
					// Get valid/invalid child shapes
					var validChildren = this.getValidChildren(children, newShape);
					var invalidChildren = children.without.apply(children, validChildren);
					
					var absoluteUL = newShape.absoluteXY();
					this.reconnectedEdges = [];
								
					// Remove edges
					invalidChildren.each(function(child){
						child.getAllDockedShapes().each(function(edge){
							if (!(edge instanceof ORYX.Core.Edge) || !edge.parent){ return; }
							
							var relatedNode = edge.getSource() === child ? edge.getTarget() : edge.getSource();

							// Try to reconnect outgoing edges to the new shape
							if (relatedNode && !children.include(relatedNode) && this.facade.getRules().canConnect({
										sourceShape		: edge.getSource() === child ? child : relatedNode,
										edgeShape		: edge,
										targetShape		: edge.getTarget() === child ? child : relatedNode
									})){
										
								var docker 	= edge.getSource() === child ? edge.dockers.first() : edge.dockers.last();
								var point 	= Object.clone(docker.getAbsoluteReferencePoint());
								point.x -= absoluteUL.x;
								point.y -= absoluteUL.y;
								
								this.reconnectedEdges.push({
									shape 	: docker.getDockedShape(),
									docker	: docker,
									point	: Object.clone(docker.referencePoint)
								})
								
								docker.setDockedShape(newShape);
								docker.setReferencePoint(point);
								
							// otherwise remove edge
							} else {
								if (!this.removeEdge.include(edge))
									this.removeEdge.push(edge);
								edge.parent.remove(edge);
							}
							
						}.bind(this))
					}.bind(this))
					
					
					// Add to the new shape
					validChildren.each(function(child){
						newShape.add(child);
					})
				},

				/**
				 * Set all incoming and outgoing edges from the shape to the new shape
				 * @param {Shape} shape
				 * @param {Shape} newShape
				 */
				setRelatedDockers: function(shape, newShape){

					if(shape.getStencil().type()==="node") {

						(shape.incoming||[]).concat(shape.outgoing||[])
							.each(function(i) { 
								i.dockers.each(function(docker) {
									if (docker.getDockedShape() == shape) {
										var rPoint = Object.clone(docker.referencePoint);
										// Move reference point per percent

										var rPointNew = {
											x: rPoint.x*newShape.bounds.width()/shape.bounds.width(),
											y: rPoint.y*newShape.bounds.height()/shape.bounds.height()
										};

										docker.setDockedShape(newShape);
										// Set reference point and center to new position
										docker.setReferencePoint(rPointNew);
										if(i instanceof ORYX.Core.Edge) {
											docker.bounds.centerMoveTo(rPointNew);
										} else {
											var absXY = shape.absoluteXY();
											docker.bounds.centerMoveTo({x:rPointNew.x+absXY.x, y:rPointNew.y+absXY.y});
											//docker.bounds.moveBy({x:rPointNew.x-rPoint.x, y:rPointNew.y-rPoint.y});
										}
									}
								});	
							});

						// for attached events
						if(shape.dockers.length>0&&shape.dockers.first().getDockedShape()) {
							newShape.dockers.first().setDockedShape(shape.dockers.first().getDockedShape());
							newShape.dockers.first().setReferencePoint(Object.clone(shape.dockers.first().referencePoint));
						}

					} else { // is edge
						newShape.dockers.first().setDockedShape(shape.dockers.first().getDockedShape());
						newShape.dockers.first().setReferencePoint(shape.dockers.first().referencePoint);
						newShape.dockers.last().setDockedShape(shape.dockers.last().getDockedShape());
						newShape.dockers.last().setReferencePoint(shape.dockers.last().referencePoint);
					}
				}
			});

			var children = shape.getChildNodes();
			var hasInvalidChildren = MorphTo.prototype.getValidChildren.call(this, children, stencil).length !== children.length;
			
			var execute = function(){
				// Create and execute command (for undo/redo)			
				var command = new MorphTo(shape, stencil, this.facade);
				
				return command;
				
			}.bind(this)
			
			if (!hasInvalidChildren) {
				return execute();
			}
	}
};

ORYX.Plugins.BPMN2_0MessageFlow = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN2_0MessageFlow);
}();
/**
 * Copyright (c) 2011
 * Sven Wagner-Boysen
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/
if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/*
 * Plugin to enable editing of BPMN 2.0 Process IDs.
 * 
 * Only consider Processes wrapped by pools:
 *  - create new Process ID only shape creation and copy insertion.
 * 
 */

new function() {
	ORYX.Plugins.BPMN2_0ProcessId = {

			/**
			 *	Constructor
			 *	@param {Object} Facade: The Facade of the Editor
			 */
			construct: function(facade){
				this.facade = facade;
				
				/* Register to shape added to monitor pool */
				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, this.handleShapeAdded.bind(this));
			},
			
			handleShapeAdded: function(event) {
				// VARs
				var shape = event.shape;
				var processId = "";
				
				if(!this.isPool(shape)) {return;}
				
				if(this.facade.isExecutingCommands()) {
					// Create new process ID
					var command =  ORYX.Core.Command.extend({
						construct: function(shape){
							this.shape = shape;
							this.oldProcessId = shape.properties["oryx-processid"];
							this.processId = ( this.oldProcessId ? this.oldProcessId + "_" : "" ) + ORYX.Editor.provideId();
							
						},
						execute: function(){
							this.shape.setProperty("oryx-processid", this.processId);
						},
						
						rollback: function() {
							this.shape.setProperty("oryx-processid", this.oldProcessId);
						}
					});
					
					this.facade.executeCommands([new command(shape)]);
				}
			},
			
			/**
			 * Check if is valid BPMN 2.0 Pool shape of stencil
			 * @param shape
			 * @return true in case of valid BPMN 2.0 Pool
			 */
			isPool: function(shape) {
				var validStencilIds = [
				    "http://b3mn.org/stencilset/bpmn2.0#Pool",
				    "http://b3mn.org/stencilset/bpmn2.0#VerticalPool"
				];
				
				return validStencilIds.include(shape.getStencil().id());
			}
	};
	
	ORYX.Plugins.BPMN2_0ProcessId = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN2_0ProcessId);
}();/**
 * Copyright (c) 2011
 * Willi Tscheschner, Sven Wagner-Boysen
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

new function() {
	ORYX.Plugins.BPMN2_0MoveLaneButtons = ORYX.Plugins.AbstractPlugin.extend({
		/**
		 * Enables overlay buttons to move lanes inside of a pool
		 * @param facade
		 */
		construct: function(facade){
			ORYX.CONFIG.BPMN20_ENABLE_LANE_MOVE_BUTTONS = true;
		}
	});
}();

new function(){
	
	ORYX.Plugins.BPMN2_0PoolLayout = ORYX.Plugins.AbstractPlugin.extend({
	
		/**
		 *	Constructor
		 *	@param {Object} Facade: The Facade of the Editor
		 */
		construct: function(facade){
			this.facade = facade;
			
			this.facade.registerOnEvent('layout.bpmn2_0.pool', this.handleLayoutPool.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.afterLoad.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEREMOVED, this.handleShapeRemove.bind(this));
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_BPMN20_DELETE_HASH, this.deleteHash.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_BPMN20_ADJUST_LANES, this.handleAdjustLanesEvent.bind(this));
			
			this.namespace = undefined;
		},
		
		/**
		 * Force to update every pool
		 */
		afterLoad: function(){
			this.facade.getCanvas().getChildNodes().each(function(shape){
				if (shape.getStencil().id().endsWith("Pool")) {
					var id = shape.getStencil().id();
					this.handleLayoutPool({
						shape: shape,
						orientation: (id.endsWith("VerticalPool") ? "vertical" : "horizontal") 
					});
				}
			}.bind(this));
			
			// Create the buttons to move a lane inside its pool if it the functionality is enabled
			if (ORYX.CONFIG.BPMN20_ENABLE_LANE_MOVE_BUTTONS) {
				this._createMoveButtons();
			}
		},
		
		/**
		 * Deletes the hashed bounds and hashed pool bounds of a given shape and its pool
		 * @param options
		 */
		deleteHash : function(options) {
			var pool = this.getPool(options.shape);
			
			if (this.hashedBounds[pool.id]) {
				if (this.hashedBounds[pool.id][options.shape.id]) {
					this.hashedBounds[pool.id][options.shape.id] = options.shape.absoluteBounds();
				}
				if (this.hashedPoolPositions[pool.id]) {
					this.hashedPoolPositions[pool.id] = pool.bounds.clone();
				}
			}
		},
		
		/**
		 * Adjusts the given lanes inside its parent pool according to the given offset
		 * @param options
		 */
		handleAdjustLanesEvent : function(options) {
			if (!options.shape || !options.offset) return;
			
			var pool = options.pool || this.getPool(options.shape);
			if (!pool) return;
			
			this.adjustLanes(pool, [options.shape], options.offset.x, options.offset.y);
		},
		
		/**
		 * If a pool is selected and contains no lane,
		 * a lane is created automagically
		 */
		onSelectionChanged: function(event) {
			var selection = event.elements;
			
			// If lane buttons are actived, hide the old ones
			if (ORYX.CONFIG.BPMN20_ENABLE_LANE_MOVE_BUTTONS && selection && selection.length !== 1) {
				this.hideMoveButtons();
			}
			
			if(selection && selection.length === 1) {
				var namespace = this.getNamespace();
				var shape = selection[0];
				
				// horizontal orientation
				if(shape.getStencil().idWithoutNs() === "Pool") {
					if(shape.getChildNodes().length === 0) {
						// create a lane inside the selected pool
						var option = {
								type:namespace + "Lane",
								position:{x:0,y:0},
								namespace:shape.getStencil().namespace(),
								parent:shape
						};
						this.facade.createShape(option);
						this.facade.getCanvas().update();
						this.facade.setSelection([shape]);
					}
				}
				
				// vertical orientation
				else if(shape.getStencil().idWithoutNs() === "VerticalPool") {
					if(shape.getChildNodes().length === 0) {
						// create a lane inside the selected pool
						var option = {
								type:namespace + "VerticalLane",
								position:{x:0,y:0},
								namespace:shape.getStencil().namespace(),
								parent:shape
						};
						this.facade.createShape(option);
						this.facade.getCanvas().update();
						this.facade.setSelection([shape]);
					}
				}
				
				// if lane buttons are activated, display the buttons
				if (ORYX.CONFIG.BPMN20_ENABLE_LANE_MOVE_BUTTONS) {
					this.showMoveButtons(shape);
				}
				
			}
			
			// Preventing selection of all lanes but not the pool
			if(selection.any(function(s){ return s instanceof ORYX.Core.Node && s.getStencil().id().endsWith("Lane"); })){
				var lanes = selection.findAll(function(s){
					return s instanceof ORYX.Core.Node && s.getStencil().id().endsWith("Lane");
				});
				
				var pools = [];
				var unselectLanes = [];
				lanes.each(function(lane){
					pools.push(this.getParentPool(lane));
				}.bind(this));
				
				pools = pools.uniq().compact().findAll(function(pool){
					var childLanes = this.getLanes(pool, true);
					if (childLanes.all(function(lane){ return lanes.include(lane); })){
						unselectLanes = unselectLanes.concat(childLanes);
						return true;
					} else if (selection.include(pool) && childLanes.any(function(lane){ return lanes.include(lane); })) {
						unselectLanes = unselectLanes.concat(childLanes);
						return true;
					} else {
						return false;
					}
				}.bind(this));
				
				if (unselectLanes.length > 0 && pools.length > 0){
					selection = selection.without.apply(selection, unselectLanes);
					selection = selection.concat(pools);
					this.facade.setSelection(selection.uniq());
				}
			}
		},
		
		handleShapeRemove: function(option) {
			
			var sh 				= option.shape;
			var parent 			= option.parent;
						
			if (sh instanceof ORYX.Core.Node 
					&& (sh.getStencil().idWithoutNs() === "Lane" || sh.getStencil().idWithoutNs() === "VerticalLane") 
					&& this.facade.isExecutingCommands()) {
			
				var laneStencilId = sh.getStencil().idWithoutNs();
				
				var pool = this.getParentPool(parent);
				if (pool&&pool.parent){		
				
					var isLeafFn = function(leaf){
						return !leaf.getChildNodes().any(function(r){ return r.getStencil().idWithoutNs() === laneStencilId; });
					};
					
					var isLeaf = isLeafFn(sh);
					var parentHasMoreLanes = parent.getChildNodes().any(function(r){ return r.getStencil().idWithoutNs() === laneStencilId; });
					
					if (isLeaf && parentHasMoreLanes){
						
						var command = new ResizeLanesCommand(sh, parent, pool, this);
						this.facade.executeCommands([command]);
						
					} else if(	!isLeaf &&
								!this.facade.getSelection().any(function(select){ // Find one of the selection, which is a lane and child of "sh" and is a leaf lane
										return 	select instanceof ORYX.Core.Node && select.getStencil().idWithoutNs() === laneStencilId &&
												select.isParent(sh) && isLeafFn(select);})) {
													
						var Command = ORYX.Core.Command.extend({
							construct: function(shape, facade, laneStencilId) {
								this.children = shape.getChildNodes(true);
								this.facade = facade;
								if(laneStencilId === "VerticalLane") {
									this.xOff = 0;
									this.yOff = 30;
								} else {
									this.xOff = 30;
									this.yOff = 0;
								}
								
							},
							execute: function() {
								this.children.each(function(child){
									child.bounds.moveBy(this.xOff,this.yOff);
								}.bind(this));
								//this.facade.getCanvas().update();
							},
							rollback: function() {
								this.children.each(function(child){
									child.bounds.moveBy(-this.xOff,-this.yOff);
								}.bind(this));
								//this.facade.getCanvas().update();
							}
						});
						this.facade.executeCommands([new Command(sh, this.facade, laneStencilId)]);
						
					} else if (isLeaf&&!parentHasMoreLanes&&parent == pool){
						parent.add(sh);
					}
				}
			
			}
			
		},
		
		getParentPool: function(shape){
			while(shape && !shape.getStencil().id().endsWith("Pool")){
				if (shape instanceof ORYX.Core.Canvas) {
					return null;
				}
				shape = shape.parent;
			}
			return shape;
		},
		
		hashedPoolPositions : {},
		hashedLaneDepth : {},
		hashedBounds : {},
		hashedPositions: {},
		
		/**
		 * Handler for layouting event 'layout.bpmn2_0.pool'
		 * @param {Object} event
		 */
		handleLayoutPool: function(event){
			
			var pool = event.shape;
			this.orientation = event.orientation;
			
			// horizontal consider height
			if(this.orientation === "horizontal") {
				var shortEdgeFN = "height";
				var longEdgeFN = "width";
			} 
			// vertical consider width
			else if( this.orientation === "vertical" ) {
				var shortEdgeFN = "width";
				var longEdgeFN = "height";
			}
			else {
				return;
			}
			
			var selection = this.facade.getSelection(); 
			var currentShape = selection.include(pool) ? pool : selection.first();
			
			currentShape = currentShape || pool;
			
			this.currentPool = pool;
			
			// Check if currently n undo-command was executing 
			// and a non-pool/lane element is selected
			// Use-Case: Task selected; add a lane; Undo;
			// -> Lane should be removed and the pool updated
			if(!this.facade.isExecutingCommands() && !currentShape.isChanged) {
				currentShape = pool;
			}
			
			// Check if it is a pool or a lane
			if (!(currentShape.getStencil().id().endsWith("Pool") || currentShape.getStencil().id().endsWith("Lane"))) {
				return;
			}
			
			if (!this.hashedBounds[pool.id]) {
				this.hashedBounds[pool.id] = {};
			}
			
			if (currentShape !== pool && !currentShape.isParent(pool) 
				&& !this.hashedBounds[pool.id][currentShape.id]){
				return;
			}
			
			
			
			// Find all child lanes
			var lanes = this.getLanes(pool);
			
			if (lanes.length <= 0) {
				return
			}
			
			var allLanes = this.getLanes(pool, true);
			var considerForDockers = allLanes.clone();
			
			var hashedPositions = $H({});
			allLanes.each(function(lane){
				hashedPositions[lane.id] = lane.bounds.upperLeft();
			});
			
			
			
			// Show/hide caption regarding the number of lanes
			if (lanes.length === 1 && this.getLanes(lanes.first()).length <= 0) {
				// TRUE if there is a caption
				// lanes.first().setProperty("oryx-showcaption", lanes.first().properties["oryx-name"].trim().length > 0);
				lanes.first().setProperty("oryx-showcaption", false);
				
				var lane = lanes.first();
				var caption = lane.properties["oryx-name"];
				if(caption.length > 0 && this.facade.isExecutingCommands()) {
					var removeLableCommand = this.removeLable(caption, lane);
					this.facade.executeCommands([removeLableCommand]);
				}
				
				var rect = lanes.first().node.getElementsByTagName("rect");
				rect[0].setAttributeNS(null, "display", "none");
			} else {
				allLanes.invoke("setProperty", "oryx-showcaption", true);
				allLanes.each(function(lane){
					var rect = lane.node.getElementsByTagName("rect");
					rect[0].removeAttributeNS(null, "display");
				});
			}
			
			var deletedLanes = [];
			var addedLanes = [];
			
			// Get all new lanes
			var i=-1;
			while (++i<allLanes.length) {
				if (!this.hashedBounds[pool.id][allLanes[i].id]){
					addedLanes.push(allLanes[i]);
				}
			}
			
			if (addedLanes.length > 0){
				currentShape = addedLanes.first();
			}
			
			
			// Get all deleted lanes
			var resourceIds = $H(this.hashedBounds[pool.id]).keys();
			var i=-1;
			while (++i<resourceIds.length) {
				if (!allLanes.any(function(lane){ return lane.id == resourceIds[i];})){
					deletedLanes.push(this.hashedBounds[pool.id][resourceIds[i]]);
					selection = selection.without(function(r){ return r.id == resourceIds[i]; });
				}
			}		
			
//			var height, width, x, y;
			var length = {}, x, y;
			
			
			if (deletedLanes.length > 0 || addedLanes.length > 0) {
				
				if (addedLanes.length === 1 && this.getLanes(addedLanes[0].parent).length === 1){
					// Set length of short edge from the pool
					// (horizontal orientation means height, vertical means width)
					length[shortEdgeFN] = this.adjustShortEdge(lanes, addedLanes[0].parent);
				} else {
					// Set short edge from the pool
					length[shortEdgeFN] = this.updateShortLength(pool);
				}
				// Set long edge from the pool
				length[longEdgeFN] = this.adjustLongEdge(lanes, pool.bounds[longEdgeFN]());	
				
				//pool._update();
			}
			
			/**
			 * Set width/height depending on the pool
			 */
			else if (pool == currentShape) {
				
				if (selection.length === 1 && this.isResized(pool, this.hashedPoolPositions[pool.id])) {
					var oldXY = this.hashedPoolPositions[pool.id].upperLeft();
					var xy = pool.bounds.upperLeft();
					var scale = 0;
					if (this.shouldScale(pool)){
						var old = this.hashedPoolPositions[pool.id];
						scale = old[shortEdgeFN]()/pool.bounds[shortEdgeFN]();
					}
				
					this.adjustLanes(pool, allLanes, oldXY.x - xy.x, oldXY.y - xy.y, scale);
				}
				
				// Set short edge from the pool
				length[shortEdgeFN] = this.adjustShortEdge(lanes, undefined, pool.bounds[shortEdgeFN]());
				// Set long side edge from the pool
				length[longEdgeFN] = this.adjustLongEdge(lanes, pool.bounds[longEdgeFN]());		
			}
			
			/**?
			 * Set width/height depending on containing lanes
			 */		
			else {
				
				// Reposition the pool if one shape is selected and the upperleft has changed
				if (selection.length === 1 && this.isResized(currentShape, this.hashedBounds[pool.id][currentShape.id])){
					var oldXY = this.hashedBounds[pool.id][currentShape.id].upperLeft();
					var xy = currentShape.absoluteXY();
					x = oldXY.x - xy.x;
					y = oldXY.y - xy.y;
					
					// Adjust all other lanes beneath this lane
					if (x||y){
						considerForDockers = considerForDockers.without(currentShape);
						this.adjustLanes(pool, this.getAllExcludedLanes(pool, currentShape), x, 0);
					}
					
					// Adjust all child lanes
					var childLanes = this.getLanes(currentShape, true);
					if (childLanes.length > 0){
						if (this.shouldScale(currentShape)){
							var old = this.hashedBounds[pool.id][currentShape.id];
							var scale = old[shortEdgeFN]()/currentShape.bounds[shortEdgeFN]();
							this.adjustLanes(pool, childLanes, x, y, scale);
						} else {
							this.adjustLanes(pool, childLanes, x, y, 0);
						}
					}
				}
				
				// Cache all bounds
				var changes = allLanes.map(function(lane){ 
					return {
						shape: lane,
						bounds: lane.bounds.clone()
					}; 
				});
				
				// Get shorter edges' length and adjust child elements
				length[shortEdgeFN] = this.adjustShortEdge(lanes, currentShape);
				// Check if something has changed and maybe create a command
				this.checkForChanges(allLanes, changes);
				
				// Set longer edges' length from the current shape
				length[longEdgeFN] = this.adjustLongEdge(lanes, currentShape.bounds[longEdgeFN]()+(this.getDepth(currentShape,pool)*30));
			}
			
			this.setDimensions(pool, length["width"], length["height"], x, y);
			
			
			if (this.facade.isExecutingCommands() && (deletedLanes.length === 0 || addedLanes.length !== 0)){ 
				// Update all dockers
				this.updateDockers(considerForDockers, pool);
				
				// Check if the order has changed
				if (this.hashedPositions[pool.id] && this.hashedPositions[pool.id].keys().any(function(key, i){
						return (allLanes[i]||{}).id	!== key;
					})){
					
					var LanesHasBeenReordered = ORYX.Core.Command.extend({
						construct: function(originPosition, newPosition, lanes, plugin, poolId) {
							this.originPosition = Object.clone(originPosition);
							this.newPosition = Object.clone(newPosition);
							this.lanes = lanes;
							this.plugin = plugin;
							this.pool = poolId;
						}, 
						execute: function(){
							if (!this.executed){
								this.executed = true;
								this.lanes.each(function(lane){
									if (this.newPosition[lane.id])
										lane.bounds.moveTo(this.newPosition[lane.id]);
								}.bind(this));
								this.plugin.hashedPositions[this.pool] = Object.clone(this.newPosition);
							}
						}, 
						rollback: function(){
							this.lanes.each(function(lane){
								if (this.originPosition[lane.id])
									lane.bounds.moveTo(this.originPosition[lane.id]);
							}.bind(this));
							this.plugin.hashedPositions[this.pool] = Object.clone(this.originPosition);
						}
					});
					
					var hp2 = $H({});
					allLanes.each(function(lane){
						hp2[lane.id] = lane.bounds.upperLeft();
					});
				
					var command = new LanesHasBeenReordered(hashedPositions, hp2, allLanes, this, pool.id);
					this.facade.executeCommands([command]);
						
				}
			}
			
			this.hashedBounds[pool.id] = {};
			this.hashedPositions[pool.id] = hashedPositions;
			
			var i=-1;
			while (++i < allLanes.length) {
				// Cache positions
				this.hashedBounds[pool.id][allLanes[i].id] = allLanes[i].absoluteBounds();
				
				// Cache also the bounds of child shapes, mainly for child subprocesses
				this.hashChildShapes(allLanes[i]);
			
				this.hashedLaneDepth[allLanes[i].id] = this.getDepth(allLanes[i], pool);
				
				this.forceToUpdateLane(allLanes[i]);
			}
			
			this.hashedPoolPositions[pool.id] = pool.bounds.clone();
			
			
			// Update selection
			//this.facade.setSelection(selection);		
		},
		
		/**
		 * Horizontal lanes: adjusts the height
		 * Vertical lanes adjusts the width
		 * 
		 * @param lanes
		 * @param changedLane
		 * @param propagateLength
		 * @returns {Number}
		 */
		adjustShortEdge: function(lanes, changedLane, propagateLength){
			
			var oldLength = 0;
			var cb = {};
			
			// horizontal consider height
			if(this.orientation === "horizontal") {
				var lengthFN = "height";
			} 
			// vertical consider width
			else if( this.orientation === "vertical" ) {
				var lengthFN = "width";
			}
			else {
				return;
			}
			
			
			if (!changedLane && propagateLength){
				var i=-1;
				while (++i<lanes.length){	
					oldLength += lanes[i].bounds[lengthFN]();
				}
			}
			
			var i=-1;
			var length = {};
			length["width"] = 0;
			length["height"] = 0;
			
			var captionOffset = {};
			captionOffset["width"] = 30;
			captionOffset["height"] = 30;
			captionOffset[lengthFN] = 0;
			
			// Iterate trough every lane
			while (++i<lanes.length){
				
				if (lanes[i] === changedLane) {
					// Propagate new height down to the children
					this.adjustShortEdge(this.getLanes(lanes[i]), undefined, lanes[i].bounds[lengthFN]());
					
					var ul = {
						x:captionOffset["width"] + length["width"], 
						y:captionOffset["height"] + length["height"]
					}; 
					
					var lr = {
						x:lanes[i].bounds.width() + captionOffset["width"] + length["width"], 
						y:lanes[i].bounds.height() + captionOffset["height"] + length["height"]
					};
					
					lanes[i].bounds.set(ul, lr);
									
				} else if (!changedLane && propagateLength) {
					
					var tempLength = (lanes[i].bounds[lengthFN]() * propagateLength) / oldLength;
					// Propagate length
					this.adjustShortEdge(this.getLanes(lanes[i]), undefined, tempLength);
					// Set length propotional to the propagated and old length
					this.setDimensions(lanes[i], (lengthFN === "width" ? tempLength : null), (lengthFN === "height" ? tempLength : null));
					this.setLanePosition(lanes[i], length[lengthFN]);
				} else {
					// Get length from children
					var tempLength = this.adjustShortEdge(this.getLanes(lanes[i]), changedLane, propagateLength);
					if (!tempLength) {
						tempLength = lanes[i].bounds[lengthFN]();
					}
					this.setDimensions(lanes[i], (lengthFN === "width" ? tempLength : null), (lengthFN === "height" ? tempLength : null));
					this.setLanePosition(lanes[i], length[lengthFN]);
				}
				
				length[lengthFN] += lanes[i].bounds[lengthFN]();
			}
			
			return length[lengthFN];
		},
		
		setDimensions: function(shape, width, height, x, y){
			var isLane = shape.getStencil().id().endsWith("Lane");
			
			if(this.orientation === "horizontal") {
				var ul = {
					x: isLane ? 30 : (shape.bounds.a.x - (x || 0)), 
					y: isLane ? shape.bounds.a.y : (shape.bounds.a.y - (y || 0))
				};
				
				var lr = {
					x: width	? shape.bounds.a.x + width - (isLane?30:(x||0)) : shape.bounds.b.x, 
					y: height 	? shape.bounds.a.y + height - (isLane?0:(y||0)) : shape.bounds.b.y	
				};
			} 
			
			else if(this.orientation === "vertical") {
				var ul = {
					x: isLane ? shape.bounds.a.x : (shape.bounds.a.x - (x || 0)),
					y: isLane ? 30 : (shape.bounds.a.y - (y || 0))
				};
				
				var lr = {
					x: width	? shape.bounds.a.x + width - (isLane?0:(x||0)) : shape.bounds.b.x,
					y: height	? shape.bounds.a.y + height - (isLane?30:(y||0)) : shape.bounds.b.y
				};
			}
			
			else {
				// undefined behavior
				return;
			}
			
			// Set the bounds
			shape.bounds.set(ul, lr);
		},
		
		/**
		 * Positioning of a lane element depending on orientation of the parent
		 * pool.
		 */
		setLanePosition: function(shape, length){
			
			if(this.orientation === "horizontal") {
				shape.bounds.moveTo(30, length);
			}
			
			else if(this.orientation === "vertical") {
				shape.bounds.moveTo(length, 30);
			}
		
		},
		
		/**
		 * Calculation of the long edge of the pool or lane resprectively
		 * 
		 * horizontal orientation means considering width
		 * vertical orientation means considering height
		 * 
		 * @param lanes
		 * @param width
		 * @returns
		 */
		adjustLongEdge: function(lanes, length) {
			
			// Set long side edges' length to each lane
			(lanes||[]).each(function(lane){
				if(this.orientation === "horizontal") {
					this.setDimensions(lane, length);
					this.adjustLongEdge(this.getLanes(lane), length - 30);
				} 
				
				else if(this.orientation === "vertical") {
					this.setDimensions(lane, null, length);
					this.adjustLongEdge(this.getLanes(lane), length - 30);
				}
			}.bind(this));
			
			return length;
		},
		
		isResized: function(shape, bounds){
			
			if (!bounds||!shape){
				return false;
			}
			
			var oldB = bounds;
			
			return Math.round(oldB.width() - shape.bounds.width()) !== 0 || Math.round(oldB.height() - shape.bounds.height()) !== 0;
		},
		
		shouldScale: function(element){
			var childLanes = element.getChildNodes().findAll(function(shape){ return shape.getStencil().id().endsWith("Lane"); });
			return childLanes.length > 1 || childLanes.any(function(lane){ return this.shouldScale(lane); }.bind(this)); 
		},
		
		adjustLanes: function(pool, lanes, x, y, scale) {
			
			scale = scale || 0;
	
			// For every lane, adjust the child nodes with the offset
			
			if(this.orientation === "horizontal") {
				lanes.each(function(l){
					l.getChildNodes().each(function(child){
						if (!child.getStencil().id().endsWith("Lane")){
							var cy = scale ? child.bounds.center().y - (child.bounds.center().y/scale) : -y;
							child.bounds.moveBy((x||0), -cy);
							
							if (scale&&child.getStencil().id().endsWith("Subprocess")) {
								this.moveChildDockers(child, {x:(0), y:-cy});
							}
							
						}
					}.bind(this));
					this.hashedBounds[pool.id][l.id].moveBy(-(x||0), !scale?-y:0);
					if (scale) {
						l.isScaled = true;
					}
				}.bind(this));
			}
			
			else if(this.orientation === "vertical") {
				lanes.each(function(l){
					l.getChildNodes().each(function(child){
						if (!child.getStencil().id().endsWith("Lane")){
							var cx = scale ? child.bounds.center().x - (child.bounds.center().x/scale) : -x;
							child.bounds.moveBy(-cx, (y||0));
							
							if (scale&&child.getStencil().id().endsWith("Subprocess")) {
								this.moveChildDockers(child, {x:-cx, y:0});
							}
							
						}
					}.bind(this));
					this.hashedBounds[pool.id][l.id].moveBy(!scale?-x:0, -(y||0));
					if (scale) {
						l.isScaled = true;
					}
				}.bind(this));
			}
		},
		
		getAllExcludedLanes: function(parent, lane){
			var lanes = [];
			parent.getChildNodes().each(function(shape){
				if ((!lane || shape !== lane) && shape.getStencil().id().endsWith("Lane")){
					lanes.push(shape);
					lanes = lanes.concat(this.getAllExcludedLanes(shape, lane));
				}
			}.bind(this));
			return lanes;
		},
		
		getDepth: function(child, parent){
			
			var i=0;
			while(child && child.parent && child !== parent){
				child = child.parent;
				++i;
			}
			return i;
		},
		
		updateDockers: function(lanes, pool){
			
			var absPool = pool.absoluteBounds(), movedShapes = [];
			var oldPool = (this.hashedPoolPositions[pool.id]||absPool).clone();
			
			var i=-1, j=-1, k=-1, l=-1, docker;
			var dockers = {};
			
			while (++i < lanes.length) {
				
				if (!this.hashedBounds[pool.id][lanes[i].id]) {
					continue;
				}
				
				var isScaled = lanes[i].isScaled;
				delete lanes[i].isScaled;
				var children = lanes[i].getChildNodes();
				var absBounds = lanes[i].absoluteBounds();
				var oldBounds = (this.hashedBounds[pool.id][lanes[i].id]||absBounds);
				//oldBounds.moveBy((absBounds.upperLeft().x-lanes[i].bounds.upperLeft().x), (absBounds.upperLeft().y-lanes[i].bounds.upperLeft().y));
				var offset = this.getOffset(lanes[i], true, pool);
				var xOffsetDepth = 0;
				var yOffsetDepth = 0;
	
				var depth = this.getDepth(lanes[i], pool);
				if ( this.hashedLaneDepth[lanes[i].id] !== undefined &&  this.hashedLaneDepth[lanes[i].id] !== depth) {
					if(this.orientation === "horizontal") {
						xOffsetDepth = (this.hashedLaneDepth[lanes[i].id] - depth) * 30;
						offset.x += xOffsetDepth;
					} else if( this.orientation === "vertical") {
						yOffsetDepth = (this.hashedLaneDepth[lanes[i].id] - depth) * 30;
						offset.y += yOffsetDepth;
					}
				}
				
				j=-1;
				
				while (++j < children.length) {
					
					if ((xOffsetDepth || yOffsetDepth) && !children[j].getStencil().id().endsWith("Lane")) {
						movedShapes.push({xOffsetDepth:xOffsetDepth, yOffsetDepth:yOffsetDepth, shape: children[j]});
						children[j].bounds.moveBy(xOffsetDepth, yOffsetDepth);							
					}
					
					if (children[j].getStencil().id().endsWith("Subprocess")) {
						this.moveChildDockers(children[j], offset);
					}
					
					var edges = [].concat(children[j].getIncomingShapes())
						.concat(children[j].getOutgoingShapes())
						// Remove all edges which are included in the selection from the list
						.findAll(function(r){ return r instanceof ORYX.Core.Edge; });
	
					k=-1;
					while (++k < edges.length) {			
						
						if (edges[k].getStencil().id().endsWith("MessageFlow")) {
							this.layoutEdges(children[j], [edges[k]], offset);
							continue;
						}
						
						l=-1;
						while (++l < edges[k].dockers.length) {
							
							docker = edges[k].dockers[l];
							
							if (docker.getDockedShape()||docker.isChanged){
								continue;
							}
						
						
							pos = docker.bounds.center();
							
							// Check if the modified center included the new position
							var isOverLane = oldBounds.isIncluded(pos);
							// Check if the original center is over the pool
							var isOutSidePool = !oldPool.isIncluded(pos);
							var previousIsOverLane = l == 0 ? isOverLane : oldBounds.isIncluded(edges[k].dockers[l-1].bounds.center());
							var nextIsOverLane = l == edges[k].dockers.length-1 ? isOverLane : oldBounds.isIncluded(edges[k].dockers[l+1].bounds.center());
							var off = Object.clone(offset);
							
							// If the 
							if (isScaled && isOverLane && this.isResized(lanes[i], this.hashedBounds[pool.id][lanes[i].id])){
								if(this.orientation === "horizontal") {
									var relY = (pos.y - absBounds.upperLeft().y + off.y);
									off.y -= (relY - (relY * (absBounds.height()/oldBounds.height()))); 
								}
								
								else if(this.orientation === "vertical") {
									var relX = (pos.x - absBounds.upperLeft().x + off.x);
									off.x -= (relX - (relX * (absBounds.width()/oldBounds.width()))); 
								}
							}
							
							// Check if the previous dockers docked shape is from this lane
							// Otherwise, check if the docker is over the lane OR is outside the lane 
							// but the previous/next was over this lane
							if (isOverLane){
								dockers[docker.id] = {docker: docker, offset:off};
							} 
							/*else if (l == 1 && edges[k].dockers.length>2 && edges[k].dockers[l-1].isDocked()){
								var dockedLane = this.getNextLane(edges[k].dockers[l-1].getDockedShape());
								if (dockedLane != lanes[i])
									continue;
								dockers[docker.id] = {docker: docker, offset:offset};
							}
							// Check if the next dockers docked shape is from this lane
							else if (l == edges[k].dockers.length-2 && edges[k].dockers.length>2 && edges[k].dockers[l+1].isDocked()){
								var dockedLane = this.getNextLane(edges[k].dockers[l+1].getDockedShape());
								if (dockedLane != lanes[i])
									continue;
								dockers[docker.id] = {docker: docker, offset:offset};
							}
													
							else if (isOutSidePool) {
								dockers[docker.id] = {docker: docker, offset:this.getOffset(lanes[i], true, pool)};
							}*/
							
						
						}
					}
							
				}
			}
			
			// Move the moved children 
			var MoveChildCommand = ORYX.Core.Command.extend({
				construct: function(state){
					this.state = state;
				},
				execute: function(){
					if (this.executed){
						this.state.each(function(s){
							s.shape.bounds.moveBy((s.xOffset||0) , (s.yOffset||0));
						});
					}
					this.executed = true;
				}, 
				rollback: function(){
					this.state.each(function(s){
						s.shape.bounds.moveBy(-(s.xOffset||0), (-s.yOffset||0));
					});
				}
			});
			
			
			// Set dockers
			this.facade.executeCommands([new ORYX.Core.MoveDockersCommand(dockers), new MoveChildCommand(movedShapes)]);
	
		},
		
		getOffset: function(lane, includePool, pool){
			
			var offset = {x:0,y:0};
			
			var offset = lane.absoluteXY();
			
			var hashed = this.hashedBounds[pool.id][lane.id] ||(includePool === true ? this.hashedPoolPositions[lane.id] : undefined);
			if (hashed) {
				offset.x -= hashed.upperLeft().x; 	
				offset.y -= hashed.upperLeft().y;		
			} else {
				return {x:0,y:0};
			}		
			return offset;
		},
		
		moveChildDockers: function(shape, offset){
			
			if (!offset.x && !offset.y) {
				return;
			} 
			
			var children = shape.getChildNodes(true);
			
			// Get all nodes
			var dockers = children
				// Get all incoming and outgoing edges
				.map(function(node){
					return [].concat(node.getIncomingShapes())
							.concat(node.getOutgoingShapes());
				})
				// Flatten all including arrays into one
				.flatten()
				// Get every edge only once
				.uniq()
				// Get all dockers
				.map(function(edge){
					return edge.dockers.length > 2 ? 
							edge.dockers.slice(1, edge.dockers.length-1) : 
							[];
				})
				// Flatten the dockers lists
				.flatten();
	
			var abs = shape.absoluteBounds();
			abs.moveBy(-offset.x, -offset.y);
			var obj = {};
			dockers.each(function(docker){
				
				if (docker.isChanged){
					return;
				}
				
				var off = Object.clone(offset);
				
				if (!abs.isIncluded(docker.bounds.center())){
					var index 	= docker.parent.dockers.indexOf(docker);
					var size	= docker.parent.dockers.length;
					var from 	= docker.parent.getSource();
					var to 		= docker.parent.getTarget();
					
					var bothAreIncluded = children.include(from) && children.include(to);
					
					if (!bothAreIncluded){
						var previousIsOver = index !== 0 ? abs.isIncluded(docker.parent.dockers[index-1].bounds.center()) : false;
						var nextIsOver = index !== size-1 ? abs.isIncluded(docker.parent.dockers[index+1].bounds.center()) : false;
						
						if (!previousIsOver && !nextIsOver){ return; }
						
						var ref = docker.parent.dockers[previousIsOver ? index-1 : index+1];
						if (Math.abs(-Math.abs(ref.bounds.center().x-docker.bounds.center().x)) < 2){
							off.y = 0;
						} else if(Math.abs(-Math.abs(ref.bounds.center().y-docker.bounds.center().y)) < 2){
							off.x = 0;
						} else {
							return;
						}
					}
					
				}
				
				obj[docker.getId()] = {
					docker:docker,
					offset:off
				};
			});
			
			// Set dockers
			this.facade.executeCommands([new ORYX.Core.MoveDockersCommand(obj)]);
				
		},
		
		/**
		 * Displays buttons rendered to the given shape to move the lane inside it's pool.
		 * @param {ORYX.Core.Shape} shape Preferably a Lane
		 */
		showMoveButtons : function(shape) {
			// Hide any existing move buttons
			this.hideMoveButtons();
			
			// If the selected shape is no lane, do nothing
			if (!(shape instanceof ORYX.Core.Node) || !["VerticalLane", "Lane"].include(shape.getStencil().idWithoutNs())) {
				return;
			}
			
			// The parent shape of the lane
			var parent = shape.parent;
			// If no parent exists or the parent is the canvas, show no move buttons
			if (!parent || parent instanceof ORYX.Core.Canvas) {
				return;
			}
			
			var allLanes = this.getLanes(this.getPool(shape), true);
			var currentOverallIndex = allLanes.indexOf(shape);
			// Get the sibling lanes of the current selection in order
			var orderedLanes = this.getLanes(parent);
			// The index of the currently selected lane
			var currentLaneIndex = orderedLanes.indexOf(shape);
			// the Lane above/left
			var pre = orderedLanes[currentLaneIndex - 1];
			// the Lane below/right
			var post = orderedLanes[currentLaneIndex + 1];
			
			// Get the zoom level
			var zoomLevel = this.facade.getCanvas().zoomLevel;
			
			// Get the bounds of the selected lane
			var bounds = shape.absoluteBounds();
			var ul = bounds.upperLeft();
			var lr = bounds.lowerRight();
			
			/* Move the lane up			(right)
			 *\ / \						--->
			 *   |
			 *   |
			 *   |
			 */
			if (pre) {
				var btn = this.moveButtons[(this.orientation === "horizontal" ? "up" : "left")];
				
				var position = {
						x	: (ul.x * zoomLevel),
						y	: (ul.y * zoomLevel)
				};
				
				btn.setDescription(ORYX.I18N.PoolLaneHandling.buttonSwitch);
				this.showButton(btn, "pre", shape, parent, pre, position);
				
				var preLanes = this.getLanes(pre);
				
				/* Move the lane up and indent	(right and indent)
				 * +--->						---+
				 * |							   |
				 * |							   |
				 * |							   |
				 * 								  \ /
				 */
				if ((preLanes||[]).length > 0) {
					var iBtn = this.moveButtons[(this.orientation === "horizontal" ? "right" : "down")];
					
					var target = preLanes.last();
					
					var iPos = {
							x	: (this.orientation === "horizontal" ? position.x + 20 : position.x) * zoomLevel,
							y	: (this.orientation === "horizontal" ? position.y : position.y + 20) * zoomLevel
					};
					
					iBtn.setDescription(ORYX.I18N.PoolLaneHandling.buttonIndent);
					this.showButton(iBtn, "pre", shape, target.parent, undefined, iPos);
				}
			}
			/* Move the lane up and outdent 	(right and outdent)
			 * <---+							   / \
			 *     |								|
			 *     |								|
			 *     |								|
			 *     								 ---+
			 */
			else if (!(parent.parent instanceof ORYX.Core.Canvas)) {
				var btn = this.moveButtons[(this.orientation === "horizontal" ? "left" : "up")];
				
				var position = {
						x	: (this.orientation === "horizontal" ? ul.x : ul.x) * zoomLevel,
						y	: (this.orientation === "horizontal" ? ul.y : ul.y) * zoomLevel
				};
				
				var adjustLane = {
						x	: (this.orientation === "horizontal" ? 0 : -1),
						y	: (this.orientation === "horizontal" ? -1 : 0)
				};
				
				btn.setDescription(ORYX.I18N.PoolLaneHandling.buttonOutdent);
				this.showButton(btn, "pre", shape, parent.parent, undefined, position, adjustLane);
			}
			
			/* Move the lane down				(left)
			 * |								<---
			 * |
			 * |
			 *\ / 
			 */
			if (post) {
				var btn = this.moveButtons[(this.orientation === "horizontal" ? "down" : "right")];
				
				var position = {
						x	: (this.orientation === "horizontal" ? ul.x : lr.x - 29) * zoomLevel,
						y	: (this.orientation === "horizontal" ? lr.y - 29 : ul.y) * zoomLevel
				};
				
				btn.setDescription(ORYX.I18N.PoolLaneHandling.buttonSwitch);
				this.showButton(btn, "post", shape, parent, post, position);
				
				var postLanes = this.getLanes(post);
				/* Move the lane down and indent	(left and indent)
				 * |								+---
				 * |								|
				 * |								|
				 * +--->							|
				 * 								   \ /
				 */
				if ((postLanes||[]).length > 0) {
					var iBtn = this.moveButtons[(this.orientation === "horizontal" ? "right" : "down")];
					
					var target = postLanes.first();
					
					var iPos = {
							x	: (this.orientation === "horizontal" ? position.x + 20 : position.x) * zoomLevel,
							y	: (this.orientation === "horizontal" ? position.y : position.y + 20) * zoomLevel
					};
					
					iBtn.setDescription(ORYX.I18N.PoolLaneHandling.buttonIndent);
					this.showButton(iBtn, "post", shape, target.parent, undefined, iPos);
				}
			}
			/* Move the lane down and outdent		(left and outdent)
			 *     |								/ \
			 *     |								 |
			 *     |								 |
			 * <---+								 |
			 * 										 +---
			 */
			else if (!(parent.parent instanceof ORYX.Core.Canvas)) {
				var btn = this.moveButtons[(this.orientation === "horizontal" ? "left" : "up")];
				
				var position = {
						x	: (this.orientation === "horizontal" ? ul.x : lr.x - 29) * zoomLevel,
						y	: (this.orientation === "horizontal" ? lr.y - 29 : ul.y) * zoomLevel
				};
				
				btn.setDescription(ORYX.I18N.PoolLaneHandling.buttonOutdent);
				this.showButton(btn, "post", shape, parent.parent, undefined, position);
			}

		},
		
		/**
		 * Displays the given MoveLaneButton and sets the callback
		 * @param {ORYX.Plugins.ShapeMenuButton} button
		 * @param {String} direction [pre, post]
		 * @param {ORYX.Core.Shape} moveShape The Lane which shall be moved
		 * @param {ORYX.Core.Shape} targetParent The target container for the Lane
		 * @param {ORYX.Core.Shape} targetShape The adjacent Lane
		 * @param {Point} displayPosition The position to display the button
		 */
		showButton : function(button, direction, moveShape, targetParent, targetShape, displayPosition, adjustLane) {
			if (!button || !displayPosition || !moveShape) {
				return;
			}
			
			button.clb = this.moveLane.bind(this, {
				moveShape	: moveShape,
				targetParent: targetParent,
				targetShape	: targetShape,
				horizontal	: this.orientation === "horizontal",
				adjustLane	: adjustLane,
				direction	: direction
			});
			
			button.setPosition(displayPosition.x, displayPosition.y);
			button.setLevel(0);
			button.show();
		},
		
		
		moveLane : function(options) {
			if (!options) return;
			
			if (options.targetShape) {
				var bounds;
				if (options.direction === "pre") {
					bounds = options.targetShape.bounds;
				} else {
					bounds = options.moveShape.bounds;
				}

				var moveDistance = (options.horizontal ? bounds.height() : bounds.width()) + 1;
				if (options.direction === "pre") {
					moveDistance *= -1;
				}
			}
			
			var moveCoordinates = {
					x	: (options.horizontal ? 0 : (moveDistance||0)),
					y	: (options.horizontal ? (moveDistance||0) : 0)
			};
			
			if (options.adjustLane && "number" === typeof options.adjustLane.x && "number" === typeof options.adjustLane.y) {
				moveCoordinates.x += options.adjustLane.x;
				moveCoordinates.y += options.adjustLane.y;
			}
			
			this.facade.executeCommands([
			                             new ORYX.Core.Command.Move([options.moveShape], moveCoordinates, options.targetParent, [options.moveShape], this),
			                             new ORYX.Core.EnsureChildCommand(this.facade, [options.targetParent])
			                             ]);
		},
		
		
		/**
		 * Hides all move buttons
		 */
		hideMoveButtons : function() {
			if (this.moveButtons) {
				$H(this.moveButtons).values().invoke("hide");
			} 
		},
		
		/**
		 * Lookup if some bounds has changed
		 * @param {Object} lanes
		 * @param {Object} changes
		 */
		checkForChanges: function(lanes, changes) {
			// Check if something has changed
			if (this.facade.isExecutingCommands() && changes.any(function(change){
				return change.shape.bounds.toString() !== change.bounds.toString();
			})){
				
				var Command = ORYX.Core.Command.extend({
							construct: function(changes) {
								this.oldState = changes;
								this.newState = changes.map(function(s){ return {shape:s.shape, bounds:s.bounds.clone()};});
							}, 
							execute: function(){
								if (this.executed){
									this.applyState(this.newState);
								}
								this.executed = true;
							}, 
							rollback: function(){
								this.applyState(this.oldState);
							},
							applyState: function(state){
								state.each(function(s){
									s.shape.bounds.set(s.bounds.upperLeft(), s.bounds.lowerRight());
								});
							}
						});
						
				this.facade.executeCommands([new Command(changes)]);
			}
		},
		
		forceToUpdateLane: function(lane){
			
			if(this.orientation === "horizontal") {
				if (lane.bounds.height() !== lane._svgShapes[0].height) {	
					lane.isChanged = true;
					lane.isResized = true;
					lane._update();
				}
			}
			
			else if(this.orientation === "vertical") {
				if (lane.bounds.width() !== lane._svgShapes[0].width) {	
					lane.isChanged = true;
					lane.isResized = true;
					lane._update();
				}
			}
		},
		
		/**
		 * {Command implemented}
		 * 
		 * Command to remove/restore the lable if there is only one lane left.
		 * 
		 * @param {String} oldcaption
		 * @param {Shape} lane
		 */
		removeLable: function(oldcaption, lane){
		
			var RemoveLable = ORYX.Core.Command.extend({
				construct: function(oldcaption, lane, facade){
					this.lane = lane;
					this.oldcaption = oldcaption;
					this.facade = facade;
				},
				execute: function(){
					this.lane.setProperty("oryx-name", "");
				},
				rollback: function() {
					this.lane.setProperty("oryx-name", this.oldcaption);
				}
			});
			
			return new RemoveLable(oldcaption, lane, this.facade);
		},
		
		/**
		 * Returns a set on all child lanes for the given Shape. If recursive is TRUE, also indirect children will be returned (default is FALSE)
		 * The set is sorted by
		 * 		- (Orientation: horizontal): first child has the lowest y-coordinate and the last one the highest.
		 * 		- (Orientation: vertical): first child has the lowest x-coordinate and the last one the highest.
		 * @param {ORYX.Core.Shape} shape
		 * @param {boolean} recursive
		 */
		getLanes: function(shape, recursive){
			var namespace = this.getNamespace();
			
			// Determine coordinate and side according to the pool orientation
			if(this.orientation === "horizontal") {
				var coord = "y";
				var lengthFN = "height";
				var laneStencilId = "Lane";
			}
			
			else if(this.orientation === "vertical") {
				var coord = "x";
				var lengthFN = "width";
				var laneStencilId = "VerticalLane";
			}
			
			// Get all the child lanes
			var lanes = shape.getChildNodes(recursive||false).findAll(function(node) { return (node.getStencil().id() === namespace + laneStencilId); });
			
			
			
			// Sort all lanes by there y coordinate
			lanes = lanes.sort(function(a, b){
				
				// Get y coordinates for upper left and lower right
				var auy = Math.round(a.bounds.upperLeft()[coord]);
				var buy = Math.round(b.bounds.upperLeft()[coord]);
				var aly = Math.round(a.bounds.lowerRight()[coord]);
				var bly = Math.round(b.bounds.lowerRight()[coord]);
				
				var ha	= this.getHashedBounds(a);
				var hb	= this.getHashedBounds(b);
				
				// Get the old y coordinates
				var oauy = Math.round(ha.upperLeft()[coord]);
				var obuy = Math.round(hb.upperLeft()[coord]);
				var oaly = Math.round(ha.lowerRight()[coord]);
				var obly = Math.round(hb.lowerRight()[coord]);
				
				// If equal, than use the old one
				if (auy == buy && aly == bly) {
					auy = oauy; buy = obuy; aly = oaly; bly = obly;
				}
				
				if (Math.round(a.bounds[lengthFN]()-ha[lengthFN]()) === 0 && Math.round(b.bounds[lengthFN]()-hb[lengthFN]()) === 0){
					return auy < buy ? -1 : (auy > buy ? 1: 0);
				}
				
				// Check if upper left and lower right is completely above/below
				var above = auy < buy && aly < bly;
				var below = auy > buy && aly > bly;
				// Check if a is above b including the old values
				var slightlyAboveBottom = auy < buy && aly >= bly && oaly < obly;
				var slightlyAboveTop = auy >= buy && aly < bly && oauy < obuy;
				// Check if a is below b including the old values
				var slightlyBelowBottom = auy > buy && aly <= bly && oaly > obly;
				var slightlyBelowTop = auy <= buy && aly > bly && oauy > obuy;
				
				// Return -1 if a is above b, 1 if b is above a, or 0 otherwise
				return  (above || slightlyAboveBottom || slightlyAboveTop ? -1 : (below || slightlyBelowBottom || slightlyBelowTop ? 1 : 0));
			}.bind(this));
					
			// Return lanes
			return lanes;
		},
		
		getNamespace: function() {
			if(!this.namespace) {
				var stencilsets = this.facade.getStencilSets();
				if(stencilsets.keys()) {
					this.namespace = stencilsets.keys()[0];
				} else {
					return undefined;
				}
			}
			return this.namespace;
		},
		
		getHashedBounds: function(shape){
			return this.currentPool && this.hashedBounds[this.currentPool.id][shape.id] ? this.hashedBounds[this.currentPool.id][shape.id] : shape.absoluteBounds();
		},
		
		/**
		 * Returns the Pool which contains the given element
		 * @param {ORYX.Core.Node} elem
		 * @returns {Pool}
		 */
		getPool : function(elem) {
		    if (!(elem instanceof ORYX.Core.Node) || !elem.parent) {
		        return;
		    }
		    if (["Pool", "VerticalPool"].include(elem.getStencil().idWithoutNs())) {
		        return elem;
		    } else {
		        return this.getPool(elem.parent);
		    }
		},
		
		updateShortLength: function(root){
			
			if(this.orientation === "horizontal") {
				var fn = "height";
			}
			else if(this.orientation === "vertical") {
				var fn = "width";
			} 
			else {
				return;
			}
			
			var lanes = this.getLanes(root);
			
			if (lanes.length == 0){
				return root.bounds[fn]();
			}
			
			var length = {};
			length[fn] = 0;
			var i=-1;
			while (++i < lanes.length) {
				this.setLanePosition(lanes[i], length[fn]);
				length[fn] += this.updateShortLength(lanes[i]);
			}
			
			this.setDimensions(root, length["width"], length["height"]);
			
			return length[fn];
		},
		
		// Record shapes for sub process layouting methods (see bpmn 2.0.js)
		
		hashChildShapes: function(shape){
			this.facade.raiseEvent({
				type: ORYX.CONFIG.EVENT_BPMN20_HASHCHILD,
				shape: shape,
				forceExecution: true
			});
		},
		
		/**
		 * Creates the buttons to move a Lane inside its Pool
		 */
		_createMoveButtons : function() {

			this.moveButtons = {};
			
			["left", "right", "up", "down"].each(function(dir) {
				this.moveButtons[dir] = new ORYX.Plugins.ShapeMenuButton({
					id			: "oryx_canvas_htmlContainer",
					msg			: "",
					icon		: ORYX.CONFIG.EXPLORER_PATH + "/src/img/signavio/arrow-move-" + dir + ".png",
					cls			: "y-movebutton y-movebutton-" + (["left", "up"].include(dir) ? "pre" : "post")+ "-" + (this.orientation || "horizontal"),
					callback	: function() {
						if (this.clb instanceof Function) {
							this.clb();
						}
					}
				});
			}.bind(this));
		}
	});
	
	var ResizeLanesCommand = ORYX.Core.Command.extend({
		
		construct: function(shape, parent, pool, plugin) {
		
			this.facade  = plugin.facade;
			this.plugin  = plugin;
			this.shape	 = shape;
			this.changes;
			
			this.pool	= pool;
			
			this.parent	= parent;
			
			
			this.shapeChildren = [];
			
			/*
			 * The Bounds have to be stored 
			 * separate because they would
			 * otherwise also be influenced 
			 */
			this.shape.getChildShapes().each(function(childShape) {
				this.shapeChildren.push({
					shape: childShape,
					bounds: {
						a: {
							x: childShape.bounds.a.x,
							y: childShape.bounds.a.y
						},
						b: {
							x: childShape.bounds.b.x,
							y: childShape.bounds.b.y
						}
					}
				});
			}.bind(this));
	
			this.shapeUpperLeft = this.shape.bounds.upperLeft();
			
			// If there is no parent, 
			// correct the abs position with the parents abs.
			/*if (!this.shape.parent) { 
				var pAbs = parent.absoluteXY();
				this.shapeUpperLeft.x += pAbs.x;
				this.shapeUpperLeft.y += pAbs.y;
			}*/
			
			// consider pool orientation
			// horizontal consider height
			if(this.plugin.orientation === "horizontal") {
				this.shortEdgeFN = "height";
				this.longEdgeFN = "width";
				this.coord = "y";
			} 
			// vertical consider width
			else if( this.plugin.orientation === "vertical" ) {
				this.shortEdgeFN = "width";
				this.longEdgeFN = "height";
				this.coord = "x";
			}
			else {
				return;
			}
			
			//this.parentHeight
			this.parentShortEdgeLength = this.parent.bounds[this.shortEdgeFN](); 
	
		},
		
		getLeafLanes: function(lane){
			var childLanes = this.plugin.getLanes(lane).map(function(child){
				return this.getLeafLanes(child);
			}.bind(this)).flatten();
			return childLanes.length > 0 ? childLanes : [lane];
		},
		
		findNewLane: function(){
			
			var lanes = this.plugin.getLanes(this.parent);
	
			var leafLanes = this.getLeafLanes(this.parent);
			/*leafLanes = leafLanes.sort(function(a,b){
				var aupl = a.absoluteXY().y;
				var bupl = b.absoluteXY().y;
				return aupl < bupl ? -1 : (aupl > bupl ? 1 : 0)
			})*/
			this.lane = leafLanes.find(function(l){ return l.bounds.upperLeft()[this.coord] >= this.shapeUpperLeft[this.coord]; }.bind(this)) || leafLanes.last();
			this.laneUpperLeft = this.lane.bounds.upperLeft();	
		},
		
		execute: function() {
			
			if(this.changes) {
				this.executeAgain();
				return;
			}
	
			/* 
			 * Rescue all ChildShapes of the deleted
			 * Shape into the lane that takes its 
			 * place 
			 */
			
			if (!this.lane){
				this.findNewLane();
			}
			
			if(this.lane) {			
				
				var laUpL = this.laneUpperLeft;
				var shUpL = this.shapeUpperLeft;
				
				var depthChange = this.plugin.getDepth(this.lane, this.parent)-1;
							
				this.changes = $H({});
				
				// Selected lane is BELOW the removed lane
				if (laUpL[this.coord] >= shUpL[this.coord]) {				
					this.lane.getChildShapes().each(function(childShape) {
						
						/*
						 * Cache the changes for rollback
						 */
						if(!this.changes[childShape.getId()]) {
							this.changes[childShape.getId()] = this.computeChanges(childShape, this.lane, this.lane, this.shape.bounds[this.shortEdgeFN]());
						}
						
						// move child shapes depending on the pool's orientation
						childShape.bounds.moveBy((this.coord === "x" ? this.shape.bounds.width() : 0), (this.coord === "y" ? this.shape.bounds.height() : 0));
					}.bind(this));
					
					this.plugin.hashChildShapes(this.lane);
					
					this.shapeChildren.each(function(shapeChild) {
						shapeChild.shape.bounds.set(shapeChild.bounds);
						shapeChild.shape.bounds.moveBy((this.coord === "y" ? (shUpL.x-30)-(depthChange*30) : 0), (this.coord === "x" ? (shUpL.y-30)-(depthChange*30) : 0));
						
						/*
						 * Cache the changes for rollback
						 */
						if(!this.changes[shapeChild.shape.getId()]) {
							this.changes[shapeChild.shape.getId()] = this.computeChanges(shapeChild.shape, this.shape, this.lane, 0);
						}
						
						this.lane.add(shapeChild.shape);
						
					}.bind(this));		
				
					this.lane.bounds.moveBy((this.coord === "x" ? shUpL.x-laUpL.x : 0), (this.coord === "y" ? shUpL.y-laUpL.y : 0));
				
				// Selected lane is ABOVE the removed lane	
				} else if(shUpL[this.coord] > laUpL[this.coord]){
					
					this.shapeChildren.each(function(shapeChild) {
						shapeChild.shape.bounds.set(shapeChild.bounds);
						
						var xOff = (this.coord === "y" ? (shUpL.x-30)-(depthChange*30) : this.lane.bounds.width());
						var yOff = (this.coord === "y" ? this.lane.bounds.height() : (shUpL.y-30)-(depthChange*30));
						
//						shapeChild.shape.bounds.moveBy((shUpL.x-30)-(depthChange*30), this.lane.bounds.height());
						shapeChild.shape.bounds.moveBy(xOff, yOff);
						
						/*
						 * Cache the changes for rollback
						 */
						if(!this.changes[shapeChild.shape.getId()]) {
							this.changes[shapeChild.shape.getId()] = this.computeChanges(shapeChild.shape, this.shape, this.lane, 0);
						}
						
						this.lane.add(shapeChild.shape);
						
					}.bind(this));
				}
			}
					
			/*
			 * Adjust the height of the lanes
			 */
			// Get the height values
			var oldShortLength	= this.lane.bounds[this.shortEdgeFN]();				
			var newShortLength	= this.lane.length === 1 ? this.parentShortEdgeLength : this.lane.bounds[this.shortEdgeFN]() + this.shape.bounds[this.shortEdgeFN]();
	
			// Set height
			this.setShortEdgeLength(newShortLength, oldShortLength, this.parent, this.parentShortEdgeLength, true);
			
			// Cache all sibling lanes
			//this.changes[this.shape.getId()] = this.computeChanges(this.shape, this.parent, this.parent, 0);
			this.plugin.getLanes(this.parent).each(function(childLane){
				if(!this.changes[childLane.getId()] && childLane !== this.lane && childLane !== this.shape) {
					this.changes[childLane.getId()] = this.computeChanges(childLane, this.parent, this.parent, 0);
				}
			}.bind(this));
				
			// Update
			this.update();
		},
		
		setShortEdgeLength: function(newShortLength, oldShortLength, parent, parentShortEdgeLength, store){
			
			// Set heigh of the lane
			this.plugin.setDimensions(this.lane, this.lane.bounds[this.longEdgeFN](), newShortLength);
			this.plugin.hashedBounds[this.pool.id][this.lane.id] = this.lane.absoluteBounds();
			
			// Adjust child lanes
			this.plugin.adjustShortEdge(this.plugin.getLanes(parent), this.lane);
			
			if (store === true){
				// Store changes
				this.changes[this.shape.getId()] = this.computeChanges(this.shape, parent, parent, 0, oldShortLength, newShortLength);	
			}
			
			// Set length of parent's longer edge (horizontal => height || vertical=> width) 
			// this.coord "y" => horizontal
			if(this.coord === "y") {
				this.plugin.setDimensions(parent, parent.bounds.width(), parentShortEdgeLength);
			} else {
				this.plugin.setDimensions(parent, parentShortEdgeLength, parent.bounds.height());
			}
			
			if (parent !== this.pool){
				if(this.coord === "y") {
					this.plugin.setDimensions(this.pool, this.pool.bounds.width(), this.pool.bounds.height() + (newShortLength-oldShortLength));
				} else {
					this.plugin.setDimensions(this.pool, this.pool.bounds.width() + (newShortLength-oldShortLength), this.pool.bounds.height());
				}
			}
		},
		
		update: function(){
			
			// Hack to prevent the updating of the dockers
			this.plugin.hashedBounds[this.pool.id]["REMOVED"] = true;
			// Update
			//this.facade.getCanvas().update();
		},
		
		rollback: function() {
			
			var laUpL = this.laneUpperLeft;
			var shUpL = this.shapeUpperLeft;
				
			this.changes.each(function(pair) {
				
				var parent 	  		= pair.value.oldParent;
				var shape  	  		= pair.value.shape;
				var parentShortLenght 	= pair.value.parentShortLength;
				var oldShortLength 	= pair.value.oldShortLength;
				var newShortLength 	= pair.value.newShortLength;
				
				// Move siblings
				if (shape.getStencil().id().endsWith("Lane")){
					shape.bounds.moveTo(pair.value.oldPosition);	
				}
				
				// If lane
				if(oldShortLength) {					
					this.setShortEdgeLength(oldShortLength, newShortLength, parent, parent.bounds[this.shortEdgeFN]() + (oldShortLength - newShortLength));
					if (laUpL[this.coord] >= shUpL[this.coord]) {
						var xOff = (this.coord === "y" ? 0 : this.shape.bounds.width()-1);
						var yOff = (this.coord === "y" ? this.shape.bounds.height()-1 : 0);
						this.lane.bounds.moveBy( xOff, yOff );
					}
				} else {
					parent.add(shape);
					shape.bounds.moveTo(pair.value.oldPosition);
					
				}

				
			}.bind(this));
			
			// Update
			//this.update();
			
		},
		
		executeAgain: function() {
			
			this.changes.each(function(pair) {
				var parent 	  = pair.value.newParent;
				var shape  	  = pair.value.shape;
				var newShortLength = pair.value.newShortLength;
				var oldShortLength = pair.value.oldShortLength;
				
				// If lane
				if(newShortLength) {
					var laUpL = this.laneUpperLeft[this.coord];
					var shUpL = this.shapeUpperLeft[this.coord];
				
					if (laUpL >= shUpL) {
						this.lane.bounds.moveBy(0, shUpL - laUpL);
					}
					this.setShortEdgeLength(newShortLength, oldShortLength, parent, parent.bounds[this.shortEdgeFN]() + (newShortLength-oldShortLength));
				} else {
					parent.add(shape);
					shape.bounds.moveTo(pair.value.newPosition);
				}
				
			}.bind(this));
			
			// Update
			this.update();
		},
		
		computeChanges: function(shape, oldParent, parent, offset, oldShortLength, newShortLength) {
			
			oldParent = this.changes[shape.getId()] ? this.changes[shape.getId()].oldParent : oldParent;
			var oldPosition = this.changes[shape.getId()] ? this.changes[shape.getId()].oldPosition : shape.bounds.upperLeft();
			
			var sUl = shape.bounds.upperLeft();
			
			var pos = {
				x: sUl.x + (this.coord === "x" ? offset : 0), 
				y: sUl.y + (this.coord === "y" ? offset : 0)
			};
			
			var changes = {
				shape		: shape,
				parentShortLength: oldParent.bounds[this.shortEdgeFN](),
				oldParent	: oldParent,
				oldPosition	: oldPosition,
				oldShortLength	: oldShortLength,
				newParent	: parent,
				newPosition : pos,
				newShortLength	: newShortLength
			};
				
			return changes;
		}
	});
	
	// TODO: reinforce the MoveLaneCommand!
	
	
	ORYX.Core.Command.AdjustLane = ORYX.Core.Command.extend({
		construct: function(changes, plugin) {
			this.oldState = changes;
			
			this.newState = changes.map(function(s) {
				return {
					pool		: s.pool,
					shape		: s.shape,
					extension	: s.extension,
					movement	: s.movement
				};
			});
			
			this.plugin = plugin;
		}, 
		execute: function(){
			delete this.undo;
			this.applyState(this.newState);
		}, 
		rollback: function(){
			this.undo = true;
			this.applyState(this.oldState);
		},
		applyState: function(state){
			state.each(function(s){
				
				this.plugin.facade.raiseEvent({
					type	: ORYX.CONFIG.EVENT_BPMN20_DELETE_HASH,
					shape	: s.shape
				});
				
				this.plugin.facade.getCanvas().update();
				if (this.undo) {
					if (s.movement)
						s.shape.bounds.moveBy(s.movement);
					if (s.extension)
						s.shape.bounds.extend({x:-s.extension.x, y:-s.extension.y});
						this.plugin.facade.raiseEvent({
							type		: ORYX.CONFIG.EVENT_BPMN20_ADJUST_LANES,
							pool		: s.pool,
							shape		: s.shape,
							offset		: s.extension
						});
//						this.plugin.adjustLanes(s.pool, [s.shape], s.extension.x, s.extension.y);
				} else {
					if (s.extension)
						s.shape.bounds.extend({x:-s.extension.x, y:-s.extension.y});
					if (s.movement)
						s.shape.bounds.moveBy({x:-s.movement.x, y:-s.movement.y});
//					this.plugin.adjustLanes(s.pool, [this.plugin.getLanes(s.pool, true)], 0, 0);
				}
				this.plugin.facade.getCanvas().update();
				
			}.bind(this));
			
		}
	});
	
	/**
	 * Implements a command to move a lane inside of another Lane or Pool.
	 * 
	 * @class MoveLaneCommand
	 * @param {ORYX.Core.Shape} lane The lane to move
	 * @param {{x: Number, y: Number}} moveCoordinates The new coordinates where the lane should be moved
	 * @param {ORYX.Core.Plugin} plugin
	 */
	ORYX.Core.MoveLaneCommand = ORYX.Core.Command.extend({
		construct : function(lane, newCoordinates, newDirection, newParent, plugin) {
			
			this.lane 			= lane;
			this.newCoordinates = newCoordinates;
			this.newDirection	= newDirection;
			this.newParent 		= newParent;
			
			this.plugin = plugin;
			this.facade = plugin.facade;
			
			this.undoStack = [];
			this.redo = false;
		},
		
		execute : function() {
			
			// If coordinates are provided, just move the lane
			if (this.newCoordinates) {
				this.moveLaneInsideParent();
				return;
			} 
			
			// Move the lane using the defined direction
			else if (this.newDirection) {
				
				var level = this.newDirection.level, position = this.newDirection.position;
				var pool = this.plugin.getPool(this.lane);
				var indexToInsert;
				
				// Put in above / left of the target
				if (["top", "left"].include(position)) {
					indexToInsert = 0;
				}
				
				/* REMEMBER THE PREVIOUS STATE */
				var oldState = {
						position	: this.lane.bounds.upperLeft(),
						direction	: this.newDirection
				};
				
				if (this.newParent) {
					// Get all true siblings of the current lane which are no lanes
					var siblings = [];
					var hasSiblingLanes = this.getSiblingLanes(this.lane.parent, siblings);
					
					/* If no siblings exist which are lanes, 
					 * move all siblings into the lane to move and remove the parent. */
					if (!hasSiblingLanes && siblings.length === 0) {
						// remember the siblings which must be moved
						oldState.movedChildren = siblings;
						
						// add the siblings to the current lane
						siblings.each(function(sibling) {
							this.lane.add(sibling);
						}.bind(this));
						
						// remember the parent
						var parentToRemove = this.lane.parent;
						oldState.removedParent = parentToRemove.serialize();
						oldState.removedParentId = parentToRemove.resourceId;
						
						// move the lane to the new parent
						this.newParent.add(this.lane);
						
						if (position === "top" && level === "outdent") {
							var above = this.plugin.getLaneAbove(parentToRemove);
							if (above)
								this.lane.bounds.moveTo({x : 0, y : above.bounds.upperLeft().y + 1});
						}
						
						if (position === "bottom" && level === "outdent") {
							this.lane.bounds.moveTo({x:0, y:parentToRemove.bounds.upperLeft().y + 1});
						}
						
						this.plugin.adjustLanes(pool, [this.lane], 30, 0);
						// if the lane should not be inserted as the first lane, move it to the bottom
						// remove the old parent
						this.newParent.remove(parentToRemove, true);
					}
					// Else just remember the old parent
					else {
						// remember the old parent lane
						oldState.parent = this.lane.parent;
						
						// Add the lane to the new parent
						this.newParent.add(this.lane, indexToInsert);
						
						if (position === "top" && level === "outdent") {
							var above = this.plugin.getLaneAbove(oldState.parent);
							if (above)
								this.lane.bounds.moveTo({x : 0, y : above.bounds.upperLeft().y + 1});
						}
						
						if (position === "bottom" && level === "outdent") {
							this.lane.bounds.moveTo({x:0, y:oldState.parent.bounds.upperLeft().y + 1});
						}
						
						// If the lane is inserted as the topmost lane into the new parent, set its bounds to 0
						if (position === "top" && level === "indent") {
							this.lane.bounds.moveTo({x:30, y:0});
						}
						
						this.facade.getCanvas().update();
						// Extend the lane after the initial update

						// TODO: variable
						
						
						if (this.redo) {
							// Invert movement of lanes for the children of the lane
							//this.plugin.adjustLanes(pool, this.plugin.getAllExcludedLanes(pool, this.lane), -30, 0);
							this.plugin.adjustLanes(pool, [this.lane], 30, 0);
							delete this.plugin.hashedBounds[pool.id][this.lane.id];
						} else {
							this.lane.bounds.extend({x:(level === "outdent" ? 30 : -30), y:0});
						}
					}
				}
				
				this.facade.setSelection([this.lane]);
				
				this.undoStack.push(oldState);
				return;
			} 
		},
		
		rollback : function() {
			this.facade.setSelection([this.lane]);
			var pool = this.plugin.getPool(this.lane);

			// get the initial state
			var newState = this.undoStack.pop(), newParent;
			
			/* REMEMBER THE REDO STATE */
			var oldState = {
					position	: this.lane.bounds.upperLeft(),
					direction	: newState.direction
			};
			
			if (this.newCoordinates) {
				this.lane.bounds.moveTo(oldState.position);
				this.redo = true;
				return;
			}
			
			var indexToInsert;
			
			// Put in above / left of the target
			if (["top", "left"].include(newState.direction.position)) {
				indexToInsert = 0;
			}
			
			if (newState.removedParent) {
				// Recreate the previously removed parent lane
				newParent = this.facade.createShape({
					serialize 	: newState.removedParent
				});
				// Set the id of the previous parent
				newParent.setResourceId(newState.removedParentId);
				
				// Add any moved children
				(newState.movedChildren||[]).each(function(child) {
					newParent.add(child);
				});
			}

			// If a new parent is defined, either a removed one or a normal one, add the lane to it
			if (newParent || newState.parent) {

				// remember the old parent
				oldState.parent = this.lane.parent;

				// if the previous parent was deleted, add the lane to the restored parent 
				if (newParent) {
					newParent.add(this.lane, indexToInsert);
				} 
				// if the remembered parent is visible, add it there
				else if (newState.parent && newState.parent.parent) {
					newState.parent.add(this.lane, indexToInsert);
				}
				// try to get the parent by using the resource id
				else {
					newParent = this.facade.getCanvas().getChildShapeByResourceId(newState.parent.resourceId);
					if (newParent) {
						this.lane.parent.remove(this.lane);
						this.facade.setSelection([newParent]);
						this.facade.getCanvas().update();
						newParent.add(this.lane, indexToInsert);
						this.facade.getCanvas().update();
					}
				}
				
//				if ("undefined" === typeof indexToInsert && newState.direction.level === "indent") {
//					this.lane.bounds.moveTo({x:0, y:this.newParent.bounds.upperLeft().y + 1});
//				}
				var cl = this.plugin.getLanes(this.lane, true);
				if (cl.length > 0)
					this.plugin.adjustLanes(pool, cl, -newState.position.x, 0);
				else
					this.plugin.adjustLanes(pool, [this.lane], -newState.position.x, 0);

				delete this.plugin.hashedBounds[pool.id][this.lane.id];
				
				this.facade.setSelection([newState.parent]);
			}
			
			if (cl && cl.length > 0)
				this.facade.setSelection([pool]);
			else
				this.facade.setSelection([this.lane]);	
			
			
			this.redo = true;
			return;
		},
		
		/**
		 * Returns true if the current target has siblings, and collects them in the given parameter.
		 * @param siblings Call by reference
		 * @returns {Boolean}
		 */
		getSiblingLanes : function(shape, siblings) {
			if (!(siblings instanceof Array)) {
				siblings = [];
			}
			var hasSiblingLanes = false;
			siblings = shape.children.without(this.lane).findAll(function(sibling) {
				// Filter all siblings which are no node
				if (!(sibling instanceof ORYX.Core.Node)) return false;
				
				// If the sibling is a lane, break the loop and remember that
				if (["Lane", "VerticalLane"].include(sibling.getStencil().idWithoutNs())) {
					hasSiblingLanes = true;
					throw $break;
				}
				return true;
			});
			return hasSiblingLanes;
		},
		
		/**
		 * Moves the current lane inside it's parent using coordinates
		 */
		moveLaneInsideParent : function() {
			var oldState = {
					position	: this.lane.bounds.upperLeft()
			};
			
			this.lane.bounds.moveTo(this.newCoordinates);
			
			this.facade.setSelection([this.lane]);
			
			this.undoStack.push(oldState);
		}
	});	
}();
/**
 * Copyright (c) 2011
 * Lukas Brand
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

if ("undefined" === typeof ORYX) var ORYX = {};
if ("undefined" === typeof ORYX.Plugins) ORYX.Plugins = {};

new function() {
	
	ORYX.Plugins.BPMN2_0PoolLaneCreation = ORYX.Plugins.AbstractPlugin.extend({

		/**
		 *	Constructor
		 *	@param {Object} facade: The Facade of the Editor
		 */
		construct: function(facade) {
			this.facade = facade;
			
			// Set the flag to hide the classic pools and lanes stencils
			ORYX.CONFIG.BPMN20_SHAPEREPOSITORY_HIDE_POOLS_LANES = true;
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_BPMN20_DIAGRAM_ORIENTATION_CHANGED, this.init.bind(this));
			
			// Get the modeling direction
			this.orientation = this.facade.getCanvas().getOrientation();	
			
			var me = this;
			
			this.namespace = this.facade.getStencilSets().keys()[0];
			
			// Offer a new entry for the shape repository
			this.facade.offer({
				// The Shape repository
				target			: ORYX.Plugins.ShapeRepository,
				title			: ORYX.I18N.PoolLaneHandling.poolLane,
				description		: ORYX.I18N.PoolLaneHandling.description,
				icon			: function() {
					//return "/stencilsets/bpmn2.0/icons/swimlane/"+ (this.facade.getCanvas().getOrientation() === "horizontal" ? "" : "vertical.") +"lane.png";
					//shanglihui 20111205
					return "/v5designer/editor/stencilsets/bpmn2.0/icons/swimlane/"+ (this.facade.getCanvas().getOrientation() === "horizontal" ? "" : "vertical.") +"lane.png";
				}.bind(this),
				hide			: function(event) {
					var bpmn = this.facade.getStencilSets().values().first();
					return !bpmn.stencils().invoke("idWithoutNs").include("Pool");
				}.bind(this),
				// The group name to add the entry to
				groups			: [ORYX.I18N.PoolLaneHandling.group],
				// The rank in the category
				index			: -1,
				namespace		: this.namespace,
				// Experimental
				id				: this.namespace + ("Lane"),
				afterDragEnterClb:function(target, e, id) {me.afterDragEnter(this, target, e, id);},
				afterDragOverClb: function(target, e, id) {me.afterDragOver(this, target, e, id);},
				afterDragOutClb	: function(target, e, id) {me.afterDragOut(this, target, e, id);},
				afterDragDropClb: function(target, e, id) {me.afterDragDrop(this, target, e, id);},
				onValidDropClb	: function(option, shape, event) {me.onValidDrop(this, option, shape, event);}
			});
			
			this._createOverlays();
			this._disableStencils();
		},
		
		/**
		 * On initialization
		 */
		init : function() {
			// Update the modeling direction
			this.orientation = this.facade.getCanvas().getOrientation();			
			this._setShapeRepositoryIcon();
			this._createOverlays();
			//this._disableStencils();
		},
		
		/**
		 * HACK: Sets the icon of the Pool/Lane shape repository entry to display the current modeling direction
		 */
		_setShapeRepositoryIcon : function() {
			var shapeRepEntry = document.body.getElementsByClassName("x-stencil-lane")[0];
			if (!(shapeRepEntry instanceof HTMLElement)) return;
			
			var icon = shapeRepEntry.getElementsByClassName("ShapeRepEntreeImg")[0];
			if (!(icon instanceof HTMLElement)) return;
			
			//icon.setAttributeNS(null, "src", "/stencilsets/bpmn2.0/icons/swimlane/" + (this.orientation === "horizontal" ? "" : "vertical.") + "lane.png");
			//shanglihui 20111205
			icon.setAttributeNS(null, "src", "/v5designer/editor/stencilsets/bpmn2.0/icons/swimlane/" + (this.orientation === "horizontal" ? "" : "vertical.") + "lane.png");
			
		},
		
		/**
		 * Disables the classic stencils to create a new Lane or a Pool
		 */
		_disableStencils : function() {
			var stencilSet;
			stencilSet = this.facade.getStencilSets()[this.namespace];
			
			if(!stencilSet) {return;}
			
			this._setStencilProperty(stencilSet, "Pool", "hide", true);
			this._setStencilProperty(stencilSet, "Lane", "hide", true);
			this._setStencilProperty(stencilSet, "VerticalPool", "hide", true);
			this._setStencilProperty(stencilSet, "VerticalLane", "hide", true);
			
			// Refresh the shape repository
			if(!this.facade.isExecutingCommands()) {
				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_STENCIL_SET_LOADED});
			}
		},
		
		/**
		 * Set a property to a given Stencil
		 * @param {String} stencilSet The namespace of the stencilset
		 * @param {String} stencilId The id of the stencil
		 * @param {String} prop The property
		 * @param {String} value The value to set
		 */
		_setStencilProperty: function(stencilSet, stencilId, prop, value) {
			var stencil = stencilSet.stencil(stencilSet.namespace() + stencilId);
			
			if(!stencil) {return;}
			
			stencil._jsonStencil[prop] = value;
		},
		
		/**
		 * Disables the mouseover event on the canvas to prevent dockers from showing when a pool/lane is dragged.
		 * @param dragZone
		 * @param target
		 * @param e
		 * @param id
		 */
		afterDragEnter : function(dragZone, target, e, id) {
			this.facade.disableEvent(ORYX.CONFIG.EVENT_MOUSEOVER);
		},
		
		/**
		 * Handles mouse move event. Displays an overlay to display where a lane could be dropped.
		 * @param dragZone The context of the drag plugin
		 * @param target
		 * @param e The event
		 * @param id
		 */
		afterDragOver : function(dragZone, target, e, id) {
			if (!dragZone) return;
			
			// Hide the highlights
			if (dragZone.highlightShape instanceof Function) {
				dragZone.highlightShape();
			} else {
				this.facade.raiseEvent({
					type: 			ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
					highlightId: 	id
				});
			}
			
			// Get the upmost possible drop target
			var dropTarget = this.getDropTarget(dragZone._lastOverElements);
			if (!dropTarget) return;
			
			/* If the mouse is currently over a lane,
			 * show the overlays to display where a new lane can be dropped */
			if (this.isLane(dropTarget)) {
				this.handleMouseOverLane(dropTarget, dragZone, e);
				return;
			}
			
			/* If the mouse is currently over the canvas,
			 * show a hint to create a new pool instead of a lane */
			if (this.isCanvas(dropTarget)) {
				this.handleMouseOverCanvas(dropTarget, dragZone, e);
				return;
			}
			
			// If the mouse is over a compartment of a pool, prohibit dropping a lane
//			if (this.isMouseOverCompartment(mouseTarget)) {
//				this.handleMouseOverCompartment(mouseTarget, dragZone);
//				return;
//			}
//			
			// If the current target is not a lane, hide all overlays
			this.prohibitLaneDrop(dragZone);
			this.hideOverlays();
			
			// If a drag rectangle exists, hide it
			if (dragZone.rectangle && !dragZone.rectangle.hidden) {
				dragZone.rectangle.hide();
			}
		},
		
		/**
		 * Function to call after the mouse has been dragged out of the drag zone, hides all overlays
		 * @param dragZone
		 * @param target
		 * @param e
		 * @param id
		 */
		afterDragOut : function(dragZone, target, e, id) {
			if (!dragZone) return;
			
			this.hideOverlays();
		},
		
		/**
		 * Function to call after the mouse button has been released, hides all shown overlays
		 * @param dragZone
		 * @param target
		 * @param e
		 * @param id
		 */
		afterDragDrop : function(dragZone, target, e, id) {
			this.hideOverlays();
			// Hide any horizontal or vertical snap lines
			if (dragZone.hLine) dragZone.hLine.hide();
			if (dragZone.vLine) dragZone.vLine.hide();
			
			// Hide an existing drag rectangle
			if (dragZone.rectangle && !dragZone.rectangle.hidden) {
				dragZone.rectangle.hide();
			}
			
			// Reenable the mouseover event on the canvas to allow dockers being shown again
			this.facade.enableEvent(ORYX.CONFIG.EVENT_MOUSEOVER);
		},
		
		
		/**
		 * Creates a new pool/lane according to the position where the mouse button was released
		 * @param dragZone
		 * @param option
		 * @param shape
		 * @param event
		 */
		onValidDrop : function(dragZone, option, shape, event) {
			// Disable dragging
			if (dragZone.hideProxy instanceof Function) {
				dragZone.hideProxy();
			}
			
			// Hide the preview rectangle
			if (dragZone.rectangle) {
				dragZone.rectangle.hide();
			}

			shape = this.getDropTarget(dragZone._lastOverElements);
			
			if (shape instanceof ORYX.Core.Canvas) {
				var nearbyPool = this.getNearbyPool(event, true);
				// OVERRIDE THE CURRENT TARGET WITH A NEARBY POOL
				if (nearbyPool) {
					shape = nearbyPool;
				}
			}
			// Create a new pool/lane
			this.createLane(dragZone, option, shape, event);
		},
		
		/**
		 * If the mouse is currently over the canvas, display a hint to create a new pool instead of a lane
		 * @param {ORYX.Core.Canvas} mouseTarget The canvas element
		 * @param dragZone
		 */
		handleMouseOverCanvas : function(mouseTarget, dragZone, event) {
			if (!dragZone) return;

			// Modify the ghost to show the hint
			this.displayPoolDropHint(dragZone);
			
			// Hide any overlays indicating a drop area
			this.hideOverlays();
			
			// Get the closest lane on the upmost level in the closest pool
			var nearbyPool = this.getNearbyPool(event, true);
			
			if (nearbyPool) {
				this.handleMouseOverLane(nearbyPool, dragZone, event);
			} else {
				// Show a rectangle representing the pool
				var scale = dragZone.getScale();
				var position = this.facade.eventCoordinates(event.browserEvent); 
				if (dragZone.snapPosition instanceof Function) {
					position = dragZone.snapPosition(position);	
				}
				
				// If no drag bounds or a drag rectangle exist, exit here
				if (!dragZone.bounds || !dragZone.rectangle) {
					return;
				}
				
				dragZone.bounds.set(this.genericPoolBounds);
				dragZone.bounds.moveTo(position.x/scale,position.y/scale);
				
				dragZone.rectangle.resize(dragZone.bounds);
				dragZone.rectangle.show();

				// Allow to drop a pool here
				dragZone.setAllowed();				
			}
		},
		
		/**
		 * Returns the primary Lane of a nearby Pool
		 * @param {BrowserEvent} event
		 * @returns {Lane}
		 */
		getNearbyPool : function(event, getUpmostLane) {
			// Get the mouse position
			var coords = this.facade.eventCoordinates(event.browserEvent);
			// All pools
			var pools = this.facade.getCanvas().getChildShapes().findAll(function(child) {
				return this.isPool(child);
			}.bind(this))
			// Check if the pool is near the mouse position
			.findAll(function(pool) {
				var wb = pool.bounds.clone();
				if (this.orientation === "horizontal") {
					wb.moveBy({x:0, y:-30});
					wb.extend({x:0, y: 60});
				} else {
					wb.moveBy({x:-30, y:0});
					wb.extend({x: 60, y:0});
				}
				return wb.isIncluded(coords);
			}.bind(this));
			// If more than one pool is close, don't to anything
			if (pools.length !== 1) { return; }
			if (!getUpmostLane) { return pools[0]; }
			
			// Get all lanes in order
			var lanes = this.getLanes(pools[0]);
			var dockingSide = this.getDockingSide(pools[0].bounds, coords, false);
			
			if (dockingSide === "pre") return lanes.first();
			if (dockingSide === "post") return lanes.last();
		},
		
		/**
		 * Returns the upmost possible drop target
		 * @param {ORYX.Core.Shape[]} lastOverElements
		 * @returns {ORYX.Core.Shape} Pool/Lane/Canvas
		 */
		getDropTarget : function(lastOverElements) {
			return (lastOverElements||[]).find(function(el) {
				return this.isCanvas(el) || this.isLane(el) || this.isPool(el);  
			}.bind(this));
		},
		
		/**
		 * Returns a set on all child lanes for the given Shape. If recursive is TRUE, also indirect children will be returned (default is FALSE)
		 * The set is sorted by
		 * 		- (Orientation: horizontal): first child has the lowest y-coordinate and the last one the highest.
		 * 		- (Orientation: vertical): first child has the lowest x-coordinate and the last one the highest.
		 * @param {ORYX.Core.Shape} shape
		 * @param {boolean} recursive
		 */
		getLanes: function(shape, recursive){
			// Determine coordinate and side according to the pool orientation
			if(this.orientation === "horizontal") {
				var coord = "y";
				var lengthFN = "height";
				var laneStencilId = "Lane";
			}
			
			else if(this.orientation === "vertical") {
				var coord = "x";
				var lengthFN = "width";
				var laneStencilId = "VerticalLane";
			}
			
			// Get all the child lanes
			var lanes = shape.getChildNodes(recursive||false).findAll(function(node) { return (node.getStencil().id() === this.namespace + laneStencilId); }.bind(this));
			
			
			
			// Sort all lanes by there y coordinate
			lanes = lanes.sort(function(a, b){
				
				// Get y coordinates for upper left and lower right
				var auy = Math.round(a.bounds.upperLeft()[coord]);
				var buy = Math.round(b.bounds.upperLeft()[coord]);
				var aly = Math.round(a.bounds.lowerRight()[coord]);
				var bly = Math.round(b.bounds.lowerRight()[coord]);
				
				var ha	= a.absoluteBounds();
				var hb	= b.absoluteBounds();
				
				// Get the old y coordinates
				var oauy = Math.round(ha.upperLeft()[coord]);
				var obuy = Math.round(hb.upperLeft()[coord]);
				var oaly = Math.round(ha.lowerRight()[coord]);
				var obly = Math.round(hb.lowerRight()[coord]);
				
				// If equal, than use the old one
				if (auy == buy && aly == bly) {
					auy = oauy; buy = obuy; aly = oaly; bly = obly;
				}
				
				if (Math.round(a.bounds[lengthFN]()-ha[lengthFN]()) === 0 && Math.round(b.bounds[lengthFN]()-hb[lengthFN]()) === 0){
					return auy < buy ? -1 : (auy > buy ? 1: 0);
				}
				
				// Check if upper left and lower right is completely above/below
				var above = auy < buy && aly < bly;
				var below = auy > buy && aly > bly;
				// Check if a is above b including the old values
				var slightlyAboveBottom = auy < buy && aly >= bly && oaly < obly;
				var slightlyAboveTop = auy >= buy && aly < bly && oauy < obuy;
				// Check if a is below b including the old values
				var slightlyBelowBottom = auy > buy && aly <= bly && oaly > obly;
				var slightlyBelowTop = auy <= buy && aly > bly && oauy > obuy;
				
				// Return -1 if a is above b, 1 if b is above a, or 0 otherwise
				return  (above || slightlyAboveBottom || slightlyAboveTop ? -1 : (below || slightlyBelowBottom || slightlyBelowTop ? 1 : 0));
			}.bind(this));
					
			// Return lanes
			return lanes;
		},
		
		/**
		 * Handles mouse over lane situations
		 * @param mouseTarget
		 * @param dragZone
		 */
		handleMouseOverLane : function(mouseTarget, dragZone, event) {
			// Hide any horizontal or vertical snap lines
			if (dragZone.hLine) dragZone.hLine.hide();
			if (dragZone.vLine) dragZone.vLine.hide();
			if (dragZone.rectangle && !dragZone.rectangle.hidden) {
				dragZone.rectangle.hide();
			}
			
			var mouseCoords = this.facade.eventCoordinates(event.browserEvent);
			var mousePos = this.getDockingSide(mouseTarget.absoluteBounds(), mouseCoords, this.isSublaneAllowed(mouseTarget));
			
			// Displays all possible overlays according to the current mouse target
			this.showOverlay(mouseTarget, mousePos);
			
			if (["pre", "post"].include(mousePos)) {
				this.displayLaneDropHint(dragZone, mousePos);
			} else if (mousePos === "sub") {
				this.displaySublaneDropHint(dragZone);
			}
			
//			if (!(["pre", "post"].include(mousePos))) return;
			
			/*
			 * TODO: RECT
			 * Erst in step 2 implementieren: shorten nutzen!
			 */
			
//			// Get the bounds of the target
//			var ab = mouseTarget.absoluteBounds();
//			var ul = ab.upperLeft();
//			var lr = ab.lowerRight();
//			var scale = dragZone.getScale();
//			
//			switch (mousePos) {
//				case "top" :		dragZone.bounds.set(ul.x, ul.y - ab.height(), lr.x, lr.y - ab.height()); break;
//				case "bottom" :		dragZone.bounds.set(ul.x, ul.y + ab.height(), lr.x, lr.y + ab.height()); break;
//			}
//			
//			dragZone.bounds.widen(-5);
//			dragZone.rectangle.resize(dragZone.bounds);
//
//			if (dragZone.rectangle.hidden) {
//				dragZone.rectangle.show();
//			}
		},
		
		/**
		 * Changes the content of the drag ghost to display a hint where the new lane would be inserted
		 * @param dragZone
		 * @param {String} pos The side
		 */
		displayLaneDropHint : function(dragZone, mousePos) {
			var side = "";
			switch(mousePos) {
				case "pre"		: side = (this.orientation === "horizontal" ? ORYX.I18N.PoolLaneHandling.above : ORYX.I18N.PoolLaneHandling.left); break;
				case "post"		: side = (this.orientation === "horizontal" ? ORYX.I18N.PoolLaneHandling.below : ORYX.I18N.PoolLaneHandling.right); break;
				default			: side = "";
			}

			dragZone.setAllowed();
			$A(dragZone.getProxy().getGhost().dom.getElementsByTagName("img")).last().src = "/stencilsets/bpmn2.0/icons/swimlane/"+
				(this.orientation === "horizontal" ? "lane.png" : "vertical.lane.png");
			$A(dragZone.getProxy().getGhost().dom.getElementsByTagName("a")).last().textContent = String.format(ORYX.I18N.PoolLaneHandling.insertLane, side);
			dragZone.getProxy().sync();
		},
		
		/**
		 * Changes the content of the drag ghost to display a hint that a new sub lane could be created
		 * @param dragZone
		 */
		displaySublaneDropHint : function(dragZone) {

			dragZone.setAllowed();
			if (dragZone.getProxy instanceof Function) {
				$A(dragZone.getProxy().getGhost().dom.getElementsByTagName("img")).last().src = "/stencilsets/bpmn2.0/icons/swimlane/" +
					(this.orientation === "horizontal" ? "lane.png" : "vertical.lane.png");
				$A(dragZone.getProxy().getGhost().dom.getElementsByTagName("a")).last().textContent = ORYX.I18N.PoolLaneHandling.createSublane;
				dragZone.getProxy().sync();
			}
		},
		
		/**
		 * Changes the content of the drag ghost to display a hint that no lane can be created.
		 * @param dragZone
		 */
		prohibitLaneDrop : function(dragZone) {
			
			dragZone.setNotAllowed();
			if (dragZone.getProxy instanceof Function) {
				$A(dragZone.getProxy().getGhost().dom.getElementsByTagName("img")).last().src = "/stencilsets/bpmn2.0/icons/swimlane/" +
					(this.orientation === "horizontal" ? "lane.png" : "vertical.lane.png");
				$A(dragZone.getProxy().getGhost().dom.getElementsByTagName("a")).last().textContent = ORYX.I18N.PoolLaneHandling.cannotCreateRole;
				dragZone.getProxy().sync();	
			}
		}, 
		
		/**
		 * Changes the content of the drag ghost to display a hint that a new pool could be created
		 * @param dragZone
		 */
		displayPoolDropHint : function(dragZone) {
			
			dragZone.setAllowed();
			if (dragZone.getProxy instanceof Function) {
				//$A(dragZone.getProxy().getGhost().dom.getElementsByTagName("img")).last().src = "/stencilsets/bpmn2.0/icons/swimlane/" +
				//shanglihui 20111205
				$A(dragZone.getProxy().getGhost().dom.getElementsByTagName("img")).last().src = "/v5designer/editor/stencilsets/bpmn2.0/icons/swimlane/" +
					(this.orientation === "horizontal" ? "pool.png" : "vertical.pool.png");
				$A(dragZone.getProxy().getGhost().dom.getElementsByTagName("a")).last().textContent = ORYX.I18N.PoolLaneHandling.createPool;
				dragZone.getProxy().sync();
			}
		}, 
		
		/**
		 * Shows all overlays according to the current mouse target
		 * 
		 * @param mouseTarget
		 * @param {String} mousePos
		 */
		showOverlay : function(mouseTarget, mousePos) {
			if (!this.overlays) return;

			// Get the id of the desired overlay
			var id = this.overlayIds[mousePos];
			if (!id || !this.overlays[id]) return;
			// Get the overlay for the given side
			var overlay = this.overlays[id];
						
			// Set the bounds of the overlay according to the display position
			this.setOverlayBounds(overlay, mouseTarget, mousePos);
			
			// Hide any previous instances of the current overlay
			this.hideOverlays();
			
			// Display the overlay
			this.facade.raiseEvent({
				type		: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
				id			: id,
				node		: overlay,
				shapes		: [mouseTarget],
				nodePosition: this.overlayPositions[mousePos],
				adjustment	: this.getOverlayAdjustment(mousePos)
			});
		},
		
		/**
		 * Returns true if it is allowed to create a new sublane
		 * @param mouseTarget
		 * @returns {Boolean}
		 */
		isSublaneAllowed : function(mouseTarget) {
			// If the mouse is currently over a compartment, forbid sublane creation
			if (this.isOverCompartment(mouseTarget)) {
				return false;
			}
			
			if (!(mouseTarget.parent instanceof ORYX.Core.Canvas) && this.isLane(mouseTarget)) {
				return mouseTarget.parent.children.findAll(function(child) {
					if (child instanceof ORYX.Core.Node) {
						return this.isLane(child);
					}
				}.bind(this)).length > 1;
			}
		},
		
		/**
		 * Returns true if the mouse is currently over a compartment
		 * @param {ORYX.Core.Shape} mouseTarget
		 * @returns {Boolean}
		 */
		isOverCompartment : function(mouseTarget) {
			return this.isLane(mouseTarget) && mouseTarget.children.any(function(child) {
				return this.isLane(child);
			}.bind(this));
		},
		
		/**
		 * Sets the bounds of the sublane overlay
		 * @param mouseTarget
		 */
		showSublaneOverlay : function(mouseTarget) {
			var subOverlay = this.overlays[this.overlayIds.sublane];
			var horizontal = (this.orientation === "horizontal");
			
			// Display the sublane overlay
			if (subOverlay) {
				var width = (horizontal ? mouseTarget.bounds.width() / 3 : mouseTarget.bounds.width() - (2 * ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS));
				var height = (horizontal ? mouseTarget.bounds.height() - (2 * ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS) : mouseTarget.bounds.height() / 3);
				subOverlay.setAttributeNS(null, "width", width);
				subOverlay.setAttributeNS(null, "height", height);

				this.facade.raiseEvent({
					type		: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
					id			: this.overlayIds.sub
				});

				this.facade.raiseEvent({
					type		: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
					id			: this.overlayIds.sub,
					// The target container for the overlay
					shapes		: [mouseTarget],
					node		: subOverlay,
					// XXX: Vertical adjustment
					nodePosition: "NE"
				});
			}
		},
		
		/**
		 * Sets the size of the displayed overlay according to the selected modelling direction
		 * @param {ORYX.Core.Bounds} bounds
		 */
		updateOverlayBounds : function(bounds) {
			this.overlay.setAttributeNS(null, "width", (this.orientation === "horizontal" ? mouseTarget.bounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS));
			this.overlay.setAttributeNS(null, "height", (this.orientation === "horizontal" ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : mouseTarget.bounds.height()));
			
		},
		
		
		// TODO: REFACTOR COMMAND
		
		/**
		 * Creates a new Lane
		 * @param dragZone
		 * @param option
		 * @param shape
		 * @param event
		 */
		createLane : function(dragZone, option, shape, event) {
			if (!dragZone || !option || !shape || !event) return;
			
			// A new command to create a pool/lane
			var Command = ORYX.Core.Command.extend({
				construct: function(dragZone, facade, newState, event) {
					this.dragZone	= dragZone;
					this.facade 	= facade;
					this.newState	= newState;
					this.event		= event;
				},
				
				execute : function() {
					var s = this.newState;
					// Create a new lane
					var newLane  = this.facade.createShape({
						type		: s.id,
						namespace	: s.namespace
					});
					
					// If a resource id is defined, set it to the lane
					if (s.createdResourceIds && s.createdResourceIds[0]) {
						newLane.setResourceId(s.createdResourceIds[0]);
					}
					
					if (s.properties instanceof Hash) {
						s.properties.each(function(prop) {
							newLane.setProperty(prop.key, prop.value);
						});
					}

					// Resize the new lane to the size of the target shape
					newLane.bounds.set(s.currentShape.bounds.clone());
					
					this.oldState = {
							id			: s.id,
							namespace	: s.namespace,
							horizontal	: s.horizontal,
							target		: s.target,
							targetId	: s.targetId,
							targetBounds: s.targetBounds.clone(),
							currentShape: s.currentShape,
							pool		: s.pool,
							poolBounds	: s.poolBounds.clone(),
							position	: s.position
					};
					
					// Find the correct target shape
					if (s.target && !s.target.parent) {
						s.target = this.facade.getCanvas().getChildShapeByResourceId(s.targetId);
					}
					
					if (["pre", "post"].include(s.position)) {
						// Add the lane
						s.target.add(newLane);
					
						// If the lane is added above the mouse target, "expand" the pool upwards to keep the mouse target's position
						if (s.position === "pre") {
							this.movePoolUp(newLane, s);
						}

						// Remember the created Lane
						this.oldState.createdLanes = [newLane];
					}
					// Create a two new sub lanes
					else if (s.position === "sub") {
						// Create a second lane
						var newLane2 = this.facade.createShape({
							type		: s.id,
							namespace	: s.namespace
						});
						
						if (s.createdResourceIds && s.createdResourceIds[1]) {
							newLane2.setResourceId(s.createdResourceIds[1]);
						}
						
						if (s.properties instanceof Hash) {
							s.properties.each(function(prop) {
								newLane2.setProperty(prop.key, prop.value);
							});
						}
						
						// Set the bounds of the second lane
						newLane2.bounds.set(s.currentShape.bounds.clone());
						
						// Add both new lanes to the current target
						s.target.add(newLane);
						s.target.add(newLane2);
						
						// Remember the lanes
						this.oldState.createdLanes = [newLane, newLane2];
					}
					
					// Select the newly created Lanes
					this.facade.setSelection(this.oldState.createdLanes);
					this.facade.getCanvas().update();
					
					// Set the parents correctly
					if (!this.adjustChild){
						this.adjustChild = new ORYX.Core.EnsureChildCommand(this.facade, newLane);
					}
					this.adjustChild.execute();
					
					// Update
					this.facade.updateSelection();	
					
					delete this.redo;
				},

				/**
				 * Move the pool up to maintain the target shape's bounds 
				 * @param newLane
				 * @param s
				 */
				movePoolUp : function(newLane, s) {
					s.pool.bounds.moveBy({
						x	: (s.horizontal ? 0 : -newLane.bounds.width()),
						y	: (s.horizontal ? -newLane.bounds.height() : 0)
					});	
					
					// If the pool is outside the canvas, expand it
					if (!this.redo && 
							(s.horizontal && s.pool.bounds.upperLeft().y < 0) ||
							(!s.horizontal && s.pool.bounds.upperLeft().x < 0)) {
						// Expand the canvas
						this.expandCanvas(newLane, s);
					}
				},
				
				/**
				 * Expand the canvas to maintain the same view position
				 * @param newLane
				 * @param s
				 */
				expandCanvas : function(newLane, s) {
					this.facade.raiseEvent({
						type	: ORYX.CONFIG.EVENT_CANVAS_RESIZE,
						position: (s.horizontal ?"N" : "W"),
						shrink	: false,
						size	: (s.horizontal ? newLane.bounds.height() : newLane.bounds.width())
					});
				},

				rollback : function() {
					// Rollback adjustment of children
					if (this.adjustChild) {
						this.adjustChild.rollback();
					}
					
					// Shortcut
					var o = this.oldState;
					
					// Delete all removed Lanes
					o.createdLanes.each(function(lane, i) {
						// Remember the resource id of the created Lane
						if (!this.newState.createdResourceIds) {
							this.newState.createdResourceIds = new Array();
						}
						this.newState.createdResourceIds[i] = lane.resourceId;
						// Delete the created Lane
						this.facade.deleteShape(lane);	
					}.bind(this));
					
					// Reset the target shape's bounds
					o.target.bounds.set(o.targetBounds);
					
					// Reset the pool's bounds
					o.pool.bounds.set(o.poolBounds);
					
					this.facade.getCanvas().update();
					this.facade.setSelection([o.target]);
					
					this.redo = true;
				}				
			});
			

			/* CREATE A NEW POOL IF THE TARGET SHAPE IS THE CANVAS */
			if (shape instanceof ORYX.Core.Canvas) {
				pool 		= shape;
				option.type = this.namespace + (this.orientation === "horizontal" ? "Pool" : "VerticalPool");
				
				// Create a new Pool
				this.facade.executeCommands([new ORYX.Core.CreateShapeCommand(option, shape, option.position, dragZone)]);
				return;
			}

			/* CREATE A NEW LANE IF THE TARGET SHAPE IS A POOL OR A LANE */
			else if (this.isLane(shape)) {
				// Get the stencil 
				var stencil 	= shape.getStencil();
				
				// Get the position where the new lane should be placed, check if a sublane could be created
				var position 	= this.getDockingSide(shape.absoluteBounds(), this.facade.eventCoordinates(event.browserEvent || event), this.isSublaneAllowed(shape));
				if (!position) return;
				
				// Get the pool containing the target (if there is any)
				var pool 		= this.getPool(shape);
				// Set the id of the shape to create
				var id 			= this.namespace + (this.orientation === "horizontal" ? "Lane" : "VerticalLane");

				var target = (position === "sub" ? shape : shape.parent);
				
				var newState = {
						id			: id,
						namespace	: this.namespace,
						horizontal	: (this.orientation === "horizontal"),
						target		: target,
						targetId	: target.resourceId,
						targetBounds: target.absoluteBounds().clone(),
						currentShape: shape,
						pool		: pool,
						poolBounds	: pool.bounds.clone(),
						position	: position,
						properties	: {
							"oryx-bgcolor"	 	: shape.properties["oryx-bgcolor"],
							"oryx-bordercolor"	: shape.properties["oryx-bordercolor"]
						}
				};
				
				// Create a new lane
				this.facade.executeCommands([new Command(dragZone, this.facade, newState, event)]);
//				this.facade.executeCommands([new Command(dragZone, this.facade, id, this.namespace, shape, pool, position, event, this.orientation)]);
			}
		}, 
		
		/**
		 * Hides all overlays
		 */
		hideOverlays : function() {
			$H(this.overlayIds||{}).values().each(function(id) {
				this.facade.raiseEvent({
					type		: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
					id			: id
				});
			}.bind(this));
		},

		/**
		 * Returns the side of the pool/lane where the new lane could be docked
		 * @param {ORYX.Core.Bounds} bounds The absolute bounds of the pool/lane
		 * @param {x: Number, y: Number} pos The current position of the cursor
		 * @param {Boolean} subAllowed Determines if a sublane could be created
		 * @returns {pos: {String} Position, adjustment: {x: {Number}x, y: {Number} y}}
		 */
		getDockingSide : function(bounds, pos, subAllowed, preventWidening) {
			if (!(bounds instanceof ORYX.Core.Bounds)) {
				return;
			}
			var ul = bounds.upperLeft();
			var lr = bounds.lowerRight();
			
			var t = this.defaultOverlaySize;
			var width = bounds.width();
			var height = bounds.height();
				
			// shorthand for the modelling direction
			var horizontal = (this.orientation === "horizontal");
			
			// If the pos is out of bounds, widen the bounds and check again
			if (!preventWidening && (horizontal && (pos.y < ul.y || pos.y > lr.y) || !horizontal && (pos.x < ul.x || pos.x > lr.x))) {
				var wb = bounds.clone();
				if (horizontal) {
					wb.moveBy({x:0, y:-30});
					wb.extend({x:0, y: 60});
				} else {
					wb.moveBy({x:-30, y:0});
					wb.extend({x: 60, y:0});
				}
				//wb.widen(30);
				return this.getDockingSide(wb, pos, subAllowed, true);
			}
			
			if (bounds.isIncluded(pos)) {
				// Virtually divide the size of the lane into three parts to determine the position 
				if (subAllowed) {
					if (horizontal && pos.y < ul.y + height/3 || !horizontal && pos.x < ul.x + width/3) {
						return "pre";
					}
					if (horizontal && pos.y < lr.y - height/3 || !horizontal && pos.x < lr.x - width/3) {
						return "sub";
					} else {
						return "post";
					}
				} else {
					if (horizontal && pos.y < ul.y + height/2 || !horizontal && pos.x < ul.x + width/2) {
						return "pre";
					} else {
						return "post";
					}
				}
			}
		},
		
		/**
		 * Returns the pool which contains the given element
		 * @param {ORYX.Core.Node} elem
		 * @returns {ORYX.Core.Node}
		 */
		getPool : function(elem) {
			if (elem instanceof ORYX.Core.Node) {
				return ["Pool", "VerticalPool"].include(elem.getStencil().idWithoutNs()) && elem || this.getPool(elem.parent);
			}
		},
		

		/**
		 * Grafts overlays for each given overlay id in this.overlayIds
		 */
		_createOverlays : function() {

			// The pool id according to the orientation
			var poolId = this.namespace + (this.orientation === "horizontal" ? "Pool" : "VerticalPool");
			
			// Get the default bounds of a bpmn2.0 pool
			this.genericPoolBounds = new ORYX.Core.Node({}, 
					this.facade.getStencilSets()[this.namespace].stencil(poolId)).bounds.clone();

			
			// The ids of the overlays
			this.overlayIds = {
					pre		: "poollanecreation.preoverlay",
					post	: "poollanecreation.postoverlay",
					sub		: "poollanecreation.suboverlay"
			};	

			// The overlay positions
			this.overlayPositions = {
					pre		: (this.orientation === "horizontal" ? "NW" : "NW"),
					post	: (this.orientation === "horizontal" ? "SW" : "NE"),
					sub		: (this.orientation === "horizontal" ? "W" : "N")
			};
			

			// Create an overlay for each given id
			this.overlays = {};
			$H(this.overlayIds||{}).values().each(function(id) {
				
				// Create a new overlay for each id
				this.overlays[id] = ORYX.Editor.graft("http://www.w3.org/2000/svg", null,
						['rect', {
							fill				: "#8dce6b",
							opacity				: "0.4",
							stroke				: "black",
							"stroke-width"		: 1,
							"stroke-dasharray"	: "2,2",
							"pointer-events"	: "none",
							"class"				: "y-docking-overlay"
						}]);
			}.bind(this));
		},
		
		/**
		 * Determines the adjustment to display the overlay according to it's position in the parent container
		 * @param {String} mousePos The position in the parent container
		 * @param {Number} width The width of the parent container
		 * @param {Number} height The height of the parent container
		 * @returns
		 */
		getOverlayAdjustment : function(mousePos) {
			if (!this.genericPoolBounds) return;
			
			// shorthand for the modelling direction
			var horizontal = (this.orientation === "horizontal");
			var width = (horizontal ? this.genericPoolBounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
			var height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : this.genericPoolBounds.height());

			switch (mousePos) {
				case "pre"		: return;
				case "post"		: return (horizontal ? 
											{y : -ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS} :
											{x : -ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS});
				case "sub"		: return (horizontal ?
											{y : -ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS/2}:
											{x : -ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS});
			};
		},
		
		/**
		 * Sets the bounds of the overlay according to the display position
		 * @param {HTMLElement} overlay
		 * @param mouseTarget
		 * @param {String} mousePos The position of the overlay
		 */
		setOverlayBounds : function(overlay, mouseTarget, mousePos) {
			if (!this.genericPoolBounds) return;
			
			// shorthand for the modelling direction
			var horizontal = (this.orientation === "horizontal");
			var width = (horizontal ? this.genericPoolBounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
			var height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : this.genericPoolBounds.height());

			// Get the width and height of the overlay
			switch (mousePos) {
				case "pre"			: width = (horizontal ? mouseTarget.bounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
									  height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : mouseTarget.bounds.height());
									  break;
				case "post"			: width = (horizontal ? mouseTarget.bounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
									  height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : mouseTarget.bounds.height());	
									  break;
				case "sub"			: width = (horizontal ? mouseTarget.bounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
				  					  height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : mouseTarget.bounds.height());	
				  					  break;
			};
			
			// Set the width and height of the overlay
			overlay.setAttributeNS(null, "width", width);
			overlay.setAttributeNS(null, "height", height);
		},
		
		/**
		 * Returns true if the given shape is a Lane
		 * @param {ORYX.Core.Shape} shape
		 * @returns {Boolean}
		 */
		isLane : function(shape) {
			return shape instanceof ORYX.Core.Node && ["VerticalLane", "Lane"].include(shape.getStencil().idWithoutNs());
		},
		
		/**
		 * Returns true if the given shape is a Pool
		 * @param {ORYX.Core.Shape} shape
		 * @returns {Boolean}
		 */
		isPool : function(shape) {
			return shape instanceof ORYX.Core.Node && ["VerticalPool", "Pool"].include(shape.getStencil().idWithoutNs());
		},
		
		/**
		 * Returns true if the given shape is the canvas
		 * @param {ORYX.Core.Shape} shape
		 * @returns {Boolean}
		 */
		isCanvas : function(shape) {
			return shape === this.facade.getCanvas();
		}
		
		
	});
}();
/**
 * Copyright (c) 2011
 * Lukas Brand
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

if ("undefined" === typeof ORYX) var ORYX = {};
if ("undefined" === typeof ORYX.Plugins) ORYX.Plugins = {};

new function() {
	
	ORYX.Plugins.BPMN2_0LaneDrag = ORYX.Plugins.AbstractPlugin.extend({

		/**
		 *	Constructor
		 *	@param {Object} facade: The Facade of the Editor
		 */
		construct: function(facade) {
			
			this.facade = facade;
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_BPMN20_DIAGRAM_ORIENTATION_CHANGED, this._updateOverlays.bind(this));
			
			var me = this;
			
			this.namespace = this.facade.getStencilSets().keys()[0];
			
			this.facade.offer({
				target			: ORYX.Plugins.DragDropResize,
				beforeDragClb	:function(target, e, id) {me.beforeDrag(this, target, e, id);},
				dragOverClb		: function(target, e, options) {me.dragOver(this, target, e, options);},
				dragDropClb		: function(option, shape, event) {return me.dragDrop(this, option, shape, event);},
				afterDragDropClb: function(target, e, id) {me.afterDragDrop(this, target, e, id);}
				
			});
			
			this._updateOverlays();
		},

		/**
		 * Updates the overlays to display when moving a Lane
		 */
		_updateOverlays : function() {
			// Get the modelling direction
			this.orientation = this.facade.getCanvas().getOrientation();

			// Create overlays
			this._createOverlays();

		},
		
		/**
		 * Disables the mouseover event on the canvas to prevent dockers from showing when a pool/lane is dragged.
		 * @param dragZone
		 * @param target
		 * @param e
		 * @param id
		 */
		beforeDrag : function(dragZone, target, e, id) {
			if (dragZone.toMoveShapes.length === 1 && this.isLane(dragZone.toMoveShapes[0])) {
				this.facade.disableEvent(ORYX.CONFIG.EVENT_MOUSEOVER);
			}
		},
		
		/**
		 * Handles mouse move event. Displays an overlay to display where a lane could be dropped.
		 * @param dragZone The context of the drag plugin
		 * @param target
		 * @param e The event
		 * @param id
		 */
		dragOver : function(dragZone, target, e, options) {
			if (!dragZone) return;
			
			if (dragZone.toMoveShapes.length === 1 && this.isLane(dragZone.toMoveShapes[0])) {
				// Disable highlights, use overlays instead
				options.preventHighlights = true;
				
				// Hide any horizontal or vertical snap lines
				(dragZone.vLines||[]).concat(dragZone.hLines||[]).invoke("hide");
				
				// get the drop target
				var dropTarget = this.facade.getCanvas().getAbstractShapesAtPosition(this.facade.eventCoordinates(e)).reverse().find(function(shape) {
					return this.isLane(shape) || this.isPool(shape) || this.isCanvas(shape);
				}.bind(this));
				
//				var dropTarget = upmostNode;//dragZone.containmentParentNode;
				if (!dropTarget || dropTarget === dragZone.toMoveShapes[0]) {
					this.hideOverlays();
					return;
				}
				
				/* If the mouse is currently over a lane,
				 * show the overlays to display where a new lane can be dropped */
				if (this.isLane(dropTarget)) {
					this.handleMouseOverLane(dropTarget, dragZone, e);
					return;
				}
				
//				if (this.isCanvas(dropTarget)) {
//					var nearbyPool = this.getNearbyPool(e);
//					if (nearbyPool && nearbyPool !== dragZone.toMoveShapes[0]) {
//						this.handleMouseOverLane(nearbyPool, dragZone, e);
//						return;
//					}
//				}
				
				dragZone.setNotAllowed();
				this.hideOverlays();
			}
		},
		
		/**
		 * Creates a new pool/lane according to the position where the mouse button was released
		 * @param dragZone
		 * @param option
		 * @param shape
		 * @param event
		 */
		dragDrop : function(dragZone, option, shape, event) {
			// If the moved shape is not a lane or multiple shapes are selected, do nothing
			if (dragZone.toMoveShapes.length !== 1 || !this.isLane(dragZone.toMoveShapes[0])) {
				return;
			}
			
			// OVERRIDE THE TARGET PARENT WITH THE UPMOST LANE|POOL|CANVAS ELEMENT
			dragZone.containmentParentNode = this.facade.getCanvas().getAbstractShapesAtPosition(this.facade.eventCoordinates(event)).reverse().find(function(shape) {
				return this.isLane(shape) || this.isPool(shape) || this.isCanvas(shape);
			}.bind(this));
			
			if (!dragZone.containmentParentNode) return;
			
			// If adding of the lane is not allowed, check if a pool nearby may take the lane
			if (!dragZone.isAddingAllowed || dragZone.containmentParentNode instanceof ORYX.Core.Canvas) {
				if (this.isCanvas(dragZone.containmentParentNode)) {
					// Check if a pool nearby exists
//					var nearbyPool = this.getNearbyPool(event);
//					if (nearbyPool && nearbyPool !== dragZone.toMoveShapes[0]) {
//						dragZone.containmentParentNode = nearbyPool;
//						dragZone.isAddingAllowed = true;
//						return;
//					}
					dragZone.isAddingAllowed = false;
					dragZone.setNotAllowed();
					return;
				}
			}
			
			if (!(dragZone.containmentParentNode.parent instanceof ORYX.Core.Canvas)) {
				dragZone.containmentParentNode = dragZone.containmentParentNode.parent;
			}
			
			return;
		},
		
		/**
		 * Function to call after the mouse button has been released, hides all shown overlays
		 * @param dragZone
		 * @param target
		 * @param e
		 * @param id
		 */
		afterDragDrop : function(dragZone, target, e, id) {
			if (dragZone.toMoveShapes.length === 1 && this.isLane(dragZone.toMoveShapes[0])) {
				this.hideOverlays();
				// Hide any horizontal or vertical snap lines
				(dragZone.vLines||[]).concat(dragZone.hLines||[]).invoke("hide");
				
				// Reenable the mouseover event on the canvas to allow dockers being shown again
				this.facade.enableEvent(ORYX.CONFIG.EVENT_MOUSEOVER);
			}
		},
		
		/**
		 * Returns the primary Lane of a nearby Pool
		 * @param {BrowserEvent} event
		 * @returns {Lane}
		 */
		getNearbyPool : function(event) {
			// Get the mouse position
			var coords = this.facade.eventCoordinates(event);
			// All pools
			var pools = this.facade.getCanvas().getChildShapes().findAll(function(child) {
				return this.isPool(child);
			}.bind(this))
			// Check if the pool is near the mouse position
			.findAll(function(pool) {
				return pool.bounds.isIncluded(coords, 30);
			});
			
			// If more than one pool is close, don't to anything
			if (pools.length !== 1) { return; }
			return pools[0];
			
			// Get all lanes in order
//			var lanes = this.getLanes(pools[0]);
//			var dockingSide = this.getDockingSide(pools[0].bounds, coords, false);
//			
//			if (dockingSide === "pre") return lanes.first();
//			if (dockingSide === "post") return lanes.last();
		},
		
		/**
		 * Returns the upmost possible drop target
		 * @param {ORYX.Core.Shape[]} lastOverElements
		 * @returns {ORYX.Core.Shape} Pool/Lane/Canvas
		 */
		getDropTarget : function(lastOverElements) {
			return (lastOverElements||[]).find(function(el) {
				return this.isCanvas(el) || this.isLane(el) || this.isPool(el);  
			}.bind(this));
		},
		
		/**
		 * Handles mouse over lane situations
		 * @param mouseTarget
		 * @param dragZone
		 */
		handleMouseOverLane : function(mouseTarget, dragZone, event) {
			var mouseCoords = this.facade.eventCoordinates(event);

			// XXX: Sublane allowed?
			var mousePos = this.getDockingSide(mouseTarget.absoluteBounds(), mouseCoords, false); //(dragZone.type === "ORYX.Plugins.DragDropResize" ? false : this.isSublaneAllowed(mouseTarget)));
			if (!mousePos) {
				this.hideOverlays();
				dragZone.setNotAllowed();
				return;
			}
			
			
			// Displays all possible overlays according to the current mouse target
			this.showOverlay(mouseTarget, mousePos);
			dragZone.setAllowed();
			
//			if (["top", "bottom"].include(mousePos)) {
//				this.displayLaneDropHint(dragZone, mousePos);
//			} else if (mousePos === "sub") {
//				this.displaySublaneDropHint(dragZone);
//			}
//			
//			if (!(["top", "bottom"].include(mousePos))) return;
			
			/*
			 * TODO: RECT
			 * Erst in step 2 implementieren: shorten nutzen!
			 */
			
//			// Get the bounds of the target
//			var ab = mouseTarget.absoluteBounds();
//			var ul = ab.upperLeft();
//			var lr = ab.lowerRight();
//			var scale = dragZone.getScale();
//			
//			switch (mousePos) {
//				case "top" :		dragZone.bounds.set(ul.x, ul.y - ab.height(), lr.x, lr.y - ab.height()); break;
//				case "bottom" :		dragZone.bounds.set(ul.x, ul.y + ab.height(), lr.x, lr.y + ab.height()); break;
//			}
//			
//			dragZone.bounds.widen(-5);
//			dragZone.rectangle.resize(dragZone.bounds);
//
//			if (dragZone.rectangle.hidden) {
//				dragZone.rectangle.show();
//			}
		},
				
		/**
		 * Shows all overlays according to the current mouse target
		 * 
		 * @param mouseTarget
		 * @param {String} mousePos
		 */
		showOverlay : function(mouseTarget, mousePos) {
			if (!this.overlays) return;

			// Get the id of the desired overlay
			var id = this.overlayIds[mousePos];
			if (!id || !this.overlays[id]) return;
			// Get the overlay for the given side
			var overlay = this.overlays[id];
						
			// Set the bounds of the overlay according to the display position
			this.setOverlayBounds(overlay, mouseTarget, mousePos);
			
			// Hide any previous instances of the current overlay
			this.hideOverlays();
			
			// Display the overlay
			this.facade.raiseEvent({
				type		: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
				id			: id,
				node		: overlay,
				shapes		: [mouseTarget],
				nodePosition: this.overlayPositions[mousePos],
				adjustment	: this.getOverlayAdjustment(mousePos)
			});
		},
		
		/**
		 * Returns true if it is allowed to create a new sublane
		 * @param mouseTarget
		 * @returns {Boolean}
		 */
		isSublaneAllowed : function(mouseTarget) {
			// If the mouse is currently over a compartment, forbid sublane creation
			if (this.isOverCompartment(mouseTarget)) {
				return false;
			}
			
			if (!(mouseTarget.parent instanceof ORYX.Core.Canvas) && this.isLane(mouseTarget)) {
				return mouseTarget.parent.children.findAll(function(child) {
					if (child instanceof ORYX.Core.Node) {
						return this.isLane(child);
					}
				}.bind(this)).length > 1;
			}
		},
		
		/**
		 * Returns true if the mouse is currently over a compartment
		 * @param {ORYX.Core.Shape} mouseTarget
		 * @returns {Boolean}
		 */
		isOverCompartment : function(mouseTarget) {
			return this.isLane(mouseTarget) && mouseTarget.children.any(function(child) {
				return this.isLane(child);
			}.bind(this));
		},
		
		/**
		 * Sets the bounds of the sublane overlay
		 * @param mouseTarget
		 */
		showSublaneOverlay : function(mouseTarget) {
			var subOverlay = this.overlays[this.overlayIds.sublane];
			var horizontal = (this.orientation === "horizontal");
			
			// Display the sublane overlay
			if (subOverlay) {
				var width = (horizontal ? mouseTarget.bounds.width() / 3 : mouseTarget.bounds.width() - (2 * this.defaultOverlaySize));
				var height = (horizontal ? mouseTarget.bounds.height() - (2 * this.defaultOverlaySize) : mouseTarget.bounds.height() / 3);
				subOverlay.setAttributeNS(null, "width", width);
				subOverlay.setAttributeNS(null, "height", height);

				this.facade.raiseEvent({
					type		: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
					id			: this.overlayIds.sub
				});

				this.facade.raiseEvent({
					type		: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
					id			: this.overlayIds.sub,
					// The target container for the overlay
					shapes		: [mouseTarget],
					node		: subOverlay,
					nodePosition: "NE"
				});
			}
		},
		
		/**
		 * Sets the size of the displayed overlay according to the selected modelling direction
		 * @param {ORYX.Core.Bounds} bounds
		 */
		updateOverlayBounds : function(bounds) {
			this.overlay.setAttributeNS(null, "width", (this.orientation === "horizontal" ? mouseTarget.bounds.width() : this.defaultOverlaySize));
			this.overlay.setAttributeNS(null, "height", (this.orientation === "horizontal" ? this.defaultOverlaySize : mouseTarget.bounds.height()));
			
		},
		
		/**
		 * Hides all overlays
		 */
		hideOverlays : function() {
			$H(this.overlayIds||{}).values().each(function(id) {
				this.facade.raiseEvent({
					type		: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
					id			: id
				});
			}.bind(this));
		},

		/**
		 * Returns the side of the pool/lane where the new lane could be docked
		 * @param {ORYX.Core.Bounds} bounds The absolute bounds of the pool/lane
		 * @param {x: Number, y: Number} pos The current position of the cursor
		 * @param {Boolean} subAllowed Determines if a sublane could be created
		 * @returns {pos: {String} Position, adjustment: {x: {Number}x, y: {Number} y}}
		 */
		getDockingSide : function(bounds, pos, subAllowed, preventWidening) {
			if (!(bounds instanceof ORYX.Core.Bounds)) {
				return;
			}
			var ul = bounds.upperLeft();
			var lr = bounds.lowerRight();
			
			var t = this.defaultOverlaySize;
			var width = bounds.width();
			var height = bounds.height();
				
			// shorthand for the modelling direction
			var horizontal = (this.orientation === "horizontal");
			
			// If the pos is out of bounds, widen the bounds and check again
			if (!preventWidening && (horizontal && (pos.y < ul.y || pos.y > lr.y) || !horizontal && (pos.x < ul.x || pos.x > lr.x))) {
				var wb = bounds.clone();
				if (horizontal) {
					wb.moveBy({x:0, y:-this.defaultOverlaySize});
					wb.extend({x:0, y: this.defaultOverlaySize*2});
				} else {
					wb.moveBy({x:-this.defaultOverlaySize, y:0});
					wb.extend({x: this.defaultOverlaySize*2, y:0});
				}
				//wb.widen(30);
				return this.getDockingSide(wb, pos, subAllowed, true);
			}
			
			if (bounds.isIncluded(pos)) {
				// Virtually divide the size of the lane into three parts to determine the position 
				if (subAllowed) {
					if (horizontal && pos.y < ul.y + height/3 || !horizontal && pos.x < ul.x + width/3) {
						return "pre";
					}
					if (horizontal && pos.y < lr.y - height/3 || !horizontal && pos.x < lr.x - width/3) {
						return "sub";
					} else {
						return "post";
					}
				} else {
					if (horizontal && pos.y < ul.y + height/2 || !horizontal && pos.x < ul.x + width/2) {
						return "pre";
					} else {
						return "post";
					}
				}
			}
		},
		
		getPool : function(elem) {
		    if (!elem || !elem.parent) {
		        return;
		    }
		    if (elem.getStencil().id().endsWith("Pool")) {
		        return elem;
		    } else {
		        return this.getPool(elem.parent);
		    }
		},
		
		/**
		 * Returns a set on all child lanes for the given Shape. If recursive is TRUE, also indirect children will be returned (default is FALSE)
		 * The set is sorted by
		 * 		- (Orientation: horizontal): first child has the lowest y-coordinate and the last one the highest.
		 * 		- (Orientation: vertical): first child has the lowest x-coordinate and the last one the highest.
		 * @param {ORYX.Core.Shape} shape
		 * @param {boolean} recursive
		 */
		getLanes: function(shape, recursive){
			// Determine coordinate and side according to the pool orientation
			if(this.orientation === "horizontal") {
				var coord = "y";
				var lengthFN = "height";
				var laneStencilId = "Lane";
			}
			
			else if(this.orientation === "vertical") {
				var coord = "x";
				var lengthFN = "width";
				var laneStencilId = "VerticalLane";
			}
			
			// Get all the child lanes
			var lanes = shape.getChildNodes(recursive||false).findAll(function(node) { return (node.getStencil().id() === this.namespace + laneStencilId); }.bind(this));
			
			
			
			// Sort all lanes by there y coordinate
			lanes = lanes.sort(function(a, b){
				
				// Get y coordinates for upper left and lower right
				var auy = Math.round(a.bounds.upperLeft()[coord]);
				var buy = Math.round(b.bounds.upperLeft()[coord]);
				var aly = Math.round(a.bounds.lowerRight()[coord]);
				var bly = Math.round(b.bounds.lowerRight()[coord]);
				
				var ha	= a.absoluteBounds();
				var hb	= b.absoluteBounds();
				
				// Get the old y coordinates
				var oauy = Math.round(ha.upperLeft()[coord]);
				var obuy = Math.round(hb.upperLeft()[coord]);
				var oaly = Math.round(ha.lowerRight()[coord]);
				var obly = Math.round(hb.lowerRight()[coord]);
				
				// If equal, than use the old one
				if (auy == buy && aly == bly) {
					auy = oauy; buy = obuy; aly = oaly; bly = obly;
				}
				
				if (Math.round(a.bounds[lengthFN]()-ha[lengthFN]()) === 0 && Math.round(b.bounds[lengthFN]()-hb[lengthFN]()) === 0){
					return auy < buy ? -1 : (auy > buy ? 1: 0);
				}
				
				// Check if upper left and lower right is completely above/below
				var above = auy < buy && aly < bly;
				var below = auy > buy && aly > bly;
				// Check if a is above b including the old values
				var slightlyAboveBottom = auy < buy && aly >= bly && oaly < obly;
				var slightlyAboveTop = auy >= buy && aly < bly && oauy < obuy;
				// Check if a is below b including the old values
				var slightlyBelowBottom = auy > buy && aly <= bly && oaly > obly;
				var slightlyBelowTop = auy <= buy && aly > bly && oauy > obuy;
				
				// Return -1 if a is above b, 1 if b is above a, or 0 otherwise
				return  (above || slightlyAboveBottom || slightlyAboveTop ? -1 : (below || slightlyBelowBottom || slightlyBelowTop ? 1 : 0));
			}.bind(this));
					
			// Return lanes
			return lanes;
		},
		
		/**
		 * Grafts overlays for each given overlay id in this.overlayIds
		 */
		_createOverlays : function() {

			// default overlay spread
			this.defaultOverlaySize = 20;
			
			var ss = this.facade.getStencilSets()[this.namespace];
			var genericPool = ss.stencil(this.namespace + (this.orientation === "horizontal" ? "Pool" : "VerticalPool"));
			if (genericPool) {
				this.genericPoolBounds = new ORYX.Core.Node({}, genericPool).bounds.clone();
			}
			
			// The id of the overlay
			this.overlayIds = {
				pre		: "lanedrag.preoverlay",
				post	: "lanedrag.postoverlay",
				sub		: "lanedrag.suboverlay"
			};
			
			// The overlay positions
			this.overlayPositions = {
					pre		: (this.orientation === "horizontal" ? "NW" : "NW"),
					post	: (this.orientation === "horizontal" ? "SW" : "NE"),
					sub		: (this.orientation === "horizontal" ? "W" : "N")
			};

			// Create an overlay for each given id
			this.overlays = {};
			$H(this.overlayIds||{}).values().each(function(id) {
				
				// Create a new overlay for each id
				this.overlays[id] = ORYX.Editor.graft("http://www.w3.org/2000/svg", null,
						['rect', {
							fill				: "#8dce6b",
							opacity				: "0.4",
							stroke				: "black",
							"stroke-width"		: 1,
							"stroke-dasharray"	: "2,2",
							"pointer-events"	: "none",
							"class"				: "y-docking-overlay"
						}]);
			}.bind(this));
		},
		
		/**
		 * Determines the adjustment to display the overlay according to it's position in the parent container
		 * @param {String} mousePos The position in the parent container
		 * @param {Number} width The width of the parent container
		 * @param {Number} height The height of the parent container
		 * @returns
		 */
		getOverlayAdjustment : function(mousePos) {
			if (!this.genericPoolBounds) return;
			
			// shorthand for the modelling direction
			var horizontal = (this.orientation === "horizontal");
			var width = (horizontal ? this.genericPoolBounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
			var height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : this.genericPoolBounds.height());

			switch (mousePos) {
				case "pre"		: return;
				case "post"		: return (horizontal ? 
											{y : -ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS} :
											{x : -ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS});
				case "sub"		: return (horizontal ?
											{y : -ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS/2}:
											{x : -ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS});
			};
		},
		
		/**
		 * Sets the bounds of the overlay according to the display position
		 * @param {HTMLElement} overlay
		 * @param mouseTarget
		 * @param {String} mousePos The position of the overlay
		 */
		setOverlayBounds : function(overlay, mouseTarget, mousePos) {
			if (!this.genericPoolBounds) return;
			
			// shorthand for the modelling direction
			var horizontal = (this.orientation === "horizontal");
			var width = (horizontal ? this.genericPoolBounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
			var height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : this.genericPoolBounds.height());

			// Get the width and height of the overlay
			switch (mousePos) {
				case "pre"			: width = (horizontal ? mouseTarget.bounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
									  height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : mouseTarget.bounds.height());
									  break;
				case "post"			: width = (horizontal ? mouseTarget.bounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
									  height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : mouseTarget.bounds.height());	
									  break;
				case "sub"			: width = (horizontal ? mouseTarget.bounds.width() : ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS);
				  					  height = (horizontal ? ORYX.CONFIG.BPMN20_DEFAULT_OVERLAY_THICKNESS : mouseTarget.bounds.height());	
				  					  break;
			};
			
			// Set the width and height of the overlay
			overlay.setAttributeNS(null, "width", width);
			overlay.setAttributeNS(null, "height", height);
		},
		
		/**
		 * Returns true if the given shape is a Lane
		 * @param {ORYX.Core.Shape} shape
		 * @returns {Boolean}
		 */
		isLane : function(shape) {
			return shape instanceof ORYX.Core.Node && ["VerticalLane", "Lane"].include(shape.getStencil().idWithoutNs());
		},
		
		/**
		 * Returns true if the given shape is a Pool
		 * @param {ORYX.Core.Shape} shape
		 * @returns {Boolean}
		 */
		isPool : function(shape) {
			return shape instanceof ORYX.Core.Node && ["VerticalPool", "Pool"].include(shape.getStencil().idWithoutNs());
		},
		
		/**
		 * Returns true if the given shape is the canvas
		 * @param {ORYX.Core.Shape} shape
		 * @returns {Boolean}
		 */
		isCanvas : function(shape) {
			return shape === this.facade.getCanvas();
		}
		
		
	});
}();
/**
 * Copyright (c) 2011
 * Sven Wagner-Boysen
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

new function(){
	
	ORYX.Plugins.BPMN2_0ModelingDirection = {
	
		/**
		 *	Constructor
		 *	@param {Object} Facade: The Facade of the Editor
		 */
		construct: function(facade){
			this.facade = facade;
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.init.bind(this));
			
			this.orientation = this.facade.getCanvas().getOrientation();
			
			// Factor defining the aspect ratio between horizontal and vertical
			// orientation, oriented at the dimensions of a task shape
			this.oFactor = 0.7;
			
			this.commands = [];
			
			// register callback in property window
			var me = this;
	        this.facade.offer({
	        	target: ORYX.Plugins.PropertyWindow,
	        	
	        	// property window configuration fields
	        	category	: "popular",
	        	name		: Signavio.I18N.BPMN20pools.modelingDirectionSwitch,
	        	value		: function() {
	        		var o = me.facade.getCanvas().getOrientation();
	        		return Signavio.I18N.BPMN20pools[o] || o;
	        	},
	        	icons		: [],
	        	generateEditor		: me.prepareEditor.bind(me),
	        	enabled		: function() {
	        		return (me.facade.getSelection().length == 0 
	        			&& me.facade.getCanvas().getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#BPMNDiagram");
	        	}
			});
		},
		
		/**
		 * Performs a check wether to enlight or hide swimlane elements.
		 */
		checkVisibleStencils: function() {
			if(this.orientation === "horizontal") {
				this.enableHorizontalSwimlanes();
 			}
			
			else if(this.orientation === "vertical") {
				this.enableVerticalSwimlanes();
			}
			
			if(!this.facade.isExecutingCommands()) {
				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_STENCIL_SET_LOADED});
			}
		},
		
		/**
		 * Enables:
		 * 		Pool, Lane and CollapsedPool.
		 * 
		 * Disables: 
		 * 		VerticalPool, VerticalLane, CollapsedVerticalPool
		 * 
		 */
		enableHorizontalSwimlanes: function() {
			var stencilSet;
			stencilSet = this.facade.getStencilSets()["http://b3mn.org/stencilset/bpmn2.0#"];
			
			if(!stencilSet) {return;}
			
			if (!ORYX.CONFIG.BPMN20_SHAPEREPOSITORY_HIDE_POOLS_LANES){
				this._setStencilProperty(stencilSet, "Pool", "hide", false);
				this._setStencilProperty(stencilSet, "Lane", "hide", false);
				this._setStencilProperty(stencilSet, "VerticalPool", "hide", true);
				this._setStencilProperty(stencilSet, "VerticalLane", "hide", true);
			}
			this._setStencilProperty(stencilSet, "CollapsedPool", "hide", false);
			this._setStencilProperty(stencilSet, "CollapsedVerticalPool", "hide", true);
		},
		
		/**
		 * Disables:
		 * 		Pool, Lane and CollapsedPool.
		 * 
		 * Enables: 
		 * 		VerticalPool, VerticalLane, CollapsedVerticalPool
		 * 
		 */
		enableVerticalSwimlanes: function() {
			var stencilSet;
			stencilSet = this.facade.getStencilSets()["http://b3mn.org/stencilset/bpmn2.0#"];
			
			if(!stencilSet) {return;}
			
			if (!ORYX.CONFIG.BPMN20_SHAPEREPOSITORY_HIDE_POOLS_LANES){
				this._setStencilProperty(stencilSet, "Pool", "hide", true);
				this._setStencilProperty(stencilSet, "Lane", "hide", true);
				this._setStencilProperty(stencilSet, "VerticalPool", "hide", false);
				this._setStencilProperty(stencilSet, "VerticalLane", "hide", false);
			}
			this._setStencilProperty(stencilSet, "CollapsedPool", "hide", true);
			this._setStencilProperty(stencilSet, "CollapsedVerticalPool", "hide", false);
		},
		
		_setStencilProperty: function(stencilSet, stencilId, prop, value) {
			var stencil = stencilSet.stencil(stencilSet.namespace() + stencilId);
			
			if(!stencil) {return;}
			
			stencil._jsonStencil[prop] = value;
		},
 		
		/**
		 * Function to create the editor field for the property window.
		 * 
		 * @returns {Ext.Editor}
		 */
		prepareEditor: function() {
			
			var store = new Ext.data.SimpleStore({
		        fields: [
		            {name: 'icon'},
					{name: 'title'},
					{name: 'value'}	
				],
		        data : [
		                ["/stencilsets/bpmn2.0/icons/swimlane/lane.png", Signavio.I18N.BPMN20pools["horizontal"], "horizontal"],
		                ["/stencilsets/bpmn2.0/icons/swimlane/vertical.lane.png", Signavio.I18N.BPMN20pools["vertical"], "vertical"]
		        ]
		    });
			
			var me = this;
			var editor = new Ext.ux.form.ComboBox({
				tpl: '<tpl for="."><div class="x-combo-list-item">{[(values.icon) ? "<img src=\'" + values.icon + "\' style=\'float: left; margin-right: 2px;\'/>" : ""]} {[values.title.escapeHTML()]}</div></tpl>',
		        store			: store,
		        displayField	:'title',
				valueField		: 'value',
				typeAhead		: true, 
				triggerAction	: 'all',
				mode			: "local",
		        selectOnFocus	: false,
				forceSelection	: true,
				editable		: false,
				readOnly		: false,
				listeners		: {
					select		: function(comp, data) {
						me.toggleDirection(data.data.value, comp);
					}
				}
			});
			
			return new Ext.Editor(editor);
		},
		
		init: function() {
//			var isNewModel = this.facade.getModelMetaData()['new'];
//			
//			// Backward compatibility: the orientation of store models without
//			// defined orientation assume a horizontal orientation
//			if(!isNewModel && !this.facade.getCanvas().orientation) {
//				this.facade.getCanvas().setOrientation("horizontal");
//				this.orientation = "horizontal";
//			}

			// enable swimlanes depending on the orientation of the model
			this.checkVisibleStencils();	
		},
		
		toggleDirection: function(orientation, comp) {
			if(!orientation 
					|| (orientation !== "vertical" && orientation !== "horizontal")
					|| orientation === this.facade.getCanvas().getOrientation()) {
				return;
			}
			
			var me = this;
			
			// Show a dialog using config options:
			Ext.Msg.show({
			   title	: Signavio.I18N.BPMN20pools.warningBoxTitle,
			   msg		: Signavio.I18N.BPMN20pools.warningBoxMsg,
			   buttons	: Ext.Msg.YESNO,
			   fn		: function(bn) {
				   if(bn === "yes") {
					   me.orientation = orientation;
					   me.translateModel();
				   } else {
					   me.facade.updateSelection();
				   } 
			   },
			   icon: Ext.MessageBox.QUESTION
			});
		},
		
		/**
		 * Command to handle the orientation of the canvas.
		 * 
		 * @param orientation
		 */
		setCanvasOrientation: function(orientation) {
			var CanvasOrientation = ORYX.Core.Command.extend({
				construct: function(orientation, facade, plugin){
					this.facade = facade;
					this.oldOrientation = this.facade.getCanvas().getOrientation();
					this.orientation = orientation;
					this.plugin = plugin;
				},
				execute: function(){
					this.facade.getCanvas().setOrientation(this.orientation);
					this.plugin.orientation = this.orientation;
					this.plugin.checkVisibleStencils();
					this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_BPMN20_DIAGRAM_ORIENTATION_CHANGED});
				},
				rollback: function(){
					this.facade.getCanvas().setOrientation(this.oldOrientation);
					this.plugin.orientation = this.oldOrientation;
					this.plugin.checkVisibleStencils();
					this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_BPMN20_DIAGRAM_ORIENTATION_CHANGED});
				}
			});
			
			this.commands.push(new CanvasOrientation(orientation, this.facade, this));
		},
		
		/**
		 * Changes the canvas's width and height values with respect to and 
		 * orientation factor.
		 */
		resizeCanvas: function() {
			var CanvasResize = ORYX.Core.Command.extend({
				construct: function(orientation, facade, me){
					this.facade = facade;
					this.oldBounds = facade.getCanvas().bounds.clone();
					this.zoomFactor = facade.getCanvas().getZoom();
					this.factor = me.oFactor||1;
				},
				execute: function(){
					var w = this.oldBounds.width() * this.factor * this.zoomFactor;
					var h = this.oldBounds.height() * (1/this.factor) * this.zoomFactor;
					
					this.facade.getCanvas().setSize({width: h, height:w});
				},
				rollback: function(){
					var w = this.oldBounds.width() * this.zoomFactor;
					var h = this.oldBounds.height() * this.zoomFactor;
					
					this.facade.getCanvas().setSize({width: w, height:h});
				}
			});
			
			this.commands.push(new CanvasResize(this.orientation, this.facade, this));
		},
		
		
		translateModel: function() {
			this.commands = [];
			
			// horizontal to vertical
			if(this.orientation === "vertical") {
				this.setCanvasOrientation(this.orientation);
				this.resizeCanvas();
				this.checkVisibleStencils();
				this.performTranslation();
			}
			
			// vertical to horizontal
			else if(this.orientation === "horizontal") {
				this.setCanvasOrientation(this.orientation);
				this.resizeCanvas();
				this.performTranslation();
				this.checkVisibleStencils();
			}
		},
		
		performTranslation: function() {
			
			// 1. translate all shapes on the canvas recursively
			// 2. morph horizontal pool/lane to vertical pool/lane
			// 3. resize canvas if necessary
			// (4.) create commands
//			this.commands = [];
			
			// Handle nodes first 
			// DEPERCATED: ... to register the movement of subprocesses
			this.facade.getCanvas().getChildNodes().each(function(child) {
				this.translateBounds(child);
				this.switchLaneOrientation(child);
			}.bind(this));
			
			// Transform edges
			this.facade.getCanvas().getChildEdges().each(function(e) {
				this.translateBounds(e);
			}.bind(this));
			
			if(this.commands && this.commands.length > 0) {
				this.facade.executeCommands(this.commands);
			} 
			
			delete this.commands;
			
		},
		
		/**
		 * Performs the transition between horizontal and vertical orientation
		 * for a single shape.
		 * 
		 */
		translateBounds: function(shape) {
			var TranslateBounds = ORYX.Core.Command.extend({
				construct: function(shape, bounds, stencilId, facade, me){
					this.oldBounds = bounds.clone();
					this.bounds = bounds;
					this.stencilId = stencilId;
					this.oldDockedBounds = {};
					
					this.shape = shape;
					
					this.newBounds = undefined;
					
					this.factor = me.oFactor||1;
					this.orientation = me.orientation;
				},
				execute: function(){
					var cn = this.oldBounds.center();
					var ul = this.oldBounds.upperLeft();
					var lr = this.oldBounds.lowerRight();
					var w = this.oldBounds.width();
					var h = this.oldBounds.height();
					
					
					// Pool/Lane container, ignore collapsed pools
					if((this.stencilId.endsWith("Pool") || this.stencilId.endsWith("Lane") 
						|| this.stencilId === "Subprocess" || this.stencilId === "EventSubprocess"
						|| this.stencilId === "Group")
							/*&& this.stencilId.indexOf("Collapsed") == -1*/) {
						w *= this.factor;
						h *= (1 / this.factor);
						
						// Move subprocesses according to the lane header
						if(this.stencilId.endsWith("Subprocess")) {
							// consider caption area of pools and lanes
							var depth = this.getLaneDepth(this.shape);
							cn.x += (this.orientation === "vertical" ? depth * 30 : 0);
							cn.y += (this.orientation === "horizontal" ? depth * 30 : 0);
							
							cn.x *= this.factor;
							cn.y *= (1 / this.factor);
							
							cn.x -= (this.orientation === "vertical" ? depth * 30 : 0);
							cn.y -= (this.orientation === "horizontal" ? depth * 30 : 0);
							
//							this.bounds.centerMoveTo(cn.y, cn.x);
//							
//							
//							var depth = this.getLaneDepth(this.shape);
//							var yOff = (this.orientation === "vertical" ? depth * (1 - this.factor) * 30 : 0);
//							var xOff = (this.orientation === "horizontal" ? depth * (1 - this.factor) * 30 : 0);
							
//							cn.x -= yOff;
//							cn.y += xOff;
						} else {
							cn.x *= this.factor;
							cn.y *= (1 / this.factor);
						}

						this.bounds.set(cn.y - h/2, cn.x - w/2, cn.y + h/2, cn.x + w/2);
						
					}
					// Edges
					else if(this.shape instanceof ORYX.Core.Edge) {
						this.convertEdgeDocker(this.shape);
						this.shape.getDockers().each(function(docker) {
							// translate only undocked docker
							if(!docker.getDockedShape()) {
								var cn = docker.bounds.center();
								cn.x *= this.factor;
								cn.y *= (1 / this.factor);
								docker.bounds.centerMoveTo(cn.y, cn.x);
							}
						}.bind(this));
					}
					// Nodes
					else {
						// Attached Intermediate events
						if((this.shape.getDockers()||[]).length == 1 && 
							this.shape.getDockers().first().getDockedShape()) {
							
							this.convertDocker(this.factor, this.shape.getDockers().first().getDockedShape(), this.shape.getDockers().first());
						} 
						
						// others
						else {
							// consider caption area of pools and lanes
							var depth = this.getLaneDepth(this.shape);
							cn.x += (this.orientation === "vertical" ? depth * 30 : 0);
							cn.y += (this.orientation === "horizontal" ? depth * 30 : 0);
							
							cn.x *= this.factor;
							cn.y *= (1 / this.factor);
							
							cn.x -= (this.orientation === "vertical" ? depth * 30 : 0);
							cn.y -= (this.orientation === "horizontal" ? depth * 30 : 0);
							
							this.bounds.centerMoveTo(cn.y, cn.x);
						}
					}
				},
				rollback: function(){
					if(this.shape instanceof ORYX.Core.Node) {
						// Attached Intermediate events
						if((this.shape.getDockers()||[]).length == 1 && 
							this.shape.getDockers().first().getDockedShape()) {
							
							this.convertDocker(this.factor, this.shape.getDockers().first().getDockedShape(), this.shape.getDockers().first(), true);
						} 
						
						// others
						else {
							// reset dockedShapeBounds to prevent shifting dockers
							if(this.shape.getStencil().idWithoutNs().endsWith("Pool")) {
								// outgoing
								(shape.getOutgoingShapes()||[]).invoke("getDockers").invoke("first").each(function(d) {
									d._dockedShapeBounds = this.oldBounds.clone();
								}.bind(this));
								
								// incoming
								(shape.getIncomingShapes()||[]).invoke("getDockers").invoke("last").each(function(d) {
									d._dockedShapeBounds = this.oldBounds.clone();
								}.bind(this));
							}
							
							this.bounds.set(this.oldBounds.upperLeft(), this.oldBounds.lowerRight());
						}
						
					} else if(this.shape instanceof ORYX.Core.Edge) {
						this.convertEdgeDocker(this.shape, true);
						this.shape.getDockers().each(function(docker) {
							// translate only undocked docker
							if(!docker.getDockedShape()) {
								var cn = docker.bounds.center();
								cn.x *= this.factor;
								cn.y *= (1 / this.factor);
								docker.bounds.centerMoveTo(cn.y, cn.x);
							}
						}.bind(this));
					}
				},
				
				/**
				 * Counts the parent lanes of a shape.
				 * 
				 * @param shape
				 */
				getLaneDepth: function(shape, count) {
					var parent = shape.parent;
					if(!parent || !parent.getStencil().id().endsWith("Lane")) {
						return count||0;
					}
					
					return this.getLaneDepth(parent, ((count+1) || 1));
				},
				
				_isScaledContainer: function(shape) {
					return shape.getStencil().id().endsWith("Pool") 
						|| shape.getStencil().id().endsWith("Lane")
						|| shape.getStencil().idWithoutNs() === "Subprocess"
						|| shape.getStencil().idWithoutNs() === "EventSubprocess"
						|| shape.getStencil().idWithoutNs() === "Group";
				},
				
				convertEdgeDocker: function(edge, isRollback) {
					var f = this.factor;
					edge.getDockers().each(function(docker) {
						var node = docker.getDockedShape();
						if(node instanceof ORYX.Core.Node) {
							this.convertDocker(f, node, docker, isRollback);
						}
					}.bind(this));
				},
				
				/**
				 * Transforms dockers of docked edges and attached nodes.
				 * 
				 * @param f
				 * 		scaling factor
				 * @param node
				 * 		the docked reference node
				 * @param docker
				 * 		the docker in question
				 * @param isRollback
				 * 		flag to indicate the command action
				 */
				convertDocker: function(f, node, docker, isRollback) {
					var isSC = this._isScaledContainer(node);
					var w = node.bounds.width();
					var h = node.bounds.height();
					var dx = docker.referencePoint.x;
					var dy = docker.referencePoint.y;
					
					// translate docked docker relative to the nodes
					// bounds dimensions
					var x = (isSC ? w * dy / (w * f) : w * (dy / h));
					var y = (isSC ? h * dx / (h * (1/f)) : h * (dx / w));
					
					// Set reference point and overwrite the old bounds
					// because there was no #update call between resizing 
					// the container and setting the reference point.
					// See Docker#update
					if(isRollback) {
						docker._dockedShapeBounds = this.oldDockedBounds[docker.getId()]||docker._dockedShapeBounds;
						docker.referencePoint = {x:x,y:y};
					} else {
						docker.setReferencePoint({x:x,y:y});
						this.oldDockedBounds[docker.getId()] = docker._dockedShapeBounds;
						docker._dockedShapeBounds = node.bounds.clone();
					}
				}
			});
			
			this.commands.push(new TranslateBounds(shape, shape.bounds, shape.getStencil().idWithoutNs(), this.facade, this));
			
			shape.getChildShapes().each(function(child) {
				this.translateBounds(child);
			}.bind(this));
		},
		
		/**
		 * Depending on the canvas's orientation change horizontal lanes to 
		 * vertical or vice versa.
		 * 
		 * @param shape
		 */
		switchLaneOrientation: function(shape) {
			if(!shape) {
				return;
			}
			
			// horizontal orientation --> vertical to horizontal
			if(this.orientation === "horizontal") {
				if(shape.getStencil().id().endsWith("http://b3mn.org/stencilset/bpmn2.0#VerticalPool")) {
					this.performLaneMorphing(shape, "Pool");
				} else if(shape.getStencil().id().endsWith("http://b3mn.org/stencilset/bpmn2.0#VerticalLane")) {
					this.performLaneMorphing(shape, "Lane");
				} else if(shape.getStencil().id().endsWith("http://b3mn.org/stencilset/bpmn2.0#CollapsedVerticalPool")) {
					this.performLaneMorphing(shape, "CollapsedPool");
				}
			}
			
			// vertical orientation --> horizontal to vertical
			else if(this.orientation === "vertical") {
				if(shape.getStencil().id().endsWith("http://b3mn.org/stencilset/bpmn2.0#Pool")) {
					this.performLaneMorphing(shape, "VerticalPool");
				} else if(shape.getStencil().id().endsWith("http://b3mn.org/stencilset/bpmn2.0#Lane")) {
					this.performLaneMorphing(shape, "VerticalLane");
				} else if(shape.getStencil().id().endsWith("http://b3mn.org/stencilset/bpmn2.0#CollapsedPool")) {
					this.performLaneMorphing(shape, "CollapsedVerticalPool");
				}
				
			}
		},
		
		/**
		 * Queues the command to morph a swimlane shape to the related 
		 * vertical representation.
		 * 
		 * @param shape
		 * @param targetStencilId
		 */
		performLaneMorphing: function(shape, targetStencilId) {
			
			// initialize and queue morph command
			var command = this.morphShape(shape, targetStencilId);
			this.commands.push(command);
		},
		
		// morphing vertical to horizontal and vice versa
		
		/**
		 * {Command implemented}
		 * @param {Shape} shape
		 * @param {Stencil} stencil
		 */
		morphShape: function(shape, stencilId){
		
			var MorphTo = ORYX.Core.Command.extend({
				construct: function(poolShape, stencilId, orientation, checkVisibleStencilsCB, facade){
					this.poolShape = poolShape;
					this.newPoolShape = undefined;
					this.objectsToSerialize = undefined;
					
					this.stencilId = stencilId;
					this.facade = facade;
					
					this.newShapes = {};
					this.shapes = {};
					this.childsOf = {};
					this.orientation = orientation;
					
					// vertical pool extension
					this.checkVisibleStencilsCB = checkVisibleStencilsCB;
					
					// create stencil
					var stencilSet = this.facade.getStencilSets();
					if(stencilSet) {
						this.vLStencil = stencilSet["http://b3mn.org/stencilset/bpmn2.0#"].stencil("http://b3mn.org/stencilset/bpmn2.0#VerticalLane");
						this.hLStencil = stencilSet["http://b3mn.org/stencilset/bpmn2.0#"].stencil("http://b3mn.org/stencilset/bpmn2.0#Lane");
					}
					
				},
				execute: function(){
					
					var shape = this.poolShape;
					
					if(!shape.parent) {return;}
					
					this.facade.setSelection([]);
					
					this.checkVisibleStencilsCB();
					
					// create stencil
					var stencilSet = this.facade.getStencilSets();
					if(!stencilSet) {
						return;
					}
					var stencil = stencilSet["http://b3mn.org/stencilset/bpmn2.0#"].stencil("http://b3mn.org/stencilset/bpmn2.0#" + this.stencilId);
					
					this.newPoolShape = this.performMorphing(shape, stencil);
					
					// Deserialize all attributes
					this.deserializeAttributes();

				},
				rollback: function(){
					
					var newShapes = $H(this.newShapes);

					if (!this.poolShape || !(this.newShapes && newShapes.values().length > 0) || !this.newPoolShape.parent) {return;}
					
					this.facade.setSelection([]);

					this.checkVisibleStencilsCB();
					
					// Append shape to the parent
					this.newPoolShape.parent.add(this.poolShape);
									
					// Add child shapes to the new one
					newShapes.values().each(function(lane) {
						lane.getChildNodes().each(function(s){
								this.shapes[lane.resourceId].add(s);
						}.bind(this));
						
					}.bind(this));
				
					// Set dockers
					this.setRelatedDockers(this.newPoolShape, this.poolShape);
					
					// Delete new shape
					newShapes.values().each(function(s) {
						this.facade.deleteShape(s);
					}.bind(this));
					
					
				},
				
				/**
				 * Stores a maping of morphed shape to the serialized object.
				 * Deserialization is performed later to prevent unnecessary 
				 * update call.
				 * 
				 */
				addToSerializeList: function(o) {
					if(!o.shape || !o.serialized) {return;}
					
					if(!(this.objectsToSerialize instanceof Array)) {
						this.objectsToSerialize = [];
					}
						
					this.objectsToSerialize.push(o);
				},
				
				deserializeAttributes: function() {
					if(this.objectsToSerialize instanceof Array) {
						this.objectsToSerialize.each(function(o) {
							var refPoints = this.recordReferencePoints(o.shape);
							o.shape.deserialize(o.serialized);
							this.restoreReferencePoints(refPoints);
						}.bind(this));
					}
				},
				
				recordReferencePoints: function(shape) {
					var inDocker = shape.getIncomingShapes().invoke("getDockers").invoke("last");
					var outDocker = shape.getOutgoingShapes().invoke("getDockers").invoke("first");
					var refPoints = [];
					
					[].concat(inDocker, outDocker).each(function(docker) {
						refPoints.push({docker: docker, refPoint: docker.referencePoint});
					});
					
					return refPoints;
				},
				
				restoreReferencePoints: function(refPoints) {
					refPoints.each(function(refPoint) {
						refPoint.docker.referencePoint = refPoint.refPoint;
					});
				},
				
				performMorphing: function(shape, stencil, parent) {
					if(!shape.parent && !parent) {return;}
					
					this.shapes[shape.resourceId] = shape;
					var parent = parent || shape.parent;
					var resourceId = shape.resourceId;

					// Serialize all attributes
					var serialized = shape.serialize();
					stencil.properties().each((function(prop) {
						if(prop.readonly()) {
							serialized = serialized.reject(function(serProp) {
								return serProp.name==prop.id();
							});
						}
					}).bind(this));

					// Get shape if already created, otherwise create a new shape
					if (this.newShapes[resourceId]){
						var newShape = this.newShapes[resourceId];
						this.facade.getCanvas().add(newShape);
					} else {
						var newShape = this.facade.createShape({
										type		: stencil.id(),
										namespace	: stencil.namespace(),
										resourceId	: resourceId,
										dontUpdateSelection : true
									});
						newShape.setResourceId(resourceId);
					}

					// calculate new bounds using old shape's upperLeft and new shape's width/height
					var boundsObj = serialized.find(function(serProp){
						return (serProp.prefix === "oryx" && serProp.name === "bounds");
					});

					var changedBounds = null;

					var height = shape.bounds.height();
					var width  = shape.bounds.width();

					// consider the minimum and maximum size of
					// the new shape

					if (newShape.minimumSize) {
						if (shape.bounds.height() < newShape.minimumSize.height) {
							height = newShape.minimumSize.height;
						}


						if (shape.bounds.width() < newShape.minimumSize.width) {
							width = newShape.minimumSize.width;
						}
					}

					if(newShape.maximumSize) {
						if(shape.bounds.height() > newShape.maximumSize.height) {
							height = newShape.maximumSize.height;
						}	

						if(shape.bounds.width() > newShape.maximumSize.width) {
							width = newShape.maximumSize.width;
						}
					}

					changedBounds = {
						a : {
							x: shape.bounds.a.x,
							y: shape.bounds.a.y
						},
						b : {
							x: shape.bounds.a.x + width,
							y: shape.bounds.a.y + height
						}						
					};

					var childShapes = shape.getChildNodes();

					// Set all related dockers
					this.setRelatedDockers(shape, newShape);
					
					// Delete the old shape, but pools only
					if(shape.getStencil().id().endsWith("Pool")) {
						this.facade.deleteShape(shape);
					}

					// Deserialize the new shape - Set all attributes
//					newShape.deserialize(serialized);
					
					// perform deserialization later to prevent an update call.
					this.addToSerializeList({shape: newShape, serialized: serialized});
					
					if(changedBounds !== null) {
						newShape.bounds.set(changedBounds);
					}

					// Try to append the children to the new shape
					this.resetAllChildShapes(childShapes, newShape);

					// Set selection
					//this.facade.setSelection([newShape]);
//						this.facade.updateSelection();
					newShape.isChanged = true;
					
					this.newShapes[resourceId] = newShape;
					
					// Search child lanes recursively
					childShapes.each(function(s) {
						// vertical orientation --> lane to vertical lane
						if(this.orientation === "vertical" && s.getStencil().id().endsWith("http://b3mn.org/stencilset/bpmn2.0#Lane")) {
							this.performMorphing(s, this.vLStencil, newShape);
						}
						
						else if(this.orientation === "horizontal" && s.getStencil().id().endsWith("http://b3mn.org/stencilset/bpmn2.0#VerticalLane")) {
							this.performMorphing(s, this.hLStencil, newShape);
						}
					}.bind(this));
					
					if(parent instanceof ORYX.Core.Shape) {
						parent.add(newShape);
					}
					
					return newShape;
				},

				resetAllChildShapes: function(children, newShape){
					// Get valid/invalid child shapes
					var validChildren = this.getValidChildren(children, newShape);
					
					
					// Add to the new shape
					validChildren.each(function(child){
						newShape.add(child);
					});
					
					
				},
				
				getValidChildren: function(children, shape){
					// Add child shapes to the new one
					return children.findAll(function(child){
						return (!child.getStencil().id().endsWith("Pool") 
							&& !child.getStencil().id().endsWith("Lane"));
					}.bind(this));
				},
				
				/**
				 * Set all incoming and outgoing edges from the shape to the new shape
				 * @param {Shape} shape
				 * @param {Shape} newShape
				 */
				setRelatedDockers: function(shape, newShape){
	
					if(shape.getStencil().type()==="node") {
	
						(shape.incoming||[]).concat(shape.outgoing||[])
							.each(function(i) { 
								i.dockers.each(function(docker) {
									if (docker.getDockedShape() == shape) {
										// Adjust of the reference points is
										// performed later in #convertDocker.
										var rPoint = Object.clone(docker.referencePoint);
										docker.setDockedShape(newShape);
										// Restored old refpoint
										docker.referencePoint = rPoint;
									}
								});	
							});
					}
				}
			});

			// Create command		
			var command = new MorphTo(shape, stencilId, this.orientation, this.checkVisibleStencils.bind(this), this.facade);
			
			return command;
		}
	};
		
	ORYX.Plugins.BPMN2_0ModelingDirection = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN2_0ModelingDirection);
}();


/**
 * Plugin to configure the default orientation to vertical
 */
new function() {
	ORYX.Plugins.DefaultOrientationVertical = {
			
			/**
			 *	Constructor
			 *	@param {Object} Facade: The Facade of the Editor
			 */
			construct: function(facade){
				//VARs
				var isNewModel = facade.getModelMetaData()['new'];
				
				if(isNewModel && !!facade.getCanvas().getOrientation()) {
					facade.getCanvas().setOrientation("vertical");
				}
			}
		};
		
		ORYX.Plugins.DefaultOrientationVertical = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.DefaultOrientationVertical);
}();/**
 * Copyright (c) 2009
 * Philipp Giese
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.BPMN2CONVERSATION = {

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, this.handleDockerDocked.bind(this));		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPE_MENU_CLOSE, this.handleDragDrop.bind(this));
	},
	
	checkForMultiInstance: function(shape) {
		
		var incomingShapes = shape.getIncomingShapes();
		var outgoingShapes = shape.getOutgoingShapes();
		var miProp = shape.properties["oryx-multiinstance"];
		
		if (incomingShapes) {
			incomingShapes.find(function(aShape){
				if (aShape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#ConversationLink") {
					if (miProp) 
						aShape.setProperty("oryx-showforkend", true);
					else 
						aShape.setProperty("oryx-showforkend", false);
				}
			});
		}
		
		if (outgoingShapes) {
			outgoingShapes.find(function(aShape){
				if (aShape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#ConversationLink") {
					if (miProp) 
						aShape.setProperty("oryx-showforkstart", true);
					else 
						aShape.setProperty("oryx-showforkstart", false);
				}
			});
		}
	},
	
	/**
	 * DragDocker.Docked Handler
	 *
	 */	
	handleDockerDocked: function(options) {

		var edge = options.parent;
		var edgeSource = options.target;
		
		if(edge.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#ConversationLink") {
			if(edgeSource.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {
				this.checkForMultiInstance(edgeSource);
				
				this.facade.getCanvas().update();
			}
		}
	},
	
	/**
	 * PropertyWindow.PropertyChanged Handler
	 */
	handlePropertyChanged: function(option) {
		
		var shapes = option.elements;
		var changed = false;

		shapes.each(function(shape) {
			if (shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {								
				this.checkForMultiInstance(shape);
				changed = true;
			}
		}.bind(this));	
		
		if(changed) this.facade.getCanvas().update();
	},
	
	handleDragDrop: function(option) {
		
		var source = option.source;
		var destination = option.destination;
		var changed = false;
		
		source.each(function(shape) {
			// a Communication node was dragged from a participant node
			if(shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {
				this.checkForMultiInstance(shape);
				changed = true;
			}
		}.bind(this));
		
		destination.each(function(shape) {
			// a connection is drawn towards a participant node
			if(shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Communication"){
				var outgoingEdges = shape.getOutgoingShapes();
				
				// we have to check the drawn edge if its ending in an Participant Node
				if(outgoingEdges) {
					outgoingEdges.each(function(aShape) {
						var edgeTarget = aShape.getTarget();
						
						if(edgeTarget) {
							if(edgeTarget.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {
								this.checkForMultiInstance(edgeTarget);
								changed = true;
							}
						}
					}.bind(this));
				}
			}			
			
			if(shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {
				this.checkForMultiInstance(shape);
				changed = true;
			}
		}.bind(this));
		
		if(changed) this.facade.getCanvas().update();
	}
};

ORYX.Plugins.BPMN2CONVERSATION = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN2CONVERSATION);
/**
 * Copyright (c) 2009
 * Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
   @namespace Oryx name space for plugins
   @name ORYX.Plugins
*/
 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
	

/**
 * This plugin provides methodes to layout the choreography diagrams of BPMN 2.0.
 * 
 * @class ORYX.Plugins.Bpmn2_0Choreography
 * @extends ORYX.Plugins.AbstractPlugin
 * @param {Object} facade
 * 		The facade of the Editor
 */
ORYX.Plugins.Bpmn2_0Choreography = {
	
	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;
		
		/* Register on event ORYX.CONFIG.EVENT_STENCIL_SET_LOADED and ensure that
		 * the stencil set extension is loaded.
		 */
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, 
										this.handleStencilSetLoaded.bind(this));
		
		/**
		 * FF 3.0 Bugfixing: Check if all events are loaded
		 */
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, function(){
			if (!this._eventsRegistered) {
				this.handleStencilSetLoaded({});
				this.afterLoad();
			}
		}.bind(this));
		
		this.participantSize = 20;
		this.extensionSizeForMarker = 10;
		this.choreographyTasksMeta = new Hash();
		
		/* Disable the layout callback until the diagram is loaded. */
		this._isLayoutEnabled = false;
	},
	
	
	/**
	 * Check if the 'http://oryx-editor.org/stencilsets/extensions/bpmn2.0choreography#'
	 * stencil set extension is loaded and thus register or unregisters on the 
	 * appropriated events.
	 */
	handleStencilSetLoaded : function(event) {
		
		/* Enable layout callback */
		if(event.lazyLoaded) {
			this._isLayoutEnabled = true;
		}
		
		this.registerPluginOnEvents();
	},
	
	/**
	 * Register this plugin on the events.
	 */
	registerPluginOnEvents: function() {
		this._eventsRegistered = true;
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this.addParticipantsOnCreation.bind(this));
		this.facade.registerOnEvent('layout.bpmn2_0.choreography.task', this.handleLayoutChoreographyTask.bind(this));
		this.facade.registerOnEvent('layout.bpmn2_0.choreography.subprocess.expanded', this.handleLayoutChoreographySubprocessExpanded.bind(this));
		this.facade.registerOnEvent('layout.bpmn2_0.choreography.subprocess.collapsed', this.handleLayoutChoreographySubprocessCollapsed.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.afterLoad.bind(this));

//		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.handlePropertyChanged.bind(this));
	},
	
	/**
	 * Unregisters this plugin from the events.
	 */
	unregisterPluginOnEvents: function() {
//		this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
		//this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, this.addParticipantsOnCreation.bind(this));
//		this.facade.unregisterOnEvent('layout.bpmn2_0.choreography.task', this.handleLayoutChoreographyTask.bind(this));
//		this.facade.unregisterOnEvent('layout.bpmn2_0.choreography.subprocess.expanded', this.handleLayoutChoreographySubprocessExpanded.bind(this));
//		this.facade.unregisterOnEvent('layout.bpmn2_0.choreography.subprocess.collapsed', this.handleLayoutChoreographySubprocessCollapsed.bind(this));
		this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_LOADED, this.afterLoad.bind(this));
	},
	
	/**
	 * Init the meta values for the layout mechanism of the choreography task 
	 * and enables the layout callback
	 * 
	 * @param {Object} event
	 * 		The event object
	 */
	afterLoad : function(event) {
		
		//if(this._isLayoutEnabled) {return;}
		/* Enable the layout callback for choreography activities */
		this._isLayoutEnabled = true;
		
		/* Initialize layout meta values for each choreography task */
		this.facade.getCanvas().getChildNodes(true).each(function(shape){
			if (!(shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyTask" ||
				shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographySubprocessCollapsed" ||
				shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographySubprocessExpanded")) {
				return;
			}

			var participantsOnTop = new Array();
			var participantsOnBottom = new Array();
			
			var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(shape);
			
			/* Get participants */
			var participants = shape.getChildNodes(false).findAll(function(node) {
				return node.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyParticipant";
			}); 
			
			/* Sort participants from up to bottom */
			participants = participants.sort(function(a,b) {
				var ay = Math.round(a.absoluteBounds().upperLeft().y);
				var by = Math.round(b.absoluteBounds().upperLeft().y);
				return  ay < by ? -1 : (ay > by ? 1 : 0);
			});
			
			/* Determine participants on top and bottom side */
			var expectedYValue = 0;
			var participantsExtendedOnTop = 0;
			var participantsExtendedOnBottom = 0;
			participants.each(function(participant) {
				/* Disable Resizing */
				participant.isResizable = false;
				
				var extended = (participant.properties['oryx-multiple_instance'] === "" ? 
						false : participant.properties['oryx-multiple_instance']);
				if(participant.bounds.upperLeft().y == expectedYValue) {
					participantsOnTop.push(participant);
					expectedYValue = participant.bounds.lowerRight().y;
					if (extended) {
						participantsExtendedOnTop++;
					}
				} else {
					/* Participant is member of the bottom band */
					participantsOnBottom.push(participant);
					if (extended) {
						participantsExtendedOnBottom++;
					}
				}
			});
			
			/* Initialize meta values */
			choreographyTaskMeta.numOfParticipantsOnTop = participantsOnTop.length;
			choreographyTaskMeta.numOfParticipantsOnBottom = participantsOnBottom.length;
			choreographyTaskMeta.numOfParticipantsExtendedOnBottom = participantsExtendedOnBottom;
			choreographyTaskMeta.numOfParticipantsExtendedOnTop = participantsExtendedOnTop;
			
			choreographyTaskMeta.bottomYStartValue = (participantsOnBottom.first() ? 
					participantsOnBottom.first().bounds.upperLeft().y : shape.bounds.height());
					
			choreographyTaskMeta.topYEndValue = (participantsOnTop.last() ? 
					participantsOnTop.last().bounds.lowerRight().y : 0);
			
			choreographyTaskMeta.center = choreographyTaskMeta.topYEndValue +
				(choreographyTaskMeta.bottomYStartValue - choreographyTaskMeta.topYEndValue) / 2;
			
			choreographyTaskMeta.oldHeight = shape.bounds.height();
			choreographyTaskMeta.oldBounds = shape.bounds.clone();
			
			choreographyTaskMeta.topParticipants = participantsOnTop;
			choreographyTaskMeta.bottomParticipants = participantsOnBottom;
			
			shape.isChanged = true;
			shape.initialParticipantsAdded = true;
		}.bind(this));
		
		/* Update to force marker positioning */
		this.facade.getCanvas().update();
	},
	
	/**
	 * Handler for 'layout.bpmn2_0.choreography.subprocess.expanded'
	 * Applies the layout for an expanded subprocess. e.g. positioning of the 
	 * text field.
	 * 
	 * @param {Object} event
	 * 		The layout event.
	 */
	handleLayoutChoreographySubprocessExpanded : function(event) {
		if(!this._isLayoutEnabled) {return;}
		
		var choreographyTask = event.shape;
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		var heightDelta = choreographyTask.bounds.height() / choreographyTask._oldBounds.height();
	
		/* Handle text field position */
		var textField = choreographyTask._labels[choreographyTask.getId() + 'text_name'];
		if(textField) {
			var top = choreographyTaskMeta.topYEndValue + 5;

			/* Consider changed in update cycle */
			if(choreographyTask.isResized && heightDelta) {
				textField.y = top / heightDelta;
			} else {
				textField.y = top;
			}
			
		}
	},
	
	
	/**
	 * Handler for 'layout.bpmn2_0.choreography.subprocess.collapsed'
	 * Applies the layout for a collapsed subprocess. 
	 * e.g. plus marker
	 * 
	 * @param {Object} event
	 * 		The layout event.
	 */
	handleLayoutChoreographySubprocessCollapsed : function(event) {
		if(!this._isLayoutEnabled) {return;}
		
		var choreographyTask = event.shape;
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		
		/* Calculate position of the "plus" marker of the subprocess */
		var plusMarker = choreographyTask._svgShapes.find(function(svgShape) {
			return svgShape.element.id == choreographyTask.getId() + 'plus_marker';
		});
		
		var plusMarkerBorder = choreographyTask._svgShapes.find(function(svgShape) {
			return svgShape.element.id == choreographyTask.getId() + 'plus_marker_border';
		});
		
		if(plusMarker && plusMarkerBorder) {
				plusMarker._isYLocked = true;
				plusMarker.y = choreographyTaskMeta.bottomYStartValue - 12;
				
				plusMarkerBorder._isYLocked = true;
				plusMarkerBorder.y = choreographyTaskMeta.bottomYStartValue - 14;
		}
	},
	
	/**
	 * When a choreography task is created, two participants automatically will
	 * be added (one initiating and one returning)
	 * 
	 * @param {Object} event
	 * 		The ORYX.CONFIG.EVENT_SHAPEADDED event
	 */
	addParticipantsOnCreation: function(event) {
		if(!this._isLayoutEnabled) {return;}
		
		var choreographyTask = event.elements.findAll(function(shape){
				return 	shape._stencil&&
						!shape.initialParticipantsAdded && 
						(shape.getStencil().id() === 
							"http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyTask" ||
						 shape.getStencil().id() === 
							"http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographySubprocessCollapsed" ||
						 shape.getStencil().id() === 
							"http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographySubprocessExpanded")
			})
		
		if (choreographyTask.length === 0){
			return;
		}
		
		// Begin Transaction
		this._isLayoutEnabled = false;
		
		choreographyTask.each(function(shape){
			shape.initialParticipantsAdded = true;
			
			if(this.hasParticipants(shape)) {return;}
			
			/* Insert initial participants */
			var participant1 = {
				type:"http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyParticipant",
				position:{x:0,y:0},
				namespace:shape.getStencil().namespace(),
				parent:shape
			};
			var shapeParticipant1 = this.facade.createShape(participant1);
			shapeParticipant1.setProperty('oryx-initiating', true);
			var propEvent = {
				elements 	: [shapeParticipant1],
				key 		: "oryx-initiating",
				value		: true
			};
			this.handlePropertyChanged(propEvent);
			
			var participant2 = {
				type:"http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyParticipant",
				position:{x:0,y:shape.bounds.lowerRight().y},
				namespace:shape.getStencil().namespace(),
				parent:shape
			};
			this.facade.createShape(participant2);
			
		}.bind(this));
		
		// End Transaction
		this._isLayoutEnabled = true;
		
		this.facade.getCanvas().update();
		this.facade.setSelection(choreographyTask);
	},
	
	/**
	 * Returns true if a shape has at least one ChoreographyParticipant
	 * as a children
	 * @param {Object} shape
	 * @return {Boolean}
	 */
	hasParticipants: function(shape){
		return  shape.getChildNodes().any(function(node) {
				return (node.getStencil().id() === 
							"http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyParticipant");
			});
	},
	
	/**
	 * Initialize the meta data object for the choreography task if necessary and
	 * return it.
	 * 
	 * @param {Object} choregraphyTask
	 * 		The choreography task
	 * @return {Object} choreographyTaskMetaData
	 * 		Positioning values to handle child participants.
	 */
	addOrGetChoreographyTaskMeta: function(choreographyTask) {
		if(!this.choreographyTasksMeta[choreographyTask.getId()]) {
			
			/* Initialize meta values */			
			this.choreographyTasksMeta[choreographyTask.getId()] = new Object();
			this.choreographyTasksMeta[choreographyTask.getId()].numOfParticipantsOnTop = 0;
			this.choreographyTasksMeta[choreographyTask.getId()].numOfParticipantsOnBottom = 0;
			this.choreographyTasksMeta[choreographyTask.getId()].numOfParticipantsExtendedOnBottom = 0;
			this.choreographyTasksMeta[choreographyTask.getId()].numOfParticipantsExtendedOnTop = 0;
			
			this.choreographyTasksMeta[choreographyTask.getId()].bottomYStartValue = 
				choreographyTask.bounds.height();
			this.choreographyTasksMeta[choreographyTask.getId()].topYEndValue = 0;
			this.choreographyTasksMeta[choreographyTask.getId()].center = 
				choreographyTask.bounds.height() / 2;
			
			this.choreographyTasksMeta[choreographyTask.getId()].oldHeight = 
				choreographyTask.bounds.height();
			this.choreographyTasksMeta[choreographyTask.getId()].oldBounds = 
				choreographyTask.bounds.clone();
			
			/* Ensure the side of participants while resizing */
			this.choreographyTasksMeta[choreographyTask.getId()].topParticipants = new Array();
			this.choreographyTasksMeta[choreographyTask.getId()].bottomParticipants = new Array();
			
		}
		return this.choreographyTasksMeta[choreographyTask.getId()];
	},
	
	/**
	 * Adjust the meta values, if the choreography task is resized.
	 * 
	 * @param {Object} choreographyTask
	 * @param {Object} choreographyTaskMeta
	 */
	handleResizingOfChoreographyTask: function(choreographyTask, choreographyTaskMeta) {
		if(choreographyTask.bounds.height() == choreographyTaskMeta.oldHeight) {return;}
		
		/* Ensure that the choreography task is not too small in height */
		
		var minimumHeight = choreographyTaskMeta.numOfParticipantsOnTop 
							* this.participantSize + 
							choreographyTaskMeta.numOfParticipantsExtendedOnTop *
							this.extensionSizeForMarker +
							choreographyTaskMeta.numOfParticipantsOnBottom 
							* this.participantSize +
							choreographyTaskMeta.numOfParticipantsExtendedOnBottom *
							this.extensionSizeForMarker 
							+ 40;
		if(minimumHeight > choreographyTask.bounds.height()) {
			var ul = choreographyTask.bounds.upperLeft();
			var oldUl = choreographyTaskMeta.oldBounds.upperLeft();
			var lr = choreographyTask.bounds.lowerRight();
			var oldLr = choreographyTaskMeta.oldBounds.lowerRight();
			
			if(ul.y != oldUl.y) {
				/* Resized on top side */
				choreographyTask.bounds.set(ul.x, lr.y - minimumHeight, lr.x, lr.y);
			} else if(lr.y != oldLr.y) {
				/* Resized on bottom side */
				choreographyTask.bounds.set(ul.x, ul.y, lr.x, ul.y + minimumHeight);
			}
		}
		
		/* Adjust the y coordinate for the starting position of the bottom participants */
		var yAdjustment = choreographyTaskMeta.oldHeight - choreographyTask.bounds.height();
		choreographyTaskMeta.bottomYStartValue -= yAdjustment;
		
		/* Signals it was resized */
		return true;
	},
	
	/**
	 * Handler for layouting event 'layout.bpmn2_0.choreography.task'
	 * 
	 * @param {Object} event
	 * 		The layout event
	 */
	handleLayoutChoreographyTask: function(event) {
		if(!this._isLayoutEnabled) {return;}
		
		var choreographyTask = event.shape;
		var isNew = !this.choreographyTasksMeta[choreographyTask.getId()];
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		
		var isResized = this.handleResizingOfChoreographyTask(choreographyTask, choreographyTaskMeta);

		var oldCountTop = choreographyTaskMeta.numOfParticipantsOnTop;
		var oldCountBottom = choreographyTaskMeta.numOfParticipantsOnBottom;
		
		/* ------- Handle participants on top side  ------- */
		
		if(isResized) {
			/* Do not calculate the position of a paraticipant if it was only a resizing */
			var participants = choreographyTaskMeta.topParticipants;
		} else {
			var participants = this.getParticipants(choreographyTask,true,false);
			
			if(!participants) {return;}
			this.ensureParticipantsParent(choreographyTask, participants);
		}
		
		var numOfParticipantsExtended = 0;

		/* Put participants into the right position */
		participants.each(function(participant, i) {
			
			/* Disable resizing by the user interface */
			participant.isResizable = false;
			
			participant.setProperty('oryx-corners', "None");
			var isExtended = this.setBoundsOfParticipantDependOnProperties(
													participant,
													i,
													numOfParticipantsExtended,
													choreographyTask.bounds.width(),
													0);
			
			/* Count extended participants */										
			if(isExtended) {numOfParticipantsExtended++;}
													
//			participant.bounds.set(0, i * this.participantSize, 
//								choreographyTask.bounds.width(), 
//								this.participantSize +  i * this.participantSize);
			
			/* The first participants gets rounded corners */
			if(i == 0) {
				participant.setProperty('oryx-corners', "Top");
			}
			
			this.adjustTopBackground(participant);
		}.bind(this));
		
		/* Resize choreography task to top side */
		var resizeFactor = participants.length - 
									choreographyTaskMeta.numOfParticipantsOnTop;
		var resizeFactorExtended = numOfParticipantsExtended -
							choreographyTaskMeta.numOfParticipantsExtendedOnTop;
		
		var bounds = choreographyTask.bounds;
		var ul = bounds.upperLeft();
		var lr = bounds.lowerRight();
		
		if (!isNew)
			bounds.set(ul.x, 
					ul.y - resizeFactor * this.participantSize 
					- resizeFactorExtended * this.extensionSizeForMarker, lr.x, lr.y);
		
		/* Set new top and bottom border values */
		choreographyTaskMeta.topYEndValue = 
							participants.length * this.participantSize 
						+	numOfParticipantsExtended * this.extensionSizeForMarker;
		
		
		/* Set new meta value for top participant band */	
		choreographyTaskMeta.numOfParticipantsExtendedOnTop = numOfParticipantsExtended;
		choreographyTaskMeta.numOfParticipantsOnTop = participants.length;
		choreographyTaskMeta.topParticipants = participants;
		
		
		/* ----- Handle participants on bottom side --------- */
		if(isResized) {
			/* Do not calculate the position of a paraticipant if it was only a resizing */
			var participants = choreographyTaskMeta.bottomParticipants;
		} else {
			var participants = this.getParticipants(choreographyTask,false,true);
			
			if(!participants) {return;}
			this.ensureParticipantsParent(choreographyTask, participants);
		}
		
				
		if (isNew){
			choreographyTaskMeta.bottomYStartValue = (bounds.height() - 
				(participants.length != 0 ? 
					eval(participants.map(function(p){ return this.participantSize + (this.isExtended(p)?this.extensionSizeForMarker:0) }.bind(this)).join("+")) :
					0));
		} else {
			choreographyTaskMeta.bottomYStartValue += 
				resizeFactor * this.participantSize + 
				resizeFactorExtended * this.extensionSizeForMarker;
		}
		
		var bottomStartYValue = choreographyTaskMeta.bottomYStartValue;
		var numOfParticipantsExtended = 0;
		
		/* Put participants into the right position */
		participants.each(function(participant, i) {
			
			/* Disable resizing by the user interface */
			participant.isResizable = false;
			
			participant.setProperty('oryx-corners', "None");
			
			var isExtendedParticipant = 
				this.setBoundsOfParticipantDependOnProperties(participant, 
								i,
								numOfParticipantsExtended,
								choreographyTask.bounds.width(),
								bottomStartYValue);
			
			/* Count extended participants */
			if(isExtendedParticipant) {numOfParticipantsExtended++;}
			
//			participant.bounds.set(0, bottomStartYValue + 
//														 i * this.participantSize, 
//								choreographyTask.bounds.width(), 
//								bottomStartYValue +
//								this.participantSize +  i * this.participantSize);
			
			/* The last participants gets rounded corners */
			if(i == participants.length - 1) {
				participant.setProperty('oryx-corners', "Bottom");
			}
			
			this.adjustTopBackground(participant);
			
		}.bind(this));
		
		/* Resize choreography task to top bottom side */
		
		var resizeFactor = participants.length - 
								choreographyTaskMeta.numOfParticipantsOnBottom;
		var resizeFactorExtended = numOfParticipantsExtended - 
						choreographyTaskMeta.numOfParticipantsExtendedOnBottom;
		
		var bounds = choreographyTask.bounds;
		var ul = bounds.upperLeft();
		var lr = bounds.lowerRight();
		
		if (!isNew)
		bounds.set( ul.x, 
					ul.y, 
					lr.x, 
					lr.y + resizeFactor * this.participantSize 
					+ resizeFactorExtended * this.extensionSizeForMarker);
		
		/* Store new meta values */
		choreographyTaskMeta.numOfParticipantsExtendedOnBottom = numOfParticipantsExtended;
		choreographyTaskMeta.numOfParticipantsOnBottom = participants.length;
		choreographyTaskMeta.bottomParticipants = participants;
		
		/* Check if participants has changed */
		var participantsHasChanged = 	oldCountTop !== choreographyTaskMeta.numOfParticipantsOnTop ||
										oldCountBottom !==choreographyTaskMeta.numOfParticipantsOnBottom;	
		
		/* Handle positioning of sub elements */
		this.ensureCenterPositionOfMagnets(choreographyTask, isResized, participantsHasChanged);
		this.adjustTextFieldAndMarkerPosition(choreographyTask);
		
		choreographyTaskMeta.oldHeight = bounds.height();
		choreographyTaskMeta.oldBounds = bounds.clone();
		
		choreographyTask.minimumSize = {width: 50, height: 40 + ((choreographyTaskMeta.numOfParticipantsOnBottom+choreographyTaskMeta.numOfParticipantsOnTop)*this.participantSize) + ((choreographyTaskMeta.numOfParticipantsExtendedOnBottom+choreographyTaskMeta.numOfParticipantsExtendedOnTop) * this.extensionSizeForMarker)}
	},
	
	/**
	 * Return TRUE if the participant is extended (has the attribute muliple instance)
	 * @param {ORYX.Core.Node} participant
	 */
	isExtended: function(participant){
		return (!participant || participant.properties['oryx-multiple_instance'] === "" ? 
					false : !!participant.properties['oryx-multiple_instance']);
	},
	
	/**
	 * Resizes the participant depending on value of the multi-instances 
	 * property.
	 * 
	 * @param {ORYX.Core.Node} participant
	 * 		The concerning participant
	 * @param {Integer} numParticipantsBefore
	 * 		Number of participants before current
	 * @param {Integer} numParticipantsExtendedBefore
	 *		Number of participants extended in size before current
	 * @param {Float} width
	 * 		The width of the participant
	 * @param {Integer} yOffset
	 * 		Offset for the position of the bottom participants
	 */
	setBoundsOfParticipantDependOnProperties: function(	participant, 
														numParticipantsBefore, 
														numParticipantsExtendedBefore,
														width,
														yOffset) {
		var extended = this.isExtended(participant);
		var ulY = yOffset + 
			numParticipantsBefore * this.participantSize + 
			numParticipantsExtendedBefore * this.extensionSizeForMarker;
		var lrY = yOffset + this.participantSize +
			numParticipantsBefore * this.participantSize + 
			(extended ? (numParticipantsExtendedBefore + 1) * this.extensionSizeForMarker : 
				numParticipantsExtendedBefore * this.extensionSizeForMarker);
		
		participant.bounds.set(	0, 
			ulY, 
			width, 
			lrY);
			
		/* Is a multi-instance participant */
		return extended;
	},
	
	/**
	 * Set the y coordinate for the text field and multiple instance marker 
	 * position in order to ensure that the text or marker is not hidden 
	 * by a participant.
	 * 
	 * @param {ORYX.Core.Node} choreographyTask
	 * 		The choreography task.
	 */
	adjustTextFieldAndMarkerPosition: function(choreographyTask) {
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		var heightDelta = choreographyTask.bounds.height() / choreographyTask._oldBounds.height();
		
		/* Handle text field position */
		var textField = choreographyTask._labels[choreographyTask.getId() + 'text_name'];
		if(textField) {
			var center = choreographyTaskMeta.topYEndValue +
				(choreographyTaskMeta.bottomYStartValue - choreographyTaskMeta.topYEndValue) / 2;

			/* Consider changed in update cycle */
			if(choreographyTask.isResized && heightDelta) {
				textField.y = center / heightDelta;
			} else {
				textField.y = center;
			}
			
		}
		
		/* Handle MI and loop marker position */
		
		/* Loop marker */
		var loopMarker = choreographyTask._svgShapes.find(function(svgShape) {
			return svgShape.element.id == choreographyTask.getId() + 'loop_path';
		});
		if(loopMarker) {
				loopMarker._isYLocked = true;
				loopMarker.y = choreographyTaskMeta.bottomYStartValue - 7;
		}
		
		/* MI parallel marker */
		var miMarker = choreographyTask._svgShapes.find(function(svgShape) {
			return svgShape.element.id == choreographyTask.getId() + 'mi_path';
		}); 
		if(miMarker) {
			miMarker._isYLocked = true;
			miMarker.y = choreographyTaskMeta.bottomYStartValue - 11;
		}
		
		/* MI sequential marker */
		var miSeqMarker = choreographyTask._svgShapes.find(function(svgShape) {
			return svgShape.element.id == choreographyTask.getId() + 'mi_sequential_path';
		}); 
		if(miSeqMarker) {
			miSeqMarker._isYLocked = true;
			miSeqMarker.y = choreographyTaskMeta.bottomYStartValue - 11;
		}
	},
	
	/**
	 * The magnets of choreography activity were placed in the middle of both
	 * participant bands.
	 * 
	 * @param {ORYX.Core.Node} choreographyTask
	 * 		The choregraphy task containing the magnets
	 * @param {boolean} isResized
	 * 		Flag indicating a resizing of the task
	 * @param {boolean} participantsHasChanged
	 * 		Flag indicating if a new participants has been added or 
	 * 		changed the position (e.g.from top to bottom).
	 * 
	 */
	ensureCenterPositionOfMagnets: function(choreographyTask, isResized, participantsHasChanged) {
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		var center = choreographyTaskMeta.topYEndValue + 
					(choreographyTaskMeta.bottomYStartValue 
								- choreographyTaskMeta.topYEndValue) / 2;
		
		var yAdjustment = center - choreographyTaskMeta.center;
		
		var heightDelta = choreographyTask.bounds.height() / 
							choreographyTaskMeta.oldBounds.height();
		if(!yAdjustment && !heightDelta) {return;}
		
		/* Find magnets that should be positioned relativly to the center */
		var magnets = choreographyTask.magnets.findAll(function(magnet) {
			return (!magnet.anchorTop && !magnet.anchorBottom)
		});
		
		/* Move magnets */
		magnets.each(function(magnet) {
			var x = magnet.bounds.center().x;
			var y = (magnet.bounds.center().y + yAdjustment) / heightDelta
			magnet.bounds.centerMoveTo(x,y);
		});
		
		/* Also move dockers */
		var absoluteTopYEndValue = choreographyTask.absoluteBounds().upperLeft().y 
									+ choreographyTaskMeta.topYEndValue;
		var absoluteBottomYStartValue = choreographyTask.absoluteBounds().upperLeft().y 
									+ choreographyTaskMeta.bottomYStartValue;
		var dockers = new Array();
		
		choreographyTask.incoming.each(function(seqFlow) {
			if(!(seqFlow instanceof ORYX.Core.Edge)) {return;}
			var docker = seqFlow.dockers.last();
			if(absoluteTopYEndValue <= docker.bounds.center().y 
				&& docker.bounds.center().y <= absoluteBottomYStartValue ) {
				dockers.push(docker);
			}
		});
		
		choreographyTask.outgoing.each(function(seqFlow) {
			if(!(seqFlow instanceof ORYX.Core.Edge)) {return;}
			var docker = seqFlow.dockers.first();
			if(absoluteTopYEndValue <= docker.bounds.center().y 
				&& docker.bounds.center().y <= absoluteBottomYStartValue ) {
				dockers.push(docker);
			}
		});
		
		if (participantsHasChanged&&choreographyTask.initialParticipantsAdded){
			dockers.each(function(dockerShape) {
				var ref = dockerShape.referencePoint;
				dockerShape.setReferencePoint({x:ref.x,y:(ref.y + yAdjustment) / heightDelta});
			});
		}

		
		/* Update center */
		choreographyTaskMeta.center = center;
	},
	
	/**
	 * Ensure that the parent of the participant is the choreography task.
	 * 
	 * @param {Object} shape
	 * 		The choreography task
	 * @param {Object} participants
	 * 		The participants
	 */
	ensureParticipantsParent: function(shape, participants) {
		if(!shape || !participants) {return;}
		
		participants.each(function(participant) {
			if(participant.parent.getId() == shape.getId()) {return;}
			
			
			
			
			/* Set ChoreographyTask as Parent */
			participant.parent.remove(participant);
			shape.add(participant);
		});
	},
	
	/**
	 * Returns the participants of a choreography task ordered by theire position.
	 * 
	 * @param {Object} shape
	 * 		The choreography task
	 * @param {Object} onTop
	 * 		Flag to get the participants from the top side of the task.
	 * @param {Object} onBottom
	 * 		Flag to get the participants from the bottom side of the task.
	 * @return {Array} participants;
	 * 		The child participants
	 */
	getParticipants: function(shape, onTop, onBottom) {
		if(shape.getStencil().id() !== "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyTask" &&
			shape.getStencil().id() !== "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographySubprocessCollapsed" &&
			shape.getStencil().id() !== "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographySubprocessExpanded") {
			return null;
		}
		
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(shape);
		var center = shape.absoluteBounds().upperLeft().y +
			 choreographyTaskMeta.topYEndValue +
			(choreographyTaskMeta.bottomYStartValue - choreographyTaskMeta.topYEndValue) / 2;
		
		/* Get participants of top side */
		var participantsTop = shape.getChildNodes(true).findAll(function(node) { 
			return (onTop && 
					node.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyParticipant" &&
					node.absoluteBounds().center().y <= center &&
					this.isParticipantOfShape(shape, node)); 
		}.bind(this));
		
		/* Get participants of bottom side */
		var participantsBottom = shape.getChildNodes(true).findAll(function(node) { 
			return (onBottom && 
					node.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyParticipant" &&
					node.absoluteBounds().center().y > center && 
					this.isParticipantOfShape(shape, node)); 
		}.bind(this));
		
		var participants = participantsTop.concat(participantsBottom);
		
		participants = participants.sort(function(a,b) {
			var ay = Math.round(a.absoluteBounds().upperLeft().y);
			var by = Math.round(b.absoluteBounds().upperLeft().y);
			return  ay < by ? -1 : (ay > by ? 1 : 0);
		});
		
		return participants;
	},
	
	/**
	 * Checks if the participant belongs to the shape. Used to detect choreography
	 * tasks inside an expanded choreography subprocess.
	 * 
	 * @param {ORYX.Core.Node} shape
	 * 		The choreography element
	 * 
	 * @param {ORYX.Core.Node} participant
	 * 		The participant node
	 * 
	 * @return {boolean} 
	 * 		True if the participant is a direct child of the shape and is not
	 * 		contained in aother choreography task or subprocess
	 */
	isParticipantOfShape: function(shape, participant) {
		var participantsParent = participant.parent;
		
		/* Get a non-participant parent of the participant */
		while(participantsParent.getStencil().id() === 
				"http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyParticipant") {
			participantsParent = participantsParent.parent;			
		}
		
		/* The detected parent should be the shape */
		
		return participantsParent.getId() === shape.getId();
	},
	
	adjustTopBackground: function(shape){
		var pos = shape.properties["oryx-corners"];
		var bg = $(shape.getId()+"roundedBgRect");
		if (!bg){ return }
		
		if(pos==="Top") {
			bg.setAttributeNS(null, "fill", "url(#"+shape.getId()+"background_top) white");
		} else {
			var bgColor = shape.properties["oryx-color"];
			bg.setAttributeNS(null, "fill", bgColor);
		}	
	},
	
	/**
	 * PropertyWindow.PropertyChanged Handler
	 * 
	 * It sets the correct color of the elements of a participant depending on
	 * either initiating or returning nature.
	 * 
	 * @param {Object} event
	 * 		The property changed event
	 */
	handlePropertyChanged: function(event) {
		var shapes = event.elements;
		var propertyKey = event.key || event.name;
		var propertyValue = event.value;
		
		var changed = false;
		shapes.each(function(shape) {
			if (shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0choreography#ChoreographyParticipant" &&
			propertyKey === "oryx-initiating") {
			
				if (!propertyValue || propertyValue === "false") {
					shape.setProperty("oryx-color", "#acacac");
				}
				else {
					shape.setProperty("oryx-color", "#ffffff");
				}
				
				changed = true;
			}
		})
		
		/* Update visualisation if necessary */
		if(changed) {
			this.facade.getCanvas().update();
		}
	}
	
};

ORYX.Plugins.Bpmn2_0Choreography = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.Bpmn2_0Choreography);
/**
 * Copyright (c) 2010
 * Philipp Giese, Lukas Brand
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 **/

if(!Signavio) { var Signavio = new Object(); }
if(!Signavio.Plugins) { Signavio.Plugins = new Object(); }

new function() {
	
	Signavio.Plugins.ViewsEditor = ORYX.Plugins.AbstractPlugin.extend({
		
		enabled: true,
				
		construct: function() {
		
			arguments.callee.$.construct.apply(this,arguments);					//Superklasse aufrufen
			
			this.facade.offer({
			
				"name"			: Signavio.I18N.ViewsEditor.name,
				"functionality"	: this.showEditor.bind(this),
				"group"			: Signavio.I18N.ViewsEditor.group,
				"icon"			: ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/application_double.png", 	
				"index"			: 0,
				"description"	: Signavio.I18N.ViewsEditor.description,
				"minShape"		: 0,
				"maxShape"		: 0
			
			});
							
		},
				
		getPools: function() {
			var pools = [];
			
			// Find all pools that are currently in the Model
			this.facade.getCanvas().getChildShapes().each(function(shape) {
				if(shape.getStencil().id().endsWith("Pool")) {					
					pools.push(shape);			
				}						
			}.bind(this));
			
			pools.sort(function(a,b) {						
				return (a.bounds.a.y - b.bounds.a.y);					
			});		
			
			return pools;
		},

		
		
		showEditor: function() {			
		
			var setWidth = function(){
				var width = this.body.getPadding("lr");

				var l = this.items.length;
				width += l * 210;
		        var ct = this.body.child(".x-column-inner");
				ct.setWidth(width);
		    }
			
			this.dialog = new Ext.Window({
				
				title			: Signavio.I18N.ViewsEditor.description,
				height			: 450,
				width			: 654,
				autoScroll		: true,
				modal			: true,													
				layout			: "column",												
				bodyStyle		: "padding:10px 10px 10px 0px; background-color:#ffffff",
				cls				: "x-view-window",
				//add new view button
				tbar			: [{
										text		: Signavio.I18N.ViewsEditor.addView,
										icon		: ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/application_form_add.png",
										cls			: "x-btn-text-icon",
										handler		: function() {
											var a = this.generateColumn(undefined, undefined, this.dialog.items.length);
											this.dialog.add(a);
								    		this.dialog.doLayout(true);
											//setWidth.call(this.dialog);
											a.el.scrollIntoView(this.dialog.body);
											
										}.bind(this)
								  }],
				//default view and views					
				items			: [].concat(this.generateColumn(Signavio.I18N.ViewsEditor.defaultView,Signavio.I18N.ViewsEditor.defaultDescription, 0, true), this.getViews()),
							   
				buttons			: [{
				       				   text		: Signavio.I18N.Buttons.save,			
				       				   handler	: function() {
											var panels = this.dialog.items.items;
											var titles = panels.map(function(p){return p.title});
											var uniq = titles.uniq();
											if (uniq.length != titles.length) {
												Ext.Msg.alert(Signavio.I18N.ViewsEditor.duplicateTitles, Signavio.I18N.ViewsEditor.duplicateTitlesTxt);
											}
											else {
												this.saveViews(this.dialog);
												this.dialog.close();
											}
								   		}.bind(this)
				       			   },
				       			   {
				       				   text		: Signavio.I18N.Buttons.cancel,
				       				   handler	: function() {
				       				   		this.dialog.close();
				       			   		}.bind(this)
				       			   }]
				
			});
			//modify horizontal scrolling
			this.dialog.on("afterlayout", setWidth)
		
			this.dialog.show();
			
			this.dialog.on("close", function(){delete this.dialog;}.bind(this))
			
		},
		
		/**
		 * save views from view option window
		 * @param {Ext.Window} dialog
		 */
		saveViews: function(dialog){

			var views = [];
			
			dialog.items.each(function(item, index){
				if(index==0){return;}
				var collapse = [];
				var hide = [];	
				var hideData;
				var hideComments;
				var description;
						
				
				item.items.each(function(pool){
					//save description
					if (pool.colDescription){description = pool.getValue();}		
					//save show pools
					if (pool.dataIndex && pool.poolHide && !pool.getValue()){hide.push(pool.dataIndex);}
					//save collapse pools
					if (pool.dataIndex && pool.poolCollapse && !pool.getValue()){collapse.push(pool.dataIndex);}
					//save show dataObjects
					if (pool.poolData && !pool.getValue()){hideData = true;}
					//save show comments
					if (pool.poolComments && !pool.getValue()){hideComments = true;}
				});
				
				views.push({
						name: item.title,
						description: description,
						definition: {
							collapse: collapse,
							hide: hide,
							hideData: hideData,
							hideComments: hideComments
						}});
			});
						
			// Implement the specific command for property change
			var Change = ORYX.Core.Command.extend({
			    construct: function(facade, views, plugin){
					this.facade = facade;
					this.views = views;
					this.plugin = plugin;
					this.oldViews = this.facade.getModelMetaData().views;
			    },   
			    execute: function(){
			    	this.facade.getModelMetaData().views = this.views;
			    	if(!this.plugin.dialog){this.plugin.showEditor();}
			    	this.facade.updateSelection();
			    	
			    },
			    rollback: function(){
			    	this.facade.getModelMetaData().views = this.oldViews;
			    	if(!this.plugin.dialog){this.plugin.showEditor();}
			    	this.facade.updateSelection();	
			    }
			})
			   
			// Execute the command
			this.facade.executeCommands([new Change(this.facade, views, this)]);
			

		},
		/**
		 * get views as columns, checking checkboxes for view options
		 */
		getViews: function(){

			var views = this.facade.getModelMetaData().views||[];
				
			var columns = [];
			
			views.each(function(view, index){
				var collapse = view.definition.collapse;
				var hideData = view.definition.hideData;
				var hideComments = view.definition.hideComments;
				var hide = view.definition.hide;
				var description = view.description;
				
				var column = this.generateColumn(view.name, description, index);
				
				column.items.getRange().reverse().each(function(pool){
					if (pool.dataIndex && pool.poolHide && hide.include(pool.dataIndex)){pool.setValue(false);}
					if (pool.dataIndex && pool.poolCollapse && collapse.include(pool.dataIndex)){pool.setValue(false);}
					if (pool.poolData && hideData){pool.setValue(false);}
					if (pool.poolComments && hideComments){pool.setValue(false);}
				});
				columns.push(column);
				
			}.bind(this));
			return columns;
		},
		
		/**
		 * generates new view as a column, returns panel
		 * @param {String} title
		 * @param {String} description
		 * @param {Integer}index
		 * @param {boolean}defaultView 
		 */
		generateColumn: function(title, description, index, defaultView){

			var pools = this.getPools();	
			
			//add view
			var panel = new Ext.Panel({
				tools:[{
						//delete view
						id:'close',
						hidden: defaultView,
						handler: function(event, toolEl, panel){
							//confirm
							Ext.Msg.confirm(Signavio.I18N.ViewsEditor.removeView, new Ext.XTemplate(Signavio.I18N.ViewsEditor.removeViewText).apply([title || Signavio.I18N.ViewsEditor.view + ((index||0) + 1)]), function(btn){
								if (btn=="yes"){
									var container = panel.ownerCt;
									container.remove(panel);
									container.doLayout();
								}
							})
						}
					}],
				title				: title || Signavio.I18N.ViewsEditor.view + ((index||0) + 1),
				layout				: 'form',
				width				: 200,
				cls					: "y-view-panel",
				style				: "margin-left:10px;",
				bodyStyle			: "padding:10px;"
			});	
			
			//add title
			var tf = new Ext.form.TextField({
				hideLabel		: true,
				disabled		: defaultView,
				width			: "95%",
				value			: panel.title,
				allowBlank		: true,
				emptyText		: Signavio.I18N.ViewsEditor.blankTitle,
				listeners		: {
										change		: function(ll, value)
										{
													var dialog = this.ownerCt.ownerCt;
													var panels = dialog.items.items;
													panels.each(function(p){
														if(p.title == value){
															this.markInvalid("Dieser Name ist bereits vergeben.");
														} else {
															if (dialog.buttons[0].disabled){
																dialog.buttons[0].enable()
															}
														}
													}.bind(this));
													panel.setTitle(value || Signavio.I18N.ViewsEditor.view + ((index||0) + 1));
										}
								}
			});
			//add description
			var ta = new Ext.form.TextArea({
				hideLabel		: true,
				disabled		: defaultView,
				colDescription	: true,
				width			: "95%",
				value			: description,
				emptyText		: Signavio.I18N.ViewsEditor.blankDescription
			});
			
			panel.add(tf);
			panel.add(ta); 
			
			//add checkboxes for each pool
			pools.each(function(pool, index){
				var c1, c2;
				var isCollapsed = pool.getStencil().id().endsWith("CollapsedPool") || pool.getStencil().id().endsWith("CollapsedVerticalPool");
				
				//show/hide pool
				c1 = new Ext.form.Checkbox({
					boxLabel 		: pool.properties["oryx-name"] ? 
										new Ext.XTemplate(Signavio.I18N.ViewsEditor.show).apply([(pool.properties["oryx-name"]||"").escapeHTML()]) : 
										new Ext.XTemplate(Signavio.I18N.ViewsEditor.show).apply(["<i>Pool " + (index + 1)+"</i>"]),
					dataIndex		: pool.resourceId,
					poolHide		: true,
					hideLabel 		: true,
					//disables option to expand pool if pool is a collapsed pool or the view is the default view  
					listeners		: {	check : function(c, checked){
											if(!checked){c2.setValue(false); c2.disable(true);}
											else if (checked && !defaultView && !isCollapsed){c2.enable(true);}
										}},
					//disables option to hide pool if the view is the default view 
					disabled		: defaultView,
					checked			: true
				});
				
				//expand/collapse pool
				c2 = new Ext.form.Checkbox({
					boxLabel		: Signavio.I18N.ViewsEditor.expanded,
					dataIndex		: pool.resourceId,
					poolCollapse	: true,
					hideLabel		: true,					
					style			: "margin-left:20px;",
					disabled		: isCollapsed || defaultView,
					checked			: !isCollapsed
					 
				});
				
				panel.add(c1);
				panel.add(c2);
				

			}.bind(this));
			
			
			//checkbox to show data objects, it systems and data stores 
			var c3 = new Ext.form.Checkbox({
				boxLabel		: Signavio.I18N.ViewsEditor.allDataObjects,
				poolData		: true,
				hideLabel		: true,
				disabled		: defaultView,
				checked			: true,
				//horizontal line between pools and data objects
				listeners		: {		render : function(){
											this.el.parent(".x-form-item").setStyle(
													{"border-top":"1px solid silver",
														"padding-top":"5px",
														"margin-top":"5px"
													})
								}}
			});
			//checkbox to show comments
			var c4 = new Ext.form.Checkbox({
				boxLabel		: Signavio.I18N.ViewsEditor.allComments,
				poolComments	: true,
				hideLabel		: true,
				disabled		: defaultView,
				checked			: true
			});
			
						
			panel.add(c3);
			panel.add(c4);
			
			panel.on('render', function(){
				panel.header.setWidth(panel.el.getWidth());
			})
			
			return panel;
		}		 
	});	
}();/**
 * Copyright (c) 2010 Signavio
 * @author Lukas Brand
 *
 **/

/**
 * @namespace
 * @name ORYX.Plugins
 */

if ("undefined" === typeof ORYX) {
	var ORYX = {};
}

if("undefined" === typeof ORYX.Plugins) {
	ORYX.Plugins = {};
}
	
new function(){
	
	ORYX.Plugins.Watermark = ORYX.Plugins.AbstractPlugin.extend({
	
		/**
		 *	Constructor
		 *	@param {Object} Facade: The Facade of the Editor
		 */
		construct: function(facade){
			this.facade = facade;
			
			this.facade.registerOnEvent('layout.bpmn2_0.pool', this.handleLayoutPool.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.handlePropertyChanges.bind(this));
		},
		
		/**
		 * Handles changes of the property
		 * @param event
		 * @param node
		 */
		handlePropertyChanges : function(event, node){
			if(!(node.getStencil().id().endsWith("#Pool") || node.getStencil().id().endsWith("#Lane"))) {
				return;
			}
			var label = node.getLabels()[0];
			var onChange = function(){
				label.unregisterOnChange(onChange);
				this.handleLayoutPool(event, node);
			}.bind(this);
			label.registerOnChange(onChange);
		}, 
		
		/**
		 * Returns the current value of the property which is
		 * associated to the given label.
		 * @param shape
		 * @param label
		 * @returns {String}
		 */
		getValue: function(shape, label){
			
			var ref		= label.id.replace(label.shapeId, ""),
				props	= shape.getStencil().properties().findAll(function(r){ return r.type().toLowerCase() == "string" && r.refToView().include(ref); }),
				lang 	= this.facade.getCanvas().getLanguage(),
				prop	= props.find(function(p){ return p.language() == lang; });
			
			if (!prop){ return ""; }
			
			// Put the current language property to the front
			props = [].concat(prop, props.without(prop));

			// Get a language where the property is defined
			var used = props.find(function(pr){ return (shape.properties[pr.prefix()+"-"+pr.id()] || "").strip() || false; });
			
			// Define a suffix where the language is named, if the used property is not the current language.
			var suffix = used && used !== prop ? " ("+(Signavio.I18N.Multilanguage[String(used.language()).toUpperCase()+"_Short"]||used.language())+")" : "";
			
			return (used && (shape.properties[used.prefix()+"-"+used.id()]).strip() + (suffix)) || "";
		},
		
		/**
		 * Handles the layouting of the pool and adds the watermarks.
		 * @param event
		 * @param node
		 */
		handleLayoutPool : function(event, node) {
			if(!node) node = event.shape;
			if (event.type === "layout.bpmn2_0.pool" || event.type === "propertyChanged" && String(event.name).startsWith("oryx-name")) {
				
				var pool, lanes, bounds, height, width, labelText, poolLength, me=this;
				
				// Find all deepest lanes aka the leaves of the tree
				var deepestLanes = [this.getDeepestLanes(node)].flatten();
				// Generate the watermarks for each lane
				deepestLanes.each(function(lane){
					// Get all relevant labels
					lanes = this.getAllParentLanes(lane);
					pool = this.getParentPool(lane);
					bounds = pool.bounds;
					height = bounds.height();
					width = bounds.width();
					labelText = [];
					
					if (!pool){ return; }
					
					// Iterate over all labels but the label of the pool to concatenate the watermark
					lanes.each(function(lane) {
						labelText.push(me.getValue(lane, lane.getLabels()[0])||undefined);
					});
					
					// Strip empty values
					labelText = labelText.compact();
					
					// If no label is generated because the lanes have no titles, generate a label using the name of the pool
					if (labelText.length === 0) {
						labelText.push(me.getValue(pool, pool.getLabels()[0]));
					}
					
				    // Generate the watermark
				    var watermark = ORYX.Editor.graft("http://www.w3.org/2000/svg", null ,
						['text', 
						    {
						        "x":0, "y":0, "fill": "silver", "stroke": "none", "class":"y-node-watermark", "font-size": "12",
						        "text-anchor": "middle","font-style":"italic"
						    }
						].concat([["tspan", {"x":0, "y":0, "dy":0}, labelText.map(function(r){ return String(r).truncate(50); }).join(" - ")]])
				    );
				    // The parent node of the deepest lane
				    var parentNodes = this.getParentNodes(lane);
				    parentNodes.each(function(parent) {
				    	// Find all previous watermarks and remove them
					    $A(parent.childNodes).each(function(child) {
							if (child.tagName === "text" && child.getAttributeNS(null, "class") === "y-node-watermark") {
								parent.removeChild(child);
							}
						});
				    });
				    
				    // Choose long side of horizontal or vertical pool respectivly
				    poolLength = 0;
				    
				    if( this.facade.getCanvas().getOrientation() === "vertical" ) {
				    	poolLength = height;
				    } else if( this.facade.getCanvas().getOrientation() === "horizontal" ) {
				    	poolLength = width;
				    }
				    
				    // Add new watermarks every 300px, if width > 350px.
					for(var i = 1; i < poolLength/750; i+=2) {
						var x = watermark.cloneNode(true);
						
						if(this.facade.getCanvas().getOrientation() === "vertical") {
							x.setAttributeNS(null, "transform", "translate("+(15)+", "+((650*i)-((lanes.length-1)*30))+") rotate(270)");
						}
						
						else {
							x.setAttributeNS(null, "transform", "translate("+((650*i)-((lanes.length-1)*30))+", "+(15)+")");
						}
						
						// Append watermark to the deepest lane.
						lane.getLabels()[0].node.parentNode.appendChild(x);
					}
				}.bind(this));
			}
		},
		
		/**
		 * Returns all parent lanes from the given node.
		 * @param node
		 * @returns {ORYX.Core.Node[]}
		 */
		getAllParentLanes : function(node) {
			var result = [];
			while (node && !(node instanceof ORYX.Core.Canvas)) {
				if (node instanceof ORYX.Core.Node && node.getStencil().id().endsWith("Lane"))
					result.push(node);
				node = node.parent;
		    }
			return result.reverse();
		},

		/**
		 * Returns the pool regarding the given node.
		 * @param node
		 * @returns {ORYX.Core.Node}
		 */
		getParentPool: function(node){
			while (node && !(node instanceof ORYX.Core.Canvas)) {
				if (node instanceof ORYX.Core.Node && node.getStencil().id().endsWith("Pool"))
					return node;
				node = node.parent;
		    }
			return undefined;
		},
		
		/**
		 * Returns the container nodes of the given lane and its parents.
		 * @param node
		 * @returns {SVGNode[]}
		 */
		getParentNodes : function(node) {
			if (!node) { return []; }
		    if (node.parent instanceof ORYX.Core.Canvas) {
		        return [node.getLabels()[0].node.parentNode];
		    } else {
		        return this.getParentNodes(node.parent).concat(node.getLabels()[0].node.parentNode);
		    }
		},
		
		
		/**
		 * Returns the deepest leaves of the given lane or pool.
		 * @param node
		 * @returns {[]}
		 */
		getDeepestLanes : function(node) {
			if (!node) { return []; }
		    var cs = node.children.findAll(function(lane) {
		        if (lane.getStencil instanceof Function &&
		        	lane.getStencil().id().endsWith("Lane")) {
		            return true;
		        } 
		    });
		    if (cs.length === 0) {
		        return node;
		    } else {
		        return cs.collect(function(c){
		            return this.getDeepestLanes(c);
		        }.bind(this));
		    }
		}
	});
		
}();
/**
 * Copyright (c) 2011
 * Adrian Klinger
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 **/

if ("undefined" === typeof Signavio) var Signavio = {};
if ("undefined" === typeof Signavio.Plugins) Signavio.Plugins = {};

new function() {

	
	Signavio.Plugins.ViewsAttributeWindow =  ORYX.Plugins.AbstractPlugin.extend({
	    
		_comboboxStates:{
			opened : Signavio.I18N.ViewDefinition.comboboxStateOpened,
			closed : Signavio.I18N.ViewDefinition.comboboxStateClosed,
			collapse : Signavio.I18N.ViewDefinition.comboboxStateCollapse,
			onlyContent: Signavio.I18N.ViewDefinition.comboboxStateOnlyContent			
		},
		
		construct: function(){
			
			arguments.callee.$.construct.apply(this,arguments);					//Superklasse aufrufen			
			this.facade.offer({		
				name			: '<a style="color:blue;"> '+Signavio.I18N.ViewDefinition.createView + '</a>',
				//name			: 'Neue Sicht definieren',		
				icon			: ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/add.png",
				icons			: [ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/add.png"], 	
				index			: 0,
				target			: ORYX.Plugins.PropertyWindow,
				category		: "view",
				getPanel 		: function(){
					return this.getMainPanel();
				}.bind(this) 
			});   	
			this.checkboxCollection = [];
			// register on selection changed event
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, function(evt,records){
				this.facadeSelectionChanged(evt.elements); 
			}.bind(this));		
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SAVED, function(){
				this.modelWasSaved();
			}.bind(this));
	    		    	    	
	    },    
	    
	    /**		 
		 * create and deliver the panel for the attributepanel in the editor
		 * the panel contains the link to create a view and the links for the defined views
		 */
	    getMainPanel: function()
	    {
	    	
	    	var mainPanel = new Ext.Panel({			    
				layout		: 'anchor',			
				cls			: 'ak-views-general-header-attribute ak-views-expanded-header-attribute ak-views-views-mainpanel ak-views-attribute-header-span',
	    		border		: true,
	    		title		: Signavio.I18N.ViewDefinition.views,	
	    		collapsible : true,
	    		collapsed	: true,
	    		titleCollapse : true,
	    		odd			: true,
	    		hideCollapseTool: true
	    	});
	    	
	    	mainPanel.on('collapse',function(panel){
	    		panel.removeClass("ak-views-expanded-header-attribute");
	    		panel.addClass("ak-views-collapsed-header-attribute");
	    	});
	    	
	    	mainPanel.on('expand',function(panel){
	    		panel.removeClass("ak-views-collapsed-header-attribute");
	    		panel.addClass("ak-views-expanded-header-attribute");
	    		// render the views new
	    		panel.doLayout();
	    	});	    	
	    	
	    	mainPanel.on('render', function(){
	    		mainPanel.ownerCt.on("resize", function(ct, width){
	    			mainPanel.setWidth(width-1);
	    		});
	    		mainPanel.setWidth(mainPanel.ownerCt.getInnerWidth()-1);
	    	});
	    	
	    	// render other views of model
	    	this.panelInPropertyWindow = mainPanel;
	    	//shanglihui 20111230 隐藏属性面板的views视图
	    	//this.renderViewsOfModel();
	    	
	    	return mainPanel;
	    	
	    },	   
	    /**		 
		 * build and deliver the panel for creating a new view
		 */
	    getCreateViewPanel: function(){
	    		    	
	    	var me = this;
	    	var imgURl = ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/add.png";
	        var img = '<img class="ak-views-image-add-button" src="'+imgURl+'" style="padding-right:5px; cursor: pointer;"></img>';
	            	
	    	return new Ext.Panel({
	    		layout: 'anchor',
	    		cls : 'ak-views-subpanel ak-views-create-view-subpanel',
	    		anchor		: '100% 100%',
	    		html: '<a href="#" class="linkToCreateViews ak-views-create-view-link">'+img+Signavio.I18N.ViewDefinition.createNewView+' </a>',
	    		afterRender: function(e){
					Ext.Panel.prototype.afterRender.apply(this, arguments); 
					this.body.query("a.linkToCreateViews").each(function(a){
						Ext.get(a).on("click", function(event){
							Event.stop(event);
							me.showViewEditor(); 
						});
					});
				}
	    	});
	    },
	    
	    /**		 
		 * create and render new Panels for the given views in the view-storage
		 */
	    renderViewsOfModel: function(){
	    	var mainPanel = this.panelInPropertyWindow;
	    	
	    	if (mainPanel.items){
		    	mainPanel.items.each(function(item){
		    		mainPanel.remove(item,true);
		    	}.bind(this));
	    	}
	    	var views = this.getAllViewsFromMeta();
	    	// 
	 	   	
	    	var desc = new Ext.Panel({
	    		html: Signavio.I18N.ViewDefinition.descriptionCreateView ,
	    		cls : "ak-views-view-title-subpanel ak-views-title-panels"
	    	}); 
	    	// add the descritption panel
	    	mainPanel.add(desc);
	    	// add the intial panel for creating views
	    	mainPanel.add(this.getCreateViewPanel());
	    	if (views && views.length> 0){		    
		    	var info = '<img style="padding-left:5px;" '+(Ext.isChrome || Ext.isSafari?'title="':'ext:qtip="') + Signavio.I18N.ViewDefinition.visibleCheckboxesInfo+ '" src="' + ORYX.CONFIG.EXPLORER_PATH + '/src/img/famfamfam/information.png" class="x-info-img"/>';
		    		    	
		    	var titlePanel = new Ext.Panel({
		    		layout: "fit",
		    		html: Signavio.I18N.ViewDefinition.descriptionViewCheckbox + info  ,		  
		    		cls : "ak-views-view-title-subpanel ak-views-title-panels"
		    	});      	
		    			    	
		    	mainPanel.add(titlePanel);
		    	
		    	this.renderGivenViews(); 
		    	
	    	}
	    	mainPanel.doLayout();
	    	  	
	    },
	    
	    renderGivenViews: function(){
	    	var odd = true;
	    	this.checkboxCollection = [];
	    	var views = this.getAllViewsFromMeta();
	    	
	    	views.each(function(view){
	    		this.addNewViewToPanel( this.panelInPropertyWindow,view,odd);
	    		odd = !odd;
	    	}.bind(this));	 
	    },
	    
	    /**		 
		 * create a new panel for a view (viewDefinition) and add this to a parent panel (mainPanel)
		 * if withLayout is true, the mainPanel call the doLayout-method
		 * odd indicates which background color the new panel has
		 */
	    addNewViewToPanel: function(mainPanel,viewDefinition,odd){	   
	    	var me = this;
	    	var definition = viewDefinition;
	    	var textPanel = new Ext.Panel({	
	    		html: '<a href="#" class="linkToCreateViews ak-views-create-view-link">' + viewDefinition.name.escapeHTML() + '</a>',
	    		afterRender: function(e){
					Ext.Panel.prototype.afterRender.apply(this, arguments); 			
					this.body.query("a.linkToCreateViews").each(function(a){						
						Ext.get(a).on("click", function(event){
							Event.stop(event);
							me.showViewEditor(viewDefinition); 
						});
					});
				}
	    	});	    		    		    	
	    		    	
	    	var checkbox = new Ext.form.Checkbox({   
	    		cls 	: 'ak-views-attribute-checkbox-margin'
	    	});	    		    	
	    	
	    	var path = ORYX.CONFIG.EXPLORER_PATH + "/src/img/views/intermediate.gif";

	    	var htmlElement = document.createElement("img");
	    	htmlElement.src = path;
	       		       	
	       	checkbox.on("render",function(checkbox){
	       		checkbox.container.dom.appendChild(checkbox.triStateImage);	       	
	       		Ext.fly(checkbox.triStateImage).on("click",function(){
		    	    Ext.fly(checkbox.triStateImage).hide();
		    	    
		    		var selection = this.facade.getSelection();
					var oldViews = this.getAllViewsFromMeta();;	
					var command = new Signavio.Plugins.ViewsAttributeWindow.CheckboxChangeCommand(selection,viewDefinition,oldViews,checkbox,false,this.facade,this);
		    	    this.facade.executeCommands([command]);
		    				    	    
		    		// neue view an die chekcbix geben, sonst arbeitet sie mit der viewdeifnition die noch alte elemente hat
		    		checkbox.show();		    	    
		    	}.bind(this));
	       		// show antoher image for highlight the checkbox, if mouse is over
	       		Ext.fly(checkbox.triStateImage).on("mouseover",function(){
		    	    var path = ORYX.CONFIG.EXPLORER_PATH + "/src/img/views/intermediate_highlighted.gif";
	       			checkbox.triStateImage.src = path;		    	    
		    	}.bind(this));
	       		// show image by leave the mouse
	       		Ext.fly(checkbox.triStateImage).on("mouseout",function(){
		    	    var path = ORYX.CONFIG.EXPLORER_PATH + "/src/img/views/intermediate.gif";
	       			checkbox.triStateImage.src = path;		    	    
		    	}.bind(this));       		
		    	Ext.fly(checkbox.triStateImage).hide();
	       	}.bind(this));
	    	      
	    	
	       	checkbox.triStateImage = htmlElement;
	    	checkbox.view = viewDefinition;
	       	
	    	checkbox.on('check',function(c,v){
	    		this.viewCheckboxChanged(c,v);
	    	}.bind(this));    		
	    		    		    		    	
	    	this.checkboxCollection.push(checkbox);
	    	
	    	var panel = new Ext.Panel({
	    		cls : (odd === true) ? ' ak-views-subpanel ak-views-odd-subpanel' : 'ak-views-subpanel' ,
	    		layout:'column',
	    		anchor: "100%",
	    		viewName: viewDefinition.name,
	    	    items: [{	    
	    	    	columnWidth: .8,
	    	    	items: [textPanel]
	    	    },{
	    	    	columnWidth: .2,
	    	    	items: [checkbox]
	    	    }]
	    	}); 
	    	    	
	    	mainPanel.add(panel);   	
	    	
	    },	  
	    
	    loadModelFromDefinition:function(definition){
	    	this.viewWindow.containerFrameRightPanel.body.mask(Signavio.I18N.ViewDefinition.preview , "x-waiting-box");         
	    	var riframe = Ext.fly("rightIFrame");
    		if (riframe) riframe.fadeOut({duration: 0.7,remove: false});
	    	var json = this.getInitialJSOnFromCurrentModel();
		   	var html = this.getPreviewHtmlForIFrame(json,Object.toJSON(definition));
		   	this.fillIFramePanelWithHTML(this.viewWindow.rightIFramePanel,html);	
	    },
	    
	    /**		 
		 * show the window for creating and editing existing views
		 * if viewDefinition undefined, there will be create a new view
		 * otherwise the window show the view depends on the viewDefinition
		 */
	    showViewEditor: function(viewDefinition)
		{
			var viewWindow = this.getWindow(viewDefinition);
		
			this.hideElements = [];
			viewWindow.on("show",function(){
				if (viewDefinition !== undefined){
					// view vorhanden
					this.firstLoading = true;
					// lade rechte seite mit der übergegeben definition
					this.loadModelFromDefinition(viewDefinition.definition);
				}else{
					// neue sicht erstellen
					this.refreshRightSide();
				}	
				this.loadInitModelForLeftSide(viewDefinition);
			}.bind(this));
			
			viewWindow.show();	
			
		},
	    
		/**
		 * get the current height of document		
		 */
		getDocHeight: function() {
		    var d = document;
		    return Math.max(
		        Math.max(d.body.scrollHeight, d.documentElement.scrollHeight),
		        Math.max(d.body.offsetHeight, d.documentElement.offsetHeight),
		        Math.max(d.body.clientHeight, d.documentElement.clientHeight)
		    );
		},
		
		/**
		 * get the current width of document		
		 */
		getDocWidth: function() {
		    var d = document;
		    return Math.max(
		        Math.max(d.body.scrollWidth, d.documentElement.scrollWidth),
		        Math.max(d.body.offsetWidth, d.documentElement.offsetWidth),
		        Math.max(d.body.clientWidth, d.documentElement.clientWidth)
		    );
		},
		
		 /**		 
		 * build and deliver the window for creating/editing a view
		 * if viewDefinition is not undefined, the controls will be filled with data of the view
		 * otherwise there are standard-values
		 */
	    getWindow:function(viewDefinition)
	    {
	    	var windowHeight =this.getDocHeight()*0.9;
	    	var windowWidth = this.getDocWidth() *0.94;
	    		    	
	    	var mainWindow;
	    	
	    	//left Panel begin
	    	
	    	var checkboxRoles = new Ext.form.Checkbox({
	    		boxLabel	: Signavio.I18N.ViewDefinition.roles,
	    		types		: ["Pool","VerticalPool","CollapsedVerticalPool","CollapsedPool","processparticipant","Lane","VerticalLane"],	    
	    		idCheckbox	: "Roles",
	    		cls			: "ak-views-legend-checkbox",
	    		checked 	: (viewDefinition == undefined) ? true : !viewDefinition.definition.hideRoles 	    	
	    	});
	    	checkboxRoles.on("check",function(c,v){this.legendCheckboxWasChecked(c,v);}.bind(this));
	    	
	    	var checkboxITSystems = new Ext.form.Checkbox({
	    		boxLabel	: Signavio.I18N.ViewDefinition.itsystems,
	    		types		: ["ITSystem"],	    	
	    		idCheckbox	: "ITSystem",
	    		cls			: "ak-views-legend-checkbox",
	    		checked 	: (viewDefinition == undefined) ? true : !viewDefinition.definition.hideITSystems 	
	    	});
	    	checkboxITSystems.on("check",function(c,v){this.legendCheckboxWasChecked(c,v);}.bind(this));
	    	
	    	var checkboxDataobjects = new Ext.form.Checkbox({
	    		boxLabel	: Signavio.I18N.ViewDefinition.dataobjects,
	    		types		: ["DataObject","DataStore","Message"],	    	
	    		idCheckbox	: "Dataobject",
	    		cls			: "ak-views-legend-checkbox",
	    		checked 	: (viewDefinition == undefined) ? true : !viewDefinition.definition.hideData 	
	    	});
	    	checkboxDataobjects.on("check",function(c,v){this.legendCheckboxWasChecked(c,v);}.bind(this));
	    	
	    	var checkboxComments = new Ext.form.Checkbox({
	    		boxLabel	: Signavio.I18N.ViewDefinition.comments,	
	    		types		: ["TextAnnotation"],
	    		idCheckbox	: "Comments",
	    		cls			: "ak-views-legend-checkbox",
	    		checked 	: (viewDefinition == undefined) ? true : !viewDefinition.definition.hideComments 	
	    	});
	    	checkboxComments.on("check",function(c,v){this.legendCheckboxWasChecked(c,v);}.bind(this));
	    	
	    	
	    	var leftIframePanel = new Ext.Panel({	    		
	    		anchor		: '100% 100%',
				layout		: 'anchor',
	    		id	   		: "leftIFramePanel",
	    		html		: '<iframe id="leftIFrame" style="width:100%;height:100%;border:none;"></iframe>',			
	    		border 		: false,
	    		style 		: "border-top-width:1px; border-top-style:solid;border-top-color:#000000;"    		
	    	});
	    	
	    	var containerFrameLeftPanel = new Ext.Panel({	   
	    		layout 		: 'anchor',
	    		border		: false,
	    		anchor		: '100% 100%',
	    		items		: [leftIframePanel]
	    	});
	    	
	    	var leftPanel = new Ext.Panel({
	    		title		: Signavio.I18N.ViewDefinition.originalView ,
	    		border		:true,
	    		region		: 'center',	 
	    		layout		: 'anchor',
	    		cls 		: 'ak-views-attribute-header ak-views-attribute-border-frame ak-views-attribute-white-box',
	    		bodyStyle	: "background-color:#ffffff; border-right:none; border-left: none; border-bottom:none;",	
	    		split		: true,
	    		items 		: [containerFrameLeftPanel]
	    	});
	    	
	    	//left Panel ends
	    	
	    	//right Panel begin
	    		    	
	    	var nameTextBox = new Ext.form.TextField({
                fieldLabel	: Signavio.I18N.ViewDefinition.name,
                name		: 'viewName',
                allowBlank	: true, 
                //grow		: true,    
                cls			: "ak-view-textbox-size",
                value		: (viewDefinition !== undefined) ? viewDefinition.name : ""
            });
	    	  	
	    	
	    	var namePanel = new Ext.Panel({
	    		defaultType	: 'textfield',
	    		layout		: 'form',
	    		border		: false,
	    		itemCls 	: "ak-view-textbox-label",    		
	    		labelWidth	: 40,
	    		items		: [nameTextBox]
	    	});
	    	
	    	var descriptionTextBox = new Ext.form.TextField({
                fieldLabel	: Signavio.I18N.ViewDefinition.description,
                name		: 'viewName',
                allowBlank	: true, 
                //grow		: true,              
                value 		: (viewDefinition !== undefined) ? viewDefinition.description : "",
    	        emptyText   : Signavio.I18N.ViewDefinition.noDescription    
            });
	    	
	    	var descriptionPanel = new Ext.Panel({
	    		defaultType	: 'textfield',
	    		layout		: 'form',
	    		border		: false,
	    		labelWidth	: 73,
	    		itemCls 	: "ak-view-textbox-label",  
	    		//width		: 280,	    	
	    		items: [descriptionTextBox]
	    	});    		
	    	
	    	var rightIframePanel = new Ext.Panel({	    		
	    		anchor		: '100% 100%',
				layout		: 'anchor',
	    		id	   		: "rightIFramePanel",
	    		html		: '<iframe id="rightIFrame" style="width:100%;height:100%;border:none;"></iframe>',			
	    		border 		: false,	    		
	    		style 		: "border-top-width:1px; border-top-style:solid;border-top-color:#000000;"
	    		
	    	});
	    	
	    	var containerFrameRightPanel = new Ext.Panel({	   
	    		layout 		: 'anchor',
	    		border		: false,
	    		anchor		: '100% 100%',
	    		items		: [rightIframePanel]
	    	});
	    	
	    	var rightPanel = new Ext.Panel({
	    		title		: Signavio.I18N.ViewDefinition.previewTitle,
	    		region		: 'east',    	
	    		border		: true,
	    		layout		: 'fit',
	    		cls 		: 'ak-views-attribute-header ak-views-attribute-border-frame ak-views-attribute-white-box',
	    		bodyStyle	: "background-color:#ffffff; border-right:none; border-left: none; border-bottom:none;",	
	    		split		: true,
	    		width		: windowWidth/2,
	    		items 		: [containerFrameRightPanel]
	    		
	    	});
	    		    	
	    	var cancelButton = new Ext.LinkButton({
	    		text		: Signavio.I18N.ViewDefinition.cancel,
	    		style		:'color: white; display: block; font-size: 11px; padding-bottom: 2px; padding-left: 5px;padding-right: 5px;padding-top: 2px; white-space: nowrap;',
	    		click		: function(){
	    			mainWindow.close();
	    		}.bind(this)
	    	});
	    	
	    	var saveButton = new Ext.Button({
	    		text		: (viewDefinition == undefined) ? Signavio.I18N.ViewDefinition.save : Signavio.I18N.ViewDefinition.saveChanges ,
	    		handler		: function(){
	    			// proofe whehter the name is unquie	    			
	    			var newView =this.getNewViewDefinition();	
	    			
		    		if (this.isValidViewName(newView.name) === false){
		    			Ext.Msg.alert(Signavio.I18N.ViewDefinition.warningName1, Signavio.I18N.ViewDefinition.warningName2 );
		    			return;
		    		}
	    			// get the new view
    		        	
    		    	// get the old veiws
    		    	var oldViews = this.getAllViewsFromMeta();;	
	    			if (viewDefinition !== undefined){	    			
	    				var viewToChange = this.viewWindow.paramViewDefinition;
	    				var command = new Signavio.Plugins.ViewsAttributeWindow.ChangeCommand(newView,viewToChange,oldViews,this.facade,this);
	    				this.facade.executeCommands([command]);	    				
	    			}else{
	    				// create new create-command for view
	    				// get the new view
	    		    	var newView =this.getNewViewDefinition();	    	
	    		    	// get the old veiws
	    		    	var oldViews = this.getAllViewsFromMeta();;	    		    
	    				var command = new Signavio.Plugins.ViewsAttributeWindow.CreateCommand(newView,oldViews,this.facade,this);
	    				this.facade.executeCommands([command]);
	    				
	    			}	    			
	    			mainWindow.close();
	    		}.bind(this)
	    	});
	    	
	    	var synchronCheckbox = new Ext.form.Checkbox({
	    		checked		: true,	    	
	    		itemCls 	: 'ak-views-synchron-checkbox',
	    		labelStyle 	: "color: white !important;",
	    		boxLabel	: Signavio.I18N.ViewDefinition.synchronScroll
	    	});
	    	
	    	synchronCheckbox.on("check",function(c,v){this.viewWindow.isSynchronScrolling = v;}.bind(this));
	    	    	
	    	var formButtons = [synchronCheckbox,cancelButton,saveButton];
	    	
	    	var delButton;
	    	
	    	if (!(viewDefinition == undefined)){
	    		// button for deleting a view
	    		delButton = new Ext.Button({
	    			text	: Signavio.I18N.ViewDefinition.deleteView ,	    			
	    			handler	: function(){
	    				Ext.Msg.confirm(Signavio.I18N.ViewDefinition.attention ,Signavio.I18N.ViewDefinition.attentionDescription  ,function(btn){
	    					if (btn == "yes"){							
								// get the old veiws
			    		    	var oldViews = this.getAllViewsFromMeta();;	
								var command = new Signavio.Plugins.ViewsAttributeWindow.RemoveCommand(viewDefinition,oldViews,this.facade,this);
								this.facade.executeCommands([command]);
			    				mainWindow.close();			    				
							}
						}.bind(this)).setIcon(Ext.MessageBox.QUESTION);	    				
	    			}.bind(this)
	    		});
	    		// button for duplicating a view
	    		dupButton = new Ext.Button({
	    			text	: Signavio.I18N.ViewDefinition.saveDuplicateButton ,	    			
	    			handler	: function(){
	    				   this.duplicateView(mainWindow);	    				  
	    			}.bind(this)
	    		});
	    		
	    		formButtons = [synchronCheckbox,cancelButton,delButton,dupButton,saveButton];
	    	}	    	
	      
	    	
	    	var configPanel = new Ext.Panel({
	    		layout			: 'column',
	    		border			: false,
	    		height			: 50,	    		
	    		items			: [{	    		        
    		        columnWidth	: !Ext.isIPad ? .1 : .11,
    		        items		: [checkboxComments],
    		        bodyStyle	:'padding-top:15px;padding-left:15px;white-space: nowrap;',
    		    	border		: false
    		    },{	    		        
    		        columnWidth	: !Ext.isIPad ? .1 : .11,
    		        items		: [checkboxDataobjects],
    		        bodyStyle	:'padding-top:15px;padding-left:15px;white-space: nowrap;',
    		    	border		: false
    		    },{	    		        
    		        columnWidth	: !Ext.isIPad ? .1 : .11,
    		        items		: [checkboxITSystems],
    		        bodyStyle	:'padding-top:15px;padding-left:15px;white-space: nowrap;',
    		    	border		: false
    		    },{	    		        
    		        columnWidth	: !Ext.isIPad ? .1 : .13,
    		        items		: [checkboxRoles],
    		        bodyStyle	:'padding-top:15px;padding-left:15px;white-space: nowrap;',
    		    	border		: false
    		    },{	    		        
    		        columnWidth	: !Ext.isIPad ? .25 : .2,
    		        items		: [namePanel],
    		        bodyStyle	:'padding-top:' + Ext.isIPad ? '15' : '13' + 'px;padding-left:15px;white-space: nowrap;',
    		    	border		: false
    		    },{	    		        
    		        columnWidth	: !Ext.isIPad ? .35 : .33,
    		        items		: [descriptionPanel],
    		        bodyStyle	:'padding-top:' + Ext.isIPad ? '15' : '13' + 'px;padding-left:25px;white-space: nowrap;',
    		    	border		: false
    		    }]
	    	});
	    	
	    	configPanel.on("afterlayout", function(panel,layout){
	    		if (panel.getSize().width < 1024) return;
	    		if (configPanel.rendered){
		    		var columnsItems = panel.items;
		    		var checkboxPadding = 40;
		    		var panelWidth = panel.getSize().width;
		    		if (columnsItems){
		    			// layout 4 checkboxes
		    			for (i=0; i < 4; i++){
			    			var col = columnsItems.items[i];
			    			if (col.rendered && col.items.items[0].rendered){			    				
			    				var labelWidth = col.items.items[0].container.dom.childElements()[0].childElements()[1].getWidth();
			    				var checkboxWidth = col.items.items[0].getSize().width;
			    				var newWidth = labelWidth + checkboxWidth + checkboxPadding;
			    				panelWidth -= newWidth;
			    				col.setWidth(newWidth);
			    			}
			    			
			    		}
		    			// layout 5.column (name textbox)
		    			var col = columnsItems.items[4];
		    			if (col.rendered && col.items.items[0].rendered){
		    				col.setWidth(300);
		    				panelWidth -= 300;
		    			}
		    			// layout 6.column (description textbox)
		    			var col = columnsItems.items[5];
		    			if (col.rendered && col.items.items[0].rendered){
		    				col.setWidth(panelWidth);
		    				// set size of textbox
		    				var label = col.items.items[0].el.dom.getElementsByTagName("label")[0];
		    				if (label){
		    					var labelWidth = Ext.fly(label).getSize().width;
		    					var textbox = col.items.items[0].items.items[0];
		    					if (textbox){
		    						textbox.setWidth(panelWidth-labelWidth-40);
		    					}
		    				}
		    				
		    			}
			    	}		    		
	    		}
	    	}.bind(this));
	    	
	    	var frameContainerPanel = new Ext.Panel({
	     	    layout						: 'border',	     
	     	    border						: false,
	     	    cls							: "ak-views-container-panel",
	     	    items						: [leftPanel,rightPanel]	    	
	    	});
	    	
	    	synchronCheckbox.on("render",function(){
	    		this.el.parent().parent().addClass("ak-views-attribute-left-checkbox ak-views-attribute-left-checkbox-position");
	    		this.el.parent().parent().setWidth("100%");
	    	});
	    	
	    	frameContainerPanel.on("render", function() {
	    		var height = this.viewWindow.getInnerHeight() - this.viewWindow.configPanel.el.getHeight();
	    		this.viewWindow.frameContainerPanel.body.setHeight(height);	    
	    		this.viewWindow.frameContainerPanel.syncSize();
	    	}.bind(this)); 
	    	
	      
	    	
	    	mainWindow = new Ext.Window({
	    	    height						: windowHeight,
	    	    layout						: 'anchor',
	    	    anchor						: '100% 100%',
	    	    width						: windowWidth,    
	    	    modal						: true,
	    	    maximizable 				: true,
	    	    nameTextBox					: nameTextBox,
	    	    nameBox 					: namePanel ,
	    	    descriptionBox				: descriptionPanel ,
	    	    leftContainer				: leftPanel,
	    	    rightContainer				: rightPanel,
	    	    rightIFramePanel 			: rightIframePanel,
	    	    leftIFramePanel 			: leftIframePanel,
	    	    checkBIT 					: checkboxITSystems,
	    	    checkBComments				: checkboxComments,
	    	    checkBDataobjects 			: checkboxDataobjects,
	    	    checkBRoles 				: checkboxRoles,
	    	    containerFrameRightPanel 	: containerFrameRightPanel,
	    	    containerFrameLeftPanel		: containerFrameLeftPanel,
	    	    frameContainerPanel			: frameContainerPanel,
	    	    configPanel					: configPanel,	    
	    	    isSynchronScrolling			: true,
	    	    paramViewDefinition			: viewDefinition,	    	
	    	    legend 						: [checkboxITSystems,checkboxComments,checkboxDataobjects,checkboxRoles],
	    	    title						: Signavio.I18N.ViewDefinition.viewsConfig ,
	    	    items						: [configPanel,frameContainerPanel],
	    	    leftFrameFacade				: undefined,
	    	    rightFrameFacade			: undefined,	 
	    	    buttons						: formButtons,
	    	    saveEditButton				: saveButton,
	    	    cls							: 'ak-splitpanel',
	    	    lastRightScroll 			: undefined,
	    	    firstLoadingLeft			: true,
	    	    firstLoadingRight			: true,
	    	    minWidth					: 600
	    	});		    	
	    	
	    	mainWindow.on("show",function(mainWindow){ 
	    		this.setHeightsOfFrames(mainWindow);
	    	}.bind(this)); 
	    	   	
	    	    	
	    	leftPanel.on("resize", function(panel,newwidth,newheight,oldwidth,oldheight) {    		
	    		this.setHeightsOfFrames(this.viewWindow);
	    	}.bind(this));  
	    	
	    	rightPanel.on("resize", function(panel,newwidth,newheight,oldwidth,oldheight) {
	    		this.setHeightsOfFrames(this.viewWindow);
	    	}.bind(this));     	
	    	
	    	
	    	mainWindow.on("resize",function(mainWindow,newWidth,newHeight){	    		
	    		    		
	    		this.adaptFramesSizeWhenResizing(mainWindow,newWidth);
	    		
	    		var w = mainWindow.getInnerWidth();
	    		if (mainWindow.configPanel.rendered){
	    			mainWindow.configPanel.setWidth(w);
	    		}	    	
	    		if (mainWindow.frameContainerPanel.rendered){
	    			mainWindow.frameContainerPanel.setWidth(w);
	    		}	
	    		this.setHeightsOfFrames(mainWindow);
	    		
	    		
	    	}.bind(this));  
	    	 	
	    		       		    	
	    	this.viewWindow = mainWindow;
	    	this.viewWindow.frameIsZooming = "";
	    	
	    	return mainWindow;	    		    	
	    },
	    
	    
	    adaptFramesSizeWhenResizing: function(mainWindow,newWidth){
	    	if (mainWindow.frameContainerPanel && mainWindow.frameContainerPanel.rendered && mainWindow.leftContainer.rendered && mainWindow.rightContainer.rendered ){	    		
	    		if (newWidth === mainWindow.oldWidth) return;
	    		mainWindow.oldWidth = newWidth;
	    		// 9 = width of splitter
	    		var oldWidth = mainWindow.leftContainer.getInnerWidth()+mainWindow.rightContainer.getInnerWidth()+9;
	    		var newRight = Math.round((mainWindow.rightContainer.getInnerWidth()/oldWidth)*(newWidth-12));	    		    		
	    		mainWindow.rightContainer.setWidth(newRight-1);    		
	    	}	     		    	
	    },
	    
	    /**		 
		 * set the heights of the 2 iframes regarding to the new size of window
		 */
	    setHeightsOfFrames: function(mainWindow){
	    	if (mainWindow.frameContainerPanel && mainWindow.frameContainerPanel.rendered && mainWindow.leftContainer.rendered && mainWindow.rightContainer.rendered ){
    			var height = mainWindow.getInnerHeight() - mainWindow.configPanel.el.getHeight();
    			mainWindow.frameContainerPanel.body.setHeight(height);
    			mainWindow.leftContainer.body.setHeight(height);
    			mainWindow.rightContainer.body.setHeight(height);  
    			if (mainWindow.frameContainerPanel.layout.rendered){
    				mainWindow.frameContainerPanel.doLayout();
    			}
    		}
	    },
	    /**		 
		 * deliver a collection of all existing view names
		 */
	    getAllViewNames: function(){
	    	var views = this.getAllViewsFromMeta();;	
	    	var ret = [];
	    	views.each(function(view){
	    		ret.push(view.name);
	    	}.bind(this));
	    	return ret;
	    },
	    
	    /**		 
		 * is called, if a view should be duplicated
		 */
	    duplicateView: function(mainWindow){
	    	// ask for the view name
	    	Ext.Msg.prompt(Signavio.I18N.ViewDefinition.saveDuplicateButton, Signavio.I18N.ViewDefinition.nameOfView, function(btn, text){
	    	    if (btn == 'ok'){
	    	       	if (this.isValidViewName(text.trim()) === false){
	    	            Ext.Msg.alert(Signavio.I18N.ViewDefinition.warningName1, Signavio.I18N.ViewDefinition.warningName2, function(){
	    	            	this.duplicateView();	 	    	          
	    	            }.bind(this));	    	           
	    	        }
	    	       	else{
	    	       		// valid name
	    	       		var dupView = this.getNewViewDefinition();
	    	       		dupView.name = text;
	    	       		var oldViews = this.getAllViewsFromMeta();;	    		    
	    				var command = new Signavio.Plugins.ViewsAttributeWindow.CreateCommand(dupView,oldViews,this.facade,this);
	    				this.facade.executeCommands([command]);	
	    				this.panelInPropertyWindow.doLayout();
	    				mainWindow.close();    				
	    	       	}
	    	    }
	    	}.bind(this));

	    },
	    
	    /**		 
		 * proof whether a given view-name is valid
		 * a name is not valid, if a name is already exisiting or a name is empty
		 */
	    isValidViewName: function(viewName){
	    	var views = this.getAllViewNames();
        	var viewDefinition = this.viewWindow.paramViewDefinition;
    		
        	if (viewName.trim() === ""){    			
    			return false;
    		} 
    	    		
    		if (viewDefinition == undefined){
    			// if the view name exisiting, create a new view
	    		if (views.indexOf(viewName) !== -1){
	    			return false;
	    		}else{
	    			return true;
	    		}	    	
    		}else{
    			// is there are a exisitng view definition, the name has to be unique and not empty
    			if (views.indexOf(viewName) === -1 || viewName === viewDefinition.name){
    				return true;
	    		}else{
	    			return false;
	    		}
    		}
	    },    
			    
	    /**		 
		 * build and deliver a new view by getting the new viewDefinition	
		 */
	    getNewViewDefinition: function(){
	    	var viewDefintion = this.getViewDefinition();
			var hideIDs = this.hideElements || [];
			var collapseIDs = [];
			var singlePoolsIDs = [];
			
			// if there are collpased pools?
			var collapsedPools = this.getAllCollapsedPools();
			collapsedPools.each(function(colPool){ collapseIDs.push(colPool.resourceId); }.bind(this));
			
			// if there are onlyContent Pools?
			var onlyContentPools = this.getAllOnlyContentPools();
			onlyContentPools.each(function(singlePool){ singlePoolsIDs.push(singlePool.resourceId); }.bind(this));
				
			// set the new frame for the leftside		
			viewDefintion.hide = hideIDs || [];
			viewDefintion.collapse = collapseIDs || [];
			viewDefintion.hideSingleRole = singlePoolsIDs || [];
			
			var newVersion = {
		    		name: this.viewWindow.nameBox.items.items[0].getValue(),
		    		description: this.viewWindow.descriptionBox.items.items[0].getValue(),
		    		definition: viewDefintion
		    	};
			
			return newVersion;
	    },
	    
	    /**		 
		 * load the initial model for left-frame 
		 */	      
	    loadInitModelForLeftSide: function(viewDefinition)
	    {
	       	this.viewWindow.containerFrameLeftPanel.body.mask(Signavio.I18N.ViewDefinition.originalPreview , "x-waiting-box");         
	    	var viewDef = {
	    			hideComments	: false,
					hideData		: false,									
					hideITSystems	: false,
					hideRoles		: false
	    	};
	   
		   	var json = this.getInitialJSOnFromCurrentModel();
		   	var html = this.getPreviewHtmlForIFrame(json,Object.toJSON(viewDef));
		   	this.fillIFramePanelWithHTML(this.viewWindow.leftIFramePanel,html);	
	    	
	    },
	    
	    /**		 
		 * deliver the current definition for hiding dataobjects,itsystems, roles and comments
		 */    
	    getViewDefinition: function(){
	    	return {
	    			hideComments	:!this.viewWindow.checkBComments.checked,
					hideData		:!this.viewWindow.checkBDataobjects.checked,										
					hideITSystems	:!this.viewWindow.checkBIT.checked,
					hideRoles		:!this.viewWindow.checkBRoles.checked
			};	
	    },
	    
	    /**		 
		 * proof whether the given shape is a type of the given types-collection by comparing the stencil id of the shape
		 * example: types = [pool, verticalPool...]
		 */
	    shapeHasTypeOf: function(shape,types)
	    {
	    	return (types.indexOf(shape.stencil.id) !== -1);
	    },   	    
	    
	    /**		 
		 * deliver all pools in the model, which are marked as "only content"
		 * returns a collection of shapes
		 */
	    getAllOnlyContentPools: function(){
	    	var col = this.viewWindow.htmlElementToPairCollection;
			var onlyContentPoolsLanes = [];
	    	for(var i in col){
				var pair = col[i];
				if (pair.shape !== undefined){
					if (pair.isCombobox && pair.getPoolState() === this._comboboxStates.onlyContent){
						onlyContentPoolsLanes.push(pair.shape);
						var childs = pair.shape.childShapes;
						for (var i in childs){
						  var element = childs[i];
						  onlyContentPoolsLanes.push(element);
						}
						// füge die lanes auch hinzu
					}				
				}
			}
	    	return onlyContentPoolsLanes;
	    },
	    
	    /**		 
		 * deliver all pools in the mode, whoich are marked as "collapse"
		 * returns a collection of shapes
		 */
	    getAllCollapsedPools: function(){
	    	var col = this.viewWindow.htmlElementToPairCollection;
			var collapsedPools = [];
	    	for(var i in col){
				var pair = col[i];
				if (pair.shape !== undefined){
					if (pair.isCombobox && pair.getPoolState() === this._comboboxStates.collapse){
						collapsedPools.push(pair.shape);
					}				
				}
			}
	    	return collapsedPools;
	    },
	    
	    /**
	     * set element as focused, which was focused before refreshing the right side
	     */
	    setFocusedElement: function(){
	    	var focusElement = this.viewWindow.focuesLeftElement;
	    	if (focusElement){
	    		Ext.fly(focusElement).focus();
	    	}
	    },
	    /**
	     * save the last element was focused before refreshing right side
	     */
	    findAndSaveFocusedElement: function(){
	    	if (this.viewWindow.leftContext){
	    		this.viewWindow.focuesLeftElement = this.viewWindow.leftContext.document.activeElement;
	    	}
	    },
	    
	    /**		 
		 * is calling, when the right frame has to be refresh for instance if an element is hiding
		 */
	    refreshRightSide: function()
		{	  
	    	var rightfacade = this.viewWindow.rightFrameFacade;
	      	this.findAndSaveFocusedElement();
	    	// save old scroll position
	    	if (rightfacade){
	    		var scrollbox = rightfacade.getModelViewer().getScrollboxEl();
	    		this.viewWindow.lastRightScroll = scrollbox.lastScroll;
	    		this.viewWindow.lastRightWidth = rightfacade.getModelViewer().getImgWidth();
	    		this.viewWindow.lastRightHeight = rightfacade.getModelViewer().getImgHeight();
	    		if (rightfacade._view.zoomslider){
	    			this.viewWindow.lastRightZoomLevel = rightfacade.getModelViewer().getZoomLevel();
	    			this.viewWindow.lastRightMinZoomLevel = this.getMinZoomLevelOfModelViewer(rightfacade.getModelViewer());
	    		}
	    	}
	    	var riframe = Ext.fly("rightIFrame");
    		if (riframe) riframe.fadeOut({duration: 0.7, remove: false });
	    	window.setTimeout(function(){
	    		this.viewWindow.containerFrameRightPanel.body.mask(Signavio.I18N.ViewDefinition.preview , "x-waiting-box");	
	    		
		    	var newView = this.getNewViewDefinition();    		
	    		// build html and show frame
				var json = this.getInitialJSOnFromCurrentModel();
	    		var html = this.getPreviewHtmlForIFrame(json,Object.toJSON(newView.definition));
	    		this.fillIFramePanelWithHTML(this.viewWindow.rightIFramePanel,html);	    		
	    	}.bind(this),700);		
		},
	    
		 /**		 
		 * returns the json-representation of the current model in the editor
		 */ 
	    getInitialJSOnFromCurrentModel: function(){
	    	return this.facade.getJSON();
	    },
	    
	    /**		 
		 * compute and deliver the minimum-zoomLevel of a given modelviewer
		 */
	    getMinZoomLevelOfModelViewer: function(modelviewer) {		
			var scaleHorizontal = (modelviewer.get("offsetWidth")-5) / modelviewer.getImgWidth();
			var scaleVertical = (modelviewer.get("offsetHeight")-5) / modelviewer.getImgHeight();
			var scale = (scaleHorizontal < scaleVertical) ? scaleHorizontal : scaleVertical;
			if(scale>1)	scale = 1;
			return scale*100;
		},
	    
			    
	    /**		 
		 * write a given html-respresentation in a given iFrame and load it
		 */
		fillIFramePanelWithHTML: function(iFramePanel,html){
			// fill the IFRame with specified html-Code
			var updateHtml = iFramePanel.initialConfig.html + '';			
			iFramePanel.body.update(updateHtml);   
			var iframe = iFramePanel.body.child("iframe");		
			var doc = undefined;
			doc = iframe.dom.contentDocument;
			doc.write(html);
			var me = this;
        	doc.close();         
        	
			doc.addEventListener("load",function(){		
				if (this.frameElement.id == "leftIFrame"){
					if (this.SignavioConfig !== undefined){
						this.SignavioConfig.callback = me.leftFrameCallback.bind(me, this);	
					}
				}
				if (this.frameElement.id == "rightIFrame"){
					if (this.SignavioConfig !== undefined){
						this.SignavioConfig.callback = me.rightFrameCallback.bind(me, this);
					}
				}
			}.bind(iframe.dom.contentWindow),true);        	
		},
	    
		 /**		 
		 * event which is called when an given modelViewer (zoomingModel) is zooming
		 */
		modelViewerIsZooming: function(zoomingModel,otherModel){
			// zoomingModel is the model which is currently zooming
			// compute the zoom Level for the other side
			if (zoomingModel == undefined || otherModel == undefined) {return;}
			var currentType;
			var oppZoomSlider;
			if (zoomingModel == this.viewWindow.leftModelViewer){
				currentType = "left";
				oppZoomSlider = this.viewWindow.rightFrameFacade._view.zoomslider;
			}
			else{
				currentType = "right";
				oppZoomSlider = this.viewWindow.leftFrameFacade._view.zoomslider;
			}
		
			if (currentType == this.viewWindow.frameIsZooming ){			
				if (this.viewWindow.isSynchronScrolling){
					var zoomLevel = zoomingModel.getZoomLevel();
					var MinZoom1 = this.getMinZoomLevelOfModelViewer(zoomingModel);
					var MinZoom2 = this.getMinZoomLevelOfModelViewer(otherModel);
					var MaxZoom1 = 100;
					var MaxZoom2 = 100;
					var range1 = MaxZoom1 - MinZoom1;
					var range2 = MaxZoom2 - MinZoom2;
					var newMinZoom1 = zoomLevel - MinZoom1;
					var zoomPercent = (100 / range1 * newMinZoom1)/100;
					var otherZoomPercent = range2*zoomPercent;
					var otherZoomLevel = MinZoom2 + otherZoomPercent;	
					if (typeof(otherZoomLevel)=== "number" && isNaN(otherZoomLevel) === false){
						otherModel.setZoomLevel(otherZoomLevel);
						if (oppZoomSlider){
							oppZoomSlider.update();
						}
					}
					
				}
			}

		},
		
		 /**		 
		 * event which is called when an given modelViewer (zoomingModel) is starting to zoom
		 */
		modelViewerIsStartingZoom: function(typeFrame){
			if (this.viewWindow.frameIsZooming == ""){
				this.viewWindow.frameIsZooming = typeFrame;
				if (typeFrame === "right"){
					// alle checkboxen der linken seite verbergen
					var col = this.viewWindow.htmlElementToPairCollection;				
			    	for(var i in col){
						var pair = col[i];
						if (pair.parentHtmlElement !== undefined){			
							Ext.fly(pair.parentHtmlElement).hide();
						}
					}
				}
			}
		},
		
		 /**		 
		 * event which is called when an given modelViewer (zoomingModel) is finishing the zooming
		 */
		modelViewerIsEndingZoom: function(typeFrame){
			if (this.viewWindow.frameIsZooming == typeFrame){
				this.viewWindow.frameIsZooming = "";
				if (typeFrame === "right"){
					// alle checkboxen der linken seite wieder zeigen
					var col = this.viewWindow.htmlElementToPairCollection;				
			    	for(var i in col){
						var pair = col[i];
						if (pair.parentHtmlElement !== undefined){						
							Ext.fly(pair.parentHtmlElement).show();
						}
					}
				}
			}
		},
		
		 /**		 
		 *  event which is called when an given modelViewer (zoomingModel) is scrolling
		 *  compute the scrollvalues of the other modelViewer and scroll it, according the syncronized scrolling is desired
		 */
		scrollingModel: function(zoomingModel,otherModel){
			if (this.viewWindow.frameIsZooming == ""){
				if (this.viewWindow.isSynchronScrolling){	
					var sc1 = zoomingModel.getScrollboxEl();
					var mv2 = otherModel;
					var sc2 = mv2.getScrollboxEl();
					
					if (sc1.scrolling || mv2._isDragging){ return; } // Prevent infinity loop
					var scrollLeft = sc1.get("scrollLeft"), scrollTop = sc1.get("scrollTop");
					
					var oH1  = sc1.get("offsetHeight"), oW1  = sc1.get("offsetWidth"),
					oH2  = sc2.get("offsetHeight"), oW2  = sc2.get("offsetWidth"),
					sH1 = sc1.get("scrollHeight"),  sH2 = sc2.get("scrollHeight"),
					sW1 = sc1.get("scrollWidth"),   sW2 = sc2.get("scrollWidth");
	
					if (!(oH1 == sH1 || oH1-17 == sH1)) oW1 = oW1 - 17; if (!(oW1 == sW1 || oW1-17 == sW1)) oH1 = oH1 - 17; 
					if (!(oH2 == sH2 || oH2-17 == sH2)) oW2 = oW2 - 17; if (!(oW2 == sW2 || oW2-17 == sW2)) oH2 = oH2 - 17; 
				
					scrollLeft 	= Math.round((scrollLeft) * ((sW2-oW2) / (sW1-oW1)));
					scrollTop 	= Math.round((scrollTop)  * ((sH2-oH2) / (sH1-oH1)));
					
					// Set scrolling
					var setLeft = Math.abs(scrollLeft - (sc2.lastScroll||{left:0}).left||0) >= 2,
						setTop =  Math.abs(scrollTop - (sc2.lastScroll||{top:0}).top||0) >= 2;
					
					var scroll = {};
					if (setLeft)	sc2.set("scrollLeft", scrollLeft);
					if (setTop) 	sc2.set("scrollTop", scrollTop);
					
					if (setLeft || setTop){
						sc2.scrolling = true;
						if (this.scrolling){
							this.scrolling = [scroll];
						} else {
							var scrollTo = function(sc){
								this.scrolling = [];							
									if (this.scrolling && this.scrolling.length > 0){
										scrollTo(this.scrolling.pop());
									} else {
										delete this.scrolling; 
										delete sc2.scrolling;
									}						
							}.bind(this);
							scrollTo(scroll);
						}					
					}				
					
					// Cache last position
					if (setLeft || setTop){
						sc1.lastScroll = {left: sc1.get("scrollLeft") ,top: sc1.get("scrollTop")};
						sc2.lastScroll = {left: sc2.get("scrollLeft") ,top: sc2.get("scrollTop")};
					}
				}			
			}
		},
		
		 /**		 
		 * callback function for the left iframe
		 * is called, if the left iframe has been loaded fully
		 */
		leftFrameCallback: function(leftContext,mashFacade)
		{	
			var liframe = Ext.fly("leftIFrame");
    		if (liframe) liframe.fadeOut({duration: 0.1});
			var timer, timer2, attach = Ext.isIE6 || Ext.isIE7 || Ext.isIE8;
			
			this.renderMarkersForShapesInLeftFrame(leftContext,mashFacade);		
			this.viewWindow.leftModelViewer = mashFacade.getModelViewer();
			this.viewWindow.leftFrameFacade = mashFacade;
			this.viewWindow.leftContext = leftContext;
			// register for changing		
			
			/*if (Ext.isIPad){
				YAHOO.widget.Slider.prototype.getValue = function(){
				    return this.value || 0;
				};
				YAHOO.widget.Slider.prototype.setValue = function(s){
					this.value = Math.max(0, Math.min(100, s));
				    this.fireEvent("change");
				    me.modelviewer.onZoomLevelChangeEnd.fire(me.modelviewer.getZoomLevel());
				    return true;
				};
			}*/
			
			this.viewWindow.leftModelViewer.onZoomLevelChange.subscribe(function(){
				this.modelViewerIsZooming(this.viewWindow.leftModelViewer,this.viewWindow.rightModelViewer);
			}.bind(this));	
			
			//register for starting zoom
			this.viewWindow.leftModelViewer.onZoomLevelChangeStart.subscribe(function(){
				this.modelViewerIsStartingZoom("left");
			}.bind(this)); 
			
			// register for ending zoom
			this.viewWindow.leftModelViewer.onZoomLevelChangeEnd.subscribe(function(){
				this.modelViewerIsEndingZoom("left");
			}.bind(this));
			
			// register for scrolling
			this.viewWindow.leftModelViewer.getScrollboxEl().get("element")[!attach?"addEventListener":"attachEvent"](!attach?"scroll":"onscroll", function(){
				this.scrollingModel(this.viewWindow.leftModelViewer,this.viewWindow.rightModelViewer);
			}.bind(this),true);
			
			window.setTimeout(function(){
	    		this.viewWindow.containerFrameLeftPanel.body.unmask();
	    		if (this.firstLoading === true && this.viewWindow.paramViewDefinition){
	    			// set the iformation from exlicit viewDefinition	    		
	    			this.setViewDefinitionForModel();	    		
	    		}else{
	    			window.setTimeout(function(){
	    				var liframe = Ext.fly("leftIFrame");
	    	    		if (liframe) liframe.fadeIn({duration: 1.0});
			    	}.bind(this),300);
	    		}
	    		if (this.viewWindow.firstLoadingLeft===true){
	    			// proofe right zoomLevel
	    			this.setBestFitZoomLevelForModel(mashFacade);
	    			this.viewWindow.firstLoadingLeft===false;
	    			window.setTimeout(function(){		    		
		    			this.viewWindow.nameTextBox.focus();	    			
		    		}.bind(this),1300);
	    		}
				
	    		
	    	}.bind(this),500);			
		},			
		
		 /**		 
		 * callback function for the right iframe
		 * is called, if the right iframe has been loaded fully
		 */	
		rightFrameCallback: function(rightContext,mashFacade)
		{
		
			var timer, timer2, attach = Ext.isIE6 || Ext.isIE7 || Ext.isIE8;
			
			this.viewWindow.rightModelViewer = mashFacade.getModelViewer();
			this.viewWindow.rightFrameFacade = mashFacade;
			this.viewWindow.rightContext = rightContext;
			
			// register for changing
			this.viewWindow.rightModelViewer.onZoomLevelChange.subscribe(function(){
				this.modelViewerIsZooming(this.viewWindow.rightModelViewer,this.viewWindow.leftModelViewer);
			}.bind(this));	
			
			//register for starting zoom
			this.viewWindow.rightModelViewer.onZoomLevelChangeStart.subscribe(function(){
				this.modelViewerIsStartingZoom("right");
			}.bind(this));

			// register for ending zoom
			this.viewWindow.rightModelViewer.onZoomLevelChangeEnd.subscribe(function(){
				this.modelViewerIsEndingZoom("right");
			}.bind(this));
			
			// register for scrolling
			this.viewWindow.rightModelViewer.getScrollboxEl().get("element")[!attach?"addEventListener":"attachEvent"](!attach?"scroll":"onscroll", function(){
				this.scrollingModel(this.viewWindow.rightModelViewer,this.viewWindow.leftModelViewer);
			}.bind(this),true);			
			
			window.setTimeout(function(){	    	
		    		//set the current zoom level depends on the left model viewer
				this.viewWindow.containerFrameRightPanel.body.unmask();
				this.viewWindow.frameIsZooming = "left";				
		    	window.setTimeout(function(){
		    		var riframe = Ext.fly("rightIFrame");
		    		if (riframe) riframe.fadeIn({duration: 1.0});
		    		window.setTimeout(function(){
			    		if (this.viewWindow.firstLoadingRight===true){
			    			this.viewWindow.firstLoadingRight=false;
			    			this.viewWindow.nameTextBox.focus();	    			
			    		}else{
			    			this.setFocusedElement();
			    		}
		    		}.bind(this),1300);
		    	}.bind(this),300);
				this.modelViewerIsZooming(this.viewWindow.leftModelViewer,this.viewWindow.rightModelViewer);
		    	this.viewWindow.frameIsZooming = "";	
		    	// alte scrollposition setzten
		    	if (this.viewWindow.lastRightScroll !== undefined){
		    		var lastLeft = this.viewWindow.lastRightScroll.left;
		    		var lastTop = this.viewWindow.lastRightScroll.top;
		    		var lastHeight = this.viewWindow.lastRightHeight;
		    		var lastWidth = this.viewWindow.lastRightWidth;
		    		var newWidth = mashFacade.getModelViewer().getImgWidth();
		    		var newHeight = mashFacade.getModelViewer().getImgHeight();
		    		var newLeft = (lastLeft*newWidth) / lastWidth;
		    		var newTop = (lastTop*newHeight) / lastHeight;
		    		
		    		var scrollbox = mashFacade.getModelViewer().getScrollboxEl();
		    		scrollbox.set("scrollLeft",newLeft);
		    		scrollbox.set("scrollTop",newTop);
		    		scrollbox.lastScroll = {left: scrollbox.get("scrollLeft") ,top: scrollbox.get("scrollTop")};
		      	}	
		    	if (this.viewWindow.firstLoadingLeft===true){		    		
		    		this.setBestFitZoomLevelForModel(mashFacade);
		    	}else{
		    		if (!this.viewWindow.isSynchronScrolling){		    				    		
			    		var zoomLevel = this.viewWindow.lastRightZoomLevel;
						var MinZoom1 = this.viewWindow.lastRightMinZoomLevel;
						var MinZoom2 = this.getMinZoomLevelOfModelViewer(mashFacade.getModelViewer());
						var MaxZoom1 = 100;
						var MaxZoom2 = 100;
						var range1 = MaxZoom1 - MinZoom1;
						var range2 = MaxZoom2 - MinZoom2;
						var newMinZoom1 = zoomLevel - MinZoom1;
						var zoomPercent = (100 / range1 * newMinZoom1)/100;
						var otherZoomPercent = range2*zoomPercent;
						var otherZoomLevel = MinZoom2 + otherZoomPercent;	
						if (typeof(otherZoomLevel)=== "number" && isNaN(otherZoomLevel) === false){
							mashFacade.getModelViewer().setZoomLevel(otherZoomLevel);
							mashFacade._view.zoomslider.update();
						}
			    	}
		    	}
		    				
		   	 	
		    }.bind(this),800);	
			
		},
		
		setBestFitZoomLevelForModel: function(mashFacade){
			var canvasWidth =  this.facade.getCanvas().bounds.width();
			var canvasHeight = this.facade.getCanvas().bounds.height();
			// Width > 3000
			// Heights > 3000
			// if height or widht above 3000, set inital zoom level higher
			if (canvasWidth > 1800 || canvasHeight > 2000){
				var mv = mashFacade.getModelViewer();
				var minLevel = this.getMinZoomLevelOfModelViewer(mv);
				var newZoomLevel = 50 + minLevel/2;
				if (typeof(newZoomLevel)=== "number" && isNaN(newZoomLevel) === false){
					mv.setZoomLevel(newZoomLevel);
					mashFacade._view.zoomslider.update();
				}
			}
		},
		
		 /**		 
		 * deliever a html-shape-object with specified id form the global html-shape-collection
		 */
		getHtmlElementShapePair: function(id){
			var col = this.viewWindow.htmlElementToPairCollection;
			for(var i in col){
				if (id == col[i].id){
					return col[i];
				}
			}			
		},
		
		 /**		 
		 * set a value and the corresponding style for a combobox
		 */
		setValueAndStyleForACombobox: function(poolShape,combobox,value, marker,isDisabled){					
			// set value for the htmlElement
			if (value){
				combobox.value = value;
			}
			this.setStyleOfCombobox(combobox, marker, value || combobox.value);								
			combobox.disabled = isDisabled;
		},
		
		 /**		 
		 * remove the given elements from the given view and save the modfied view in store
		 */
		hideElementsInViewAndSave: function(elements,view){
			// nur die parent elemten disablen, also müssen diese vorher berarbeitet werden
			// wenn kinder von einem parent  und dieser in den elements ist, dann nur den parent
			
			var considerShapes = this.getAllShapesToConsider(elements);
			
			// elemente in der view ausgeblendet werden
			var hide = view.definition.hide || [];
			considerShapes.each(function(sel){
				if (sel){
    				// checkboxelement oder comboboxelement?
					hide.push(sel.resourceId);	
				}
			}.bind(this));
			// doppelte elemente l?schen (eher pr?ventiv)
			hide = hide.uniq();
			view.definition.hide = hide;
			this.storeView(view);
			return view;
		},
		
		 /**		 
		 * add given elements to the given view and save the view in the global store
		 */
		showElementsInViewAndSave: function(elements,view){
			// prüfe für jedes element ob diese in hide bzw. hideSingleRole stehen
			var hide = view.definition.hide;
			elements.each(function(sel){
				if (sel){
    				var sid = sel.resourceId;
    				if (hide.indexOf(sid) !== -1){
    					hide.remove(sid);
    				}
				}
			}.bind(this));
			hide = hide.uniq();
			view.definition.hide = hide;
			this.storeView(view);
			return view;
		},
		/**		 
		 * is called, if the model was saved
		 * render the links for the views new, because the new views get ids from server, now
		 */
		modelWasSaved: function(){
			this.renderViewsOfModel();	
			this.facadeSelectionChanged(this.facade.getSelection());
		},		
		
		/**		 
		 * deliever all views from the global meta-store of the current model
		 */
		getAllViewsFromMeta: function(){
			var views = this.facade.getModelMetaData().views || [];
			return views;
		},
		/**		 
		 * overwrite the views in the global meta-store if the current model with the
		 * given views
		 */
		setAllViewsFromMeta: function(views){
			this.facade.getModelMetaData().views = views;
		},
		
		 /**		 
		 * is called, if a checkbox of a view in the attribute panel is clicked (value changed)
		 */
		viewCheckboxChanged: function(checkbox,newValue){
									
			var selection = this.facade.getSelection();
			if (selection){				
				var oldViews = this.getAllViewsFromMeta();		
				var command = new Signavio.Plugins.ViewsAttributeWindow.CheckboxChangeCommand(selection,checkbox.view,oldViews,checkbox,newValue,this.facade,this);
				this.facade.executeCommands([command]);				
			}
		},
		
		 /**		 
		 * add a given view to the global viewstore and save their to the metadata-store
		 */
		storeView: function(view){
			// view finden und diese ver?ndern
			var oldViews = this.getAllViewsFromMeta();;	
	    	var newViews =[];
	    	oldViews.each(function(v){
	    		if (view.name === v.name){
	    			newViews.push(view);
	    		}
	    		else{
	    			newViews.push(v);
	    		}
	    	}.bind(this));	
	    	// neue views speichern	    
	    	this.setAllViewsFromMeta(newViews);
		},
		
		 /**		 
		 * disable and uncheck all given checkboxes
		 */
		disableAndUncheckAll: function(checkboxCollection){
			if (checkboxCollection){
				checkboxCollection.each(function(c){
					c.setValue(false);
					c.disable();
					c.show();
					if (c.triStateImage){
						Ext.fly(c.triStateImage).hide();
					}
				}.bind(this));
			}
		},
	    
		
		 /**		 
		 * enable and check all given checkboxes
		 */
		enableAll: function(checkboxCollection){
			if (checkboxCollection){
				checkboxCollection.each(function(c){
					c.setValue(false);
					c.enable();
				}.bind(this));
			}			
		},
		
		 /**		 
		 * suspend the events of the given checkbox to set a value
		 * without calling the event
		 */
		suspendEventsForAllCheckboxes: function(checkboxCollection){
			if (checkboxCollection){
				checkboxCollection.each(function(c){					
					c.suspendEvents();
				}.bind(this));
			}			
		},
		
		 /**		 
		 * resume all events of the given checkboxes
		 */
		resumeEventsForAllCheckboxes: function(checkboxCollection){
			if (checkboxCollection){
				checkboxCollection.each(function(c){					
					c.resumeEvents();
				}.bind(this));
			}			
		},		
		
		 /**		 
		 * proof whether the type of a given shape is an ITSystem
		 */
		isShapeAnITSystem: function(shape){
			var types = ["ITSystem"];
			return (types.indexOf(shape._stencil.idWithoutNs(shape._stencil.idWithoutNs())) !== -1 );
		},
		
		 /**		 
		 * proof whether the type of a given shape is a dataobject
		 */
		isShapeADataobject: function(shape){
			var types = ["DataObject","DataStore","Message"];
			return (types.indexOf(shape._stencil.idWithoutNs(shape._stencil.idWithoutNs())) !== -1 );
		},
		
		 /**		 
		 * proof whether the type of a given shape is a role
		 */
		isShapeARole: function(shape){
			var types = ["Pool","VerticalPool","CollapsedVerticalPool","CollapsedPool","processparticipant","Lane","VerticalLane"];
			return (types.indexOf(shape._stencil.idWithoutNs(shape._stencil.idWithoutNs())) !== -1 );
		},
		
		 /**		 
		 * proof whether the type of a given shape is a comment
		 */
		isShapeAComment: function(shape){
			var types = ["TextAnnotation"];		
			return (types.indexOf(shape._stencil.idWithoutNs(shape._stencil.idWithoutNs())) !== -1 );
		},
		
		/**		 
		 * proof whether a given shape is a lane
		 */
		isShapeALane: function(shape){
			var types = ["Lane","VerticalLane"];
			return (types.indexOf(shape.stencil.id) !== -1 );
		},
		
		 /**		 
		 *  proof whether a given shape is a pool
		 */
	    shapeIsPool: function(shape){
	    	return (shape._stencil.idWithoutNs() == "Pool" || shape._stencil.idWithoutNs() == "VerticalPool");
	    },
		
		 /**		 
		 * proof whether a given shape is disabled in view by elemente-type
		 */
		isShapeVisibleInViewByLegend: function(shape,view){
			return !((view.definition.hideRoles === true && this.isShapeARole(shape)) ||
					(view.definition.hideITSystems === true && this.isShapeAnITSystem(shape)) ||
					(view.definition.hideComments === true && this.isShapeAComment(shape)) ||
					(view.definition.hideData === true && this.isShapeADataobject(shape)));
		},
		
		 /**		 
		 * proof whether a given shape is visible in a given view
		 */
		isShapeVisibleInView: function(shape,view){
			var isDisabledByLegend = false;
			var isDisabledByParent = false;
			var isDisabledByDefinition = false;
			
			var def = view.definition;
			var sid = shape.resourceId;
			// wenn das shape die facade ist, dann immer false zurückgeben 
			if (sid === "facade" || shape.parent == undefined){
				return true;
			}
				
			// ist das shape in der definition hide enthalten?
			if (def.hide && def.hide.indexOf(sid)!== -1){
				return false;
			}
			
			// ist das shape in der definition hide enthalten?
			if (def.hideSingleRole && def.hideSingleRole.indexOf(sid)!== -1){
				return false;
			}
			
			// prüfen ob das shape durch die legende schon disabeld ist
			if (this.isShapeVisibleInViewByLegend(shape,view) === false){
				return false;
			}			
			
			// prüfen ob sein parent disabled ist
			return this.isShapeVisibleInView(shape.parent,view);
			
		},
		
		/**		 
		 * proof whether a given shape is disabled in view by elemente-type and parent
		 */
		isShapeVisibleByParentAndLegend: function(shape,view){
			var isDisabledByLegend = false;
			var isDisabledByParent = false;
					
			var def = view.definition;
			var sid = shape.resourceId;
			// wenn das shape die facade ist, dann immer false zurückgeben 
			if (sid === "facade" || shape.parent == undefined){
				return true;
			}
			
			// prüfen ob das shape durch die legende schon disabeld ist
			if (this.isShapeVisibleInViewByLegend(shape,view) === false){
				return false;
			}			
			
			// prüfen ob sein parent disabled ist
			return this.isShapeVisibleInView(shape.parent,view);			
		},
		
		 /**		 
		 * is called, if the selection was changed
		 * updates the checkboxes for each view and show whether the
		 * selected elements visible in the views
		 */
	    facadeSelectionChanged: function(selection){
	    	var checkboxes = this.checkboxCollection;
	    	this.clearAllCheckboxes(checkboxes);	    	
	    	if (selection)
	    	{	    		
	    		this.suspendEventsForAllCheckboxes(checkboxes);	    		
		    	if (selection.length === 0){
		    		this.disableAndUncheckAll(checkboxes);
		    		this.resumeEventsForAllCheckboxes(checkboxes);	
		    		return;
		    	}else{
		    		this.enableAll(checkboxes);
		    	}	    	
		    	    
		    	// pruefe ob die element jeweils in der view vorhanden sind
		    
		    	checkboxes.each(function(checkbox){		    	
		    		var view = checkbox.view;
		    		var hideElements = view.definition.hide;
		    		var hideSingleRoles = view.definition.hideSingleRole;
		    		var collapseElements = view.definition.collapse;
		    		var count = selection.length;
		    		var countByParent = false;
		    		var countByLegend = false;
		    		var countByParentOrLegend = selection.length;
		    		// reset	
		    		selection.each(function(sel){
		    			// pruefe ob einzelnes element in    			
		    			var isVisible = true;
		    			if (sel){
		    				var isVisibleInView = this.isShapeVisibleInView(sel,view);
		    				// prüfen ob sie druch ihre eltern oder legend disabled sind
		    				if (this.isShapeVisibleByParentAndLegend(sel,view)=== false){
		    					countByParentOrLegend--;
		    				}
		    				if (isVisibleInView === true){
		    					count--;
		    				}
		    				if (this.isShapeVisibleInView(sel.parent,view)===false){
		    					countByParent = true;
		    				}
		    				if (this.isShapeVisibleInViewByLegend(sel,view)===false){
		    					countByLegend = true;
		    				}
		    			}
		    		}.bind(this));
		    		
		    		// nur wenn alle elemente enthalten sind, wird ein hacken gesetzt
		    		if (count === 0){
		    			checkbox.setValue(true);
		    		}
		    		if (count === selection.length){
		    			checkbox.setValue(false);
		    		}		    		
		    		if (count > 0 && count < selection.length){
		    			checkbox.hide();
		    			Ext.fly(checkbox.triStateImage).show();
		    			var sichtbar = selection.length-count;
		    			var nichtSichtbar = count;
		    			
		    			var des = Signavio.I18N.ViewDefinition.viewToolTip4;
		    			des = des.replace("[verb1]", (sichtbar === 1 ? Signavio.I18N.ViewDefinition.is :Signavio.I18N.ViewDefinition.are) );
		    			des = des.replace("[count1]", sichtbar.toString());
		    			des = des.replace("[element1]", (sichtbar === 1 ? Signavio.I18N.ViewDefinition.element :Signavio.I18N.ViewDefinition.elements) );
		    			des = des.replace("[count2]", nichtSichtbar.toString());
		    			des = des.replace("[element2]", (nichtSichtbar === 1 ? Signavio.I18N.ViewDefinition.element :Signavio.I18N.ViewDefinition.elements) );		    			
		    				    			
		    			new Ext.ToolTip({
				        	showDelay:50,		        	
				        	html:des,
				        	target: checkbox.triStateImage	        	
				        });		    		
		    			Ext.QuickTips.init();
		    		}
		    		// wenn ALLE elemente nich aktivertbar sein dann die checkbox disablen
		    		if(0 === countByParentOrLegend){
		    			// wenn disabled dann soll tool top text angezeigt werden
		    			checkbox.show();
		    			Ext.fly(checkbox.triStateImage).hide();
		    			checkbox.disable();
		    			this.addToolTipToCheckbox(checkbox,countByParent,countByLegend);
		    		}
		    		
		    		
		    	}.bind(this));
		    	
	    	}
	    	this.resumeEventsForAllCheckboxes(checkboxes);	
	    },
	    
	    /**		 
		 * clear all given checkboxes, by set value on false, remove overlay-images etc.
		 */
	    clearAllCheckboxes: function(checkboxCollection){
	    	this.suspendEventsForAllCheckboxes(checkboxCollection);	
	    	if (checkboxCollection){
				checkboxCollection.each(function(c){
					c.setValue(false);
					c.enable();
					if (c.imageLayer && c.el){
						Ext.fly(c.el.id).parent().dom.removeChild(c.imageLayer);
						c.imageLayer = undefined;
					}
					if (c.triStateImage){
						Ext.fly(c.triStateImage).hide();
					}
				}.bind(this));
			}		
	    	this.resumeEventsForAllCheckboxes(checkboxCollection);	
	    },
	    
	    /**		 
		 * add a tooltip to a given checkbox
		 * in this it is used, to inform the user that selected elements couldnt
		 * modifiy, because it is not allowed by type or parent
		 */
	    addToolTipToCheckbox: function(checbox,disabledByParent,disabledByLegend){
	    	if (!checbox || !checbox.el){ return; }
	    	var imageLayer= document.createElement("img");
	    	imageLayer.src = Ext.BLANK_IMAGE_URL;
	    	imageLayer.setAttribute("class","ak-views-tooltip-layer");
	    	Ext.fly(checbox.el.id).parent().dom.appendChild(imageLayer);
	    	var des ="";
	    	if (disabledByParent=== true && disabledByLegend === false){
	    		des = Signavio.I18N.ViewDefinition.viewToolTip1 ;
	    	}
	    	if (disabledByParent=== false && disabledByLegend === true){
	    		des = Signavio.I18N.ViewDefinition.viewToolTip2;
	    	}
	    	if (disabledByParent=== true && disabledByLegend === true){
	    		des = Signavio.I18N.ViewDefinition.viewToolTip3;
	    	}
	    	
	    	if (des !== ""){
		    	new Ext.ToolTip({
		        	showDelay:50,		        	
		        	html:des,
		        	target: imageLayer	        	
		        });  
	    		checbox.imageLayer = imageLayer;
    			Ext.QuickTips.init();
	    	}
	    },
	    
	  
		
	    /**		 
		 * set the view definition for a model by loaded view
		 * set the collapsed pools, hidden elements usw.
		 * after that the function render the new preview
		 */
		setViewDefinitionForModel: function(){
			var viewDef = this.viewWindow.paramViewDefinition;
			var def 	= viewDef.definition;
			
			// set collapse pools
			var collapseElements = def.collapse || [];
			if (collapseElements){
				collapseElements.each(function(collapseID){
					var shapePair = this.getHtmlElementShapePair(collapseID);
					if (shapePair){
						this.setStyleOfCombobox(shapePair.htmlElement,shapePair.marker,this._comboboxStates.collapse);
						this.setStateForParentChilds(shapePair.shape,false);
					}
				}.bind(this));				
			}
			
			// set only content pools
			var contentElements = def.hideSingleRole || [];
			if (contentElements){
				contentElements.each(function(onlyContentID){
					var shapePair = this.getHtmlElementShapePair(onlyContentID);
					if (shapePair){
						// Lane oder Pool?
						if (shapePair.isCombobox=== false){
							this.setStateOfCheckbox(shapePair.htmlElement,shapePair.marker,false,true,true,false);
						}else{
							this.setStyleOfCombobox(shapePair.htmlElement,shapePair.marker,this._comboboxStates.onlyContent);	
						}
						
											
					}
				}.bind(this));				
			}
					
			// set hide Elements by hide-Field
			this.hideElements = def.hide || [];
			var hideElements  = def.hide || [];
			if (hideElements){
				hideElements.each(function(hideID){
					var shapePair = this.getHtmlElementShapePair(hideID);
					if (shapePair){
						if (shapePair.isCombobox == false){
							// proof wether the chekcbox has to disabled or not
							// ist parent disabled?
							var parentPair = this.getParentPairForAPair(shapePair);
							var parentPool = this.getParentPoolForShape(shapePair.shape);
							if (parentPair === undefined && parentPool){
								parentPair = this.getHtmlElementShapePair(parentPool.resourceId);	
							}
							if (parentPair){
								if (parentPair.isActive()){
									this.setStateOfCheckbox(shapePair.htmlElement,shapePair.marker,false,false,false,true);	
								}else{
									this.setStateOfCheckbox(shapePair.htmlElement,shapePair.marker,false,true,true,true);	
								}					
							}else{
								this.setStateOfCheckbox(shapePair.htmlElement,shapePair.marker,false,false,false,true);	
							}																			
							this.setStateForParentChilds(shapePair.shape,false);
						} else
						{					
							// setzten comboboxrn				
							this.setStyleOfCombobox(shapePair.htmlElement,shapePair.marker,this._comboboxStates.closed);
							this.setStateForParentChilds(shapePair.shape,false);
						}
					}
				}.bind(this));
			}
			// if legend-checkbox is disabled, disabled all child which are depend on this
		    
			if (def.hideComments === true){
				this.setStatusForShapesOfLegend(this.viewWindow.checkBComments, false);
			}
			if (def.hideITSystems === true){
				this.setStatusForShapesOfLegend(this.viewWindow.checkBIT, false);
			}
			if (def.hideData === true){
				this.setStatusForShapesOfLegend(this.viewWindow.checkBDataobjects, false);
			}
			if (def.hideRoles === true){
				this.setStatusForShapesOfLegend(this.viewWindow.checkBRoles, false);
			}			
					
			this.viewWindow.containerFrameLeftPanel.body.unmask();
			window.setTimeout(function(){
	    		var liframe = Ext.fly("leftIFrame");
	    		if (liframe) liframe.fadeIn({duration: 1.0});
	    	}.bind(this),500);
			
		},
		
		/**		 
		 * set a state for a given checkbox
		 */
		setStateOfCheckbox: function(htmlCheckbox,marker,isActive,isCheckboxTransparent,isDisabled,isMarkerTransparent){
			htmlCheckbox.checked = isActive;
			htmlCheckbox.disabled = isDisabled;			
			var parent = Ext.fly(Ext.fly(htmlCheckbox).parent());
			if (isActive){
				parent.removeClass("ak-checkbox-shadow-view-unchecked");
				parent.addClass("ak-checkbox-shadow-view-checked");								
			}
			else{
				parent.removeClass("ak-checkbox-shadow-view-checked");
				parent.addClass("ak-checkbox-shadow-view-unchecked");										
			}
			if (isMarkerTransparent){
				marker.setNodeClassName(["signavio-marker","ak-views-attribute-marker-transparent"].join(" ")); 
			}
			else{
				marker.setNodeClassName(["signavio-marker"].join(" "));
			}
			if (isCheckboxTransparent){
				parent.addClass("ak-checkbox-shadow-view-checkbox-transparent");
			}
			else{
				parent.removeClass("ak-checkbox-shadow-view-checkbox-transparent");
			}
			
		},
		
		/**		 
		 * set style of a given combobox
		 */
		setStyleOfCombobox: function(combobox,marker,value)
		{
			var parentDiv = Ext.fly(Ext.fly(combobox).parent());
			if (value === this._comboboxStates.opened){
				parentDiv.removeClass("ak-combox-shadow-view-inhalt-sichtbar");
				parentDiv.removeClass("ak-combox-shadow-view-unchecked");
				parentDiv.removeClass("ak-combox-shadow-view-zugeklappt");
				parentDiv.addClass("ak-combox-shadow-view-checked");
				marker.setNodeClassName(["signavio-marker"].join(" "));	
				combobox.value = this._comboboxStates.opened.toString();
				return;				
			}
			if (value === this._comboboxStates.collapse){
				parentDiv.removeClass("ak-combox-shadow-view-inhalt-sichtbar");
				parentDiv.removeClass("ak-combox-shadow-view-unchecked");
				parentDiv.addClass("ak-combox-shadow-view-zugeklappt");
				parentDiv.removeClass("ak-combox-shadow-view-checked");
				marker.setNodeClassName(["signavio-marker"].join(" "));	
				combobox.value = this._comboboxStates.collapse.toString();				
				return;				
			}
			if (value === this._comboboxStates.onlyContent){
				Ext.fly(parentDiv).removeClass("ak-combox-shadow-view-unchecked");
				Ext.fly(parentDiv).removeClass("ak-combox-shadow-view-zugeklappt");
				Ext.fly(parentDiv).removeClass("ak-combox-shadow-view-checked");
				Ext.fly(parentDiv).addClass("ak-combox-shadow-view-inhalt-sichtbar");
				marker.setNodeClassName(["signavio-marker"].join(" "));	
				combobox.value = this._comboboxStates.onlyContent.toString();
				return;				
			}
			if (value === this._comboboxStates.closed){
				Ext.fly(parentDiv).removeClass("ak-combox-shadow-view-inhalt-sichtbar");
				Ext.fly(parentDiv).addClass("ak-combox-shadow-view-unchecked");
				Ext.fly(parentDiv).removeClass("ak-combox-shadow-view-zugeklappt");
				Ext.fly(parentDiv).removeClass("ak-combox-shadow-view-checked");
				marker.setNodeClassName(["signavio-marker","ak-views-attribute-marker-transparent"].join(" "));	
				combobox.value = this._comboboxStates.closed.toString();
				return;				 
			}
		},	
		
		/**		 
		 * deliver the type-checkbox for an html-shape-pair
		 * e.g. checkbox for roles oder itsystems
		 * return undefined if the shape has no type
		 */
		getLegendCheckboxForAPair: function(pair){
			var legend = this.viewWindow.legend;
			var ret = undefined;
			legend.each(function(checkbox){
				if (pair.shape !== undefined){
					if (this.shapeHasTypeOf(pair.shape,checkbox.types) == true){
						ret = checkbox;
						throw $break;						
					}
				}
			}.bind(this));
			return ret;
			
		},
		
		/**		 
		 * deliever the parent or parentparent...parentpool of a given shape
		 * except the canvas, the function deliver undefined
		 */
		getParentPoolForShape: function(childShape){
			var parentShape = undefined;
			if (childShape.stencil.id == "Pool" || childShape.stencil.id == "VerticalPool")
				return childShape; 
			if (childShape !== undefined){
				parentShape = childShape.parentShape;
				if (parentShape !== [] && parentShape !== undefined && parentShape !== null){
					if (parentShape.stencil.id == "Pool" || parentShape.stencil.id == "VerticalPool"){
						return parentShape;
					}else{
						return this.getParentPoolForShape(parentShape);
					}
				}
			}
			return parentShape; 
		},
		
		/**		 
		 * deliever to a given childpair the parentpair
		 */
		getParentPairForAPair: function(childPair){
			if (childPair !== undefined && childPair.shape !== undefined){
				var parentShape = childPair.shape.parentShape;
				if (parentShape !== undefined){
					return this.getHtmlElementShapePair(parentShape.resourceId);
				}
				return undefined;
			}
			return undefined;
		},
		
		/**		 
		 * set the states of checkbox which belongs to a special type like IT-System
		 * checkbox = node which presents the element group like Roles or ITSystem
		 */
		setStatusForShapesOfLegend: function(checkbox,enable)
		 {
			 var pairs = this.viewWindow.htmlElementToPairCollection;		
		    	for(var i in pairs){
					var pair = pairs[i];
					var legendCheckbox = this.getLegendCheckboxForAPair(pair);
					var parentPair = this.getParentPairForAPair(pair);					
					if (legendCheckbox !== undefined && legendCheckbox.idCheckbox === checkbox.idCheckbox){
						// if there are parents which influence the current shape?					
						if (parentPair !== undefined){
							// parent exist
							var parentEnabled = false;						
							parentEnabled =  parentPair.isActive();
							if (enable && parentEnabled){							
								// activate the shape only if the parent is actice and the shape isnt hidden by user
								if (this.isElementInHide(pair.shape.resourceId)===true){
									this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,false,false,true);
									this.setStateForParentChilds(pair.shape,false);
								}else{
									this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
									this.setStateForParentChilds(pair.shape,true);
								}								
							}else{
								if (!parentEnabled){							
									if (enable){
										// wenn der parent disabled ist muss überprüft werden, ob es sich um lane handelt
										// und wenn es sich um einen lane handelt prüfen ob der pool auf "only content" gesetzt ist
										if (parentPair.shape.stencil.id.endsWith("Lane")){
											// zugeh?rigen pool finden
											var parentPool = this.getParentPoolForShape(parentPair.shape);
											var parentPoolPair = this.getHtmlElementShapePair(parentPool.resourceId);
											if (parentPoolPair){
												// nur wenn der status auf nicht "only content" gestzt ist, disablen
												if (parentPoolPair.getPoolState() === this._comboboxStates.onlyContent){
													if (this.isElementInHide(pair.shape.resourceId)===true){
														this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,false,false,true);
														this.setStateForParentChilds(pair.shape,false);
													}else{
														this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
														this.setStateForParentChilds(pair.shape,true);
													}	
												}else{
													this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,true);
												}
											}else{
												this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,true);
											}
										}else{									
											this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,true);
										}
									}else{
										this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,true);
									}
								}else{
									this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,true);
								}
							}
						}else{
							// there is no parent						
							if (pair.isCombobox === false){
								if (enable){
									if (this.isElementInHide(pair.shape.resourceId)===true){
										this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,false,false,true);
										this.setStateForParentChilds(pair.shape,false);
									}else{
										this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
										this.setStateForParentChilds(pair.shape,true);
									}
								}else{
									this.setStateOfCheckbox(pair.htmlElement,pair.marker,enable,!enable,!enable,!enable);
								}								
							}else{								
								var parentPoolShape = this.getParentPoolForShape(pair.shape);
								var parentPoolPair = this.getHtmlElementShapePair(parentPoolShape.resourceId);
								if (!enable){
										pair.htmlElement.oldValue = pair.htmlElement.value;
										this.setValueAndStyleForACombobox(pair.shape,pair.htmlElement,this._comboboxStates.onlyContent,pair.marker,true);									
								}
								else{
									this.setValueAndStyleForACombobox(pair.shape,pair.htmlElement,pair.htmlElement.oldValue,pair.marker,!enable);
									this.setStateForParentChilds(pair.shape,true);
								}
							}
						}						
					}
				}
		 },
		
		 /**		 
		 * set the state of childsshapes of a given shape (parent) depends on the state of parent (active) 
		 */
		 setStateForParentChilds: function(parent,active){
				var leftFacade = this.viewWindow.leftFrameFacade;
				var childs = parent.childShapes;
				for(var i in childs){			
					var child = leftFacade._findShape(childs[i].resourceId);		
					if (child ){					
						var pair = this.getHtmlElementShapePair(child.resourceId);		
						if (pair){						
							var legendCheckbox = this.getLegendCheckboxForAPair(pair);					
							
							if (legendCheckbox === undefined){
								// if the shape isnt depended on a special elementgroup like ITSystem
								if (active){
									// parentshape is active
									this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
									// proof whether the shape is hidden by user?							
									if (this.isElementInHide(child.resourceId)===true){
										// if is it true, enable node for shape but marked as hidden
										this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,false,false,true);
										// set states for childs
										this.setStateForParentChilds(child,false);
									}else{
										// otherwise, shape can enable and activate
										this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
										this.setStateForParentChilds(child,true);
									}
									
								}else{
									// parentshape is disabled -> child and his childs also disabled
									this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,true);
									this.setStateForParentChilds(child,false);
								}
							}						
							else{
								// element belongs to an elementgroup
								if (active){									
									if (legendCheckbox.getValue()==true){
										// elementgroup is active
										// proof whether the shape was deactived by user								
										if (this.isElementInHide(child.resourceId)===true){
											// disable child
											this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,false,false,true);
											// set states for childs
											this.setStateForParentChilds(child,false);
										}else{											
											this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
											this.setStateForParentChilds(child,true);
										}									
									}								
								}else{
									// parent is deactived -> also child is deactived
									this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,true);
									this.setStateForParentChilds(child,false);
								}
							}
							
						}
						else{
							this.setStateForParentChilds(child,active);
						}
					}
				}
					
		 },		
		
		 /**		 
		 * set the shapes which have to hide in case of onlycontent
		 * e.g. Pools/Lanes  
		 */
		 disableElementsByOnlyContent: function(parent){
				var leftFacade = this.viewWindow.leftFrameFacade;
				var childs = parent.childShapes;
				for(var i in childs){			
					var child = leftFacade._findShape(childs[i].resourceId);		
					if (child ){					
						var pair = this.getHtmlElementShapePair(child.resourceId);		
						if (!pair){
							this.disableElementsByOnlyContent(child);
						}else{					
							if (pair.shape.stencil.id == "Lane" || pair.shape.stencil.id == "VerticalLane"){
								this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,false);								
							}else{
								// kann die checkbox enabled werden? nur wenn sei nicht in hide ist bzw. legend nicht ist bzw parent disabled ist
								if (this.isElementInHide(child.resourceId)===false){								
									// alle anderen müssen enabled werden, wenn die legendbox dafür auch enabled ist
									var legendCheckbox = this.getLegendCheckboxForAPair(pair);
									if (legendCheckbox === undefined){
										// auf jeden fall enablen, es sein denn der parent ist disabled
										var parentPair = this.getParentPairForAPair(pair);	
										
										if (parentPair){
											// wenn parent eine lane 
											if (parentPair.shape.stencil.id.endsWith("Lane")){				
												if(this.isElementInHide(parent.resourceId) === true){
													this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,true);
												} else {
													this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
												}
											}
											else{
												// status setzten abh?ngig vom parent
												if (parentPair.isActive()===true){
													this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
												}else{													
													this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,false);														
												}
											}											
										}
										else{
											this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
										}															
									}else{
										// legende ist vorhanden
										if (legendCheckbox.getValue()==true){
											// legende ist akiviert, also noch eltern prüfen
											var parentPair = this.getParentPairForAPair(pair);
											// parent darf keine lane sein										    
											if (parentPair){
												if (parentPair.shape.stencil.id.endsWith("Lane")===false){													
														// status setzten abh?ngig vom parent
													if (parentPair.isActive()===true){
														this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
													}else{													
														this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,false);														
													}														
												}else{
													this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
												}
											}
											else{
												this.setStateOfCheckbox(pair.htmlElement,pair.marker,true,false,false,false);
											}												
										}else{
											// legende ist disabled, also auch checkbox disablen
											this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,true,true,false);
										}	
									}	
								}
								else{
									this.setStateOfCheckbox(pair.htmlElement,pair.marker,false,false,false,true);
								}
							}
							this.disableElementsByOnlyContent(pair.shape);
						}							
					}
				}
					
		 },		
			 
		 /**		 
		 *  add one shape-id to the global hide-Array
		 */
		addElementToHide: function(element){
			this.hideElements.push(element);
		},
		
		/**		 
		 * proof whether a shape-id is in the global hide-Array
		 */
		isElementInHide: function(element){
			return (this.hideElements.indexOf(element) !== -1);
		},
		
		/**		 
		 * remove one shape-id from the global hide-Array
		 */
		removeElementToHide: function(element){
			this.hideElements.remove(element);
		},
		
		/**		 
		 * event is called, if a checkbox for a shape is clicked
		 */
		shapeCheckboxClicked: function(checkbox,shape,marker){
			// set the state for the chekbox which was clicked		
			if (checkbox !== undefined && shape !== undefined && marker !== undefined)
			{
				// clear the last timeout 
				if (this.timeOutID !== undefined){
					window.clearTimeout(this.timeOutID);				
				}
				var value = checkbox.checked;
				if (value === true){
					this.removeElementToHide(shape.resourceId);
				}else{
					this.addElementToHide(shape.resourceId);
				}
				this.setStateOfCheckbox(checkbox,marker,value,false,false,!value);	
				// set the states for the childShapes of the checkbox-shape
				// nur ausführen wenn es kinder hat
				this.setStateForParentChilds(shape,value);
				// halbe sekunde warten bevor geladen wird
				this.timeOutID = window.setTimeout(function(){					
					this.timeOutID = undefined;
					this.refreshRightSide();		
		    	}.bind(this),1200);
				
				
			}
		},
		
		/**		 
		 * event is called, if a combobox for a pool is clicked
		 */
		shapeComboboxClicked: function(combobox,shape,marker){	
			if (combobox !== undefined && shape !== undefined && marker !== undefined)
			{
				// clear the last timeout 
				if (this.timeOutID !== undefined){
					window.clearTimeout(this.timeOutID);				
				}
				var value = Ext.fly(combobox).getValue();			
				this.setStyleOfCombobox(combobox,marker,value);
				var pair = this.getHtmlElementShapePair(shape.resourceId);
				if (pair){
					if (value !== this._comboboxStates.onlyContent){
						
						this.setStateForParentChilds(shape,pair.isActive());
					}					
					else{
						// disable state for all lanes
						// 
						this.disableElementsByOnlyContent(shape);
					}
					// zu hide hinzufügen?
					if (value === this._comboboxStates.onlyContent){
						this.removeElementToHide(shape.resourceId);
					}
					if (value === this._comboboxStates.opened){
						this.removeElementToHide(shape.resourceId);
					}
					if (value === this._comboboxStates.collapse){
						this.removeElementToHide(shape.resourceId);
					}
					if (value === this._comboboxStates.closed){
						this.addElementToHide(shape.resourceId);
					}
				}				
				this.timeOutID = window.setTimeout(function(){					
					this.timeOutID = undefined;
					this.refreshRightSide();		
		    	}.bind(this),1500);
			}
		},
		
		 /**		 
		 * is called, when a checkbox of the legend (dataobject, itsystem, roles, comments) was checked
		 * seperate between checked and unchecked, depending on this event, the method will refresh the model
		 */
	    legendCheckboxWasChecked: function(checkbox,newValue)
	    {
	    	//refresh the left panel
	    	if (this.viewWindow.leftFrameFacade !== undefined)
	    	{
	    		if (checkbox.types !== undefined){
	    			// clear the last timeout 
					if (this.timeOutID !== undefined){
						window.clearTimeout(this.timeOutID);				
					}
	    			this.setStatusForShapesOfLegend(checkbox,newValue);
	    			this.timeOutID = window.setTimeout(function(){					
						this.timeOutID = undefined;
						this.refreshRightSide();						
			    	}.bind(this),1100);
	    		}
	    	}    	
	    },
		
	    /**		 
		 *  proof whether a given lane has siblings which are also lanes
		 */
	    hasLaneSiblings: function(lane){
	    	var parent = lane.parentShape;
	    	var countLanes = 0;
	    	var childs = parent.childShapes;
	    	for (var i in childs){
	    	    var child = childs[i];
	    	    if (child.stencil.id.endsWith("Lane") && child.resourceId !== lane.resourceId){
	    	            return true;
	    	    }
	    	}
	    	return false;
	    },
	    
		/**		 
		 *  render the checkboxes/combovboxes for the given shapes in the view
		 */
		renderMarkersForShapesInLeftFrame: function(leftContext, leftFacade){		
		    	
		  if (leftFacade != undefined){
	    		var canvasChilds = leftFacade._view.modelviewer.canvas.getNodes();
	    		// render checkboxes for non-pool elements
	    		var shapes = [];
	    		for(var i in canvasChilds){
	    			var shape = leftFacade._findShape(canvasChilds[i].resourceId);
	    			if(shape) 
	    			{		    			
	    				shapes.push(shape);
	    			}		    		
	    		}
	    		// add a marker for each shape
	    		var classNames = ["signavio-marker"];
	    		var htmlElementToPairCollection = [];
	    		shapes.each(function(shape){
	    			if (shape !== undefined){
		    			var orientation;
		    			var htmlElement;
		    			var isCombobox = false;
		    			var abort = false;
		    			// proof at first on lane, because a single lane doesnt get a marker
		    			if (shape.stencil.id.endsWith("Lane")){
		    				abort = !this.hasLaneSiblings(shape);
		    			}
		    			if (!abort){
			    			// create a marker for the shape to add later the icon
			    			var marker = new leftContext.MOVI.util.Marker(shape);
			    			marker.setNodeClassName(classNames.join(" "));
			    			if (shape.stencil.id !== "Pool" && shape.stencil.id !== "VerticalPool"){		    			
				    			// create a checkbox   				    			    			
			    				htmlElement = document.createElement("input");
			    				htmlElement.setAttribute("type","checkbox");
			    				htmlElement.setAttribute("class","ak-htmlElement-checkbox-margin-view");
			    				$(htmlElement).setStyle({margin: "0px !important"}); // for webkit
			    				htmlElement.checked = true;	    		    
				    			// register on click event
				    			Ext.fly(htmlElement).on("click", function(){this.shapeCheckboxClicked(htmlElement,shape,marker);}.bind(this));	
				    			// configure where the html-element have to place
				    			if (shape.stencil.id === "Lane"){
				    				orientation = 'northwest';
				    			}else if(shape.stencil.id === "TextAnnotation"){
				    				orientation = 'northwest';
				    			}else{
				    				orientation = 'northeast';
				    			}
				    				    			    			
			    			}
			    			if (shape.stencil.id === "Pool" || shape.stencil.id === "VerticalPool"){
			    				// create a combobox	    				
			    				htmlElement = document.createElement("select");
			    				// create the first option
			    				var option1 = document.createElement("option");
			    				option1.value = this._comboboxStates.opened;
			    				option1.appendChild(document.createTextNode(this._comboboxStates.opened));
			    				htmlElement.appendChild(option1);
			    				// create the second option
			    				var option2 = document.createElement("option");
			    				option2.value = this._comboboxStates.collapse;
			    				option2.appendChild(document.createTextNode(this._comboboxStates.collapse));
			    				htmlElement.appendChild(option2);
			    				// create the third option
			    				var option3 = document.createElement("option");
			    				option3.value =this._comboboxStates.onlyContent;
			    				option3.appendChild(document.createTextNode(this._comboboxStates.onlyContent));
			    				htmlElement.appendChild(option3);
			    				// create the fourth option
			    				var option4 = document.createElement("option");
			    				option4.value = this._comboboxStates.closed;
			    				option4.appendChild(document.createTextNode(this._comboboxStates.closed));
			    				htmlElement.appendChild(option4);
			    				// register on click-event
			    				$(htmlElement).setStyle({margin: "0px !important"});// for webkit
			    				Ext.fly(htmlElement).on("change", function(){this.shapeComboboxClicked(htmlElement,shape,marker);}.bind(this));
			    				// configure where the html-element have to place
			    				orientation = 'south';
			    				isCombobox = true;		    				
			    			}
			    			// add the htmlElement to a div and add the div to the marker
			    			var divHtmlElement = document.createElement("div");	
			    			divHtmlElement.appendChild(htmlElement);	    		
			    			marker.addIcon(orientation,divHtmlElement);	
			    			if (isCombobox){
			    				Ext.fly(divHtmlElement).addClass("ak-combox-shadow-view-checked");
			    				Ext.fly(divHtmlElement).addClass("ak-combobox-size-view-div");
			    			}else{
			    				Ext.fly(divHtmlElement).addClass("ak-checkbox-shadow-view-checked");
				    			Ext.fly(divHtmlElement).addClass("ak-checkbox-div-view");
			    			}		    			
			    			if(shape.stencil.id === "Lane"){
			    				Ext.fly(divHtmlElement).addClass("ak-checkbox-view-lane");
			    			}
			    			if(shape.stencil.id === "VerticalLane"){
			    				Ext.fly(divHtmlElement).addClass("ak-checkbox-view-verticallane");
			    			}		    			
			    			if(shape.stencil.id === "TextAnnotation"){
			    				Ext.fly(divHtmlElement).addClass("ak-checkbox-view-textannotation");
			    			}
			    			var pair = {};
			    			pair.isCombobox = isCombobox;
			    			pair.shape = shape;
			    			pair.id = shape.resourceId;
			    			pair.htmlElement = htmlElement;
			    			pair.marker = marker;	    		
			    			pair.parentHtmlElement = divHtmlElement;
			    			var me = this;
			    			pair.isActive = function(){
			    				if (this.isCombobox == false){
			    					return this.htmlElement.checked;
			    				}
			    				else{
			    					return (Ext.fly(this.htmlElement).getValue() === Signavio.I18N.ViewDefinition.comboboxStateOpened);
			    				}
			    				return false;
			    			};
			    			pair.getPoolState = function(){
			    				if (this.isCombobox == false){
			    					return undefined;
			    				}
			    				else{
			    					return Ext.fly(this.htmlElement).getValue();
			    				}		    				 
			    			};
			    			htmlElementToPairCollection.push(pair);
		    			}
	    			}
	    		}.bind(this));
	    		this.viewWindow.htmlElementToPairCollection = htmlElementToPairCollection;	    		
	       }		    	
	    	
		},
		
		/**		 
		 * deliever the css-tag regarding to the current browser-version
		 */
		getBrowserVersionClass: function(){
			if (Ext.isGecko === true) return "view-gecko";
			if (Ext.isChrome === true || Ext.isSafari2 === true || Ext.isSafari === true ) return "view-webkit";
			if (Ext.isOpera === true) return "view-opera";
			if (Ext.isIE9 === true) return "view-IE9";
			return "";
		},
		
		/**		 
		 * Deliever the html-fragment for the mashup-view
		 */
		getPreviewHtmlForIFrame: function(jsonData,viewDefinition)
		{
		  	// browser version aus dem body lesen			
			// CSS
			var ipadCss = Ext.isIPad ? "x-ipad" : "";
        	var css  = "body, .x-wrapper, .movi-scrollbox { width: 100%; height: 100% !important; padding: 0; margin: 0; } a {display: none !important;}" + this.getCssStyleForMashup();
			var html = '<html><head><style>'+(css)+'</style><title></title>';
			html 	+= '<script type="text/javascript">' + "\n";
			html 	+= "var SignavioConfig = {" + "\n";
			html 	+= "json: " + Object.toJSON(jsonData) +",\n";
			html 	+= "view:" + viewDefinition + ",\n";
			html 	+= "element:'model'" + ",\n";
			html 	+= "zoomSlider: true" + ",\n";
			html 	+= "overflowX: 'fit' " + ",\n";
			html 	+= "overflowY: 'fit' " + "\n";
			html 	+= "}" + "\n</script>";
			html 	+= '</head>';
			html 	+= '<body class="'+this.getBrowserVersionClass()+' ak-views-zoom-margin '+ ipadCss +' ">';
			var test = '<body class="'+this.getBrowserVersionClass()+' ak-views-zoom-margin '+ ipadCss +' ">';			
			html 	+= '<script type="text/javascript" src="'+(this.getServer())+'/mashup/signavio.js"></script>' + "\n";
			html 	+= '<div id="model" style="width: 100%; height: 100%">';			
			html 	+= '</div></body></html>';
			return html;			
		},
		
		/**
		 * deliever the css style
		 * @returns {String}
		 */
		
		getCssStyleForMashup: function()
		{			
			return 	".ak-views-attribute-marker-transparent {" +
					  "background-color: white !important; " +
					  "opacity: 0.55; " +
					"} " +
					
					".ak-checkbox-shadow-view-checkbox-transparent{ " +
					"	opacity: 0.55; " +
					"} " +		
					
					".ak-checkbox-shadow-view-checked{ " +
					"	box-shadow: 0 0 4px 1px silver; " +
					"	-moz-box-shadow: 0 0 4px 1px silver;	" +
					"	-webkit-box-shadow: 0 0 4px 1px silver; " +
					"	border: 2px solid #8BC10D; " +
					"	border-radius: 2px;	 " +
					"	-webkit-border-radius: 2px;	" +
					"	-moz-border-radius: 2px; " +	
					"}" +	
					
					".ak-checkbox-shadow-view-unchecked{" +
					"	box-shadow: 0 0 4px 1px silver;" +
					"	-moz-box-shadow: 0 0 4px 1px silver;	" +
					"	-webkit-box-shadow: 0 0 4px 1px silver;" +
					"	border: 2px solid #EC0008;" +
					"	border-radius: 2px;	" +
					"	-webkit-border-radius: 2px;	" +
					"	-moz-border-radius: 2px;	" +
					"}" +
					
					".ak-combox-shadow-view-checked{" +
					"	box-shadow: 0 0 4px 1px silver;" +
					"	-moz-box-shadow: 0 0 4px 1px silver;	" +
					"	-webkit-box-shadow: 0 0 4px 1px silver;" +
					"	border: 2px solid #8BC10D;" +
					"	border-radius: 2px;	" +
					"	-webkit-border-radius: 2px;	" +
					"	-moz-border-radius: 2px;" +
					"}" +
					
					".ak-combox-shadow-view-zugeklappt{" +
					"	box-shadow: 0 0 4px 1px silver;" +
					"	-moz-box-shadow: 0 0 4px 1px silver;	" +
					"	-webkit-box-shadow: 0 0 4px 1px silver;" +
					"	border: 2px solid #FFAA00;" +
					"	border-radius: 2px;	" +
					"	-webkit-border-radius: 2px;	" +
					"	-moz-border-radius: 2px;" +
					"}" +
					
					".ak-combox-shadow-view-inhalt-sichtbar{ " +	
					"	box-shadow: 0 0 4px 1px silver; " +
					"	-moz-box-shadow: 0 0 4px 1px silver; " +	
					"	-webkit-box-shadow: 0 0 4px 1px silver; " +
					"	border: 2px solid rgb(245,177,201); " +
					"	border-radius: 2px;	" +
					"	-webkit-border-radius: 2px;	" +
					"	-moz-border-radius: 2px; " +
					"} " +
					
					".ak-checkbox-view-lane{ " +
					"	margin-top: 18px !important; " +
					"	margin-left: 18px !important;	" +
					"}" +
					
					" .view-IE9 div.ak-checkbox-view-lane{ " +
					"	margin-top: 18px !important; " +
					"	margin-left: 18px !important;	" +
					"}" +
					
					".ak-checkbox-view-verticallane{ " +
					"	margin-top: 18px !important; " +
					"	margin-left: -22px !important;	" +
					"}" +
					
					".ak-checkbox-view-textannotation{ " +
					"	margin-top: 0px !important; " +
					"	margin-left: 0px !important;	" +
					"}" +
					
					".ak-views-zoom-margin .signavio-zoom{ " +
					"	margin-top: 20px !important;	" +
					"}" +
					
					".ak.views-zoom-margin .movi-zoomslider-vertical{ " +
					"	cursor: n-resize !important;	" +
					"}" +
					
					".ak.views-zoom-margin .movi-zoomslider-thumb{ " +
					"	cursor: n-resize !important;	" +
					"}" +
					
					".ak-combox-shadow-view-unchecked{ " +
					"	box-shadow: 0 0 4px 1px silver; " +
					"	-moz-box-shadow: 0 0 4px 1px silver;	" +
					"	-webkit-box-shadow: 0 0 4px 1px silver; " +
					"	border: 2px solid #EC0008; " +
					"	border-radius: 2px;	 " +
					"	-webkit-border-radius: 2px;	" +
					"	-moz-border-radius: 2px;	" +
					"}" +
					
					".ak-combobox-div-view{ " +
					"	height: 13px; " +
					"	width: 13px;	" +
					"} " +							
					
					
					".ak-htmlElement-checkbox-margin-view{" +
					"	margin: 0px !important;	" +
					"}" +
					
					".view-IE9 .ak-htmlElement-checkbox-margin-view{" +
					"	margin-top: -3px !important;	" +
					"	margin-left: -3px !important;	" +
					"	margin-right: -3px !important;	" +
					"	margin-bottom: -3px !important;	" +
					"}" +
					
					".ak-checkbox-div-view{" +
					"	height: 13px;" +
					"	width: 13px;	" +
					"}" +
					
					".x-ipad .ak-checkbox-div-view{" +
					"	height: 16px !important;" +
					"	width: 16px !important;" +
					"}" +
					
					".view-IE9 .ak-combobox-size-view-div{ " +
					"	height: 19px ; " +
					"} " +	
					
					".ak-combobox-size-view-div{ " +
					"	height: 20px ; " +
					"} " +				
				
					".view-IE9 .ak-checkbox-div-view{ " +
					"	margin: 0 0 0 0 !important; " +
					"	padding:0 0 0 0 !important; " +
					"} " +
					
					".view-webkit .ak-combobox-size-view-div{ " +	
					"	margin: 0 0 0 0 !important; " +
					"	padding:0 0 0 0 !important; " +
					"} " +
					
					".view-opera .ak-combox-shadow-view-checked{ " +
					"	border:1px solid #8BC10D; " +
					"}"	+	
			
					".x-ipad .signavio-zoom {" +
					    "background: none repeat scroll 0 0 transparent;" +
					    "height: 45px;" +
					    "left: 0px;" +
					"}" +

					".x-ipad .signavio-zoom-in {" +
					    "background: url('/portal/src/img/slider-track-vert.png') no-repeat scroll 10px 10px transparent;"+
					    "height: 32px;"+
					    "left: 0;"+
					    "position: absolute;"+
					    "top: -10px;   "+
					    " width: 42px;"+
					"}"+
		
					".x-ipad .signavio-zoomslider {"+
						"display: none;"+
					"}"+
					
					".x-ipad .movi-zoomslider-thumb {"+
						"background-image: url('/portal/src/img/s.gif') !important;" +
					"}"+					
					
					".x-ipad .signavio-zoom-out {"+
					    "background: url('/portal/src/img/slider-track-vert.png') no-repeat scroll 10px -123px transparent;"+
					    "bottom: -10px;"+
					    "height: 32px;"+
					    "left: 0;"+
					    "position: absolute;  " +
					    "width: 42px;"+
					"}";
		},
			    
		/**		 
		 * Deliever the Server-URl
		 */
		getServer: function(){
			return window.location.protocol+"//"+window.location.host;
		},
		
		/**
		 * get only the top-level-shapes of a set of shapes
		 * copied from Willy
		 */
		getAllShapesToConsider: function(shapes){
	        			
			var shapesToConsider = [], oshapes = shapes; // only top-level shapes
	        var childShapesToConsider = []; // all child shapes of top-level shapes
	        var canvas = this.facade.getCanvas(), rules = this.facade.getRules();
	                
	        shapes.each(function(shape){
	              	
	        	//Throw away these shapes which have a parent in given shapes
	            var isChildShapeOfAnother = shapes.any(function(s2){
	                return s2.hasChildShape(shape);
	            });
				/*
				 * since deleting the parent of a shape no longer
				 * means that all child shapes are deleted as
				 * well, we have to consider them for deletion
				 */
	            if(isChildShapeOfAnother) return;
	            
	            // This shape should be considered
	            shapesToConsider.push(shape);
	            // Consider attached nodes (e.g. intermediate events)
	            if (shape instanceof ORYX.Core.Node) {
					var attached = shape.getOutgoingNodes();
					attached = attached.findAll(function(a){ return !shapes.include(a); });
	                shapesToConsider = shapesToConsider.concat(attached);
	            }
	            
				// Append all shapes which doesnt fit to any parent
	            /*shapesToConsider = [].concat(shapesToConsider, shape.getChildShapes(false).findAll(function(cshape){
					var dc = ORYX.Plugins.Edit.DeleteCommand.prototype;
					return !dc.findParent.call({facade:this.facade, findParent:dc.findParent}, cshape, shape.parent) && !shapesToConsider.include(cshape);
				}.bind(this)));*/
	        }.bind(this));
	        
	        // All edges between considered child shapes should be considered
	        // Look for these edges having incoming and outgoing in childShapesToConsider
	        var edgesToConsider = this.facade.getCanvas().getChildEdges().select(function(edge){
	            // Ignore if already added
	            if(shapesToConsider.include(edge)) return false;
	            // Add if already is in the list of shapes
	            if(oshapes.include(edge)) return true;
	            // Ignore if there are no docked shapes
	            if(edge.getAllDockedShapes().size() === 0) return false; 
	            // True if all docked shapes are in considered child shapes
	            return edge.getAllDockedShapes().all(function(shape){
	                // Remember: Edges can have other edges on outgoing, that is why edges must not be included in childShapesToConsider
	                //return shape instanceof ORYX.Core.Edge || childShapesToConsider.include(shape);
					// Edges will only be removed if manually selected
					// or if the target or the source no longer exist
					return false;
	            });
	        });
	        shapesToConsider = [].concat(shapesToConsider, edgesToConsider).uniq();        
	        return shapesToConsider;
	    }	
	
	});
	
	Signavio.Plugins.ViewsAttributeWindow.CheckboxChangeCommand = ORYX.Core.Command.extend({
		
		construct: function(selection,view,oldViews,checkbox,newValue,facade,me){
			this.selection = selection;
			this.view = view;
			this.checkbox = checkbox;
			this.newValue = newValue;
			var savedViews = [];
			oldViews = oldViews || [];
			oldViews.each(function(v){
				savedViews.push(v);
			}.bind(this));
			this.oldViews = savedViews;		
			this.facade = facade;
			this.me = me;
		},	
					
		/**		 
		 * remove a given view (viewDefinition) from the view-storage
		 * and call method for rendering new panels for views
		 */
		execute: function(){
			if (this.facade.getSelection() !== this.selection){
				this.facade.setSelection(this.selection);
			}
			
			if (this.newValue === false){
				this.checkbox.view = this.me.hideElementsInViewAndSave(this.selection,this.view);
			}else{
				this.checkbox.view = this.me.showElementsInViewAndSave(this.selection,this.view);
			}
	  
		},
		
		rollback: function(){
		   
		   this.facade.setSelection(this.selection);
		   if (this.newValue === true){
				this.checkbox.view = this.me.hideElementsInViewAndSave(this.selection,this.view);
				this.checkbox.show();				
			}else{
				this.checkbox.view = this.me.showElementsInViewAndSave(this.selection,this.view);
				this.checkbox.show();
			}
		}
	});
	
	
	Signavio.Plugins.ViewsAttributeWindow.RemoveCommand = ORYX.Core.Command.extend({
		
		construct: function(viewToDelete,oldViews,facade,me){
			this.viewToDelete = viewToDelete;
			this.oldViews = oldViews;
			this.facade = facade;
			this.me = me;
		},	
					
		/**		 
		 * remove a given view (viewDefinition) from the view-storage
		 * and call method for rendering new panels for views
		 */
		execute: function(){
			// delete version by name
	    	var oldViews = this.oldViews;
	    	
	    	var newViews = [];
	    	oldViews.each(function(view){
	    		if (view.name !== this.viewToDelete.name){
	    			newViews.push(view);
	    		}
	    	}.bind(this));   
	    	this.me.setAllViewsFromMeta(newViews);
	    	// delete link vom panel
	    	this.me.renderViewsOfModel();
	    	this.me.panelInPropertyWindow.doLayout();
	  
		},
		
		rollback: function(){		   
		   this.me.setAllViewsFromMeta(this.oldViews);
		   this.me.renderViewsOfModel(); 
		   this.me.panelInPropertyWindow.doLayout();
		}
	});
	
	
	Signavio.Plugins.ViewsAttributeWindow.CreateCommand = ORYX.Core.Command.extend({
		
		construct: function(newView,oldViews,facade,me){
			this.newView = newView;
			this.oldViews = oldViews;
			this.facade = facade;
			this.me = me;
		},	
					
	    /**		 
		 * save a new view in the view-storage by getting the new viewDefinition
		 * and call method for rendering new panels for views
		 */	 
		execute: function(){
			var newViews = [];
			this.oldViews.each(function(v){
				newViews.push(v);
			}.bind(this));
			newViews.push(this.newView);
			this.me.setAllViewsFromMeta(newViews);
			this.me.renderViewsOfModel();  
			this.me.panelInPropertyWindow.doLayout();
	  
		},
		
		rollback: function(){
		   this.me.setAllViewsFromMeta(this.oldViews);
		   this.me.renderViewsOfModel(); 
		   this.me.panelInPropertyWindow.doLayout();
		}
	});
	

	Signavio.Plugins.ViewsAttributeWindow.ChangeCommand = ORYX.Core.Command.extend({
		
		construct: function(newView,oldView,oldViews,facade,me){
			this.newView = newView;
			this.oldViews = oldViews;
			this.oldView = oldView;
			this.facade = facade;
			this.me = me;
		},	
					
		/**		 
		 * change an exisiting view, by getting the new viewDefinition and save it in the view-collection 
		 * and call method for rendering new panels for views
		 */    	 
				
		execute: function(){
			var oldView = this.oldView;
	    	var newView = this.newView;	   
	    	// find view in the store to change the new view
	    	var oldViews = this.oldViews;	
	    	var newViews =[];
	    	oldViews.each(function(view){
	    		if (oldView.name === view.name){
	    			newViews.push(newView);
	    		}
	    		else{
	    			newViews.push(view);
	    		}
	    	}.bind(this));		    	
	    	this.me.setAllViewsFromMeta(newViews);
	    	// render links
	    	this.me.renderViewsOfModel(); 
	    	this.me.panelInPropertyWindow.doLayout();
		},
		
		rollback: function(){
		   this.me.setAllViewsFromMeta(this.oldViews);
		   this.me.renderViewsOfModel(); 
		   this.me.panelInPropertyWindow.doLayout();
		}
	});


}();/**
 * Copyright (c) 2009
 * Philipp Giese | Willi Tscheschner | Philipp Berger
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

if(!Signavio) { var Signavio = {}; }
if(!Signavio.Plugins) { Signavio.Plugins = {}; }
	
new function() {
	
	/**
	 * Plugin to enable if the Signavio branding 
	 * can be excluded in the pdf export
	 * @class
	 * @inherit Signavio.Core.Plugin
	 */
	Signavio.Plugins.MapExportEnableSignavioBrandingOption = ORYX.Plugins.AbstractPlugin.extend({
		enabled: true,
		construct: function() {
			arguments.callee.$.construct.apply(this, arguments);	
			ORYX.CONFIG.SIGNAVIO_BRANDING_CONFIGURABEL = true;
		}
	});
	
	Signavio.Plugins.PDFExport = {
		enabled: true,
		
		construct: function() {
		
			arguments.callee.$.construct.apply(this, arguments);
			
			this.facade.offer({
	            'name'			: ORYX.I18N.File.print,
	            'functionality'	: this.exportPDF.bind(this),
	            'group'			: ORYX.I18N.File.group,
	            'icon'			: ORYX.PATH + "images/printer.png",
	            'description'	: ORYX.I18N.File.printDesc,
	            'index'			: 4,
	            'minShape'		: 0,
	            'maxShape'		: 0
	        });
		},
		
		exportPDF: function() {			
			
			var x1,x2,y1,y2 = undefined;
			
			this.facade.getCanvas().getChildShapes(true).each(function(shape) {
				var absBounds = shape.absoluteBounds();
				var ul = absBounds.upperLeft();
				var lr = absBounds.lowerRight();
				if(x1 == undefined) {
					x1 = ul.x;
					y1 = ul.y;
					x2 = lr.x;
					y2 = lr.y;
				} else {
					x1 = Math.min(x1, ul.x);
					y1 = Math.min(y1, ul.y);
					x2 = Math.max(x2, lr.x);
					y2 = Math.max(y2, lr.y);
				}
			});
			
			var isHor = (x2-x1 >= y2-y1);
			
			var store = new Ext.data.SimpleStore({
			    data : [
		            //-- NAME								-- FORMAT							-- IMAGE																-- PAGE MODE				-- LANDSCAPE	-- INDEX
		            [Signavio.I18N.PDFExport.fitToPage, 	Signavio.I18N.PDFExport.portrait, 	ORYX.CONFIG.EXPLORER_PATH + "/src/img/map/1page.vertical.png", 			"FitToPage", 				false,			0],
		            [Signavio.I18N.PDFExport.clipAllSides,	Signavio.I18N.PDFExport.portrait, 	ORYX.CONFIG.EXPLORER_PATH + "/src/img/map/4pages.vertical.png", 		"MapClip", 					false,			0],
		            [Signavio.I18N.PDFExport.clipBottom,	Signavio.I18N.PDFExport.landscape, 	ORYX.CONFIG.EXPLORER_PATH + "/src/img/map/2pages.ns.horizontal.png", 	"OneSideClipNS",			true, 			0],
		            [Signavio.I18N.PDFExport.clipBottom, 	Signavio.I18N.PDFExport.portrait, 	ORYX.CONFIG.EXPLORER_PATH + "/src/img/map/2pages.ns.vertical.png", 		"OneSideClipNS", 			false,			0],
		            [Signavio.I18N.PDFExport.fitToPage, 	Signavio.I18N.PDFExport.landscape,	ORYX.CONFIG.EXPLORER_PATH + "/src/img/map/1page.horizontal.png", 		"FitToPage",				true, 			1],
		            [Signavio.I18N.PDFExport.clipAllSides, 	Signavio.I18N.PDFExport.landscape,	ORYX.CONFIG.EXPLORER_PATH + "/src/img/map/4pages.horizontal.png", 		"MapClip",					true,	 		1],
		            [Signavio.I18N.PDFExport.clipRight, 	Signavio.I18N.PDFExport.portrait,	ORYX.CONFIG.EXPLORER_PATH + "/src/img/map/2pages.ew.vertical.png", 		"OneSideClipEW", 			false,			1],
			        [Signavio.I18N.PDFExport.clipRight,		Signavio.I18N.PDFExport.landscape, 	ORYX.CONFIG.EXPLORER_PATH + "/src/img/map/2pages.ew.horizontal.png", 	"OneSideClipEW",			true,		 	1]
			    ],
			    fields: ["name", "format", "img", "pageMode", "landscape", "index"]
			});
			
			store.sort("index", isHor ? "DESC" : "ASC");
			
			var data = new Ext.DataView({
				tpl: '<tpl for=".">'+
						'<div class="thumb-wrap">'+
							'<span class="thumb-title">{name}</span>' +
							'<span class="thumb-format">{format}</span>' +
							'<div class="thumb"><img src="{img}" title="{name}" /></div>' +
						'</div>' +
					'</tpl><div class="x-clear"></div>',
			    itemSelector : 'div.thumb-wrap',
                overClass	 : 'x-view-over',
				store : store,
				style : "overflow:auto; padding:0px;",
				cls	  : "x-plugin-map-view",
				singleSelect : true,
				width : 332,
				height: 230,    
				doSingleSelection : function(item, index, e){
		        	this.select(index, false);
				},
				afterRender : function(){
					Ext.DataView.prototype.afterRender.apply(this, arguments);
					this.select(0);		
				},
				listeners : {
					containerclick : function(a,e){
						return false;
					}
				}
			});
			
			var optionWindow = new Ext.Window({ 
				resizable	: false,
				minimizable	: false,
				modal		: true,
				width		: 345,
				title		: Signavio.I18N.PDFExport.optionWindowTitle,
				bodyStyle	: "background-color:white;",
				items		: [
	     		   new Ext.form.Label({
	     			   	style:"display:block;padding-bottom:10px;padding-left:7px;padding-right:5px;padding-top:5px;width:320px;",
			    		text:Signavio.I18N.PDFExport.offerTitleDesc
			    	}),data,new Ext.Panel({
						layout: "form",
						style: "padding-left:7px",
						cls: "x-form-map-export-branding",
						border: false,
						items: [{
								xtype:'checkbox',
								hideLabel : true,
								name: "showSignavioBranding",
								checked: this.facade.getModelMetaData().mode === "Enterprise",
								disabled: !ORYX.CONFIG.SIGNAVIO_BRANDING_CONFIGURABEL,
								//boxLabel: Signavio.I18N.PDFExport.branding +" "+ ((!ORYX.CONFIG.SIGNAVIO_BRANDING_CONFIGURABEL)?' <img ext:qtip="' + Signavio.I18N.PDFExport.premiumOnly +'" src="/explorer/src/img/famfamfam/information.png" style="margin-left: 2px; margin-top: -3px; position: relative; top: 4px;"/>':"")
								//shanglihui 20111124 编辑器输出到pdf按钮弹出的对话框上的一个图片
								boxLabel: Signavio.I18N.PDFExport.branding +" "+ ((!ORYX.CONFIG.SIGNAVIO_BRANDING_CONFIGURABEL)?' <img ext:qtip="' + Signavio.I18N.PDFExport.premiumOnly +'" src="/v5designer/explorer/src/img/famfamfam/information.png" style="margin-left: 2px; margin-top: -3px; position: relative; top: 4px;"/>':"")
							},{
								xtype:'checkbox',
								hideLabel : true,
								checked: false,
								boxLabel:Signavio.I18N.PDFExport.blackWhite
							},
							this.facade.getModelMetaData().mode === "Academic"?
							{
								xtype: 'checkbox',
								hideLabel: true,
								checked: false,
								name: "isSketchy",
								boxLabel: Signavio.I18N.PDFExport.sketchy,
								visible: this.facade.getModelMetaData().mode === "Academic"
							}:null
						].compact()
					})],
				buttons: [
					{
			        	text: Signavio.I18N.PDFExport.buttonTitle,
			        	handler: function(){
					
							var record = data.getSelectedRecords()[0];
							
							// Get the serialized svg image source
					        var svgClone 	= this.facade.getCanvas().getSVGRepresentation(true);
					        if (this.facade.getCanvas().properties["oryx-showstripableelements"] !== true) {
					        	var stripOutArray = Element.getElementsByClassName(svgClone, "stripable-element");
					        	for (var i=stripOutArray.length-1; i>=0; i--) {
					        		stripOutArray[i].parentNode.removeChild(stripOutArray[i]);
					        	}
					        }
							  
							// Remove all forced stripable elements 
				        	var stripOutArray = Element.getElementsByClassName(svgClone, "stripable-element-force");
				        	for (var i=stripOutArray.length-1; i>=0; i--) {
				        		stripOutArray[i].parentNode.removeChild(stripOutArray[i]);
				        	}
							          
							// Parse dom to string
					        var svgDOM 	= DataManager.serialize(svgClone);
											        
							var checkBoxPanel = optionWindow.items.get(2);
							
					        this.sendRequest({
					        	landscape	: record.get("landscape"),
								pageMode	: record.get("pageMode"),
								filename	: this.facade.getModelMetaData().name || "",
								title		: this.facade.getModelMetaData().name || "",
								svg_xml		: svgDOM,
								showSignavioBranding	: !checkBoxPanel.items.get(0).getValue(),
								blackWhite	: checkBoxPanel.items.get(1)?checkBoxPanel.items.get(1).getValue():false,
								isSketchy	: checkBoxPanel.items.get(2)?checkBoxPanel.items.get(2).getValue():false,
								scale		: 1.4
					        });
					        						
							optionWindow.close();
							
						}.bind(this)
			    	},
			    	{
			    		text : Signavio.I18N.PDFExport.closeTitle,
			    		handler : function(){
			    			optionWindow.close();
			    		}
			    	}
				]
			});
			
			optionWindow.show();
		},
    	sendRequest: function(options, success){
    		
			var charsToDeleteFromFileName = /[\/\\\*><\|]/g;
			
			options.filename = options.filename.replace(charsToDeleteFromFileName, " ");
			
			
			// Append security parameter
			Ext.apply(options, Ext.Ajax.getSecurityParameter());
			
			/*if (this.frame) {
				this.frame.remove()
				delete this.frame;
			}*/
			
			// Create a new form
			//this.frame = Ext.getBody().createChild({tag:'iframe',cls:'x-hidden',id:'iframe',name:'iframe'});
			
			// Define the url
			var url = window.location.protocol+"//"+window.location.host+window.location.pathname.substring(0,window.location.pathname.lastIndexOf("/")) + ORYX.CONFIG.DIAGRAM_PRINTER_URL + "/" + encodeURI(options.filename) + ".pdf";

			// Open a new window
			var w = window.open();
			
			// Parse all inputs
			var inputs = [];
			
			$H(options).each(function(hash){
				if (hash.value instanceof Array) {
					hash.value.each(function(val){
						inputs.push(["input", {type:"hidden", value:val, name:hash.key}]);
					})
				} else {
					inputs.push(["input", {type:"hidden", value:hash.value, name:hash.key}]);
				}
			})
						
			// Create form
			/*
			var form = ORYX.Editor.graft(null, w.document, //this.frame.dom, 
					["form", {action:url, method:"POST" }]
					 	.concat(inputs)
				)	
			*/
			var doc = w.document;
				
			var form = doc.createElement("form");
			form.setAttribute("action", url);
			form.setAttribute("method", "POST");
			form.setAttribute("accept-charset", "utf-8");
			form.setAttribute("enctype", "application/x-www-form-urlencoded");

			
			$H(options).each(function(hash) {
				var input = doc.createElement("input");
				input.setAttribute("type", "hidden");
				input.setAttribute("name", hash.key);
				input.setAttribute("value", hash.value);
				
				form.appendChild(input);
			});
			
			w.document.body.appendChild(form);
			
			// Submit
			form.submit();
		}
	};
	
	Signavio.Plugins.PDFExport = ORYX.Plugins.AbstractPlugin.extend(Signavio.Plugins.PDFExport);
	
}();
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.SimplePrint = Clazz.extend({

    facade: undefined,
	    
    construct: function(facade){
        this.facade = facade;
         
        this.facade.offer({
            'name': ORYX.I18N.File.print,
            'functionality': this.exportPDF.bind(this),
            'group': ORYX.I18N.File.group,
            'icon': ORYX.PATH + "images/printer.png",
            'description': ORYX.I18N.File.printDesc,
            'index': 4,
            'minShape': 0,
            'maxShape': 0
        });
    },
	
    exportPDF: function(){
    	
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.File.genPDF});
		
        var resource = location.href;
        
        // Get the serialized svg image source
        var svgClone = this.facade.getCanvas().getSVGRepresentation(true);
        
        var svgDOM = DataManager.serialize(svgClone);
		
        // Send the svg to the server.
        //TODO make this better by using content negotiation instead of format parameter.
        //TODO make this better by generating svg on the server, too.
        var fileName = this.facade.getModelMetaData().name || "diagram";
        
        var w = window.open();
        
        var inputs = [];
        
        var url = window.location.protocol+"//"+window.location.host+ORYX.CONFIG.PDF_EXPORT_URL;
        
        inputs.push(["input", {type:"hidden", value:svgDOM, name:'data'}]);
        inputs.push(["input", {type:"hidden", value:fileName, name:'name'}]);
        
        // Append security parameter
		$H(Ext.Ajax.getSecurityParameter()).each(function(hash){
				if (hash.value instanceof Array) {
					hash.value.each(function(val){
						inputs.push(["input", {type:"hidden", value:val, name:hash.key}]);
					})
				} else {
					inputs.push(["input", {type:"hidden", value:hash.value, name:hash.key}]);
				}
			});
		 
        // Create form
		var form = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", w.document.body, //this.frame.dom, 
				["form", {action:url, method:"POST" }]
				 	.concat(inputs)
			);

		// Submit
		form.submit();
		
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
    }
});
/**
 * Copyright (c) 2010
 * Christian Ress <bart@oryx-uml.the-bart.org>, Philipp Giese
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
*/
if(!ORYX) { var ORYX = {}; }
if(!ORYX.Plugins) { ORYX.Plugins = {}; }

(function() {
	/**
	 * The UML plugin provides layout methods referring to the UML stencilset. 
	 * 
	 * @class ORYX.Plugins.UML
	 * @extends Clazz
	 * @param {Object} facade The facade of the editor
	 */
	ORYX.Plugins.UML = Clazz.extend({
		facade: undefined,
		
		/**
		 * Creates a new instance of the UML plugin and registers it on the
		 * layout events listed in the UML stencil set.
		 * 
		 * @constructor
		 * @param {Object} facade The facade of the editor
		 */
		construct: function(facade) {
			this.facade = facade;
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.handlePropertyChanged.bind(this));
			this.facade.registerOnEvent('layout.uml.class', this.handleLayoutClass.bind(this));
			this.facade.registerOnEvent('layout.uml.complexClass', this.handleLayoutComplexClass.bind(this));
			this.facade.registerOnEvent('layout.uml.list', this.handleLayoutList.bind(this));
			this.facade.registerOnEvent('layout.uml.association', this.handleLayoutAssociation.bind(this));
			this.facade.registerOnEvent('layout.uml.qualified_association', this.handleLayoutQualifiedAssociation.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.addReadingDirectionOnLoad.bind(this));
		},
		
		/**
		 * Add reading direction on load.
		 *
		 * Because the reading direction arrow is added to the
		 * label of an edge, we have to iterate over all edges
		 * and add the arrow on load for it to appear.
		 *
		 * @param {Object} event
		 */
		addReadingDirectionOnLoad : function(event) {
			this.facade.getCanvas().edges.each(function(edge){
				if (edge.properties["oryx-direction"] == "left" || edge.properties["oryx-direction"] == "right") {
					this.addReadingDirection(edge);
				}
			}.bind(this));
		},
		
		/**
		 * calculates the height of a text, taking line breaks into consideration
		 *
		 * @param {Object} labelElement the label
		 * @param {String} the label test
		 */
		
		calculateLabelHeight: function (labelElement, labelValue) {
			var fontSize = labelElement.getFontSize();
			var lines = labelElement.node.childNodes.length;
			
			try {
				return Math.max(labelElement.node.getBBox().height, 1 * fontSize + 0.75);
			} catch (e) {
				if (lines) {
					return lines * fontSize + 0.75;
				} else {
					return 1 * fontSize + 0.75;
				}
			}
		},
		calculateLabelWidth : function (labelElement, labelValue) {
			
			try {
				return Math.max(labelElement.node.getBBox().width+5, 40);
			} catch (e) {
				return 40;
			}
		},
		
		/**
		 * Add Reading Direction to the name label after it has been changed
		 */
		handlePropertyChanged : function(event) {
			if (event.name == "oryx-name" || event.name == "oryx-direction") {
				this.addReadingDirection(event.elements[0]);
			} 
		},
		
		setClassAbstract: function(shape, isAbstract) {
            isAbstract = (isAbstract === true || isAbstract === "true");			
			var className = this.getLabel(shape, "name");
			
			className.node.setAttribute("font-style", isAbstract ? "italic" : "normal");
		},
		
		/**
		 * Layout class shapes.
		 *   - make text italic when abstract
		 */
		handleLayoutClass : function(event) {
			var shape = event.shape;
			
			this.setClassAbstract(shape, shape.properties["oryx-abstract"]);
		},

		getLabel: function(shape, id) {
			return shape.getLabels().find(function(label) {
				return label.id === (shape.id + id);
			});
		},
		
		getSVGElement: function(shape, id) {
			return shape._svgShapes.find(function(svg) {
				return svg.element.id === (shape.id + id);
			}).element;
		},
		
		moveLine: function(line, y) {
			line.setAttribute("y1", y);
			line.setAttribute("y2", y);
		},
		
		getClassLabels: function(shape) {
			return {
				name: this.getLabel(shape, "name"),
				attributes: this.getLabel(shape, "attributes"),
				stereotype: this.getLabel(shape, "keyword"),
				methods: this.getLabel(shape, "methods")
			};
		},
		
		getClassHeights: function(shape, labels) {
			return {
				name: this.calculateLabelHeight(labels.name, shape.properties["oryx-name"]),
				attributes: this.calculateLabelHeight(labels.attributes, shape.properties["oryx-attributes"]),
				methods: this.calculateLabelHeight(labels.methods, shape.properties["oryx-methods"])
			};
		},
		
		/**
		 * Layout complex class shapes.
		 *   - make text italic when abstract
		 *   - resize methods and attributes boxes according to their content
		 */
		handleLayoutComplexClass: function(event) {
			var shape = event.shape;
			
			this.setClassAbstract(shape, shape.properties["oryx-abstract"]);
		
			// Only update if the last label gets updated
			if (shape.getLabels().any(function(label){ 
				return label.isUpdating();
			})){
				return;
			}
			
			var labels = this.getClassLabels(shape);
			var heights = this.getClassHeights(shape, labels);
			
			if(shape.properties["oryx-keyword"]) {
				labels.stereotype.text("<<" + shape.properties["oryx-keyword"] + ">>");
				labels.stereotype.update();
			}
			
			var separator = this.getSVGElement(shape, "separator");
			var upperseparator = this.getSVGElement(shape, "upperseparator");
			
			var classY = 14;
			var attributesY = 22;
			var methodsY = 44;
			var distanceTilSeparator = attributesY + heights.attributes + 2;
			var distanceTilBottom = distanceTilSeparator + heights.methods + 1;
			
			// resize stencil according to classname's height
			if (labels.name.node.childNodes.length > 1){
				classY = heights.name + 7;
				attributesY += heights.name;
				methodsY += heights.name;
				distanceTilSeparator += heights.name;
				distanceTilBottom += heights.name;
			}
			
			if (shape.properties["oryx-keyword"]) {
				classY += 10;
				attributesY += 10;
				methodsY += 10;
				distanceTilSeparator += 10;
				distanceTilBottom += 10;
			}
			
			//set position of the class name
			labels.name.setY(classY);
			
			//set position of the first separator
			this.moveLine(upperseparator, attributesY - 2);
			
			//set position of the second separator
			this.moveLine(separator, distanceTilSeparator);
			
			// realign attributes label (so that oryx' internal references are correct)	
			labels.attributes.setY(attributesY);
			
			// realign methods label (so that oryx' internal references are correct)
			labels.methods.setY(distanceTilSeparator + 3);
			
			// If something has changed
			if (shape.bounds.height() !== distanceTilBottom + 5 && !this.updating) {
				// resize shape
				this.updating = true;
				shape.bounds.set(shape.bounds.upperLeft(), {
					x: shape.bounds.b.x, 
					y: shape.bounds.a.y + distanceTilBottom + 5
				});
				
				this.facade.getCanvas().update();
				this.facade.updateSelection();
				delete this.updating;
			}
		},
		
		/**
		 * Layout the interface and enumeration shape. Resize according to their content.
		 */
		handleLayoutList: function(event) {
			var shape = event.shape;
			
			if (shape.getLabels().any(function(label){ 
				return label.isUpdating();
			})){
				return;
			}
			var nameValue = shape.properties["oryx-name"];			
			var itemsValue = shape.properties["oryx-items"];
			
			var name = this.getLabel(shape, "name");
			var items = this.getLabel(shape, "items");
			
			var separator = this.getSVGElement(shape, "separator");
			
			var nameHeight = this.calculateLabelHeight(name, nameValue);
			var itemsHeight = this.calculateLabelHeight(items, itemsValue);
		
			var itemsStart = 32;
			
			this.moveLine(separator, 30);
			
			if (name.node.childNodes.length > 1) {
				//set position of the class name
				//name.y = 22;
				this.moveLine(separator, 14 + nameHeight);
				itemsStart = 16 + nameHeight;
			};
			
			var distanceTilBottom = itemsStart + itemsHeight + 3;
			
			
			// realign methods label (so that oryx' internal references are correct)
			items.setY(itemsStart + 3);
		
			// If something has changed
			if (shape.bounds.height() !== distanceTilBottom + 5) {
			
				// resize shape
				shape.bounds.set(shape.bounds.upperLeft() , {
					x: shape.bounds.b.x, 
					y: shape.bounds.a.y + distanceTilBottom + 5
				});
				
				this.facade.getCanvas().update();
				this.facade.updateSelection();
			}
		},
		
		/**
		 * Draws the reading direction arrow when an association is changed.
		 */
		handleLayoutAssociation : function(event) {
			this.addReadingDirection(event.shape);
		},
		 
		addReadingDirection : function(shape) {
			var name = this.getLabel(shape, "name");
			var nameValue = shape.properties["oryx-name"];

			if (name.text().split("< ").last() != "" || name.text().split(" >").first() != "") {
				
				switch(shape.properties["oryx-direction"]) {
					case "left":
						name.text("< " + nameValue);
						break;
					case "right":
						name.text(nameValue + " >");
						break;
					default:
						name.text(nameValue);
				}
			}
		},
		
		/**
		 * Resizes the qualifier box of a qualified association according to its content.
		 */
		handleLayoutQualifiedAssociation : function(event) {
			var shape = event.shape;
			var qualifier = this.getLabel(shape, "qualifier");
			var qualifierValue = shape.properties["oryx-qualifier"];
			
			var width = this.calculateLabelWidth(qualifier, qualifierValue);
			
			shape._markers.values()[0].element.lastElementChild.setAttributeNS(null, "width", width);
			shape._markers.values()[0].element.setAttributeNS(null, "markerWidth", width);
			
			this.facade.getCanvas().update();
		}
	});
}());
/**
 * Copyright (c) 2010
 * Ralf Diestelkaemper, Lukas Brand
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
*/
if("undefined" == typeof ORYX){ var ORYX = {}; }
if("undefined" == typeof ORYX.Plugins){ ORYX.Plugins = {}; }

new function(){
	/**
	 * The UMLUseCase plugin provides layout methods referring to the UMLUseCase stencilset. 
	 * 
	 * @class ORYX.Plugins.UMLUseCase
	 * @extends Clazz
	 * @param {Object} facade The facade of the editor
	 */
	ORYX.Plugins.UMLUseCase = Clazz.extend({
		/** @lends ORYX.Plugins.UMLUseCase# */
		
		/**
		 * Creates a new instance of the UML plugin and registers it on the
		 * layout events listed in the UML UseCase stencil set.
		 * 
		 * @constructs
		 * @param {Object} facade The facade of the editor
		 */
		construct: function(facade) {
			this.facade = facade;
			this.facade.registerOnEvent('layout.uml.useCaseExtended', this.handleUseCaseExtendedLayout.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.handleDiagramOnLoad.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
		},
		
		/**
		 * Handles the layouting after loading a diagram
		 * This Function starts a recursion 
		 * which layouts the stereotypes of all systems and
		 * the UseCaseExtended.
		 *
		 * @param {Object} event The event, that is fired after a Use Case diagram is loaded
		 */
		handleDiagramOnLoad : function(event) {
			this.layoutAllSystems(this.facade.getCanvas());
		},
		
		/**
		* Recursivly layouts the system, 
		* all child systems and the UseCasesExtended the system includes
		*
		* @param {ORYX.Core.Node} system A system shape
		*/
		layoutAllSystems : function(system){
			
			this.layoutAllUseCaseExtended(system);
			
			var systems = system.getChildNodes().findAll( function(child) {
				if (this.isSystemNode(child)) {
					return child;
				}
			}.bind(this));
			
			systems.each(function(systemNode){ 
				this.layoutStereotype(systemNode);
				this.layoutAllSystems(systemNode); //recursion
			}.bind(this));
		
		},
		
		/**
		* Layouts all UseCasesExtended contained in the system
		*
		* @param {ORYX.Core.Node} system A system shape
		*/
		layoutAllUseCaseExtended : function(system){
			
			var useCasesExtended = system.getChildNodes().findAll(function(child) {
				if (this.isUseCaseExtendedNode(child)) {
					return child;
				}
			}.bind(this));
			
			useCasesExtended.each(function(useCaseExtendedNode){ 
				this.layoutUseCaseExtended(useCaseExtendedNode);
			}.bind(this));
		
		},
		
		/**
		* This method is called when a UseCaseExtended shape is modified.
		* It registers another handling method to the selection changed event, 
		* since that event is fired late enough to do the needed layouting.
		*
		* The chain of called methods, to do the layouting:
		*		handleUseCaseExtendedLayout(...) | layouting event fired
		*	->	handleUseCaseExtendedSelection(...) | selection event fired
		*	->	layoutUseCaseExtended(...) | simple method call
		*
		* @param {Object} event The event which is fired after the UseCaseExtended shape is modified
		*/
		handleUseCaseExtendedLayout : function(event) {
			
			var shape = event.shape;
			if (shape.isResized){
				this.SelectionEventFunction = this.handleUseCaseExtendedSelection.bind(this);
				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this.SelectionEventFunction);
			}		
		},
		
		/**
		* This method is called after a UseCaseExtended shape is modified.
		* It deregisters itself on the selection changed event, 
		* since this event is fired late enough to do the needed layouting.
		*
		* First the method checks whether the event has a reference to a UseCaseExtended shape, 
		* since there is no guarantee.
		* 
		* @param {Object} event The event which is fired after the UseCaseExtended is resized
		*/
		handleUseCaseExtendedSelection : function(event) {
			
			var shape = event.elements.first();
			if (!this.isUseCaseExtendedNode(shape)) {return;}
			
			this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this.SelectionEventFunction);
			this.layoutUseCaseExtended(shape);
		},
		
		/**
		* This method layouts the UseCaseExtended shape
		* It places the textframe and text which describe the extensions directly underneath 
		* the text "Extension Points"
		* Neither the resize attribute nor the anchors attribute had the desired effect.
		* 
		* @param {ORYX.Core.Node} useCaseExtended A UseCaseExtended shape
		*/
		layoutUseCaseExtended : function(useCaseExtended){
		
			var extensionPointTextFrame = useCaseExtended._svgShapes.find(
					function(element) { return element.element.id == (useCaseExtended.id + "extension_point_text_frame"); 
				}).element;
			var extensionPointText = useCaseExtended.getLabels().find(
					function(label) { return label.id == (useCaseExtended.id + "extensions"); 
				});
			var extensionText = useCaseExtended.getLabels().find(
					function(label) { return label.id == (useCaseExtended.id + "extensionpoint"); 
				});
			var verticalDifference = extensionPointTextFrame.y.baseVal.value - extensionText.y-16;
			extensionPointTextFrame.y.baseVal.value= extensionText.y+16;
			extensionPointText.y= extensionText.y+16;
			extensionPointTextFrame.height.baseVal.value += verticalDifference;	
		
		},	
	
		
		/**
		* Initiates the Stereotype layout
		* This method is called whenever a property of a shape is changed. 
		* It filters the events, which belong to a System shape and are fired,
		* when the stereotype or name is changed.
		*
		*@param {Object} event The event that is fired after changing a property of a shape.
		*/
		handlePropertyChanged : function(event) {
			var shape = event.elements.first();
			if (!this.isSystemNode(shape)) {return;}
			if (!(this.isStereotypeKeyEvent(event) || this.isNameKeyEvent(event))) {return;}
			this.layoutStereotype(shape);			
		},
		
		/**
		* Layouts the stereotype and name properties of a System shape
		* It places the stereotype and property of a System properly and hides the stereotype when necessary
		*
		*@param {ORYX.Core.Node} system The System shape the user modified the stereotype/name from.
		*/
		layoutStereotype: function(system) {
		
			var stereotype = system.getLabels().find(
					function(label) { return label.id == (system.id + "stereotype"); 
				});
			var name = system.getLabels().find(
					function(label) { return label.id == (system.id + "text"); 
				});
			
			if (stereotype.text().empty()){
						name.y=stereotype.y;
						stereotype.hide();
					}else{
						name.y = stereotype.y+14;
						stereotype.show();
						stereotype.text("a‰a" + system.properties["oryx-stereotype"] + "a‰?");
					}
			name.update();
			stereotype.update();
		},
		
		/**
		* Helper method, which returns true, if the received shape is an extended Use Case. 
		*@private
		*@param {Object} shape The shape that is checked for beeing an extended Use Case.
		*@return {boolean} The result is true, if the shape is an extended Use Case.
		*/
		isUseCaseExtendedNode : function(shape) {
			return "http://b3mn.org/stencilset/umlusecase#usecaseextended" == shape.getStencil().id().toLowerCase();
		},
		
		/**
		* Helper method, which returns true, if the received shape is an  Use Case. 
		*@private
		*@param {Object} shape The shape that is checked for beeing an  Use Case.
		*@return {boolean} The result is true, if the shape is an  Use Case.
		*/
		isUseCaseNode : function(shape) {
			return "http://b3mn.org/stencilset/umlusecase#usecase" == shape.getStencil().id().toLowerCase();
		},
	
		
		/**
		* Helper method, which returns true, if the received shape is a system. 
		*@private
		*@param {Object} shape The shape that is checked for beeing a system.
		*@return {boolean} The result is true, if the shape is a system
		*/
		isSystemNode : function(shape) {
			return "http://b3mn.org/stencilset/umlusecase#system" == shape.getStencil().id().toLowerCase();
		},
		
		/**
		* Helper method, which returns true, if the received shape is an include edge. 
		*@private
		*@param {Object} shape The shape that is checked for beeing an include edge.
		*@return {boolean} The result is true, if the shape is an include edge
		*/
		isIncludeEdge : function(shape) {
			return "http://b3mn.org/stencilset/umlusecase#include" == shape.getStencil().id().toLowerCase();
		},
		
		/**
		* Helper method, which returns true, if the received shape is an extend edge. 
		*@private
		*@param {Object} shape The shape that is checked for beeing an extend edge.
		*@return {boolean} The result is true, if the shape is an extend edge
		*/
		isExtendEdge : function(shape) {
			return "http://b3mn.org/stencilset/umlusecase#extend" == shape.getStencil().id().toLowerCase();
		},
		
		/**
		* Helper method, which returns true, if the received event handles a stereotype.
		*@private 
		*@param {Object} event The event that is checked for handling an oryx-stereotype.
		*@return {boolean} The result is true, if event handles a stereotype
		*/
		isStereotypeKeyEvent : function(event) {
			return event["key"] == "oryx-stereotype";
		},
		
		/**
		* Helper method, which returns true, if the received event handles a name.
		*@private 
		*@param {Object} event The event that is checked for handling an oryx-name.
		*@return {boolean} The result is true, if event handles a name
		*/
		isNameKeyEvent : function(event) {
			return event["key"] == "oryx-name";
		}
	});
}();
/**
 * Copyright (c) 2010
 * Willi Tscheschner
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

/**
 * Define Namespace
 */
if (!Signavio) { var Signavio = new Object(); }
if (!Signavio.Plugins) { Signavio.Plugins = new Object(); }


(function(){
	
	
	// The suffix of the stencil set id
	var LABEL_NODES = {
		"http://b3mn.org/stencilset/bpmn2.0#": ["gContainer", "#Subprocess@name", "#EventSubprocess@name", "GatewaysMorph", "Message", "StartEventsMorph", "IntermediateEventsMorph", "EndEventsMorph", "ITSystem", "DataStore", "Group", "processparticipant", "wmBorder"],
		"http://b3mn.org/stencilset/bpmn2.0choreography#": ["ChoreographySubprocessExpanded", "#Subprocess", "GatewaysMorph", "Message", "StartEventsMorph", "IntermediateEventsMorph", "EndEventsMorph", "ITSystem", "wmBorder"],
		"http://b3mn.org/stencilset/epc#": ["gContainer", "@frequency", "@time", "wmBorder", "Letter", "Phone", "Mail@title", "Fax"],
		"http://b3mn.org/stencilset/bpmn2.0conversation#": ["Communication", "SubConversation"],
		"http://b3mn.org/stencilset/timjpdl3#": ["GatewaysMorph", "StartEventsMorph", "EndEventsMorph", "IntermediateEventMorph"],
		'http://www.signavio.com/stencilsets/processmap#' : ["gContainer", 'Group'],
		'http://www.signavio.com/stencilsets/organigram#' : ["gContainer"]
	};
	
	var DEACTIVATE_POSITIONING = {
		"http://b3mn.org/stencilset/UML2.2Class#": ["QualifiedAssociation@qualifier"]
	};
	
	// The group of stencils
	var LABEL_NODES_INNER = ["Subprocess", "EventSubprocess", "ChoreographySubprocessExpanded", "Group", "wmBorder", "gContainer"];
	var LABEL_CORNER_DISTANCE = {
		"GatewaysMorph" :  { x: 14, y : 16},
		"StartEventsMorph" : { x: 9, y : 9},
		"IntermediateEventsMorph" : { x: 9, y : 9},
		"EndEventsMorph": { x: 9, y : 9},
		"Event" :  { x: 3, y : 14},
		"Function" :  { x: 3, y : 9},
		"Communication" :  { x: 8, y : 12},
		"SubConversation" :  { x: 8, y : 12}
	};
	
	var Position = function(x, y){
	    this.x = (arguments.length === 1 && arguments[0].x !== undefined ? arguments[0].x : arguments[0]) || 0;
	    this.y = (arguments.length === 1 && arguments[0].y !== undefined ? arguments[0].y : arguments[1]) || 0;
	};
		
	Position.prototype.moveBy = function(){
		return new Position(this.x + (arguments.length === 1 && arguments[0].x !== undefined ? arguments[0].x : arguments[0]) || 0, 
							this.y + (arguments.length === 1 && arguments[0].y !== undefined ? arguments[0].y : arguments[1]) || 0);
	};
	
	Position.prototype.castToInts = function(){
		return new Position(Math.floor(this.x), Math.floor(this.y));
	};

	Signavio.Plugins.LabelPosition = ORYX.Plugins.AbstractPlugin.extend({
		
		/**
		 * Provides a frame around each label
		 * 
		 * @class Signavio.Plugins.LabelPosition
		 */
		construct: function(facade){
			this.facade = facade;
			this.frames = [];
			
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOVER, this.onOver.bind(this));
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, function() {
    			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.onPropertyChanged.bind(this));
			}.bind(this));
			
			document.addEventListener('mousedown', function(){this.mouseDown = true;}.bind(this), true);
			document.addEventListener('mouseup', function(){ delete this.mouseDown; }.bind(this), true);
		},
		
		onPropertyChanged: function(e) {
		    var shape = (e.elements||[]).first();
		    
		    if(!(shape instanceof ORYX.Core.Edge)) {
		    	return;
		    }
		    
		    window.setTimeout(function() {
		    	shape.getLabels().each(function(label) {
                    if(!label.visible()) {
                        this.removeFrame(label);
                    } else {
                    	this.addFrame(label, shape);
                    }
                }.bind(this));
		    }.bind(this), 200);
		},
		
		onOver: function(event, uiObj){
			// Show the frame if going over the text with the mouse
			if (uiObj instanceof ORYX.Core.Shape && ["text", "tspan"].include(event.target.tagName.toLowerCase()) && !this.mouseDown){
				var text = event.target.tagName.toLowerCase() == "tspan" ? event.target.parentNode : event.target;
				uiObj.getLabels().each(function(label){
					if (label.node === text){
						var frame = this.addFrame(label, uiObj);
						if (frame){
							frame.onMouseOut = function(){
								if (!frame.isDragging){
									this.removeFrames(this.selectedShape);
								}
							}.bind(this)
						}
					}
				}.bind(this))
			}
		},
		
		/**
		 * Show a frame around each label
		 * of the selected elements.
		 *
		 */
		onSelectionChanged: function(){
			var me = this;
			// If one is selected
			if (this.facade.getSelection().length === 1) {
				// Reuse the older one, if its the same
				if (this.facade.getSelection()[0] === this.selectedShape){
					return;
				}
				// Remove other frames
				this.removeFrames(this.facade.getSelection()[0]);
				var shape; // Chache the selected shape
				this.selectedShape = shape = this.facade.getSelection()[0];
				// Add new frames
				shape.getLabels().each(function(label){
					me.addFrame(label, shape)
				});
			} else {
				this.removeFrames();
				delete this.selectedShape;
			}
			
		},
		
		removeFrame: function(label) {
		    this.frames.each(function(frame) {
		        if(label === frame.label) {
		        	frame.destroy();
		        	
		        	throw $break;
		        }
		    });
		},
		
		/**
		 * Removes all created frames
		 *
		 */
		removeFrames: function(none){
			this.frames = this.frames.findAll(function(frame){
				if (!none || none != frame.shape){
					frame.destroy();
					return false;
				}
				return true
			});
		},
		
		/**
		 * Adds a frame for a label, if there is text
		 */
		addFrame: function(label, shape){
			if(this.isBlacklisted(shape, label)) {
				return null;
			}
			
			if (label.visible() && label.text() && (shape instanceof ORYX.Core.Edge || this.canReposition(label, shape))) {
				var frame = this.frames.find(function(frame){ return frame.label == label && frame.shape == shape });
				if (!frame){
					frame = new LabelFrame(label, shape, this.facade);
					this.frames.push(frame);
				}
				return frame;
			}
			return null;
		},
		
		isBlacklisted: function(shape, label) {
			var namespace = shape.getStencil().namespace();
			var entries = DEACTIVATE_POSITIONING[namespace];
			var reject = false;
			
			(entries || []).each(function(entry) {
				var shapeId = entry.split("@")[0];
				var labelId = entry.split("@")[1];
				
				shapeId = namespace + shapeId;
				labelId = labelId !== undefined ? shape.id + labelId : "";
				
				if(shape.getStencil().id() === shapeId) {
					reject = !labelId || labelId && labelId === label.id;
					
					throw $break;
				}
			});
							
			return reject;
		},
		
		/**
		 * Returns TRUE if the label can be reposition
		 * @param {Object} label
		 * @param {Object} shape
		 */
		canReposition: function(label, shape){
			var namespace = shape.getStencil().namespace();
			
			return (LABEL_NODES[namespace]||[]).any(function(n){ 
				// Check if id is a stencil
				var isStencil = shape.getStencil().id().toLowerCase().endsWith(n.toLowerCase());
				// Check if id is a role
				var isRole = shape.getStencil().roles().include(shape.getStencil().namespace() + n);
				// Check if label is one of the defined property
				if (!isStencil && !isRole && n.include("@")){
					var sId = n.split("@")[0];
					var propId = n.split("@")[1];
					
					if (sId && !shape.getStencil().id().toLowerCase().endsWith(sId.toLowerCase())){
						return false;
					}

					return shape.getStencil().properties().any(function(property){
						return property.id() == propId && property.refToView().any(function(ref){ 
							return shape.getLabel(ref) === label; 
						});
					});
				}
				
				return isStencil || isRole;
			});
		}
		
	});
	
	var EdgePosition = Clazz.extend({
		construct: function(label, shape, position){
			this.label = label;
			this.shape = shape;
			this.position = position;
			this.calculate();
		},
		calculate: function(){
			
			var label = this.label, dockers = this.shape.dockers;
			var fdocker, sdocker;
			
			if (this.position.include("start")){
				fdocker = dockers[0]; sdocker = dockers[1];
			} else if (this.position.include("end")) {
				fdocker = dockers.last(); sdocker = dockers[dockers.length-2];
			} else if (this.position.include("mid")) {
				var mid = Math.ceil(dockers.length/2)-1;
				fdocker = dockers[mid]; sdocker = dockers[mid+1];
			}
			
			var fdposition = fdocker.bounds.center();
			var sdposition = sdocker.bounds.center();
			
			var ivector = ORYX.Core.Math.getIdentityVector(fdposition, sdposition);
			var ofvector = ORYX.Core.Math.getOrthogonalIdentityVector(ivector);
			var angle = this.shape._getAngle(fdocker, sdocker);
			if (!(angle <= 90 || angle > 270)) {
				ofvector.x *= -1; ofvector.y *= -1;
			}
			
			this.vector = ivector;
			this.orthogonalVector = ofvector;
			var v = Object.clone(ofvector);
			var fontSize = label.getFontSize()-1;
			
			// Initial state
			// 		--------------------->
			// (1) Move top/bottom with the offset
			// 		|-------------------->
			// 		V
			// (2) Move left/right with the offset
			// 		|-------------------->
			// 		V-->
			// (3) Move left/right with the length of the label
			// 		|-------------------->
			// 		V-->------->		
			// (4) Move to the initial position
			
			switch(this.position) {
				case "midtop":
					if (dockers.length%2 === 0){
						var midPoint = ORYX.Core.Math.getPointBetweenTwoPoints(fdposition, sdposition, 0.5);
						v.x *= label.getOffsetTop()+(fontSize/2); v.y *= label.getOffsetTop()+(fontSize/2); // (1)
						v.x += midPoint.x; v.y += midPoint.y; 												// (4)
						break;
					}
				case "starttop":
					v.x *= label.getOffsetTop()+(fontSize/2); v.y *= label.getOffsetTop()+(fontSize/2); // (1)
					v.x += ivector.x * label.getOffsetTop(); v.y += ivector.y * label.getOffsetTop();	// (2)
					//v.x += ivector.x * (label.getWidth()/2); v.y += ivector.y * (label.getWidth()/2);	// (3)
					v.x += fdposition.x; v.y += fdposition.y; 											// (4)
					break;
				case "midbottom":
					if (dockers.length%2 === 0){
						var midPoint = ORYX.Core.Math.getPointBetweenTwoPoints(fdposition, sdposition, 0.5);
						v.x *= -label.getOffsetTop()-(fontSize/2); v.y *= -label.getOffsetTop()-(fontSize/2); 	// (1)
						v.x += midPoint.x; v.y += midPoint.y; 													// (4)
						break;
					}
				case "startbottom":
					v.x *= -label.getOffsetTop()-(fontSize/2); v.y *= -label.getOffsetTop()-(fontSize/2); 	// (1)
					v.x += ivector.x * label.getOffsetTop(); v.y += ivector.y * label.getOffsetTop();		// (2)
					//v.x += ivector.x * (label.getWidth()/2); v.y += ivector.y * (label.getWidth()/2);		// (3)
					v.x += fdposition.x; v.y += fdposition.y; 		 										// (4)		    
					break;
				case "endtop":
					v.x *= label.getOffsetTop()+(fontSize/2); v.y *= label.getOffsetTop()+(fontSize/2); 	// (1)
					v.x += ivector.x * label.getOffsetTop(); v.y += ivector.y * label.getOffsetTop();		// (2)
					//v.x += ivector.x * (label.getWidth()/2); v.y += ivector.y * (label.getWidth()/2);		// (3)
					v.x += fdposition.x; v.y += fdposition.y;  		 										// (4)				    
					break;
				case "endbottom":
					v.x *= -label.getOffsetTop()-(fontSize/2); v.y *= -label.getOffsetTop()-(fontSize/2); 	// (1)
					v.x += ivector.x * label.getOffsetTop(); v.y += ivector.y * label.getOffsetTop();		// (2)
					//v.x += ivector.x * (label.getWidth()/2); v.y += ivector.y * (label.getWidth()/2);		// (3)
					v.x += fdposition.x; v.y += fdposition.y; 	 		 									// (4)			    
					break;
			}
			
			this.firstdocker = fdocker; this.seconddocker = sdocker;
			this.angle = angle; this.center = v;
		}
	})
	
	/**
	 * Implements the border for a label which adds some
	 * functions to the label.
	 * 
	 * @class LabelFrame
	 */
	var LabelFrame = Clazz.extend({
		
		// Defines the offset of the frame around the label
		offset: 2,
		
		snapDistance: 10,
		labelDistance: 5,
		
		color_docked: "silver",
		color_snapped: "blue",
		color_undocked : "red",
		color_referenced: "green",
		
		onMouseOut: Ext.emptyFn,
		
		construct: function(label, shape, facade){
			this.label = label;
			this.shape = shape;
			this.facade = facade;
			this.nodes = [];
			this.init();
		},
		
		/**
		 * Initialize all needed objects
		 */
		init: function(){
			// Set the size
			this.initTimer = window.setTimeout(function(){
				if (this.label)
					this.setSize(this.label);
			}.bind(this), 1);
			// Add an event listener	
			this.getSVG().addEventListener("mousedown", this.startDragDrop.bind(this), true);
			
			this.updateLabelClb = this.onLabelUpdate.bind(this);
			this.label.registerOnChange(this.updateLabelClb);
			
			this.initOnMouseOut();
		},
		
		/**
		 * Implements a workaround to see if a mouse
		 * went out of the label, even when its done 
		 * very quickly.
		 */
		initOnMouseOut: function(){
			
			var node = this.label.node;
			var mouseOut = function(){
				this.onMouseTimer = window.setTimeout(function(){
					this.onMouseOut();
				}.bind(this), 100);
				node.removeEventListener("mouseout", mouseOut, true);
			}.bind(this);
			node.addEventListener("mouseout", mouseOut, true);
			this.getSVG().addEventListener("mouseover", function(){window.clearTimeout(this.onMouseTimer)}.bind(this), true);
			this.getSVG().addEventListener("mouseout", function(){
				this.onMouseOut();
			}.bind(this), true);			
		},
		
		getScale: function(){
			return this.facade.getCanvas().getZoom() || 1;
		},
		
		/**
		 * Return a rectangle
		 */
		getSVG: function(){
			if (!this.node){
				// Create indicator for edge intersection point
				/*this.intersection = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.label.node.parentNode,
					['circle', {
						'display'		: 'none',
						'cx'			: '8',
						'cy'			: '8',
						'r'				: '3',
						'fill'			: '#CCCCCC',
						'stroke'		: 'black',
						'stroke-width'	: '1',
						'fill-opacity' 	: '1',
						'stroke-opacity': '0.5'}]);*/
				
				this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.label.node.parentNode, 
					['g', {
						'pointer-events'	: 'all',
						'cursor'			: 'move'}]);

				this.node.rect = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,
					['path', {
						'd'					: 'M 0 0',
						'stroke-width'		: Math.max(0.2, (1/this.getScale()) || 1), 
						'stroke-dasharray'	: '10, 2',
						'shape-rendering'	: 'crispEdges',
						'stroke'			: this.color_docked,
						'stroke-opacity' 	: '0.7',
						'fill'				: 'none'}]);
				
				//this.nodes.push(this.intersection);
				this.nodes.push(this.node);
				
				if (this.shape instanceof ORYX.Core.Edge) {
					this.generateEdgePositionReferencePoints();
				}
			}
			return this.node;
		},
		
		generateEdgePositionReferencePoints: function(){
			if (!this.node){ return; }
		
			//var g = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['g', {}]);
			//this.nodes.push(g);
			var gn = $H({}), gp = $H({}), label = this.label, shape = this.shape;
				
			["starttop","startbottom",/*"midtop", "midbottom", */"endtop","endbottom", label.getOriginEdgePosition()].uniq().each(function(obj){
				gp[obj] = new EdgePosition(label, shape, obj);
				/*gn[obj] = ORYX.Editor.graft("http://www.w3.org/2000/svg", g, 
					['circle', {
						'cx'			: '2',
						'cy'			: '2',
						'r'				: '2',
						'fill'			: '#CCCCCC',
						'stroke'		: 'black',
						'stroke-width'	: '1',
						'fill-opacity' 	: '0.8',
						'stroke-opacity': '0.1',
						'transform'		: 'translate('+(gp[obj].center.x-2)+','+(gp[obj].center.y-2)+')'}]);*/
			});
			
			this.edgePositions = gp;
			//this.edgePositionNodes = gn;
			
			// Append g
			//this.label.node.parentNode.appendChild(g);
		},
		
		/**
		 * Callback to handle label changes.
		 */
		onLabelUpdate: function(){
			window.clearTimeout(this.initTimer);
			// Set the correct size of the frame
			this.setSize(this.label);
			
			this.labelOffset = this.positionToLabelPosition(new Position(0,0));
		},
		
		getPathD: function(w, h){
			var c = 4;
			return ["M 0 0 L", w, "0 L", w, h-c,"L", w-c, h, "L 0", h, "Z"].join(" ")
		},
		
		setSize: function(){
			
			var x, y, width, height;
			switch(arguments.length){
				case 1:
					if (arguments[0] instanceof ORYX.Core.SVG.Label){
						var label = arguments[0];
						x = label.getX(); y = label.getY();
						width = label.getWidth(); height = label.getHeight();
					}
					break
				case 4:
					x = arguments[0]; y = arguments[1];
					width = arguments[2]; height = arguments[3];
					break;
			}
			
			if (x === undefined || y === undefined || width === undefined || height === undefined ){
				throw new Error("LabelFrame.setSize() in labelPosition.js invalid argument.");
			}
			
			var svg = this.getSVG(), rotate = "";
			
			if (this.label.getEdgePosition()){
				var ep = this.label.getEdgePosition();
				var angle = this.label.rotate();
				var dockers = this.shape.dockers, center;
				
				// Start position
				if (ep.include("start")){
					center = dockers.first().bounds.center();
				// End position
				} else if (ep.include("end")){
					center = dockers.last().bounds.center();
				// Mid position
				} else {
					var mid = Math.ceil(this.shape.dockers.length/2)-1;
					// Mid middle
					if (this.shape.dockers.length%2 === 0){
						center = ORYX.Core.Math.getPointBetweenTwoPoints(dockers[mid].bounds.center(), 
										dockers[mid+1].bounds.center(), 
										0.5);
					// Mid left
					} else {
						center = dockers[mid].bounds.center();
					}
					
				}
				rotate = ["rotate(", angle, ", ", center.x, ", ", center.y, ") "].join("");  
			} 
			
			x = x - this.offset - (width%2==0?1:0);
			y = y - this.offset;
			
			// Set the group element to the correct position
			svg.setAttribute("transform", [rotate, "translate(", Math.floor(x), ", ", Math.floor(y), ")"].join(""));
			
			width = Math.floor(width+(2*this.offset))+1; height = Math.floor(height+(2*this.offset));
			// Set width/height of rect
			svg.rect.setAttribute("d", this.getPathD(width, height));

			// Set drag circle to south-west
			//svg.drag.setAttribute("transform", ["translate(", -8, ", ", height+(2*this.offset)-7, ")"].join(""));
			this.applyIndicator(this.label.position ? 0 : (this.label.getReferencePoint() ? 3 : 1));
			
			
			// Show reference point indicator
			this.setIntersectionPoint(this.label.getReferencePoint());
		},
		
		/**
		 * Apply the state of the label
		 * 1 means docked to the origin position
		 * 2 means docked somewhere else
		 * if else, the state is undocked somewhere else
		 * @param {Object} state
		 * @deprecated
		 */
		applyIndicator: function(state){

			return;
			
			// Set color of the stroke
			/*if (state === 1){
				this.getSVG().rect.setAttribute("stroke", this.color_docked);
			} else if (state === 2){
				this.getSVG().rect.setAttribute("stroke", this.color_snapped);			
			} else if (state === 3){
				this.getSVG().rect.setAttribute("stroke", this.color_referenced);
			} else {
				this.getSVG().rect.setAttribute("stroke", this.color_undocked);
			} 
			
			// Set the edge snapping point
			if (this.edgePositionNodes && this.shape instanceof ORYX.Core.Edge) {
				if (this.label.getEdgePosition() && this.edgePositionNodes[this.label.getEdgePosition()]) {
					this.edgePositionNodes[this.label.getEdgePosition()].setAttribute("display", "none")
				} else {
					this.edgePositionNodes.values().invoke("removeAttribute", "display");
				}
			}*/
		},
		
		setIntersectionPoint: function(reference){
			/**if (reference && this.label.isVisible){
				this.intersection.removeAttribute('display');
				this.intersection.setAttribute('transform', ["translate(", Math.floor(reference.intersection.x-8), ", ", Math.floor(reference.intersection.y-8), ")"].join(""));
			} else {
				this.intersection.setAttribute('display', 'none');
			}*/
		},
		
		setPositionOfNode: function(node, position){
			node.setAttributeNS(null, 'x', Math.floor(position.x));
			node.setAttributeNS(null, 'y', Math.floor(position.y));
		},
		
		positionToLabelPosition: function(position, useOrigin){
			if (!position){
				return null;
			}
			position = new Position(position).moveBy(this.offset*2, this.offset*2);
			if (this.label){
				var x = 0, y = 0;
				switch (this.label[useOrigin?"getOriginHorizontalAlign":"horizontalAlign"]()){
					case 'left':
						x -= this.offset;
						break;
					case 'center' :
						x += Math.ceil(this.label.getWidth()/2) - (this.offset);
						break;
					case 'right' :
						x += this.label.getWidth() - (this.offset);
						break;
				}
				switch (this.label[useOrigin?"getOriginVerticalAlign":"verticalAlign"]()){
					case 'top':
						y -= this.offset;
						break;
					case 'middle' :
						y += Math.ceil(this.label.getHeight()/2) - (this.offset);
						break;
					case 'bottom' :
						y += this.label.getHeight() - (2*this.offset);
						break;
				}
				position = position.moveBy(x+(this.label.getWidth()%2==0?1:0), y);
			}
			return position.castToInts();
		},
		
		setLabelPosition: function(position){
			this.setPositionOfNode(this.label.node, position);
			for (var i = 0, child = this.label.node.childNodes, size = child.length; i < size; ++i){
				this.setPositionOfNode(child[i], position);
			}
		},
		
		startDragDrop: function(evt){
			
			if (this.isDragging){
				return;
			}
			this.isDragging = true;
			
			ORYX.Core.SVGEnableDrag(evt, this.getSVG(), {
				movedCallback: this.onDrag.bind(this),
				upCallback: this.onDragDrop.bind(this),
				adjustPosition: this.adjustPosition.bind(this)
			})
			
			this.labelOffset = this.positionToLabelPosition(new Position(0,0));
			
			Ext.getBody().setStyle("cursor", "move");
			
			this.initialState = {
				position : this.label.getPosition(),
				edgePosition : this.label.getEdgePosition(),
				reference : this.label.getReferencePoint(),				
				valign : this.label.verticalAlign(),
				halign : this.label.horizontalAlign()
			}
			
			this.initDragDrop = true;
		},
		
		getCornerDistance: function(shape){
			if (!this.cornerDistance) {
				var r = shape.getStencil().roles().find(function(role){
					return LABEL_CORNER_DISTANCE[role] || LABEL_CORNER_DISTANCE[role.replace(shape.getStencil().namespace(), "")];
				});
				this.cornerDistance = r ? LABEL_CORNER_DISTANCE[r] || LABEL_CORNER_DISTANCE[r.replace(shape.getStencil().namespace(), "")] : {x: 0,y: 0};
			}
			return this.cornerDistance;
		},
		
		adjustPositionAtNode: function(position, event){

			var labelRef = this.labelOffset.moveBy(position);
			var labelRefOrigin = this.positionToLabelPosition(position, true);
			var smid = this.shape.bounds.midPoint();
			var sw = this.shape.bounds.width();
			var sh = this.shape.bounds.height();
			var lw = this.label.getWidth() + (this.offset*2);
			var lh = this.label.getHeight() + (this.offset*2);
			var cd = this.getCornerDistance(this.shape);
			
			var shape = this.shape;
			var inner = LABEL_NODES_INNER.any(function(n){ return shape.getStencil().id().toLowerCase().endsWith(n.toLowerCase()) || shape.getStencil().roles().include(shape.getStencil().namespace() + n)})
			var outter = !inner;
			
			// No anchor
			this.label.anchorLeft = this.label.anchorTop = false;
			this.label.anchorRight = this.label.anchorBottom = false;
			this.label.horizontalAlign("center");
			this.label.verticalAlign("middle");
				
			if (Math.abs(this.label.x-labelRefOrigin.x) < this.snapDistance && Math.abs(this.label.y-labelRefOrigin.y) < this.snapDistance) {
				position = new Position(position).moveBy(this.label.x-labelRefOrigin.x, this.label.y-labelRefOrigin.y);
				this.applyIndicator(1); // Docked to origin position
				this.label.resetAnchorPosition(); // Set the anchor to origin position
				this.label.horizontalAlign(this.label.getOriginHorizontalAlign());
				this.label.verticalAlign(this.label.getOriginVerticalAlign());
				return position;
			
			} else if (event.ctrlKey || event.metaKey) {
				return position;
			
			
			// SNAP AT X Position
			// 
			//       x
			//  .---------.
			//  |x   x   x|
			// x|x       x|x
			//  |x   x   x|
			//  '---------'
			//       x
			// 
			
			// INNER: LEFT-TOP
			} else if (inner && Math.abs(position.x) < this.snapDistance && Math.abs(position.y) < this.snapDistance) {
				position = {x: 0, y: 0};
				this.label.anchorLeft = this.label.anchorTop = true;
				this.label.horizontalAlign("left");
				this.label.verticalAlign("top");

			// INNER: CENTER-TOP
			} else if (inner && Math.abs(smid.x-(position.x+(lw/2))) < this.snapDistance && Math.abs(position.y) < this.snapDistance) {
				position = {x: smid.x-(lw/2)-(2*this.offset)+1, y: 0};
				this.label.anchorTop = true;
				this.label.horizontalAlign("center");
				this.label.verticalAlign("top");
				
			// INNER: RIGHT-TOP
			} else if (inner && Math.abs(sw-(position.x+(lw))) < this.snapDistance && Math.abs(position.y) < this.snapDistance) {
				position = {x: sw-lw-(4*this.offset)+1, y: 0}; 
				this.label.anchorRight = this.label.anchorTop = true;
				this.label.horizontalAlign("right");
				this.label.verticalAlign("top");



			// INNER: LEFT-MIDDLE
			} else if (inner && Math.abs(position.x) < this.snapDistance && Math.abs(smid.y-(position.y+(lh/2))) < this.snapDistance) {
				position = {x: 0, y: smid.y-(lh/2)-(2*this.offset)+1};
				this.label.anchorLeft = true;
				this.label.horizontalAlign("left");
				this.label.verticalAlign("middle");

			// INNER: CENTER-MIDDLE
			} else if (inner && Math.abs(smid.x-(position.x+(lw/2))) < this.snapDistance && Math.abs(smid.y-(position.y+(lh/2))) < this.snapDistance) {
				position = {x: smid.x-(lw/2)-(2*this.offset)+1, y: smid.y-(lh/2)-(2*this.offset)+1};
				//TODO: Implement middle Anchor?
//				this.label.anchorMiddle = true;
				this.label.horizontalAlign("center");
				this.label.verticalAlign("middle");
			// INNER: RIGHT-MIDDLE
			} else if (inner && Math.abs(sw-(position.x+(lw))) < this.snapDistance && Math.abs(smid.y-(position.y+(lh/2))) < this.snapDistance) {
				position = {x: sw-lw-(4*this.offset)+1, y: smid.y-(lh/2)-(2*this.offset)+1}; 
				this.label.anchorRight = true;
				this.label.horizontalAlign("right");
				this.label.verticalAlign("middle");
								
				
				
			// INNER: LEFT-BOTTOM
			} else if (inner && Math.abs(position.x) < this.snapDistance && Math.abs(sh-(position.y+lh)) < this.snapDistance) {
				position = {x: 0, y: sh-lh-(4*this.offset)+1};
				this.label.anchorLeft = this.label.anchorBottom = true;
				this.label.horizontalAlign("left");
				this.label.verticalAlign("bottom");

			// INNER: CENTER-BOTTOM
			} else if (inner && Math.abs(smid.x-(position.x+(lw/2))) < this.snapDistance && Math.abs(sh-(position.y+lh)) < this.snapDistance) {
				position = {x: smid.x-(lw/2)-(2*this.offset)+1, y: sh-lh-(4*this.offset)+1};
				this.label.anchorBottom = true;
				this.label.horizontalAlign("center");
				this.label.verticalAlign("bottom");
				
			// INNER: RIGHT-BOTTOM
			} else if (inner && Math.abs(sw-(position.x+(lw))) < this.snapDistance && Math.abs(sh-(position.y+lh)) < this.snapDistance) {
				position = {x: sw-lw-(4*this.offset)+1, y: sh-lh-(4*this.offset)+1};
				this.label.anchorRight = this.label.anchorBottom = true;
				this.label.horizontalAlign("right");
				this.label.verticalAlign("bottom");
			
			
			
			// OUTER: CENTER-TOP
			} else if (outter && Math.abs(smid.x-(position.x+(lw/2))) < this.snapDistance && Math.abs(position.y+lh) < this.snapDistance) {
				position = {x: smid.x-(lw/2)-(2*this.offset)+1, y: -lh-(2*this.offset)-3};
				this.label.anchorTop = true;
				this.label.horizontalAlign("center");
				this.label.verticalAlign("bottom");
				
								
			// OUTER: CENTER-BOTTOM
			} else if (outter && Math.abs(smid.x-(position.x+(lw/2))) < this.snapDistance && Math.abs(sh-(position.y)) < this.snapDistance) {
				position = {x: smid.x-(lw/2)-(2*this.offset)+1, y: sh};
				this.label.anchorBottom = true;
				this.label.horizontalAlign("center");
				this.label.verticalAlign("top");
				
										
			// OUTER: LEFT-MIDDLE
			} else if (outter && Math.abs(position.x+lw) < this.snapDistance && Math.abs(smid.y-(position.y+(lh/2))) < this.snapDistance) {
				position = {x: -lw-(2*this.offset)-3, y: smid.y-(lh/2)-(2*this.offset)+1};
				this.label.anchorLeft = true;
				this.label.horizontalAlign("right");
				this.label.verticalAlign("middle");
				

			// OUTER: RIGHT-MIDDLE
			} else if (outter && Math.abs(sw-(position.x)) < this.snapDistance && Math.abs(smid.y-(position.y+(lh/2))) < this.snapDistance) {
				position = {x: sw, y: smid.y-(lh/2)-(2*this.offset)+1}; 
				this.label.anchorRight = true;
				this.label.horizontalAlign("left");
				this.label.verticalAlign("middle");
									
				
			// OUTER: LEFT-TOP
			} else if (outter && Math.abs(position.x+lw-cd.x) < this.snapDistance && Math.abs(position.y+lh-cd.y) < this.snapDistance) {
				position = {x: -lw-(2*this.offset)-3+cd.x, y: -lh-(2*this.offset)-3+cd.y};
				this.label.anchorLeft = this.label.anchorTop = true;
				this.label.horizontalAlign("right");
				this.label.verticalAlign("bottom");


			// OUTER: RIGHT-TOP
			} else if (outter && Math.abs(sw-position.x-cd.x) < this.snapDistance && Math.abs(position.y+lh-cd.y) < this.snapDistance) {
				position = {x:sw-cd.x, y: -lh-(2*this.offset)-3+cd.y};
				this.label.anchorRight = this.label.anchorTop = true;
				this.label.horizontalAlign("left");
				this.label.verticalAlign("bottom");		
								
			// OUTER: LEFT-BOTTOM
			} else if (outter && Math.abs(position.x+lw-cd.x) < this.snapDistance && Math.abs(sh-(position.y)-cd.y) < this.snapDistance) {
				position = {x: -lw-(2*this.offset)-3+cd.x, y: sh-cd.y};
				this.label.anchorLeft= this.label.anchorBottom = true;
				this.label.horizontalAlign("right");
				this.label.verticalAlign("top");
				
												
			// OUTER: RIGHT-BOTTOM
			} else if (outter && Math.abs(sw-(position.x)-cd.x) < this.snapDistance && Math.abs(sh-(position.y)-cd.y) < this.snapDistance) {
				position = {x: sw-cd.x, y: sh-cd.y};
				this.label.anchorRight = this.label.anchorBottom = true;
				this.label.horizontalAlign("left");
				this.label.verticalAlign("top");
														
			// NOWHERE
			} else {
				this.applyIndicator(0); // Docked nowhere
				return position;
			}
			
			this.applyIndicator(2);
			return new Position(position)
							.moveBy(-this.offset, -this.offset)
							.moveBy(this.labelDistance, this.labelDistance)
							.castToInts();
		},
		
		adjustPositionAtEdge: function(position, event){
			

			var label = this.label, shape = this.shape;
			var dockers = this.shape.dockers;
			
			if (label.isUpdating()){
				return false;
			}
			
			var sn = this.snapDistance + 5;
			//var lw = label.getWidth() + (this.offset*2);
			//var lh = label.getHeight() + (this.offset*2);
			//var fs = label.getFontSize()-1;
			
			//var centerTop = {x: position.x+(lw/2), y: position.y+lh-(fs/2)};
			//var centerBottom = {x: position.x + (lw/2), y: position.y+(fs/2)};
			
			var mouseCoordinate = this.facade.eventCoordinates(event);
			
			// SNAP AT X Position
			// 
			// x        x        x
			// ------------------->
			// x        x        x
			if (this.edgePositions.values().any(function(ep){
				//var center = ep.position.include("top") ? centerTop : centerBottom;
				if (ORYX.Core.Math.getDistancePointToPoint(ep.center, mouseCoordinate) < sn) {
					var pos = ep.firstdocker.bounds.center();
					label.setReferencePoint();
					if (label.getEdgePosition() !== ep.position) {
						label.setEdgePosition(ep.position);
						shape._update(true);
					}
					return true;
				}
				return false;
			}.bind(this))){
				// Update label offset which is needed for the drag'n'drop
				this.setIntersectionPoint();
				this.applyIndicator(1);
				this.labelOffset = this.positionToLabelPosition(new Position(0,0));
				return false;
			}
			
			
			// Reset the edge position			
			if (label.getEdgePosition()){
				label.dirty = true;
				label.setEdgePosition();
			}
			
			// DONT Snap if ctrl
			if (event.ctrlKey || event.metaKey) {
				return position;
			}
			
			// Get x/y/width/height
			var x = position.x+this.offset, y = position.y+this.offset, w = label.getWidth(), h = label.getHeight();
			// Dont snap if the label is over the edge
			if (this.shape.isBoundsIncluded(new ORYX.Core.Bounds(x, y, x+w, y+h-2))){
				return position;
			}
			
			// SNAP AT X Position
			// 
			// xxxxxxxxxxxxxxxxxxx
			// ------------------->
			// xxxxxxxxxxxxxxxxxxx
			
			var cd = this.shape.dockers.pluck("bounds").invoke("center");
			var sna = this.snapDistance, snapped = [];
			
			[["ul", new Position(x, y)],
			 ["ur", new Position(x+w, y)],
			 ["ll", new Position(x, y+h-2)],
			 ["lr", new Position(x+w, y+h-2)]].each(function(pos){
			 	
				for (i = 1, size = cd.length; i < size; ++i) {
					var p1 = cd[i - 1], p2 = cd[i];
					
					// Only snap once for a segment
					if (snapped[i]){
						continue;
					}
					
					// Get directed distance
					var distance = ORYX.Core.Math.distancePointLinie(p1, p2, pos[1], true);
					distance *= ORYX.Core.Math.pointIsLeftOfLine(p1, p2, pos[1]) ? -1 : 1;
					// Defined the original offset
					var offset = distance > 0 ? label.getOffsetTop() : label.getOffsetBottom();
				
					if ("number" == typeof distance && 
						Math.abs(distance) > 2 && Math.abs(Math.abs(distance)-offset) < sna && 
						this.isCorrectPosition(pos[0], distance, ORYX.Core.Math.getAngle(p1, p2))) {

						var ortho = ORYX.Core.Math.getOrthogonalIdentityVector(p1, p2);
						var co = (distance < 0 ? -1 : 1) * (Math.abs(distance) - offset);
					
						position.x -= ortho.x*co;
						position.y -= ortho.y*co;
						snapped[i] = true;
					}
				}
			}.bind(this));

			return position;
				
		},
		
		getHorizontalAlignByOrientation: function(orientation){
			return ["ul", "ll"].include(orientation)?"left":(["ur", "lr"].include(orientation)?"right":"center");
		},
		
		getVerticalAlignByOrientation: function(orientation){
			return ["ul", "ur"].include(orientation)?"top":(["ll", "lr"].include(orientation)?"bottom":"middle");
		},
		
		adjustLabelPosition: function(position){
			var ref = this.label.getReferencePoint();
			var ha = "center", va = "middle";
			if (ref) {
				ha = this.getHorizontalAlignByOrientation(ref.orientation);
				va = this.getVerticalAlignByOrientation(ref.orientation);
				if (Math.abs(ref.segment.fromPosition.y-ref.segment.toPosition.y) < 1){
					ha = "left";
				} 
			}
			
			var x = position.x+this.offset, y = position.y+this.offset;
			
			
			switch (ha){
				case 'left'		: x += 0; break;
				case 'center' 	: x += (this.label.getWidth()/2); break;
				case 'right' 	: x += this.label.getWidth(); break;
			}
			switch (va){
				case 'top'		: y += 0; break;
				case 'middle' 	: y += this.label.getHeight()/2; break;
				case 'bottom' 	: y += this.label.getHeight()-(this.offset); break;
			}
			
			
			this.label.horizontalAlign(ha);
			this.label.verticalAlign(va);
			this.label.node.setAttributeNS(null, 'text-anchor', ha==="left"?"start":(ha==="right"?"end":"middle"));
			this.label.node.setAttributeNS(null, 'transform', 'rotate(0)');
			this.labelOffset = this.positionToLabelPosition(new Position(0,0));
			
			this.label.setX(x+1); this.label.setY(y);
			this.label.node.setAttributeNS(null, 'x', x+1);
			this.label.node.setAttributeNS(null, 'y', y);
			this.label._positionText();
			
		},
					
		/**
		 * Snaps the position to some specific
		 * points, depending on the type of shape
		 * @param {Object} position
		 */
		adjustPosition: function(position, event){
			if (!this.label){
				return position;
			}
			if (this.shape instanceof ORYX.Core.Node){
				return this.adjustPositionAtNode(position, event);
			} else if (this.shape instanceof ORYX.Core.Edge){
				return this.adjustPositionAtEdge(position, event);
			} else {
				return position;
			}
		},
				
		/**	
		 * Returns the center of the frame
		 * @return {Position}
		 */
		getCenter: function(){
			var bb = this.getSVG().getBBox();
			var mt = this.getSVG().getCTM();
			return {
				x: mt.e + bb.width/2,
				y: mt.f + bb.height/2
			};
		},
		
		/**
		 * Returns TRUE if the orientation is on the correct side
		 * @param {String} orientation "ul", "ll", "ur", "lr", "ce"
		 * @param {Number} distance
		 * @param {Number} angle
		 */
		isCorrectPosition: function(orientation, distance, angle){
			
			return ((0 <= angle && angle <= 90) && ((distance >= 0 && orientation == "lr") || (distance < 0 && orientation == "ul"))) ||
					((90 <= angle && angle <= 180) && ((distance >= 0 && orientation == "ur") || (distance < 0 && orientation == "ll"))) ||
					((180 <= angle && angle <= 270) && ((distance >= 0 && orientation == "ul") || (distance < 0 && orientation == "lr"))) ||
					(((270 <= angle && angle <= 360) || angle == 0) && ((distance >= 0 && orientation == "ll") || (distance < 0 && orientation == "ur"))) ||
					orientation == "ce";
		
		},
		
		/**
		 * Returns the best fitting reference point of the label
		 * depending on five positions: upper-left, upper-right, 
		 * lower-right, lower-left, and center
		 *
		 */
		calculateEdgeReferencePoint: function(label){
			var x, y, width, height;
			
			if (label instanceof ORYX.Core.SVG.Label){
				x = label.getX(); y = label.getY();
				width = label.getWidth(); height = label.getHeight()-2;
			} else if (arguments.length == 4){
				x = arguments[0]; y = arguments[1];
				width = arguments[2]; height = arguments[3]-2;
			} else {
				return null;
			}
			
			var center = {x: x+(width/2), y: y+(height/2)};
			
			
			// TRUE if the labe is over the edge
			var labelIsOverEdge = this.shape.isBoundsIncluded(new ORYX.Core.Bounds(x, y, x+width, y+height));
			
			if (labelIsOverEdge) {
				// Only check the center position
				return this.calculateEdgeReferencePointForAPoint(center) || null;
			
			} else {
				var grf;
				// Check every corner of the edge			
				[["ul", new Position(x, y)],
				 ["ll", new Position(x, y+height)],
				 ["ur", new Position(x+width, y)],
				 ["lr", new Position(x+width, y+height)],
				 ["ce", center]
				].each(function(position){
					var rf = this.calculateEdgeReferencePointForAPoint(position[1]);
					if (rf) {
						var angle = ORYX.Core.Math.getAngle(rf.segment.fromPosition, rf.segment.toPosition);
						
						// Check if the correct position fits to the calculated segment
						if (!(this.isCorrectPosition(position[0], rf.distance, angle))){
								return
						}
						
						if("undefined" == typeof grf || Math.abs(grf.distance) > Math.abs(rf.distance)){
							grf = rf;
							grf.orientation = position[0];
						}
					}
				}.bind(this));
				 
				return grf || null;
			}
			

		},
		
		calculateEdgeReferencePointForAPoint: function(point){ 

			var segment = this.shape.findSegment(point); // segment = distance, fromDocker, toDocker
			if (!segment){ return null; }
			
			var intersection = ORYX.Core.Math.getPointOfIntersectionPointLine(
									segment.fromDocker.bounds.center(), 	// P1 - Center of the first docker
									segment.toDocker.bounds.center(), 		// P2 - Center of the second docker
									point, 									// P3 - Point 
									true)						
			
			// Define direction
			segment.distance *= ORYX.Core.Math.pointIsLeftOfLine(segment.fromDocker.bounds.center(), segment.toDocker.bounds.center(), point) ? -1 : 1;
			
			// Return the object
			return {
				dirty : true,
				distance : segment.distance,
				intersection : intersection,
				segment: {
					from: segment.fromDocker,
					fromIndex: this.shape.dockers.indexOf(segment.fromDocker),
					fromPosition: segment.fromDocker.bounds.center(),
					to: segment.toDocker,
					toIndex:  this.shape.dockers.indexOf(segment.toDocker),
					toPosition: segment.toDocker.bounds.center()
				}
			}
		},
		
		onDrag: function(evt, position){
			
			// Adjust the reference position
			if (this.shape instanceof ORYX.Core.Edge && !this.label.getEdgePosition()){
				var label = this.label;
				
				var ref = this.calculateEdgeReferencePoint(label);
				var ha = "center", va = "middle";
				// Get the alignment for the reference point
				if (ref){
					ha = this.getHorizontalAlignByOrientation(ref.orientation);
					va = this.getVerticalAlignByOrientation(ref.orientation);
					this.label.setReferencePoint(ref);
				} else {
					this.label.setReferencePoint();
				}
				
				
				this.applyIndicator(ref ? 3 : 2);
				// Set correct alignment
				if (label.horizontalAlign() !== ha || label.verticalAlign() !== va || label.dirty){
					this.adjustLabelPosition(position);
					this.setIntersectionPoint(ref);
					delete label.dirty;
					return;
				} else {
					// Apply indicators
					this.setIntersectionPoint(ref);
				}
				
			}
			this.setLabelPosition(this.labelOffset.moveBy(position));
			
			if (this.initDragDrop){	
				// Raise event to hide the shape menu!
				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_DRAGDROP_START});
				delete this.initDragDrop;
			}
		},
		
		onDragDrop: function(evt, position){
			// Finish resize
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_DRAGDROP_END});
			
			if (!this.label){
				return;
			}
			
			if (position) {
				position = this.positionToLabelPosition(position)
				
				if (this.shape instanceof ORYX.Core.Node) {
					// If the position is too close to the origin position, reset the position
					if (!position || (Math.abs(this.label.x - position.x) < 3 && Math.abs(this.label.y - position.y) < 3 )) {
						this.label.setPosition();
					} else {
						this.label.setPosition(position);
					}
				} else if (this.shape instanceof ORYX.Core.Edge) {
					// Only set a reference point if no edge position is set
					if (!this.label.getEdgePosition()) {
						var ref = this.calculateEdgeReferencePoint(this.label);
						if (ref) {
							this.label.setReferencePoint(ref);
							this.label.horizontalAlign(["ul", "ll"].include(ref.orientation)?"left":(["ur", "lr"].include(ref.orientation)?"right":"center"));
							this.label.verticalAlign(["ul", "ur"].include(ref.orientation)?"top":(["ll", "lr"].include(ref.orientation)?"bottom":"middle"));
						}
						else {
							this.label.setPosition(position);
							this.label.horizontalAlign(this.label.getOriginHorizontalAlign());
							this.label.verticalAlign(this.label.getOriginVerticalAlign());
						}
					}
					
					// Force to update edge
					this.shape._update(true);
				}
				
				
				// UNDO/REDO - Command
				var Change = ORYX.Core.Command.extend({
					construct: function(label, shape, facade, oldState){
						this.oldState = oldState;
						this.label = label;
						this.shape = shape;
						this.facade = facade;
					},			
					execute: function(){
						if (!this.newState) {
							this.newState = {
								position : this.label.getPosition(),
								edgePosition : this.label.getEdgePosition(),
								reference : this.label.getReferencePoint(),
								valign : this.label.verticalAlign(),
								halign : this.label.horizontalAlign()
							}
						} else {
							this.setState(this.newState);
						}
					},			
					rollback: function(){
						this.setState(this.oldState);
					},
					setState: function(state){
						this.label.verticalAlign(state.valign);
						this.label.horizontalAlign(state.halign);
						this.label.setEdgePosition(state.edgePosition);
						this.label.setPosition(state.position);
						var ref = state.reference;
						if (ref){ ref.dirty = true; }
						this.label.setReferencePoint(ref);
						this.shape._update(true);				
			            this.facade.updateSelection(); 
					}
				});
				
				this.facade.executeCommands([new Change(this.label, this.shape, this.facade, this.initialState)]);
			}
			delete this.labelOffset;
			delete this.isDragging;
			Ext.getBody().setStyle("cursor", "default");
		},
		
		/**
		 * Destroyes the frame of a label and
		 * removes all related svg elements.
		 * 
		 */
		destroy: function(){
			// Stop initializing
			window.clearTimeout(this.initTimer);
			
			// Remove from the parent
			this.nodes.each(function(node){
				if(node.parentNode) {
    				node.parentNode.removeChild(node);
				}
			});
			
			// Unregister from update
			if (this.updateLabelClb)
				this.label.unregisterOnChange(this.updateLabelClb);
			
			// Remove the object
			delete this.label;
			delete this.node;
			//delete this.intersection;
			delete this.updateLabelClb;
		}
	})
	
	
	
	
}());
/**
 * Copyright (c) 2010
 * Lukas Brand, Robert B?hme
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.DockerCreation = Clazz.extend({
	
	construct: function( facade ){
		this.facade = facade;		

		//visual representation of the Ghostdocker
		this.circle = ORYX.Editor.graft("http://www.w3.org/2000/svg", null ,
				['g', {"pointer-events":"none"},
					['circle', {cx: "3", cy: "3", r: "3", fill:"red", opacity:"0.5"}]]); 
		
		//Event registrations
		this.moveClb = this.handleMouseMove.bind(this);
		this.downClb = this.handleMouseDown.bind(this);
		this.outClb = this.handleMouseOut.bind(this);
		
		// Register global event listener to prevent the ghost point, if e.g. drag'n'drop or other mouse operations
		document.addEventListener('mousedown', function(){this.mouseDown = true;}.bind(this), true);
		document.addEventListener('mouseup', function(){
			delete this.mouseDown;
			delete this.activated;
			window.clearTimeout(this.timer);
		}.bind(this), true);

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOVER, this.handleMouseOver.bind(this));
		//Double click is reserved for label access, so abort action
		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DBLCLICK,function(){window.clearTimeout(this.timer)}.bind(this));
		//click is reserved for selecting, so abort action when mouse goes up
		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEUP,function(){window.clearTimeout(this.timer)}.bind(this));
	},
	
	/**
	 * MouseOut Handler
	 * 
	 *hide the Ghostpoint when Leaving the mouse from an edge
	 */
	handleMouseOut: function(event, uiObj) {	
		if (!this.activated){
			this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEMOVE, this.moveClb);
			this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.downClb);
			this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEOUT, this.outClb);			
			this.hideOverlay();
		} else {
			this.handleMouseMove(event, uiObj, true);
		}
	},
	

	/**
	 * MouseOver Handler
	 * 
	 * shows the Ghostpoint if the edge is selected
	 * @param {Object} event
	 * @param {Object} uiObj
	 */
	handleMouseOver: function(event, uiObj) {
		//show the Ghostdocker on the edge
		if (!this.mouseDown && uiObj instanceof ORYX.Core.Edge && uiObj.containsNode(event.target) && this.isEdgeDocked(uiObj)){
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEMOVE, this.moveClb);
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.downClb);
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOUT, this.outClb);

			this.showOverlay(uiObj);
			this.handleMouseMove(event, uiObj);
		}
	},
	
	/**
	 * MouseDown Handler
	 * 
	 *create a Docker when clicking on a selected edge
	 */
	handleMouseDown: function(event, edge) {	
		if (event.which==1 && edge instanceof ORYX.Core.Edge && this.isEdgeDocked(edge)){					
			//Timer for dblclick to be able to create a label
			this.activated = this.facade.eventCoordinates(event);
		}
	},
	
	/**
	 * MouseMove Handler
	 * 
	 *refresh the ghostpoint when moving the mouse over an edge
	 */
	handleMouseMove: function(event, edge, force) {		
		if (edge instanceof ORYX.Core.Edge && this.isEdgeDocked(edge)){
			var point = this.calculateOptimal(edge, this.facade.eventCoordinates(event));
			this.circle.setAttributeNS(null, "transform", "translate("+(point.x-3)+ ", " + (point.y-3) + ")");
			
			if (this.activated && (force === true|| ORYX.Core.Math.getDistancePointToPoint(this.facade.eventCoordinates(event), this.activated) > 3)){
				//window.clearTimeout(this.timer);
				//this.timer = window.setTimeout(function () {
					// Give the event to enable one click creation and drag
					this.addDockerCommand({
			            edge: edge,
						event: event,
			            position: point
			        });
					delete this.activated;
				//}.bind(this), 10);
			}
		}	
	},
	
	/**
	 * returns true if the edge is docked to at least one node
	 */
	isEdgeDocked: function(edge){
		return !!(edge.incoming.length || edge.outgoing.length);
	},
	
	/**
	 * Command for creating a new Docker
	 * 
	 * @param {Object} options
	 */
	addDockerCommand: function(options){
	    if(!options.edge)
	        return;
	    
		
		var edge = options.edge, docker, index, firstSelection = 0;
		options.docker = docker = edge.addDocker(options.position, options.docker);
		index = edge.dockers.indexOf(docker);   
						
		// Wait with the command till the end of the drag
		var onDragged = function(){
			// The assumption is that the third selectionchange is the end of the drag docker
			if (firstSelection++ < 2){ return; } 
			this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, onDragged);
			
			var Command = ORYX.Core.Command.extend({
		        construct: function(edge, docker, index, facade){            
		            this.edge = edge;
					this.docker = docker;
		            this.index = index;
		            this.facade = facade;
					this.pos = this.edge.dockers[index + 1].bounds.center();
		        },
		        execute: function(){
					if (this.firstExecution){
						//this.docker.bounds.centerMoveTo(this.edge.dockers[this.index].bounds.center());
						//this.edge.dockers[this.index].bounds.centerMoveTo(this.pos)
						this.docker.parent = false; 
		            	this.edge.add(this.docker,this.index);
						this.removedDockers = this.edge.removeUnusedDockers();
						
					}
					this.firstExecution = true;
		        },
		        rollback: function(){
		            this.edge.removeDocker(this.docker);
					this.docker.parent = true; 
					//this.edge.dockers[this.index].bounds.centerMoveTo(this.pos)    
					(this.removedDockers||$H({})).each(function(d){
						this.edge.add(d.value, Number(d.key));
						this.edge._update(true);
					}.bind(this));
		        }
		    });
			
			if (docker && index < edge.dockers.length - 1) {
				this.facade.executeCommands([new Command(edge, docker, index, this.facade)]);
			}
		}.bind(this);
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, onDragged);
		
		
		this.facade.raiseEvent({
			uiEvent: options.event,
			type: ORYX.CONFIG.EVENT_DOCKERDRAG
		}, options.docker );
	    
	},
	
	/**
	 *show the ghostpoint overlay
	 *
	 *@param {Shape} edge
	 *@param {Point} point
	 */
	showOverlay: function(edge){
		if (this.circle && edge && edge.node && !Ext.isIPad)
			edge.node.firstChild.appendChild(this.circle);
	},
	
	/**
	 * calculates the optimal point on the edge to display the docker
	 * @param {Object} edge The edge
	 * @param {Object} point The mouse position
	 * @return {Object} best Best point for the docker 
	 */
	calculateOptimal : function(edge, point){
		// 
		var best = point;
		var min_distance = Infinity;
		
		for (var i=0, l=edge.dockers.length; i < l-1; i++) {
			var intersection_point = ORYX.Core.Math.getPointOfIntersectionPointLine(
				edge.dockers[i].bounds.center(),
				edge.dockers[i+1].bounds.center(),
				point,
				true // consider only the current segment instead of the whole line ("Strecke, statt Gerade") for distance calculation
			);
			if(!intersection_point) {
				continue;
			}	
			var current_distance = ORYX.Core.Math.getDistancePointToPoint(point, intersection_point);
			if (min_distance > current_distance) {
				min_distance = current_distance;
				best = intersection_point;
			}
		}
		return best;
	},
	
	/**
	 *hide the ghostpoint overlay
	 */
	hideOverlay: function() {
		if (this.circle && this.circle.parentNode)
			this.circle.parentNode.removeChild(this.circle);
	}

});/**
 * Copyright (c) 2010 Signavio
 * @author Lukas Brand
 *
 **/

/**
 * @namespace
 * @name ORYX.Plugins
 */
if ("undefined" == typeof ORYX) {
	var ORYX = {};
}
if(!ORYX.Plugins) {
	ORYX.Plugins = {};
}

new function(){
	/**
	 * @class ORYX.Plugins.MoveEdgeSegment
	 * @extends Clazz
	 */
	
	ORYX.Plugins.MoveEdgeSegment = Clazz.extend({
		/**
		 * @lends ORYX.Plugins.MoveEdgeSegment#
		 * @constructor
		 * @param {Facade} facade
		 */
		construct: function(facade){
			this.facade = facade;		
			this.shapeSelection = undefined;
			this.activeSegment = undefined;
			this.hLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_HORIZONTAL);
			this.vLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_VERTICAL);
			this.moverActive = false;
			this.mouseDown = false;
			this.movers = undefined;

			// global switch for iPad
			this.iPad = Ext.isIPad;

			//visual representation of the Mover
			this.rect = ORYX.Editor.graft("http://www.w3.org/2000/svg", null ,
					['g', {"pointer-events":"all", "class":"mover"},
						['rect', {fill:"yellow", stroke:"black", opacity:Ext.isIPad ? "0.3" : "0.5"}],
						['rect', {fill:"none", stroke:"white", visibility:"hidden"}]	
					]
			); 	
			
			document.addEventListener('mousedown', function(){this.mouseDown = true;}.bind(this), true);
			document.addEventListener('mouseup', function(){this.mouseDown = false;}.bind(this), true);
			
			if (this.iPad){
				
				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this.showAllMover.bind(this));
				
			} else {			
				
				//Event registrations
				this.rect.addEventListener('mousedown', this.moverMouseDown.bind(this), true);
				this.rect.addEventListener('mouseover', this.moverMouseOver.bind(this), true);
				this.rect.addEventListener('mouseout', this.moverMouseOut.bind(this), true);
				this.rect.addEventListener('click', this.onClick.bind(this), true);
				this.rect.addEventListener('dblclick', this.onDblClick.bind(this), true);
				
				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOVER, this.showMover.bind(this));
				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOUT, this.hideMover.bind(this));
			}
			//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DBLCLICK, function(){this.fireEvent('dblclick', this.activeSegment.edge, this.activeSegment.edge.getLabels()[0].text());}.bind(this)); 
				
		},
		/**
		 * Clickhandler for the rect
		 * @param e
		 */
		onClick: function(e){
			if (this.activeSegment){
				var edge = this.activeSegment.edge;
				var selection = this.facade.getSelection();
				var isIncluded = selection.include(edge);
				if (e.ctrlKey) {
					if (!isIncluded) {
						this.facade.setSelection([].concat(selection, edge));
					} else {
						this.facade.setSelection(selection.without(edge));	
					}
				} else {
					if (!isIncluded)
						this.facade.setSelection([edge]);
				}
			}
		},
		
		/**
		 * On dbl-click, delegate the event to the edge
		 * @param e
		 */
		onDblClick: function(e){
			if (this.activeSegment){
				this.activeSegment.edge._delegateEvent(e);
			}
		},
		
		showAllMover: function(event) {
			
			if (this.isDragging){
				this.hideOverlay(this.activeSegment);
				return;
			} else {
				this.hideOverlay();
			}
			
			if (this.facade.getSelection().length !== 1 && !(this.facade.getSelection()[0] instanceof ORYX.Core.Edge)){
				return;
			}
			
			
			this.movers = [];
			
			// Get all segments
			var segments = [], edge = this.facade.getSelection()[0];
			
			for (var i = 0, l = edge.dockers.length-1; i < l; ++i) {
				var point1 = edge.dockers[i].bounds.center(); 
				var point2 = edge.dockers[i+1].bounds.center();  
				var midPoint = ORYX.Core.Math.midPoint(point1, point2);
				var isVer = Math.abs(point1.x - point2.x) < 1;
				var isHor = Math.abs(point1.y - point2.y) < 1;
				var align = isHor ? "horizontal" : (isVer ? "vertical" : false);
	
				if (!align || (Math.abs(point1.x-point2.x) < 40 && Math.abs(point1.y-point2.y) < 40)){
					continue;
				}

				var node = this.rect.cloneNode(true);
				
				segments.push({
					fromDocker	: edge.dockers[i],
					toDocker	: edge.dockers[i+1],
					midPoint	: midPoint,
					edge		: edge,
					align		: align,
					node		: node
				});
				
				this.movers.push(node);
				node.addEventListener('mousedown', this.moverMouseDown.bind(this, segments.last()), true);
				node.addEventListener('click', this.onClick.bind(this), true);
				node.addEventListener('dblclick', this.onDblClick.bind(this), true);
			}
			
			this.showMover(event, [edge], segments);
		},
		
		/**
		 * Shows the Mover on the edge 
		 * 
		 * @param {Event} event
		 * @param {ORYX.Core.UIObject} uiObj
		 */
		showMover: function(event, uiObj, segments) {
	
			//show the Mover on the edge
			var height, width;
			
			// iPad mode
			if (this.iPad) {
				if (uiObj instanceof Array) {
					uiObj.each(function(edge){
						if (edge instanceof ORYX.Core.Edge && this.isEdgeDocked(edge) && segments !== undefined){
							var point;
							height = 40;
							width = 14;
							
							window.clearTimeout(this.overTimer);
							
							segments.each(function(segment, index){
								point = segment.midPoint;
								if (segment.align == "horizontal") {
									this.movers[index].firstChild.setAttributeNS(null, "x", -(height/2));
									this.movers[index].firstChild.setAttributeNS(null, "y", -(width/2));
									this.movers[index].firstChild.setAttributeNS(null, "width", height);
									this.movers[index].firstChild.setAttributeNS(null, "height", width);
									this.movers[index].childNodes[1].setAttributeNS(null, "x", -(height/2));
									this.movers[index].childNodes[1].setAttributeNS(null, "y", -((width + 6)/2));
									this.movers[index].childNodes[1].setAttributeNS(null, "width", height);
									this.movers[index].childNodes[1].setAttributeNS(null, "height", width + 6);
									this.movers[index].setAttributeNS(null, "style", "cursor:n-resize;");
								}
								else if (segment.align == "vertical") {
									this.movers[index].firstChild.setAttributeNS(null, "x", -(width/2));
									this.movers[index].firstChild.setAttributeNS(null, "y", -(height/2));
									this.movers[index].firstChild.setAttributeNS(null, "width", width);
									this.movers[index].firstChild.setAttributeNS(null, "height", height);
									this.movers[index].childNodes[1].setAttributeNS(null, "x", -((width + 6)/2));
									this.movers[index].childNodes[1].setAttributeNS(null, "y", -(height/2));
									this.movers[index].childNodes[1].setAttributeNS(null, "width", width + 6);
									this.movers[index].childNodes[1].setAttributeNS(null, "height", height);
									this.movers[index].setAttributeNS(null, "style", "cursor:w-resize;");
								}
								this.movers[index].setAttributeNS(null, "transform", "translate(" + (point.x) + ", " + (point.y) + ")");
								
							}.bind(this));
						}
						this.showOverlay(edge);
						this.mouseOver = true;
						
	//					var point = this.calculateOptimal(uiObj, this.facade.eventCoordinates(event));
	//					this.activeSegment = uiObj.findSegment(point);
	//					this.activeSegment.align = point.align;
	//					this.activeSegment.edge = uiObj;
					}.bind(this));
				}
			} else {
				if (!this.mouseDown && uiObj instanceof ORYX.Core.Edge && this.isEdgeDocked(uiObj)){
	
					// Normal mode
					height = 20;
					width = 6;
				
					var point = this.calculateOptimal(uiObj, this.facade.eventCoordinates(event));
					
					window.clearTimeout(this.overTimer);
					
					if (point) {
						if (point.align == "horizontal") {
							this.rect.firstChild.setAttributeNS(null, "x", -(height/2));
							this.rect.firstChild.setAttributeNS(null, "y", -(width/2));
							this.rect.firstChild.setAttributeNS(null, "width", height);
							this.rect.firstChild.setAttributeNS(null, "height", width);
							this.rect.childNodes[1].setAttributeNS(null, "x", -(height/2));
							this.rect.childNodes[1].setAttributeNS(null, "y", -((width + 6)/2));
							this.rect.childNodes[1].setAttributeNS(null, "width", height);
							this.rect.childNodes[1].setAttributeNS(null, "height", width + 6);
							this.rect.setAttributeNS(null, "style", "cursor:n-resize;");
						
						
						}
						else if (point.align == "vertical") {
							this.rect.firstChild.setAttributeNS(null, "x", -(width/2));
							this.rect.firstChild.setAttributeNS(null, "y", -(height/2));
							this.rect.firstChild.setAttributeNS(null, "width", width);
							this.rect.firstChild.setAttributeNS(null, "height", height);
							this.rect.childNodes[1].setAttributeNS(null, "x", -((width + 6)/2));
							this.rect.childNodes[1].setAttributeNS(null, "y", -(height/2));
							this.rect.childNodes[1].setAttributeNS(null, "width", width + 6);
							this.rect.childNodes[1].setAttributeNS(null, "height", height);
							this.rect.setAttributeNS(null, "style", "cursor:w-resize;");
						}
		
						this.rect.setAttributeNS(null, "transform", "translate(" + (point.x) + ", " + (point.y) + ")");
						this.showOverlay(uiObj);
						this.mouseOver = true;
						this.activeSegment = uiObj.findSegment(point);
						this.activeSegment.align = point.align;
						this.activeSegment.edge = uiObj;
					}
				}
				
				if(this.isDragging){
					this.activeSegment.edge.dockers.invoke("hide");
				}
				
				if (this.mouseDown && this.activeSegment) {
					//this.activeSegment.edge.dockers.first().hide();
					//this.activeSegment.edge.dockers.last().hide();
				}
			}
		},
		
		hideMover: function(event) {
			//hides the Mover
			if (this.mouseOver && !this.moverActive) {
				window.clearTimeout(this.overTimer);
				this.overTimer = window.setTimeout(function(){
					this.hideOverlay();
					//this.activeSegment.edge.dockers.invoke("hide");
					delete this.mouseOver;
					delete this.activeSegment;	
				}.bind(this), 1);
			}
		},
			
		/**
		 * MouseOut Handler
		 * 
		 *hides the Mover when leaving
		 */
		moverMouseOut: function(event) {		
			if (!this.iPad) {
				this.hideMover(event);
				//if(this.isDragging){
					//Ext.getBody().setStyle("cursor", "auto");
					this.activeSegment.edge.dockers.invoke("hide");
				//}
			}
		},
		
		/**
		 * Moves the segment according to the position of the Mover
		 * 
		 * @param {Array} segments All segments of the active edge
		 * @param {Event} event
		 */
		moverMouseDown: function() {
			var segment, event;
			if (arguments.length === 1) {
				event = arguments[0];
			} else if (arguments.length === 2) {
				segment = arguments[0];
				event = arguments[1];
			}

			this.moverActive = true;
			
			if (this.iPad) {
				
				if (!this.movers) {
					return;
				}
				
				if (!segment){
					var a = this.facade.eventCoordinates(event);
					segment = segments.find(function(segment){
					    var b = segment.fromDocker.bounds.center();
					    var c = segment.toDocker.bounds.center();
					    return ORYX.Core.Math.isPointInLine(a.x, a.y, b.x, b.y, c.x, c.y, 10);
					});
				}
				this.activeSegment = segment;
			}
	
			if((this.activeSegment && !this.isDragging)){
				this.isDragging = true;
				this.isInitialized = true;
				
				if (!this.activeSegment.fromDocker || !this.activeSegment.toDocker) {
					return;
				}
				var edge = this.activeSegment.edge;
				var fromDocker = this.activeSegment.fromDocker;
				var toDocker = this.activeSegment.toDocker;
				var orientation = this.activeSegment.align;
				var d = edge.dockers;
	
				//get first shape and the relevant properties
				var fromShape = undefined;
				if (d[0].isDocked()) {
					var shape = edge.dockers[0].getDockedShape();
					var absoluteBounds = shape.absoluteBounds();
					fromShape = {
						shape 		: shape,
						center		: absoluteBounds.center(),
						upperLeft	: absoluteBounds.upperLeft(),
						lowerRight	: absoluteBounds.lowerRight()
					};
				}
				
				//get last shape and the relevant properties
				var toShape = undefined;
				if (d[d.length - 1].isDocked()) {
					var shape = edge.dockers[d.length - 1].getDockedShape();
					var absoluteBounds = shape.absoluteBounds();
					toShape = {
							shape 		: shape,
							center		: absoluteBounds.center(),
							upperLeft	: absoluteBounds.upperLeft(),
							lowerRight	: absoluteBounds.lowerRight()
					};
				}
				
				//the old position
				var old = orientation == "horizontal" ?
					this.activeSegment.fromDocker.bounds.center().y:
					this.activeSegment.fromDocker.bounds.center().x;
	
							
				var data = {
					fromShape 		: fromShape,
					fromDocker		: fromDocker,
					toShape			: toShape,
					toDocker		: toDocker,
					edge			: edge,
					snapPoints		: [],
					dockers			: [],
					magnets			: [],
					old				: old,
					canvas			: this.facade.getCanvas()
				};
						
				if (this.iPad) {
					ORYX.Core.SVGEnableDrag(event, event.currentTarget, {
						movedCallback: this.onDrag.bind(this, data),
						upCallback: this.onDragDrop.bind(this, data),
						adjustPosition: this.adjustPosition.bind(this, data)
					});
				} else {
					ORYX.Core.SVGEnableDrag(event, this.rect, {
						movedCallback: this.onDrag.bind(this, data),
						upCallback: this.onDragDrop.bind(this, data),
						adjustPosition: this.adjustPosition.bind(this, data)
					});
				}
				
				var dockers = this.activeSegment.edge.dockers.collect(function(docker){
					return {
						docker:docker,
						pos:docker.bounds.center(),
						ref:docker.referencePoint
					};
				});
				
				// Needed for Undo/Redo
				this.initialState = {
					fromDocker: fromDocker,
					fromPosition: fromDocker.bounds.center(),
					fromReference: fromDocker.referencePoint,
					toDocker: toDocker,
					toPosition: toDocker.bounds.center(),
					toReference: toDocker.referencePoint,
					dockers: dockers,
					shape: edge,
					fromShape: fromShape,
					toShape: toShape
				};
			}
		},
		
		moverMouseOver: function(){
			window.clearTimeout(this.overTimer);
			if (this.activeSegment && !this.moverActive) {
				this.activeSegment.edge.dockers.invoke("show");
			}
		},
			
		onDrag : function(data, event, point){
			if (this.activeSegment){
				// Init when first mouse move
				if (this.isInitialized && this.isDragging) {
					this.initDrag(data);
					delete this.isInitialized;
				}
				
				//the first (left) docker
				var p1 = this.activeSegment.fromDocker;
				//the last(right) docker
				var p2 = this.activeSegment.toDocker;
	
				var offset = 7;
		
				//orientation of the segment
				var orientation = this.activeSegment.align;	
				
				//horizontal movement
				if (orientation == "vertical") {
					p1.bounds.centerMoveTo(point.x, p1.bounds.center().y);
					if(p1.referencePoint){
						p1.setReferencePoint({
							x :	point.x -data.fromShape.upperLeft.x,
							y :	p1.referencePoint.y
						});
					} 
					p2.bounds.centerMoveTo(point.x, p2.bounds.center().y);
					if(p2.referencePoint){
						p2.setReferencePoint({
							x :	point.x - data.toShape.upperLeft.x,
							y :	p2.referencePoint.y
						});
					} 
				//vertical movement
				} else if (orientation == "horizontal") {
					p1.bounds.centerMoveTo(p1.bounds.center().x, point.y);
					if(p1.referencePoint){
						p1.setReferencePoint({
							x :	p1.referencePoint.x,
							y :	point.y - data.fromShape.upperLeft.y
						});
					} 
					p2.bounds.centerMoveTo(p2.bounds.center().x, point.y);
					if(p2.referencePoint){
						p2.setReferencePoint({
							x :	p2.referencePoint.x,
							y :	point.y - data.toShape.upperLeft.y
						});
					} 
				}		
				this.activeSegment.edge._update(true);			
			}
		},
		
		/**
		 * Initialize the drag and drop (after mouse has been moved)
		 *
		 */
		initDrag: function(data){
			if (!this.activeSegment || !this.isDragging || !this.activeSegment.fromDocker || !this.activeSegment.toDocker) {
				return;
			}
			
			// Set global cursor to prevent flickering
			if (this.activeSegment.align == "horizontal") {
				Ext.getBody().setStyle("cursor", "n-resize");
			} else if (this.activeSegment.align == "vertical") {
				Ext.getBody().setStyle("cursor", "w-resize");
			}
	
			var edge = this.activeSegment.edge;
			
			// Disable label repositioning while the edge is dragged
			edge.hideLabels();
	
			var orientation = this.activeSegment.align;
				
			var fromDocker = this.activeSegment.fromDocker;
			var toDocker = this.activeSegment.toDocker;
			var preDocker = edge.dockers[edge.dockers.indexOf(fromDocker) - 1];
			var postDocker = edge.dockers[edge.dockers.indexOf(toDocker) + 1];
	
			
			var toShape = data.toShape, fromShape = data.fromShape;
				
			//remove bounding box from the edge while dragging
			this.shapeSelection = this.facade.getSelection();
			this.facade.setSelection(this.shapeSelection.without(this.activeSegment.edge));		
			
			
			//workaround for flickering dockers
			this.activeSegment.edge.dockers.invoke("show");
			this.activeSegment.edge.dockers
				.without(fromDocker.isDocked() ? this.activeSegment.edge.dockers.first() : null)
				.without((preDocker && preDocker.isDocked()) ? this.activeSegment.edge.dockers.first() : null)
				.without(toDocker.isDocked() ? this.activeSegment.edge.dockers.last(): null)
				.without((postDocker && postDocker.isDocked()) ? this.activeSegment.edge.dockers.last() : null)
				.invoke("preventHiding", true);
			this.activeSegment.edge.dockers.invoke("hide");
			
			
			/** Magnets **/
			var magnets = [];
			
			if (preDocker && preDocker.isDocked() || fromDocker.isDocked()) {
				magnets = magnets.concat(this.getRelevantMagnets(fromShape, preDocker || fromDocker, orientation));
			}
			
			if (postDocker && postDocker.isDocked() || toDocker.isDocked()) {
				magnets = magnets.concat(this.getRelevantMagnets(toShape, preDocker || fromDocker, orientation));
			}
			
			// Show magnets
			magnets.invoke("show");		
			data.magnets = magnets;
			
			
			/** Snapping points **/
	
			//get all dockers
			var snapPoints = [];
			var dockers = [];
			edge.dockers.each(function(docker){
				if (docker.isDocked()) {
					snapPoints.push(orientation == "horizontal" ? 
						docker.referencePoint.y + docker.getDockedShape().absoluteBounds().upperLeft().y:
						docker.referencePoint.x + docker.getDockedShape().absoluteBounds().upperLeft().x
					);
				} else {
					snapPoints.push(orientation == "horizontal" ?
						docker.bounds.center().y:
						docker.bounds.center().x
					);
				}
				dockers.push({
					val	: orientation == "horizontal" ? docker.bounds.center().y : docker.bounds.center().x,
					id	: docker.id
				})
			})
	
			
			// add the origin position 
			snapPoints.push(data.old);
			
			//get related edges
			window.clearTimeout(this.dockerTimer);
			this.dockerTimer = window.setTimeout(function(){
				if (edge.incoming[0]) {
					if (edge.incoming[0].outgoing.length > 1) {
						edge.incoming[0].outgoing.without(edge).each(function(e){
							e.dockers.each(function(docker){
								if (docker.isDocked()) {
									snapPoints.push(orientation == "horizontal" ?
										docker.referencePoint.y + docker.getDockedShape().absoluteBounds().upperLeft().y :
										docker.referencePoint.x + docker.getDockedShape().absoluteBounds().upperLeft().x
									);
								} else {
									snapPoints.push(orientation == "horizontal" ?
										docker.bounds.center().y:
										docker.bounds.center().x
									);
								}
							})
						}.bind(this))
					}
					if (edge.incoming[0].incoming.length > 0){
						edge.incoming[0].incoming.each(function(i){
							i.dockers.each(function(docker){
								if (docker.isDocked()) {
									snapPoints.push(orientation == "horizontal" ?
										docker.referencePoint.y + docker.getDockedShape().absoluteBounds().upperLeft().y :
										docker.referencePoint.x + docker.getDockedShape().absoluteBounds().upperLeft().x
										
									);
								} else {
									snapPoints.push(orientation == "horizontal" ?
										docker.bounds.center().y:
										docker.bounds.center().x
									);
								}
							})	
						})
					}
				}
				if (edge.outgoing[0]) {
					if (edge.outgoing[0].incoming.length > 1) {
						edge.outgoing[0].incoming.without(edge).each(function(e){
							e.dockers.each(function(docker){
								if (docker.isDocked()) {
									snapPoints.push(orientation == "horizontal" ?
										docker.referencePoint.y + docker.getDockedShape().absoluteBounds().upperLeft().y :
										docker.referencePoint.x + docker.getDockedShape().absoluteBounds().upperLeft().x
										
									);
								} else {
									snapPoints.push(orientation == "horizontal" ?
										docker.bounds.center().y:
										docker.bounds.center().x
									);
								}
							})
						})
					}	
					if (edge.outgoing[0].outgoing.length > 0){
						edge.outgoing[0].outgoing.each(function(o){
							o.dockers.each(function(docker){
								if (docker.isDocked()) {
									snapPoints.push(orientation == "horizontal" ?
										docker.referencePoint.y + docker.getDockedShape().absoluteBounds().upperLeft().y :
										docker.referencePoint.x + docker.getDockedShape().absoluteBounds().upperLeft().x
										
									);
								} else {
									snapPoints.push(orientation == "horizontal" ?
										docker.bounds.center().y:
										docker.bounds.center().x
									);
								}
							})	
						})
					}
				}
			}.bind(this), 100);
			data.dockers = dockers;
			data.snapPoints = snapPoints;
		},
		onDragDrop : function(data){
			delete this.isDragging;
			Ext.getBody().setStyle("cursor", "auto");
			this.hLine.hide();
			this.vLine.hide();
			this.moverActive = false;
			
			var edge = this.activeSegment.edge;
			
			// Show the labels
			edge.showLabels();
			
			if (this.isInitialized){
				delete this.isInitialized;
				return;
			}
			
			// Hide dockers
			edge.dockers.invoke("preventHiding", false);	
			edge.dockers.invoke("hide");
			
			if (this.iPad) {
				this.hideOverlay();
			}
			
			// Set the selection including the edge
			//this.facade.setSelection([this.activeSegment.edge], false);
			
			data.magnets.invoke("hide");
				
			this.hideMover();
			if (this.initialState.fromPosition.x == this.initialState.fromDocker.bounds.center().x &&
				this.initialState.fromPosition.y == this.initialState.fromDocker.bounds.center().y &&
				this.initialState.toPosition.x == this.initialState.toDocker.bounds.center().x &&
				this.initialState.toPosition.y == this.initialState.toDocker.bounds.center().y) { 
				return;
			}
			
			// UNDO/REDO - Command
			var Change = ORYX.Core.Command.extend({
				construct: function(facade, oldState){
					this.oldState = oldState;
					this.shape = oldState.shape;
					this.dockers = oldState.dockers;
					this.facade = facade;
					this.removedDockers = $H({});
					this.fromShape = oldState.fromShape;
					this.toShape = oldState.toShape;
				},			
				execute: function(){
					if (!this.newState) {
						
						if (!(this.fromShape && this.toShape && this.fromShape.shape == this.toShape.shape)) {
							this.removedDockers = this.shape.removeUnusedDockers();
						}
						
						if (this.fromShape && (!this.toShape || this.fromShape.shape !== this.toShape.shape)) {
							if (this.fromShape.shape.isPointIncluded(this.shape.dockers[0].bounds.center().x, this.shape.dockers[0].bounds.center().y) &&
							    this.fromShape.shape.isPointIncluded(this.shape.dockers[1].bounds.center().x, this.shape.dockers[1].bounds.center().y)) {
								
								this.removedDockers[1] = this.shape.dockers[1];
								var ref = {x:this.shape.dockers[1].bounds.center().x - this.fromShape.upperLeft.x, y:this.shape.dockers[1].bounds.center().y - this.fromShape.upperLeft.y};
								this.shape.remove(this.shape.dockers[1]);
								this.shape.dockers[0].setReferencePoint(ref);
								this.shape._update(true);
							}
						}
						if (this.toShape && (!this.fromShape || this.fromShape.shape !== this.toShape.shape)) {
							if (this.toShape.shape.isPointIncluded(this.shape.dockers[this.shape.dockers.length - 1].bounds.center().x, this.shape.dockers[this.shape.dockers.length - 1].bounds.center().y) &&
						    	this.toShape.shape.isPointIncluded(this.shape.dockers[this.shape.dockers.length - 2].bounds.center().x, this.shape.dockers[this.shape.dockers.length - 2].bounds.center().y)) {
								
								this.removedDockers[this.shape.dockers.length - 2] = this.shape.dockers[this.shape.dockers.length - 2];
								var ref = {x:this.shape.dockers[this.shape.dockers.length - 2].bounds.center().x - this.toShape.upperLeft.x, y:this.shape.dockers[this.shape.dockers.length - 2].bounds.center().y - this.toShape.upperLeft.y};
								this.shape.remove(this.shape.dockers[this.shape.dockers.length - 2]);
								this.shape.dockers[this.shape.dockers.length - 1].setReferencePoint(ref);
								this.shape._update(true)
							} 
						}
	
						var dockers = this.shape.dockers.collect(function(docker){
							return {
								docker:docker,
								pos:docker.bounds.center(),
								ref:docker.referencePoint
							};
						});
						this.newState = {
								shape : this.shape,
								dockers : dockers,
								fromShape : this.fromShape,
								toShape : this.toShape
						};
						
						this.facade.setSelection([this.shape]);
						this.shape._update(true);				
			            this.facade.updateSelection(); 
					} else {
						this.setState(this.newState);
					}
				},			
				rollback: function(){			
					(this.removedDockers||$H({})).each(function(d){
						if (d) {
							this.shape.add(d.value, Number(d.key));
						}
					}.bind(this));
					this.setState(this.oldState);
				},
				setState: function(state){
					var dockers = state.dockers.pluck("docker");
					var shapeDockers = this.shape.dockers;
					var fromShape = state.fromShape;
					var toShape = state.toShape;
					
					// Remove unused docker
					for (var i = shapeDockers.length-1; i >= 0; --i){
						if (!dockers.include(shapeDockers[i])) {
							this.removedDockers[i] = shapeDockers[i];
							this.shape.remove(shapeDockers[i]);
						}
					}
					
					// Add used docker
					dockers.each(function(docker, i){
						if (!shapeDockers.include(docker)/* && !shapeDockers.any(function(shapeDocker) {
							return  !!shapeDocker.parent &&
									Math.abs(shapeDocker.bounds.center().x-docker.bounds.center().x) < 1 &&
								 	Math.abs(shapeDocker.bounds.center().y-docker.bounds.center().y) < 1
						})*/) {
							this.shape.add(docker, i);
						}
					}.bind(this));
	
					state.dockers.each(function(sdocker, index) {
						if (sdocker.docker.isDocked()) {
							sdocker.docker.setReferencePoint(sdocker.ref);
						}
						sdocker.docker.bounds.centerMoveTo(sdocker.pos);
					}.bind(this));			
	
					this.facade.setSelection([this.shape]);
					this.shape._update(true);				
		            this.facade.updateSelection(); 
				}
			});
			
			this.facade.executeCommands([new Change(this.facade, this.initialState)]);			
		},
		adjustPosition : function(data, position, event){
			if (this.activeSegment) {
				position.x += 6;
				position.y += 6;
				var offset = 7;
				
				//orientation of the segment
				var orientation = this.activeSegment.align;
				var horizontal = (orientation == "horizontal");
				
				//position of the mover on the active segment
				var middle = this.middle(this.activeSegment.fromDocker, this.activeSegment.toDocker, orientation);
	
				var edge = data.edge;
				var dockers = edge.dockers;
				var dockerCount = dockers.length;
	
				//restrict movement to the canvas
				var canvasLimit = horizontal ? (data.canvas.bounds.height() - offset) : (data.canvas.bounds.width() - offset);
				if (horizontal ? (position.y < offset || position.y > canvasLimit):
								 (position.x < offset || position.x > canvasLimit)) {
					if (horizontal) {
						position.y = position.y < offset ? offset : position.y > (canvasLimit) ? canvasLimit : position.y; 
						return {x : middle, y : position.y};
					} else {
						position.x = position.x < offset ? offset : position.x > (canvasLimit) ? canvasLimit : position.x;
						return {x : position.x, y : middle};
					}
				}
	
				//docker creation
				
				//fromDocker
				if (dockers[0].isDocked()) {
					this.dockSegment(
						this.activeSegment.fromDocker, data.fromShape, position, edge, edge.dockers, edge.dockers.length, orientation, "from"
					);
				}
				//toDocker
				if (dockers[dockerCount - 1].isDocked()) {
					this.dockSegment(
						this.activeSegment.toDocker, data.toShape, position, edge, edge.dockers, edge.dockers.length, orientation, "to"
					);
				}
				
				var snapPoint = this.snap(position, data, event);
				
				return horizontal ? {x:middle, y:snapPoint.y} : {x:snapPoint.x, y:middle};
			}
			return position;		
		},
		
		snap : function(point, data, event){
	
			this.hLine.hide();
			this.vLine.hide();
			
			//disable snapping if ctrl is pressed
			if (event.ctrlKey) return point;
			
			var range = 5;
			var from = this.activeSegment.fromDocker;
			var to = this.activeSegment.toDocker;
	
			//the real dockers 
			var dockers = data.dockers;
			
	    	var snapPoints = data.snapPoints;
	
			var orientation = this.activeSegment.align;
	
			//snap to middle between previous and next dockers
			if (dockers.length >= 4) {
				dockers.each(function(docker, index) {
					if (dockers[index - 1] && dockers[index + 2] && docker.id == from.id) {
						var min = Math.min(dockers[index - 1].val, dockers[index + 2].val);
						var max = Math.max(dockers[index - 1].val, dockers[index + 2].val);
						var mid = min + (max - min) / 2;
						if (orientation == "horizontal") {
							if ((point.y < mid + range) && (point.y > mid - range) && max - min > 20) {
								point = {x : point.x, y : mid};
	//							this.hLine.update(point.y);
							}
						} else if (orientation == "vertical") {
							if ((point.x < mid + range) && (point.x > mid - range) && max - min > 20) {
								point = {x : mid, y : point.y};
	//							this.vLine.update(point.x);
							}
						}
					}	
				}.bind(this))
			}
	
			//snap to magnets
			data.magnets.each(function(magnet){
				if (orientation == "horizontal" && (magnet.y - range) < point.y && (magnet.y + range) > point.y ){
	    			point = {x:point.x, y:magnet.y};
	//    			this.hLine.update(point.y)
	    		} else if (orientation == "vertical" && (magnet.x - range) < point.x && (magnet.x + range) > point.x){
	    			point = {x:magnet.x, y:point.y};
	//    			this.vLine.update(point.x)
	    		}
			}.bind(this))
	
			//snap to snapPoints
			snapPoints.each(function(snapPoint){
				if (orientation == "horizontal" && (snapPoint - range) < point.y && (snapPoint + range) > point.y) {
					point = {x:point.x, y:snapPoint};
					if (snapPoint != data.old) {
						this.hLine.update(point.y);
					}
					throw $break;
				} else if (orientation == "vertical" && (snapPoint - range) < point.x && (snapPoint + range) > point.x) {
					point = {x:snapPoint, y:point.y};
					if (snapPoint != data.old) {
						this.vLine.update(point.x);
					}
					throw $break;
				}
			}.bind(this))
			
			return point;
		},
		/**
		 * Returns true if the edge is inside the bounds of the docked shape.
		 * 
		 * @param {Point} point The current position of the mouse
		 * @param {Object} shapeData The stripped data of the docked shape
		 * @param {String} orientation The orientation of the segment
		 * @return {Boolean}
		 */
		insideShape : function(point, shapeData, orientation){
			
			//the shape and it's measures
			var ulX = shapeData.upperLeft.x;
			var ulY = shapeData.upperLeft.y;
			var lrX = shapeData.lowerRight.x;
			var lrY = shapeData.lowerRight.y;
	
			var offset = 7;
	
			//limit vertical movement of the edge to the shape's borders
			if(orientation == "horizontal"){
				return point.y > ulY + offset && point.y < lrY - offset;
			}						
			//limit horizontal movement of the edge to the shape's borders
			if(orientation == "vertical"){
				return point.x > ulX + offset && point.x < lrX - offset;
			}
		},
		
		/**
		 * Returns true if the edge is docked to at least one node.
		 * 
		 * @param {Object} edge The selected edge
		 * @return {Boolean}
		 */
		isEdgeDocked: function(edge){
			return !! (edge.dockers.length > 2 && (edge.incoming.length || edge.outgoing.length) ||
					  (edge.incoming.length && edge.outgoing.length));
		},
		
		
		middle : function(fromDocker, toDocker, orientation) {
			var a = orientation == "horizontal" ? fromDocker.bounds.center().x : fromDocker.bounds.center().y;
			var b = orientation == "horizontal" ? toDocker.bounds.center().x : toDocker.bounds.center().y;
			var min = Math.min(a, b);
			var max = Math.max(a, b);
			return min + (max - min) / 2;
		},
				
		/**
		 * Checks if the active segment is moved out of / into the bounds of the docked shape(s) and if so, creates a new docker or deletes the unused docker.
		 * 
		 * @param {Object} docker The docker of the active segment, either the fromDocker or the toDocker.
		 * @param {Object} shape The data of the docked shape of either the fromDocker or the toDocker.
		 * @param {Point} position The current mouse position.
		 * @param {Object} edge The edge aka parent of 'docker'.
		 * @param {Array} dockers All dockers of the 'edge'.
		 * @param {Number} dockerCount The number of the dockers.
		 * @param {String} orientation The orientation of the active segment.
		 * @param {String} pos Defines the passed docker. "from" -> docker == fromDocker, "to" -> docker == toDocker.
		 */
		dockSegment : function(docker, shape, position, edge, dockers, dockerCount, orientation, pos) {
			if (!shape) {return;}
			
			//shortcut for checking orientation
			var horizontal = (orientation == "horizontal");
			//shortcut for checking if it's the fromDocker or the toDocker of the active segment
			var from = (pos == "from");
			var prevStart = undefined, prevEnd = undefined;
			//some of the shape's coordinates
			var ul = shape.upperLeft;
			var lr = shape.lowerRight;
					
			//DOCK!
			if (docker.id == (from ? dockers[0].id : dockers[dockerCount - 1].id)) {
				if (horizontal ? (position.y < ul.y || position.y > lr.y):
				   				 (position.x < ul.x || position.x > lr.x)) {
	
					//if a docker has already been removed, readd it
					// TODO: ? prevStart and prevEnd is allways undefined
					if (from ? prevStart : prevEnd) {
						edge.addDocker.apply(edge, from ? [1, prevStart] : [dockerCount - 2, prevEnd]);
						if (from) {
							this.activeSegment.fromDocker = dockers[1];
							this.activeSegment.fromDocker.preventHiding(true);
							this.activeSegment.fromDocker.show();
							prevStart = undefined;
						} else {
							this.activeSegment.toDocker = dockers[dockerCount - 2];
							this.activeSegment.toDocker.preventHiding(true);
							this.activeSegment.toDocker.show();
							prevEnd = undefined;
						}
	
					//else create new docker
					} else { 
						if (from) {
							var fromRef = horizontal ? (docker.referencePoint.x + ul.x):
													   (docker.referencePoint.y + ul.y);
							edge.createDocker(1, horizontal ? ({x : fromRef, y : position.y}) :
															  ({x : position.x, y : fromRef}));
							this.activeSegment.fromDocker = dockers[1];
							this.activeSegment.fromDocker.preventHiding(true);
							this.activeSegment.fromDocker.show();
							dockers.first().setReferencePoint(horizontal ? ({x:fromRef - ul.x, y:shape.shape._defaultMagnet.bounds.center().y}) :
																	  ({x:shape.shape._defaultMagnet.bounds.center().x, y:fromRef - ul.y}));
						} else {
							var toRef = horizontal ? (docker.referencePoint.x + ul.x):
													 (docker.referencePoint.y + ul.y);
							edge.createDocker(dockerCount - 1, horizontal ? ({x : toRef, y : position.y}) :
																			({x : position.x, y : toRef}));
							this.activeSegment.toDocker = dockers[dockerCount - 1];
							this.activeSegment.toDocker.preventHiding(true);
							this.activeSegment.toDocker.show();
							dockers.last().setReferencePoint(horizontal ? ({x:toRef - ul.x, y:shape.shape._defaultMagnet.bounds.center().y }):
																				({x:shape.shape._defaultMagnet.bounds.center().x, y:toRef - ul.y}));
						}
					}
					var middle = this.middle(this.activeSegment.fromDocker, this.activeSegment.toDocker, orientation);
				}
			} else if (docker.id == (from ? (dockers[1].id) : (dockers[dockerCount - 2].id))) {
				//if segment is dragged into the shape
				if (horizontal ? (position.y >= ul.y && position.y <= lr.y):
								 (position.x >= ul.x && position.x <= lr.x)) {
					if (from) {
						prevStart = dockers[1];
						edge.remove(dockers[1]);
						this.activeSegment.fromDocker = dockers[0];
					} else {
						prevEnd = dockers[dockerCount - 2];
						edge.remove(dockers[dockerCount - 2]);
						this.activeSegment.toDocker = dockers[dockerCount - 1];
					}
				}
			}		
		},
		
		getRelevantMagnets : function(shapeData, docker, orientation) {
			var shapeMagnets = shapeData.shape.getMagnets();
			var horizontal = (orientation == "horizontal");
			var magnets = [];
			
			if (shapeMagnets.length === 1){
				magnets = shapeMagnets[0];
			} else {
				var side = this.getSide(shapeData.center, docker, orientation);
	
				magnets = shapeData.shape.getMagnets().findAll(function(magnet) {
					switch (side) {
						case "left" : return magnet.anchorLeft; 
						
						case "right" : return magnet.anchorRight;
						
						case "top" : return magnet.anchorTop;
						
						case "bottom" : return magnet.anchorBottom;
					}
				})
			}
	
			if (magnets.length > 0) {
				magnets.each(function(magnet) {
					magnet.x = magnet.bounds.center().x + shapeData.upperLeft.x;
					magnet.y = magnet.bounds.center().y + shapeData.upperLeft.y; 
				})
			}
			return magnets;
		},
		
		getSide : function(shapeCenter, docker, orientation) {
			var horizontal = (orientation == "horizontal");
			if (horizontal) {
				return (docker.bounds.center().x < shapeCenter.x) ? "left" : "right";
			} else {
				return (docker.bounds.center().y < shapeCenter.y) ? "top" : "bottom";
			}
		},
		
		
		/**
		 * Calculates the best point to place the edge segment mover. It calculates the current segment,
		 * checks if it is either horizontal or vertical and determines the center of this segment. If the
		 * segment is skew, the position for the edge segment is outside of the canvas.
		 * 
		 * @param {Shape} edge The whole edge
		 * @param {Point} point The current position of the mouse
		 * @return {Object} best The optimal point to place the Mover and the alignment of the segment
		 */
		calculateOptimal : function(edge, point){
			var best;
			
			// calculate the optimal point ON THE EDGE to display the mover
			for (var i = 0, l = edge.dockers.length-1; i < l; ++i) {
				var point1 = edge.dockers[i].bounds.center(); 
				var point2 = edge.dockers[i+1].bounds.center();  
				
				if(ORYX.Core.Math.isPointInLine(point.x, point.y, point1.x, point1.y, point2.x, point2.y, 10)) {
					var isVer = Math.abs(point1.x - point2.x) < 1;
					var isHor = Math.abs(point1.y - point2.y) < 1;
					if (isVer||isHor) {
						var distance = ORYX.Core.Math.distancePointLinie(point1, point2, point, true);
						if (distance !== null && (!best || best.distance > distance)){
							best = ORYX.Core.Math.midPoint(point1, point2);
							best.align = isHor ? "horizontal" : (isVer ? "vertical" : false);
							best.distance = distance;
						}
					}
				}
	
	//			if(ORYX.Core.Math.isPointInLine(point.x, point.y, point1.x, point1.y, point2.x, point2.y, 5)) {
	//				if (point1.y == point2.y || point1.x == point2.x) {
	//					var best = ORYX.Core.Math.midPoint(point1, point2);
	//					best.align = (point1.y == point2.y) ? "horizontal" : (point1.x == point2.x) ? "vertical" : false;
	//					return best;
	//				}
	//			}
			}
			return best || null;
		},
		/**
		 * 
		 * @param edge
		 */
		showOverlay: function(edge){
			if (this.iPad) {
				if (this.movers) {
					this.movers.each(function(mover){
						edge.node.lastChild.appendChild(mover);
					}.bind(this));
				}
			} else {
				edge.node.lastChild.appendChild(this.rect);
			}
		},
		
		/**
		 *hides the Mover
		 */
		hideOverlay: function(exceptSegment) {
			if (this.iPad) {
				if (this.movers) {
					this.movers.each(function(mover){
						if (mover.parentNode && (!exceptSegment || mover !== exceptSegment.node)) {
							mover.parentNode.removeChild(mover);
						}
					});
					//delete this.movers;
				}
			} else {
				if (this.rect.parentNode) {
					this.rect.parentNode.removeChild(this.rect);
				}
			}
		}		
	
	});
//	ORYX.Plugins.MoveEdgeSegment = Clazz.extend(ORYX.Plugins.MoveEdgeSegment);
}();/**
 * Copyright (c) 2010 Signavio
 * @author Willi Tscheschner
 *
 **/

/**
 * @namespace
 * @name ORYX.Plugins
 */
if ("undefined" === typeof Signavio) { var Signavio = {}; }
if ("undefined" === typeof Signavio.Plugins) { Signavio.Plugins = {}; }
	
new function(){
	
	Signavio.Plugins.Multilanguage = ORYX.Plugins.AbstractPlugin.extend({
	
		/**
		 *	Constructor
		 *	@param {Object} Facade: The Facade of the Editor
		 */
		construct: function(facade){
			
			// Enable the config variable to TRUE to enable the multi language
			ORYX.CONFIG.MULTI_LANGUAGES_ENABLED = true;
			
			// Init
			this.facade = facade;
			this.initButtons();
		},
		
		/**
		 * Initialize all the buttons of the defined languages
		 */
		initButtons: function(){
			

			// Add a separator
			this.facade.offer({		
				'group'		: "ZZZZZZZZZGroup.Multilanguage",
				'name'		: true,
				'addFill'	: true,
				'index'		: 1
			});
			
			// Get the current language
			var current = this.facade.getCanvas().getLanguage(),
				languages = $H(ORYX.CONFIG.MULTI_LANGUAGES||{}),
				dropDownIcon = ORYX.CONFIG.EXPLORER_PATH + "/src/img/flags/" + (languages[current]);

			// Create a button for every defined language
			languages.each(function(lang, index){
				var name = Signavio.I18N.Multilanguage[String(lang.key).toUpperCase()] || lang.key;
				var button = {		
						'name' 				: name,
						'group'				: "ZZZZZZZZZZGroup.Multilanguage",
						'index'				: index,
						'dropDownGroupIcon' : dropDownIcon,
						'toggle' 			: false,
						'icon' 				: ORYX.CONFIG.EXPLORER_PATH + "/src/img/flags/" + lang.value,
						'functionality' 	: function(){ this.changeLanguage(button.buttonInstance, lang.key); }.bind(this),
						'index'				: 2,
						'style'				: lang.key == current ? "font-weight:bold" : undefined
					};
				this.facade.offer(button);
				this.initialButton = this.initialButton || button;
			}.bind(this));
		},
		
		/**
		 * Change the current language of the diagram
		 */
		changeLanguage: function(button, lang){
			// Change button
			this.setButton(button);
			
			// Set language
			this.facade.getCanvas().setLanguage(lang);
			
			// Update selection for the property window
			this.facade.raiseEvent({
				type : ORYX.CONFIG.EVENT_SELECTION_CHANGED,
				elements : this.facade.getSelection()
			});
			
		},
		
		/**
		 * Activate a button and change the icon of the split button
		 * @param button
		 */
		setButton: function(button){
			
			// Set the icon to the split button
			var bt = button.splitButton;
			bt.icon = button.icon;
			bt.el.child(bt.buttonSelector).setStyle('background-image', 'url(' +bt.icon +')');
			
			// Bold the text
			button.parentMenu.items.each(function(btn){
			    btn.el.setStyle("font-weight", "");
			});
			button.el.setStyle("font-weight", "bold");
			
		}
	});
		
}();
/**
 * Copyright (c) 2010
 * Willi Tscheschner
 * 
 * This code is proprietary software within the 
 * company Signavio GmbH.
 * 
 **/
if ("undefined" == typeof window.Signavio) { var Signavio = {};}
if ("undefined" == typeof Signavio.Plugins) { Signavio.Plugins = {};}

(function(){
	
	Signavio.Plugins.Locking = ORYX.Plugins.AbstractPlugin.extend({
		
		pingInterval: 30, // The interval of the ping in seconds
		
	    construct: function(facade){
			this.facade = facade;

			// Setup UI
			this.setupPanel();
			// Start requesting
			this.doPing();
			
			// Update panel position on certain events
			Ext.getCmp(this.panel.parent("div.x-panel").id).on("resize", this.updatePanelPosition, this);
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ZOOM, this.updatePanelPosition.bind(this) );
			// Update ping if saved
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SAVED, this.doPing.bind(this) );
			
			// Check for changes of the cookie, to see if user is logged in
			ORYX.Editor.Cookie.onChange(function(val){
				window.clearTimeout(this.timer);
				if (!this.isLoggedIn()){
					this.onNotAuthorized();
				} else {
					this.doPing();
				}
			}.bind(this));
		},
		
		/**
		 * Generates the panel and its templates
		 * 
		 */
		setupPanel: function(){
			
			this.tplUser = new Ext.XTemplate(	"<span>", Signavio.I18N.Locking.editing, " </span>",
												'<tpl for=".">',
													'<tpl for="rep">',
														'<span class="x-user" title="{company}">{name}</span>{[xcount!=xindex?",":""]} ',
													'</tpl>',
												'</tpl>');

			this.tplFail = new Ext.XTemplate(	"<span class='x-fail'>{message}</span>");
			
			this.panel = Ext.get(this.facade.getCanvas()
										.getHTMLContainer()
										.parentNode
										.parentNode
										.parentNode
										.appendChild(document.createElement("div")));
			
			this.panel.addClass("x-locking");
			
		},

		/**
		 * Set the panel to the correct position
		 * depending on the scrollbars
		 * 
		 */
		updatePanelPosition: function(){
			if (!this.scroll)
				this.scroll = this.facade.getCanvas().getScrollNode();
			
			if (this.scroll.scrollWidth <= this.scroll.offsetWidth -17 
					|| this.scroll.scrollHeight == this.scroll.offsetHeight){
				this.panel.setBottom("2px");
			} else {
				this.panel.setBottom("");
			}

			if (this.scroll.scrollHeight <= this.scroll.offsetHeight -17 
					|| this.scroll.scrollWidth == this.scroll.offsetWidth){
				this.panel.setRight("2px");
			} else {
				this.panel.setRight("");
			}
		},
		
		/**
		 * Callback if a timeout was raised before
		 * the response was sent
		 */
		onAbort: function(){
			// Set message
			this.tplFail.overwrite(this.panel, {message: Signavio.I18N.Locking.timeout});
		},

		/**
		 * Callback if the user is not online
		 * 
		 */
		onNotOnline: function(){
			// Set message
			this.tplFail.overwrite(this.panel, {message: Signavio.I18N.Locking.notOnline});
		},
		
		/**
		 * Callback if the user is not authorized
		 * 
		 */
		onNotAuthorized: function(){
			// Set message
			this.tplFail.overwrite(this.panel, {message: Signavio.I18N.Locking.notAuthorized});
		},
		
		/**
		 * Returns TRUE if there is a current user in the cookie 
		 * @returns {Boolean}
		 */
		isLoggedIn: function(){
			var id = ((ORYX.Editor.Cookie.getParams()||{}).identifier||"").replace(/"/g, "");
			return id && id != 'public';
		},
		
		/**
		 * Callback if the user has 
		 * no rights on the current model
		 * 
		 */
		onNoRights: function(){
			// Set message
			this.tplFail.overwrite(this.panel, {message: Signavio.I18N.Locking.noRights});
		},
		
		/**
		 * Callback if the request failed
		 */
		onFailure: function(){
			
			// Set message
			this.tplFail.overwrite(this.panel, {message: Signavio.I18N.Locking.connectionProblem});
			
			// Shift the ping interval 
			// to prevent parallel pings
			window.setTimeout(function(){
				this.doWait();
			}.bind(this), 5000);
		},
		
		/**
		 * Returns the user object. Check if
		 * the user is in the cache, otherwise 
		 * call the info object.
		 * @param href
		 * @returns {Object}
		 */
		getUser: function(href){
			if (!this.users){ this.users = {}; }
			
			var user = this.users[href];
			if (!user){ 
				// Only retrieve user if a correct user id is given
				if (href.split("/").length == 32){
					new Ajax.Request(ORYX.CONFIG.SERVER_HANDLER_ROOT + href + "/info", {
			            method: 'get',
			            asynchronous: false,
						requestHeaders: {"Accept":"application/json"},
						encoding: 'UTF-8',
						onSuccess: (function(transport) {
							user = {
									rel	: "user",
									href: href,
									rep	: (transport.responseText||"{}").evalJSON()
							};
						}).bind(this)
					});
				// Otherwise use system user
				} else {
					user = {rel	: "user",
							href: href,
							rep	: {
								name: "<i>System</i>",
								company: ""
							}};
				}
				this.users[href] = user;
			}
			return user;
		},
		
		/**
		 * 
		 * @param users
		 */
		cacheUsers: function(users){
			if (!this.users){ this.users = {}; }

			[].concat(users).each(function(user){
				if ("user" == user.rel)
					this.users[user.href] = user;
			}.bind(this));
		},
		
		/**
		 * Callback if the request went successfully
		 * @param response
		 */
		onSuccess: function(response){
			
			// For further research, cache users
			this.cacheUsers(response);
			
			// Get the current user
			var current = unescape((ORYX.Editor.Cookie.getParams()||{}).login||"").toLowerCase();
			// Get the set of all other users
			var user = response.findAll(function(data){
							return "user" == data.rel && current && data.rep.mail.toLowerCase() !== current;
						});
			
			// Set users
			if (user.length > 0){
				this.panel.show();
				this.tplUser.overwrite(this.panel, user);
			} else {
				this.panel.update("");
				this.panel.hide();
			}
			
			
			// Check for changes
			var model = response.find(function(data){
							return "mod" == data.rel;
						});
			var cModel = this.facade.getModelMetaData();
			if (model && cModel && model.rep.rev !== cModel.revision){
				var author = this.getUser(model.rep.author);
				if (author && current && author.rep.mail != current){
					this.panel.show();
					this.panel.insertHtml("afterBegin", (new Ext.Template(Signavio.I18N.Locking.remoteEdited+"<br/>")).apply(author.rep));
				}
			}
		},
		
		/**
		 * Callback if request went either
		 * success or failed.
		 *  
		 */
		onComplete: function(){
			this.doWait();
		},
		
		/**
		 * Waits a specific time to 
		 * call the doPing method
		 *  
		 */
		doWait: function(){
			// Reset timer
			window.clearTimeout(this.timer);
			
			// Start timer
			this.timer = window.setTimeout(function(){
				this.doPing();
				delete this.timer;
			}.bind(this), this.pingInterval*1000);
		},
		
		/**
		 * Do a Ping to the server and
		 * call one of the response methods (on...)
		 * 
		 */
		doPing: function(){
			
			if (!this.isLoggedIn()){
				return;
			}
			
			var model = this.facade.getModelMetaData();
			
			if (model["new"]){
				this.panel.hide();
				return;
			}
			
			Ext.Ajax.request({
				url				: ORYX.CONFIG.SERVER_MODEL_HANDLER+"/"+(model.modelId)+"/ping",
				method			: "POST",
				headers			: {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
				params			: {},
				success			: function(transport){
					this.onSuccess((transport.responseText||"{}").evalJSON());
					this.onComplete();
				}.bind(this),
				failure			: function(transport){
					if(transport.status && transport.status === 401) {
						this.onNotAuthorized();
						return; // Stop requesting
					} else if(transport.status && transport.status === 403) {
						this.onNoRights();
						return; // Stop requesting
					} else if(transport.statusText === "transaction aborted") {
						this.onAbort();
					} else if(transport.statusText === "communication failure") {
						this.onNotOnline();
					} else {
						this.onFailure();
					}
					this.onComplete();
				}.bind(this)
			});
		}
	});	
}());

/**
 * Copyright (c) 2010
 * Adrian Klinger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = {};



new function(){

	var CONST = {};
	CONST.DUMMY_SVG = 	'<svg xmlns="http://www.w3.org/2000/svg" xmlns:oryx="http://oryx-editor.org" '
			+ 'width="1" height="1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000'
			+ '/svg"><defs/><g stroke="black" font-family="Verdana, sans-serif" font-size-adjust="none" font-style="normal"'
			+ ' font-variant="normal" font-weight="normal" line-heigth="normal" font-size="12"><g class="stencils" transform'
			+ '="translate(0)"><g class="me"/><g class="children"/><g class="edge"/></g></g></svg>';
	
	var Request = {};
	Request.execute = function(url, callback, params, method){
		
		var successcallback = callback instanceof Array ? callback[0] : callback; 
		var failedcallback = callback instanceof Array ? callback[1] : undefined;
		
		new Ajax.Request(url, {
				method		: method || 'get',
				parameters	: params, 
				requestHeaders : {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
				asynchronous: false,
				onSuccess: function(transport){
					var json;
					try {
						json = transport.responseText.evalJSON();	
					} catch(e){
						json = transport.responseText;
					}
					
					if (successcallback instanceof Function)
						successcallback(json, transport);
				},
				onFailure: function(transport){
					if (failedcallback instanceof Function)
						failedcallback( transport);
				}
			});
	}
	
	Signavio.Plugins.AutomaticCollapsedSubProcesses = ORYX.Plugins.AbstractPlugin.extend({
		
		construct: function(facade){
			    
		        this.facade = facade;
		        this.pluginMenuIsShown = false;
		        this.button = {
						target 			: ORYX.Plugins.ShapeMenuPlugin,
						functionality	: function(){
			    			this.togglePluginMenu();
			    		}.bind(this),
			    	 	icon			: ORYX.PATH + 'images/wrench_orange.png',
			    		description		: ORYX.I18N.Subprocessing.PluginDescription,
			            align			: ORYX.CONFIG.SHAPEMENU_BOTTOM,
			            minShape		: 2,			          
			            isEnabled		: function(){			            	
			            	return ("undefined" != typeof this.facade && (this.facade.getCanvas().getStencil().namespace()=="http://b3mn.org/stencilset/bpmn2.0#"))			    			
			           }.bind(this)};
		        
		        this.facade.offer(this.button);
		        this.facade.registerOnEvent("shapemenu.showMorphButton", this.shapeMenuWasCreated.bind(this));
		},		
		/**
		 * Is called, if an Shapemenu of a shape is constructed
		 * Function overwrite the handlerfunction of the button, which morph a subprocess to a collapsedsubprocess
		 */
		shapeMenuWasCreated: function(eventObject){
			
			if (eventObject.selectedElements.length != 1) {return;}
			if (!eventObject.selectedElements[0].getStencil().id().endsWith("Subprocess"))  {return;}
			var button = eventObject.buttons.find(function(button){return (button.identifier.endsWith("CollapsedEventSubprocess")|| button.identifier.endsWith("CollapsedSubprocess"))});
			if (!button) {return;}
			if (eventObject.selectedElements[0].getChildShapes().length > 0){
				button.setHandler(function(){ this.startSubProcessing([eventObject.selectedElements[0]]) }.bind(this));
			}
		},
		/**
		 * Create the buttons for the plugin-shapemenu
		 * firstButton = Selected Elements (ever disabled)
		 * second Button = Button, which create the a new collpsed Task and copy the selected Elements to a new diagram
		 */
		createPluginMenuItems:function(){			

			if ("undefined" != typeof this.facade && this.facade.getSelection().length > 1)
			{	
				var button1 = new Ext.menu.Item({
					text			: ORYX.I18N.Subprocessing.SelectedItems,
					icon			: "/stencilsets/bpmn2.0/icons/activity/event.subprocess.png",					
					disabled		: 	true
				});	
				
				var button2 = new Ext.menu.Item({
					text			: ORYX.I18N.Subprocessing.OpenedSubprocess,
					icon			: "/stencilsets/bpmn2.0/icons/activity/subprocess.png",
					handler			: function(){									
							this.startSubProcessing(this.facade.getSelection());
					}.bind(this) 
				});	
				this.pluginMenu.addItem(button1);
				this.pluginMenu.addItem(button2);
			}
		},
		
		onSelectionChanged: function(event) {				
			if (this.pluginMenu != undefined && this.pluginMenuIsShown == true)
			{
				this.hidePluginMenu();
			}
		},
		
		createPluginMenu:function(){
			this.pluginMenu = new Ext.menu.Menu();			
			this.createPluginMenuItems();			
		},
		
		togglePluginMenu:function(){
			if (this.pluginMenuIsShown == true){				
				this.hidePluginMenu();
			}
			else {
				this.showPluginMenu();					
			}
		},	
		
		showPluginMenu:function(){		
			this.createPluginMenu();
			this.pluginMenuIsShown = true;
			this.pluginMenu.show(this.button.button.node);			
		},
		
		hidePluginMenu:function(){
			this.pluginMenuIsShown = false;
			this.pluginMenu.destroy();
		},
		
		/**
		 * the mainfunction, which capsule the pluginfunctionality
		 */
		startSubProcessing: function(selections){
			
			var SubProcessingCommandClass = ORYX.Core.Command.extend({
				construct: function(facade,selection,plugin){
					this.selectedShapes = selection;					
					this.selection = selection;
					this.facade = facade;	
					this.plugin = plugin;
					this.consideredShapes = this.getAllShapesToConsider(selections);
				},
				
				execute: function(){
					//var selection = this.facade.getSelection();
			        var selection = this.selectedShapes;
					if(selection.length == 0) return;
			        // proof for name
			        var name = this.getSingleCollapsedProcessName(selection);
			        var isValid = this.checkSelections(selection);
					if (!isValid){
						Ext.Msg.confirm(ORYX.I18N.Subprocessing.Attention,ORYX.I18N.Subprocessing.AttentionDesc ,function(btn){
							if (btn == "yes"){
								var window = this.getWindowForSubprocessing(selection,name);
								window.show();
							}
						}.bind(this)).setIcon(Ext.MessageBox.WARNING);						
					}
					else{
						var window = this.getWindowForSubprocessing(selection,name);
						window.show();
					}
				},
								
				/**
				 * During a rollback, the function restore the Nodes which are not attached
				 */
				restoreNotAttachedNodes: function(){				
					var nodes = this.shapesToAdd.nodes;
					nodes.each(function(node){
						if (node.isAttached == false){
							var parent = this.facade.getCanvas().getChildShapeByResourceId(node.parent) || this.facade.getCanvas();
							parent.add(node.node);
						}
					}.bind(this));
				},
				
				/**
				 * During a rollback, the function restore the Nodes which are attached
				 */
				restoreAttachedNotes: function(){
					var nodes = this.shapesToAdd.nodes;
					nodes.each(function(node){
						if (node.isAttached == true){
							var parent = this.facade.getCanvas().getChildShapeByResourceId(node.parent) || this.facade.getCanvas();
							parent.add(node.node);
							var dockedShape = this.facade.getCanvas().getChildShapeByResourceId(node.dockerShape);
							if (dockedShape){
								node.node.getDockers().first().setDockedShape(dockedShape);
								node.node.getDockers().first().setReferencePoint(node.refPoint);	
							}
						}
					}.bind(this));
				},
				/**
				 * During a rollback, the function restore the Edges, which are deleted from the "old" model
				 */
				restoreDeletedEdges: function(){
					var edges = this.shapesToAdd.edges;
					edges.each(function(edge){
						var canvas = this.facade.getCanvas();
						var dockers = edge.edge.getDockers();
						canvas.add(edge.edge);
						if (edge.hasFirstDockedShape){
							var source = canvas.getChildShapeByResourceId(edge.source);
							if (dockers.first()){
								dockers.first().setDockedShape(source);
								dockers.first().setReferencePoint(edge.sourceRefPoint);
							};	
						}
						if (edge.hasLastDockedShape){
							var target = canvas.getChildShapeByResourceId(edge.target);
							if (dockers.last()){
								dockers.last().setDockedShape(target);
								dockers.last().setReferencePoint(edge.targetRefPoint);
							};	
						}												
					}.bind(this));	
				},
				/**
				 * During a rollback, the function restore the Edges, which are nit deleted from the "old" model, but
				 * the target or the source of these edges were set new, now they have to get the old targets/sources
				 */
				restoreTargetSourceEdges: function(){
					var noSourceEdges = this.otherEdges.noSourceEdges;
					noSourceEdges.each(function(sEdge){
						var edge = this.facade.getCanvas().getChildShapeByResourceId(sEdge.edge);
						var sourceShape = this.facade.getCanvas().getChildShapeByResourceId(sEdge.source);
						if (edge && sourceShape){
							edge.getDockers().last().setDockedShape(sourceShape);
							edge.getDockers().last().setReferencePoint(sEdge.refPoint);
						}
					}.bind(this));
					var noTargetEdges = this.otherEdges.noTargetEdges;
					noTargetEdges.each(function(tEdge){
						var edge = this.facade.getCanvas().getChildShapeByResourceId(tEdge.edge);
						var targetShape = this.facade.getCanvas().getChildShapeByResourceId(tEdge.target);
						if (edge && targetShape){
							edge.getDockers().first().setDockedShape(targetShape);
							edge.getDockers().first().setReferencePoint(tEdge.refPoint);
						}
					}.bind(this));				
				},
				
				/**
				 *   During a rollback, the function restore edges, which are deleted, because there were edges
				 *   with the same target and source, now they have to restore and get their old target/source
				 */				
				restoreDeletedMultipleEdges: function(){
					this.deletedEdges.each(function(edge){
						var canvas = this.facade.getCanvas();
						var source = canvas.getChildShapeByResourceId(edge.source);
						var target = canvas.getChildShapeByResourceId(edge.target);
						var dockers = edge.edge.getDockers();
						canvas.add(edge.edge);
						if (dockers.first()){
							dockers.first().setDockedShape(source);
							dockers.first().setReferencePoint(edge.sourceRefPoint);
						};						
						if (dockers.last()){
							dockers.last().setDockedShape(target);
							dockers.last().setReferencePoint(edge.targetRefPoint);
						};
					}.bind(this));
				},
				
				/**
				 * During a rollback, the function restore edges, which get a new layout during subprocessing
				 * Now they have to get their old Layout
				 */
				restoreLayoutedEdges: function(){
					this.layoutedEdgs.each(function(edge){
						var canvas = this.facade.getCanvas();
						var source = canvas.getChildShapeByResourceId(edge.source);
						var target = canvas.getChildShapeByResourceId(edge.target);
						var lEdge =  canvas.getChildShapeByResourceId(edge.id);
						var dockers = lEdge.getDockers();							
						if (dockers.first()){
							dockers.first().setDockedShape(source);
							dockers.first().setReferencePoint(edge.sourceRefPoint);
						};						
						if (dockers.last()){
							dockers.last().setDockedShape(target);
							dockers.last().setReferencePoint(edge.targetRefPoint);
						};
						// delete new bendPoints and add the old bendPoints
						var bendPoints = lEdge.dockers.findAll(function(docker){return !docker.isDocked();});
						bendPoints.each(function(docker){
							lEdge.removeDocker(docker);
						});
						// add old dockers
						edge.bendPoints.each(function(docker){
							lEdge.add(docker);
						});
					}.bind(this));
				},
				/**
				 * During a rollback, the function restore the single subprocess, if it is necessary
				 */
				restoreSubprocessTask: function(){
					var parent = this.facade.getCanvas().getChildShapeByResourceId(this.openedSubprocessParent) || this.facade.getCanvas();
					parent.add(this.openedSubprocess);
					// restore the attached events for that							
					if (this.attachedEvents){
					this.attachedEvents.each(function(attachedEvent){
							this.openedSubprocess.add(attachedEvent.shape);
							attachedEvent.shape.getDockers().first().setDockedShape(this.openedSubprocess);
							attachedEvent.shape.getDockers().first().setReferencePoint(attachedEvent.refPoint);
						}.bind(this));	
					}
				},
				
				rollback: function(){
					var des = new Ext.Template(ORYX.I18N.Subprocessing.Rollback).apply([this.subprocessName]);
					Ext.Msg.alert('Information', des ,function(){
						// delete shapes, which were not in the old model, like the created collapsed subprocess
						this.deleteShapes(this.shapesToDelete);					
						// If an opened process has been deleted, restore these first
						if (this.openedSubprocessWasDeleted){
							this.restoreSubprocessTask();
						}
						// restore all old nodes
						// at first which are not attached
						this.restoreNotAttachedNodes();
						// resore nodes which are attached
						this.restoreAttachedNotes();
						// restore all old edges
						this.restoreDeletedEdges();
						// set the target and the source to the old edges
						this.restoreTargetSourceEdges();
						// restore deleted Edges
						this.restoreDeletedMultipleEdges();						
						// edges, which were layouted, restore to the old layout
						this.restoreLayoutedEdges();
						this.facade.getCanvas().update();
						// select the restored shapes
						this.facade.setSelection(this.selectedShapes);
					}.bind(this)).setIcon(Ext.MessageBox.INFO);
				},
				
				/**
				 * Proof, whether the selection contains only on shape and this shape is a Subprocess
				 * If there is only subprocess, the name is returning
				 */
				getSingleCollapsedProcessName: function(selections){
					var shapeCount = 0;
			    	var subprocess = {};
			    	var topLevelShapes = this.getAllShapesToConsider(selections);
			    	topLevelShapes.each(function(shape){
			    		if (shape instanceof ORYX.Core.Node && shape.getDockers().length == 0){
			    			subprocess = shape;
			    			shapeCount++;
			    		}
			    	});			    	
			    	if (shapeCount == 1 && subprocess.getStencil().id().endsWith("Subprocess")){
			    		return subprocess.properties["oryx-name"];
			    	}					
					return undefined;
				},
				
				/**
				 * Create and returns the UI-window for the interaction with the human
				 */
				getWindowForSubprocessing: function(selections,name){
										
					var textbox = new Ext.form.TextField({				
					    width:  175,
					    style: 'font-size:11px',
					    value:	(name !== undefined && name.trim() !== "") ? name : ORYX.I18N.Subprocessing.NewSubprocess
					});

					var label = new Ext.form.TextField({
					    value: ORYX.I18N.Subprocessing.NewNameSubprocess,   
					    style: 'background:transparent;opacity:1.0;width:100%;border:none;font-size:11px',
					    readOnly: true,
					    border:false
					});


					var panel = new Ext.Panel({   
					    layout:'column',
					    html: '<div style="padding-left: 12px; padding-right: 12px;padding-top:8px;padding-bottom:8px;" >' + ORYX.I18N.Subprocessing.Description + '</div>',					    
					    bodyStyle :'background:none;border:none',					  
					    items: [{        
					        width: 165,
					        items: [label],
					        bodyStyle: 'padding-top:10px;padding-left:8px;background:none;',
					        border:false
					        
					    },{    
					        items: [textbox],
					        bodyStyle: 'padding-top:10px;background:none;',
					        border:false
					      
					    }]
					});

					var checkboxNewTab = new Ext.form.Checkbox({
					    boxLabel: ORYX.I18N.Subprocessing.OpenSubprocess   
					});


					var checkboxPanel1 = new Ext.Panel({
					   //layout: 'anchor',
					   items: [checkboxNewTab],
					   bodyStyle: 'padding-top:10px;padding-left:12px;padding-bottom:10px',
					   border: false  
					});

					var win = new Ext.Window({
						width:	370,
					    modal: true,
					    layout: 'anchor',			   
					    title: ORYX.I18N.Subprocessing.AutomaticSubprocess,
					    items:[panel,checkboxPanel1],
					    resizable:false,
					    bodyStyle: 'background-color:white',
					    buttons: [
					      {
						    text: ORYX.I18N.Subprocessing.CreateSubprocess,
						    handler: function(button){						    	
						    	var name = textbox.getValue();
						    	if (name == undefined || name.trim()==""){
						    		name = ORYX.I18N.Subprocessing.NewSubprocess;
						    	}
						    	var showNewTab = checkboxNewTab.getValue();				    				    					    	
						    	this.subprocessName = name;
						    	win.body.mask(ORYX.I18N.Subprocessing.SubprocessCreated, "x-waiting-box");
						    	this.doSubprocessing(selections,name,showNewTab);
						    	win.body.unmask();
						    	win.close();	
						    	
						    }.bind(this)},
						  {
						    text: ORYX.I18N.Subprocessing.Cancel,
						    handler: function(button){
						    	win.close();}.bind(this)}
					]
					});	
					return win;
				},
				/**
				 * Check the selected Elements for mistakes
				 * Different Patterns describe semantic-mistakes
				 * return true, if the selection is valid
				 */
				checkSelections: function(selection){
					// proof cases, which maybe edit the semantic of the modell
					var topLevelShapes = this.consideredShapes.findAll(function(shape){return shape instanceof ORYX.Core.Node});
					var allSelections = [];
					selection.each(function(shape){
			    		if (shape instanceof ORYX.Core.Node){
			    			allSelections = allSelections.concat(shape.getChildShapes(true));
			    			allSelections.push(shape);
			    		}
			    	});
					var sequensflows = this.getAdditionalEdges(topLevelShapes);
					var incomingFlows = sequensflows.noSourceEdges;
					var outgoingFlows = sequensflows.noTargetEdges;
					
					// 1.Case: proof whether there are more as 2 incoming flows 
					if (incomingFlows.length > 1) return false;
					// 2.Case: proof whether there are more as 2 outgoing flows 
					if (outgoingFlows.length > 1) return false;		
					// 3.Case: If there is one, and only one, incoming flow, then all selected shapes have to have at least one incoming flow
					if (incomingFlows.length == 1){						
						var invalid = false;
						topLevelShapes.each(function(shape){
							if (shape.incoming.length < 1){ 
								invalid = true; 
								throw $break;}
						});
						if (invalid == true) {return false};
					}
					// 4.Case: If there is one, and only one, outgoing flow, then all selected shapes have to have at least one outgoing flow
					if (outgoingFlows.length == 1){				
						var invalid = false;
						topLevelShapes.each(function(shape){
							if (shape.outgoing.length < 1){ 
								invalid = true; 
								throw $break;}
						});
						if (invalid == true) {return false};
					}
					// 5.Case : all selected shapes have to has the same pool or all shapes are on the canvas
					var poolName = "";
					var invalid = false;
					topLevelShapes.each(function(shape){
						var parent = this.findParentPool(shape);
						if (poolName == ""){
							poolName = parent;
						}else {
							if (poolName != parent){
								invalid = true; 
								throw $break;
							}
						}						
					}.bind(this));
					if (invalid == true) {return false};
					// 6.Case and 7.Case, there are no pools or lanes selected
					var invalid = false;
					allSelections.each(function(shape){
						var id = shape.getStencil().id().split("#")[1];
						if (id == "Pool" || id == "Lane" || id == "VerticalPool" || id == "VerticalLane"){
							invalid = true;
							throw $break;
						}
					});
					if (invalid == true) {return false};
					// if there is no case occured, the selection is valid
					return true;
				},
				
				/**
				 * Proof, whether there is a one and only one pool where all shapes located
				 * default the function return the canvas
				 */
				findParentPool: function(shape){
					// find the parent pool for the shape or return the canvas, if there is no parentpool
					if (shape.parent){
						var parent = shape.parent;
						while (parent && !(parent instanceof ORYX.Core.Canvas)){
							if (parent.getStencil().id().endsWith("Pool")){
								return parent.resourceId;
							}
							parent = parent.parent;
						}
						return parent.resourceId;
					}
				},
				/**
				 * Save edges for rollback, which have a new target or source to the new collapsed task
				 */
				saveOtherEdges: function(otherEdges){
					var noTargetEdges = otherEdges.noTargetEdges;
					var noSourceEdges = otherEdges.noSourceEdges;
				 	this.otherEdges = {};
				 	this.otherEdges.noSourceEdges =[];
				 	noSourceEdges.each(function(edge){
				 		var se = {};
				 		se.source = edge.getDockers().last().getDockedShape().resourceId;
				 		se.edge = edge.resourceId;
				 		se.refPoint = edge.getDockers().last().referencePoint;
				 		this.otherEdges.noSourceEdges.push(se);
				 	}.bind(this));
				 	this.otherEdges.noTargetEdges =[];
				 	noTargetEdges.each(function(edge){
				 		var te = {};
				 		te.target = edge.getDockers().first().getDockedShape().resourceId;
				 		te.edge = edge.resourceId;
				 		te.refPoint = edge.getDockers().first().referencePoint;
				 		this.otherEdges.noTargetEdges.push(te);
				 	}.bind(this));
				},
				/**
				 * Save shapes, which have to delete after a rollback (mostly the new collapsd subprocess and optional edges)
				 */
				saveShapesToDelete: function(shapes){
					this.shapesToDelete = [];
					this.shapesToDelete = this.shapesToDelete.concat(shapes);
				},
				
				/**
				 * Save the shapes, which had deleted after subprocessing, also the elements that copied to the new model
				 * After a rollback, they have to add to the old model, again
				 */				
				saveShapesToAdd: function(shapes){
					this.shapesToAdd = {};
					var nodes = shapes.findAll(function(shape){
						return shape instanceof ORYX.Core.Node;
					});
					var edges = shapes.findAll(function(shape){
						return shape instanceof ORYX.Core.Edge;
					});
					// save to every shape the parent
					this.shapesToAdd.nodes = [];
					nodes.each(function(node){
						var n = {};
						n.node = node;
						n.parent = node.parent.resourceId;
						if (node.getDockers().length==0 || (node.getDockers().length==1 && !node.getDockers().first().getDockedShape())){							
							n.isAttached = false;							
						}
						else // Attached Events
						{							
							n.isAttached = true;
							n.dockerShape = node.getDockers().first().getDockedShape().resourceId;	
							n.refPoint = node.getDockers().first().referencePoint;
						}
						this.shapesToAdd.nodes.push(n);
					}.bind(this));
					// save also attached Events
					this.shapesToAdd.attEvents = [];
					
					// save to every edge, the target and the source and with associated refernce points
					this.shapesToAdd.edges = [];					
					edges.each(function(edge){
						var e = {};
						e.edge = edge;						
						var firstDockerShape = edge.getDockers().first().getDockedShape();							
						e.hasFirstDockedShape = (firstDockerShape !== undefined);
						if ((firstDockerShape !== undefined)){
							e.source = edge.getDockers().first().getDockedShape().resourceId;
							e.sourceRefPoint = edge.getDockers().first().referencePoint;
						}						
						var lastDockerShape = edge.getDockers().last().getDockedShape();
						e.hasLastDockedShape = (lastDockerShape !== undefined);
						if (e.hasLastDockedShape){
							e.target = edge.getDockers().last().getDockedShape().resourceId;
							e.targetRefPoint = edge.getDockers().last().referencePoint;
						}						
						this.shapesToAdd.edges.push(e);
						
					}.bind(this));
				},
				
				/**
				 * Mainfunction for subprocessing: Separation of concerns
				 */				
				doSubprocessing: function(selections,subProcessName,showInNewTab){	
					
					// get Edges which are not selected, but they are important
					var edgesFromParent = this.getEdgesFromParent(this.consideredShapes);
					// get the ToplevelShapes
				    var topLevelShapes = this.consideredShapes;	
				    topLevelShapes = topLevelShapes.concat(edgesFromParent);
				    // get Addtitonal Edges
				    var addEdges = this.getAdditionalEdges(this.consideredShapes);
				    // delete edges, which have the same target and source
				    this.deleteDuplicateEdges(addEdges);	
				    // create an new Model with the shapes
				    topLevelShapes = topLevelShapes.concat(addEdges.goodEdges);
				    // delete all edges, which are not assiciated with the new diagram
				    topLevelShapes = this.deleteEdges(topLevelShapes, addEdges);		    
				    topLevelShapes = topLevelShapes.uniq();				   
				    // proof whether only one openend subprocess is selected
				    var erg = this.configureWhenOnlyOneSubProcess(topLevelShapes);
				    topLevelShapes = erg.shapes;				  
				    // create the model
				    var modelID = this.createNewModelWithShapes(topLevelShapes,subProcessName);
				    // show the new model, if it is nessary
				    if (showInNewTab){
				    	this.showNewModelInTab(modelID);
				    }
				    // create a new collapsedTask
				    var collShape = this.createCollapsedSubprocess(topLevelShapes,subProcessName,erg.status,erg.subprocessShape);
				    // only for rollback
				    this.saveShapesToDelete(collShape);
				    // set Link to the new process-diagram
				    var modelURL = window.location.protocol +"//"+ window.location.host + "/" + ORYX.CONFIG.SERVER_MODEL_HANDLER.replace("\.\./", "") + "/" + modelID;
				    collShape.setProperty("oryx-entry",modelURL);
				    // only for rollback
				    this.saveOtherEdges(addEdges);				
					var layoutEdges = addEdges.noSourceEdges.concat(addEdges.noTargetEdges);
				    this.saveLayoutedEdges(layoutEdges);
					// connect the edges to the new shape
					this.setOldEdges(collShape,addEdges,erg.existsAttachedEvents);				   			    
				    // only for rollback
				    this.saveShapesToAdd(topLevelShapes);
				    // only for rollback
				    if (erg.existsAttachedEvents){
				    	this.saveAttachedEvents(erg.attachedEvents);
				    }
				    // delete the "old" selection
				    this.deleteShapes(topLevelShapes);				    
				    if (erg.status){
				    	this.openedSubprocessWasDeleted = true;
				    	this.openedSubprocessParent = erg.subprocessShape.parent.resourceId;
				    	this.openedSubprocess = erg.subprocessShape;
				    	this.deleteShapes([erg.subprocessShape]);
				    	// if there are attached events, added to the new shape
				    	if (erg.existsAttachedEvents){
				    		this.setAttachedEvens(erg,collShape);
				    	}
				    } 			   
				    // layout the edges, which are connected to the new shape			    
				    this.plugin.doLayout(layoutEdges);
				    this.facade.getCanvas().update();
				    this.facade.setSelection(collShape);
				    this.facade.updateSelection();
				},
				/**
				 * This function, add attached Events to the new collapsed task, if there were attached Events
				 */
				setAttachedEvens: function(erg,collapsedSubprocess){
					erg.attachedEvents.each(function(att){
		    			//this.facade.deleteShape(att.shape);
						collapsedSubprocess.add(att.shape);
		    			att.shape.getDockers().first().setDockedShape(collapsedSubprocess);
		    			// compute new reference point				    			
		    			var newW = (collapsedSubprocess.bounds.width()*att.refPoint.x) / erg.subprocessShape.bounds.width();
		    			var newH = (collapsedSubprocess.bounds.height()*att.refPoint.y) / erg.subprocessShape.bounds.height();
		    			att.shape.getDockers().first().setReferencePoint({x:newW,y:newH});			    			
		    		});
				},
				/**
				 * Save attached events from the subprocess to restore their later by rollback
				 */
				saveAttachedEvents: function(attachedEvents){
					this.attachedEvents = [].concat(attachedEvents);							
				},
				
				/**
				 * configure shapes, if there is only one subprocess, then the parent subprocess will be deleted in the new model
				 */
				configureWhenOnlyOneSubProcess: function(shapes){	
			    	var shapeCount = 0;
			    	var subprocess = {};
			    	shapes.each(function(shape){
			    		if (shape instanceof ORYX.Core.Node && shape.getDockers().length == 0){
			    			subprocess = shape;
			    			shapeCount++;
			    		}
			    	});	    	
			    	var attachedEvents = [];
			    	if (shapeCount == 1 && subprocess.getStencil().id().endsWith("Subprocess")){
			    		var childNodes = subprocess.getChildShapes(true);
			    		shapes = shapes.without(subprocess);
			    		shapes = [].concat(shapes, childNodes);
			    		shapes = this.getAllShapesToConsider(shapes);
			    		// prüfen ob angeh?ngte ereignse angeheftet sind
			    		var att = subprocess.outgoing.findAll(function(shape){return (shape instanceof ORYX.Core.Node && shape.getDockers().length == 1)});			    		
			    		att.each(function(at){
			    			var attachedEvent = {};
			    			attachedEvent.shape = at;
			    			attachedEvent.parent = at.getDockers().first().getDockedShape().resourceId;
			    			attachedEvent.refPoint = at.getDockers().first().referencePoint;
			    			attachedEvents.push(attachedEvent);
			    			shapes.remove(at);			    			
			    		});
			    	};
			    	
			    	return {
			    		status					: (shapeCount == 1 && subprocess.getStencil().id().endsWith("Subprocess")),
			    		subprocessShape			: subprocess,
			    		shapes					: shapes,
			    		attachedEvents			: attachedEvents,
			    		existsAttachedEvents	: (attachedEvents.length !== 0)
			    	};
			    },	
				
			    /**
			     * save edges for rollback, which are layouted afer subprocessing
			     */
				saveLayoutedEdges: function(layoutEdges){
					this.layoutedEdgs = [];
				    layoutEdges.each(function(edge){
				    	 var l = {};
				    	 l.id = edge.resourceId;
				    	 l.target = edge.dockers.last().getDockedShape().resourceId;
				    	 l.targetRefPoint = edge.dockers.last().referencePoint;
				    	 l.source = edge.dockers.first().getDockedShape().resourceId;
				    	 l.sourceRefPoint = edge.dockers.first().referencePoint;
				    	 l.bendPoints = edge.dockers.findAll(function(docker){return !docker.isDocked();});
				    	 this.layoutedEdgs.push(l);
				    }.bind(this));
				},
							
				doRequest: function(url, callback, params, method){
					Request.execute(url, callback, params, method)
				},	
				
				shapesToJson: function(shapes){
					var json = shapes.map(function(stencil){
						return stencil.toJSON();
					});
					
					// Get all resource ids
					var resourceIds = shapes.map(function(r){ return [].concat(r, r.getChildShapes(true)).pluck("resourceId") }).flatten();
					
					// Remove those outgoings which refer to a resource 
					// id which is not in the list of ids.
					var removeOutgoings = function(shs){
						(shs||[]).each(function(sh){
							if (sh.outgoing){
								sh.outgoing = sh.outgoing.findAll(function(out){
									return resourceIds.include(out.resourceId);
								});
							}
							if (sh.childShapes){
								removeOutgoings(sh.childShapes);
							}
						});
					};
					removeOutgoings(json);
					
					return json;
				},
								
				deleteShapes:function(shapes){
					if (shapes){
						shapes.each(function(shape){
							 this.facade.deleteShape(shape);
						}.bind(this));
					}
				},
				
				/**
				 * compute the middle point of a shape
				 */
				getCentralPointForShape: function(pointA,pointB){
					var x = (pointA.x+pointB.x) /2;
					var y = (pointA.y+pointB.y)/2;
					var point = {};
					point.x = x;
					point.y = y;		
					return point;
				},
				
				/**
				 * compute the new coords for the new collapsed subprocess
				 */
				getCentralPointForShapes: function(shapes){
					var maxY = -1;
					var maxX = -1;
					var minY = Number.MAX_VALUE;
					var minX = Number.MAX_VALUE;
					
					shapes.each(function(shape){						
						var midPoint = shape.absoluteCenterXY();
						if (maxY<midPoint.y) {maxY = midPoint.y };
						if (maxX<midPoint.x) {maxX = midPoint.x };
						if (minY>midPoint.y) {minY = midPoint.y };
						if (minX>midPoint.x) {minX = midPoint.x };
					});
					var minPoint = {};
					minPoint.x = minX; minPoint.y = minY;
					var maxPoint = {};
					maxPoint.x = maxX; maxPoint.y = maxY;
					return  this.getCentralPointForShape(minPoint, maxPoint);
				},
				
				/**
				 * get only the top-level-shapes of a set of shapes
				 */
				getAllShapesToConsider: function(shapes){
			        var shapesToConsider = [], oshapes = shapes; // only top-level shapes
			        var childShapesToConsider = []; // all child shapes of top-level shapes
			        var canvas = this.facade.getCanvas(), rules = this.facade.getRules();
			        
			        // Remove all parent shape which can not be child of the canvas
			        shapes = shapes.findAll(function(shape){
			            //Throw away these shapes which have a parent in given shapes
			            if (shapes.any(function(s2){
				                return s2.hasChildShape(shape);
				            })){
				            return true;
			            }
			            
			            return rules.canContain({
							containingShape: canvas,
							containedShape: shape
						});			            
			        });
			        
			        shapes.each(function(shape){
			            //Throw away these shapes which have a parent in given shapes
			            var isChildShapeOfAnother = shapes.any(function(s2){
			                return s2.hasChildShape(shape);
			            });
						/*
						 * since deleting the parent of a shape no longer
						 * means that all child shapes are deleted as
						 * well, we have to consider them for deletion
						 */
			            if(isChildShapeOfAnother) return;
			            
			            // This shape should be considered
			            shapesToConsider.push(shape);
			            // Consider attached nodes (e.g. intermediate events)
			            if (shape instanceof ORYX.Core.Node) {
							var attached = shape.getOutgoingNodes();
							attached = attached.findAll(function(a){ return !shapes.include(a) });
			                shapesToConsider = shapesToConsider.concat(attached);
			            }
			            
						// Append all shapes which doesnt fit to any parent
			            /*shapesToConsider = [].concat(shapesToConsider, shape.getChildShapes(false).findAll(function(cshape){
							var dc = ORYX.Plugins.Edit.DeleteCommand.prototype;
							return !dc.findParent.call({facade:this.facade, findParent:dc.findParent}, cshape, shape.parent) && !shapesToConsider.include(cshape);
						}.bind(this)));*/
			        }.bind(this));
			        
			        // All edges between considered child shapes should be considered
			        // Look for these edges having incoming and outgoing in childShapesToConsider
			        var edgesToConsider = this.facade.getCanvas().getChildEdges().select(function(edge){
			            // Ignore if already added
			            if(shapesToConsider.include(edge)) return false;
			            // Add if already is in the list of shapes
			            if(oshapes.include(edge)) return true;
			            // Ignore if there are no docked shapes
			            if(edge.getAllDockedShapes().size() === 0) return false; 
			            // True if all docked shapes are in considered child shapes
			            return edge.getAllDockedShapes().all(function(shape){
			                // Remember: Edges can have other edges on outgoing, that is why edges must not be included in childShapesToConsider
			                //return shape instanceof ORYX.Core.Edge || childShapesToConsider.include(shape);
							// Edges will only be removed if manually selected
							// or if the target or the source no longer exist
							return false;
			            });
			        });
			        shapesToConsider = [].concat(shapesToConsider, edgesToConsider).uniq();        
			        return shapesToConsider;
			    },	 
			    
			    /**
			     * Get Edges, which will have a new target/source after subprocessing 
			     * for example, if an edge is not copy to the new model, then the source/target of this edge is the new collapsed subprocess
			     */
			    getAdditionalEdges: function(shapes){			    	
			    	
			    	var edges = [];			
			    	var nodes = [];
			    	// segement the shapes into edges and nodes
			    	shapes.each(function(shape){			    	
			    		if (shape instanceof ORYX.Core.Edge){
			    			edges.push(shape.resourceId);
			    		}
			    		else{
			    			nodes.push(shape.resourceId);
			    			shape.incoming.each(function(inEdge){
				    		  if (inEdge instanceof ORYX.Core.Edge){
			    				edges.push(inEdge.resourceId);}
				    		});
				    		// ausgehende kanten
				    		shape.outgoing.each(function(outEdge){
				    		  if (outEdge instanceof ORYX.Core.Edge){
				    			edges.push(outEdge.resourceId);}
				    		});
			    		}
			    	}.bind(this));   
			    	edges = edges.uniq();
			    	nodes = nodes.uniq();
			    	// find edges, which have no targetshape, no sourceshape or both in selection
			    	var noSourceEdges = [];
			       	var noTargetEdges = [];
			       	var noTargetNoSourceEdges = [];
			       	var goodEdges = [];
			    	var hasTargets,hasSources = false;			    	
			    	var fristDockerShape,dockers,lastDockerShape,dEdge,firstDockerShapeId,lastDockerShapeId = {}; 
			       	edges.each(function(edge) {
			    		dEdge = this.facade.getCanvas().getChildShapeByResourceId(edge);
			    		hasTargets = false;
			    		hasSources = false;			    	
			    		dockers = dEdge.getDockers();
			    		firstDockerShape = dockers.first().getDockedShape();
			    		lastDockerShape = dockers.last().getDockedShape();
			    		if (firstDockerShape){
			    			firstDockerShapeId = dockers.first().getDockedShape().resourceId;
			    			if (firstDockerShapeId && nodes.indexOf(firstDockerShapeId) > -1){
				    			hasSources = true;
				    		}
			    		}
			    		else{
			    			hasSources = true;
			    		}
			    		
			    		if (lastDockerShape){
			    			lastDockerShapeId = dockers.last().getDockedShape().resourceId;
			    			if (lastDockerShapeId && nodes.indexOf(lastDockerShapeId) > -1){
				    			hasTargets = true;
				    		} 
			    		}
			    		else{
			    			hasTargets = true;
			    		}		    		
			    		
			    		if (hasSources === true && hasTargets === true) {
			    			goodEdges.push(dEdge);
			    			return;
			    		}
			    		if (hasSources==false && hasTargets==true){
			    			noSourceEdges.push(dEdge);
			    			return; 
			    		}
			    		if (hasSources==true && hasTargets==false){
			    			noTargetEdges.push(dEdge);
			    			return;
			    		}
			    		noTargetNoSourceEdges.push(dEdge);
			    		
			    	}.bind(this));
			    	var edgesResult = {};
			       	edgesResult.goodEdges = goodEdges.uniq();
			    	edgesResult.noSourceEdges = noSourceEdges.uniq();
			    	edgesResult.noTargetEdges =noTargetEdges.uniq();
			    	edgesResult.noTargetNoSourceEdges = noTargetNoSourceEdges.uniq();
			    	return edgesResult;
			    },
			    
			    deleteEdges: function(selections,addEdges){
			    	addEdges.noSourceEdges.each(function(edge){
			    		selections.remove(edge)	    		    		
			    	})
			    	addEdges.noTargetEdges.each(function(edge){
			    		selections.remove(edge)	    		    		
			    	})
			    	addEdges.noTargetNoSourceEdges.each(function(edge){
			    		selections.remove(edge)	    		    		
			    	})
			    	return selections;
			    },
			    /**
			     * Find edges which have the same target AND the same source, if there are edges, delete them
			     * 
			     */
			    deleteDuplicateEdges: function(edges){			     
			    	this.deletedEdges = [];
			    	$H(edges).each(function(val){
			    		var edgesList = val.value;
				    	for (var i = 0; i < edgesList.length;i++){
				    		var delList = [];
				    		for (var j = 0; j < edgesList.length;j++){
				    			if (i !== j){				    		
				    				if (val.key=="noSourceEdges"){				    			
					    				var dockerE1 = edgesList[i].dockers.first().getDockedShape().resourceId;
					    				var dockerE2 = edgesList[j].dockers.first().getDockedShape().resourceId;
					    				if (dockerE1 && dockerE2 && (dockerE1 == dockerE2)){
					    					delList.push(edgesList[j]);
					    				}
				    				}
				    				if (val.key=="noTargetEdges"){				    		
					    				var dockerE1 = edgesList[i].dockers.last().getDockedShape().resourceId;
					    				var dockerE2 = edgesList[j].dockers.last().getDockedShape().resourceId;
					    				if (dockerE1 && dockerE2 && (dockerE1 == dockerE2)){
					    					delList.push(edgesList[j]);
					    				}
				    				} 				    				
				    			}
				    		}
				    		edgesList = this.saveAndDeleteEdgesList(delList,edgesList);				    			    		
				    	}
				   }.bind(this));
			       return edges;			    
			    },
			    /**
			     * This function save the edges for rollback and deleted from the old model
			     */
			    saveAndDeleteEdgesList: function(delList,edgesList){
			    	delList.each(function(edge){
		    			edgesList.remove(edge);		    		
		    			var d = {};
		    			d.source = edge.dockers.first().getDockedShape().resourceId;
		    			d.target = edge.dockers.last().getDockedShape().resourceId;
		    			d.sourceRefPoint = edge.dockers.first().referencePoint;
		    			d.targetRefPoint = edge.dockers.last().referencePoint;
		    			d.edge = edge;
		    			this.deletedEdges.push(d);		    
		    			this.facade.deleteShape(edge);		    			
		    		}.bind(this));	
			    	return edgesList;
			    },
			  		    
			    /**
			     * Get all edges, which are not selected, but important for the model
			     * for example, edges which are between two selected shapes
			     */
			    getEdgesFromParent:function(selections){			
			    	var topLevelShapes = selections;			
			    	var allNodesFromParents = [];
			    	topLevelShapes.each(function(shape){
			    		if (shape instanceof ORYX.Core.Node){
			    			allNodesFromParents = allNodesFromParents.concat(shape.getChildShapes(true));
			    		}
			    	});
			    	allNodesFromParents = allNodesFromParents.concat(topLevelShapes).uniq();
			    	
			    	// alle parent durchsuchen, ob sie attached-Events haben
			    	var attachedEvents = [];
			    	topLevelShapes.each(function(shape){
			    		if (shape instanceof ORYX.Core.Node){
			    			var atts = shape.outgoing.findAll(function(out){return (out instanceof ORYX.Core.Node)});
							atts.each(function(a){
								attachedEvents.push(a);
							});	
			    		}
			    	});
			    	attachedEvents = attachedEvents.uniq();
			    	allNodesFromParents = allNodesFromParents.concat(attachedEvents);
			    	
			    	var allEdges = this.facade.getCanvas().getChildEdges();
			     	var additionalEdges = [];
			     	allEdges.each(function(edge){			  
			     		if (edge instanceof ORYX.Core.Edge){
			     			var dockerAShape = edge.dockers.first().getDockedShape();
		    				var dockerEShape = edge.dockers.last().getDockedShape();
		    				if (dockerAShape && dockerEShape && allNodesFromParents.include(dockerAShape) && allNodesFromParents.include(dockerEShape)){
		    					additionalEdges.push(edge);
		    				}    					
			     		}
			     	});
			    	return additionalEdges;	    	
			    },		    
			    		
				/**
				 * If there are edges which have a new source/target to the new collapsed subprocess
				 * then set the target/source to new collapsed subprocess
				 */
				setOldEdges: function(collapsedSubProcess, oldEdges,existsAttachedEvents){
					oldEdges.noSourceEdges.each(function(edge){				
						if (!existsAttachedEvents){
							edge.getDockers().last().setDockedShape(collapsedSubProcess);
							edge.getDockers().last().setReferencePoint(collapsedSubProcess.bounds.midPoint());
						}
						else{
							if (edge.getDockers().last().getDockedShape().getDockers().length !==1){
								edge.getDockers().last().setDockedShape(collapsedSubProcess);
								edge.getDockers().last().setReferencePoint(collapsedSubProcess.bounds.midPoint());
							}
						}
					});	
					oldEdges.noTargetEdges.each(function(edge){
						if (!existsAttachedEvents){
							edge.getDockers().first().setDockedShape(collapsedSubProcess);
							edge.getDockers().first().setReferencePoint(collapsedSubProcess.bounds.midPoint());
						}
						else{
							if (edge.getDockers().first().getDockedShape().getDockers().length !==1){
								edge.getDockers().first().setDockedShape(collapsedSubProcess);
								edge.getDockers().first().setReferencePoint(collapsedSubProcess.bounds.midPoint());
							}
						}
					});				
				},
				/**
				 * Find a parent, if it is possible, which is the parent for all shapes
				 */
				findUniqueParent: function(shapes){	
					var topLevelShapes = this.getAllShapesToConsider(shapes);
					var parentID = "FoundNoParent";
					var foundParent = true;
					var parent = undefined;
					topLevelShapes.each(function(shape){						
						if (shape.parent) {
							if (parentID == "FoundNoParent") {
								parentID = shape.parent.resourceId
								parent = shape.parent;
							} else {
								if (shape.parent.resourceId != parentID) {
									foundParent = false;
								}
							}
						}
					});
					if (parentID == "FoundNoParent" || foundParent==false){
						return this.facade.getCanvas();
					}else{
						return parent;
					}
				},
				/**
				 * Compute the distance between a shape and its parent
				 */
				getParentsDiff: function(shape){
					var parent = shape.parent;
					var diffX = 0;
					var diffY = 0;
					while (parent && !(parent instanceof ORYX.Core.Canvas)){
						var p = parent.bounds.a;
						diffX+= p.x;
						diffY+= p.y;
						parent = parent.parent;
					}
					var diff = {};
					diff.x = diffX;
					diff.y = diffY;
					return diff;
				},
				
				/**
				 * Returns a shape which are allowed to 
				 * be a parent of the given stencil type
				 * @param type
				 * @param middPointOfAll
				 * @param shapes
				 * @param originParent
				 * @returns
				 */
				getAllowedParent: function(type, middPointOfAll, shapes, originParent){
					
					var availableParents = [].concat(
								this.facade.getCanvas().getAbstractShapesAtPosition(middPointOfAll).reverse().findAll(function(r){ return r instanceof ORYX.Core.Node && !shapes.any(function(s){ return r.isParent(s); }); }),
								this.facade.getCanvas(),
								this.findUniqueParent(shapes))
							.uniq().compact();
					
					if (originParent){
						availableParents.push(originParent);
					}
					
					var namespace  = this.facade.getCanvas().getStencil().namespace(),
						stencilset = this.facade.getStencilSets()[namespace],
						stencil    = stencilset.stencil(namespace+""+type);
					
					for(var i = 0, size = availableParents.length; i < size; ++i){
						if (this.facade.getRules().canContain({
									containingShape: availableParents[i],
									containedStencil: stencil
								})){
							return availableParents[i];
						}
					}
					
					return undefined;
				},
				/**
				 * Create a new collapsed subprocess-shape
				 */
				createCollapsedSubprocess: function(shapes,subProcessName,isSingleSubprocess,singleSubprocessShape){
						
					//create the new Shape					
					var typeOfNewTask = "CollapsedSubprocess";
					// set the position
					// at first, we have to comput the middlepoint of the selections
					var middPointOfAll = this.getCentralPointForShapes(shapes);
					
					// Get parent
					var parent;			
					if (isSingleSubprocess){
						if (singleSubprocessShape && singleSubprocessShape.getStencil().id().endsWith("EventSubprocess")){
							typeOfNewTask = "CollapsedEventSubprocess";
						}
						if (singleSubprocessShape){
							parent = this.getAllowedParent(typeOfNewTask, middPointOfAll, [].concat(shapes, singleSubprocessShape), singleSubprocessShape.parent);
						}
					}
					if (!parent){
						 parent = this.getAllowedParent(typeOfNewTask, middPointOfAll, shapes);	
					}
					
					if (!parent){
						return undefined;
					}

					var option = {
							type		:this.facade.getCanvas().getStencil().namespace() + typeOfNewTask,					
							namespace	:this.facade.getCanvas().getStencil().namespace(),
							parent		:parent
					};						
					var shape = this.facade.createShape(option);
					// then we have to differentiate the parentsbounds
					var parentsDiff = this.getParentsDiff(shape);			
					shape.bounds.centerMoveTo({x:middPointOfAll.x-parentsDiff.x,y:middPointOfAll.y-parentsDiff.y});
					//shape.setHiddenProperty("absoluteCenterXY",{x:middPointOfAll.x,y:middPointOfAll.y});
				
					shape.setProperty("oryx-name",subProcessName);			
					return shape;
				},
				/**
				 * Helperfunction to show the new model in a new browsertab/window
				 */
				showNewModelInTab: function(modelID){
					var modelURL = window.location.protocol +"//"+ window.location.host + "/" + ORYX.CONFIG.SERVER_MODEL_HANDLER.replace("\.\./", "") + "/" + modelID;
					window.setTimeout(function(){
						window.open(ORYX.CONFIG.SERVER_EDITOR_HANDLER + "?id=" + modelID)
					}, 100);
				},
				
				/**
				 *  Compute the distance of the shape which is closest to the offset-point
				 *  and then move all specified shapes to the new distance 
				 */
				moveShapesToTop: function(shapes){				
					var minX =Number.MAX_VALUE;
					var minY =Number.MAX_VALUE;
					// the offset
					var KOS = {x:50,y:50};
					shapes.each(function(shape){
						if (shape instanceof ORYX.Core.Node){
							var ul = shape.bounds.upperLeft();
							if (minX > ul.x) {minX = ul.x};
							if (minY > ul.y) {minY = ul.y};
						}
					});	
					if (minX < KOS.x) {minX = KOS.x};
					if (minY < KOS.y) {minY = KOS.y};
					
					minX = minX - KOS.x;
					minY = minY - KOS.y;
					
					shapes.each(function(shape){
						if (shape instanceof ORYX.Core.Node){
							if (shape.getDockers().length == 1){
								var c = shape.bounds.center();
								shape.getDockers().first().bounds.centerMoveTo({x:c.x-minX,y:c.y-minY});
							} else {
								var c = shape.bounds.center();
								shape.bounds.centerMoveTo({x:c.x-minX,y:c.y-minY});								
							}
						}
						if (shape instanceof ORYX.Core.Edge){
							var bendPoints = shape.dockers.findAll(function(docker){return !docker.isDocked();});
							bendPoints.each(function(point){
								var c = point.bounds.center();
								point.bounds.centerMoveTo({x:c.x-minX,y:c.y-minY});
							});
						}
					});					
					var erg = {};
					erg.shapes = shapes;
					erg.minY = minY;
					erg.minX = minX;
					return erg;
				},
				/**
				 * Move the shapes back, again
				 */
				moveShapesBack: function(shapes,minX,minY){
					shapes.each(function(shape){
						if (shape instanceof ORYX.Core.Node){
							var c = shape.bounds.center();
							shape.bounds.centerMoveTo({x:c.x+minX,y:c.y+minY});
						}
						if (shape instanceof ORYX.Core.Edge){
							var bendPoints = shape.dockers.findAll(function(docker){return !docker.isDocked();});
							bendPoints.each(function(point){
								var c = point.bounds.center();
								point.bounds.centerMoveTo({x:c.x+minX,y:c.y+minY});
							});
						}
					});
					return shapes;
				},
				
				/**
				 * Create a new modell with the specified shapes and modelname
				 * return the id of the created model
				 */
				createNewModelWithShapes: function(shapes,newModelName){					
					// set the toplevelshapes to the absolute bounds
					var oldBoundsCenter = [];
					shapes.each(function(shape){
						if (shape instanceof ORYX.Core.Node){
							var absCenter = shape.absoluteBounds().center();
							var oldCenter = shape.bounds.center();
							oldBoundsCenter.push(oldCenter);
							shape.bounds.centerMoveTo(absCenter);
						}
					});
						
					var erg = this.moveShapesToTop(shapes);
					shapes = erg.shapes;
					
					
					var stencilset 	= this.facade.getStencilSets()[this.facade.getCanvas().getStencil().namespace()];
					var parent 		= this.facade.getModelMetaData().parent;
					var extensions 	= this.facade.getModelMetaData().model.ssextensions || [];
					
					var url = ORYX.CONFIG.SERVER_EDITOR_CREATE_HANDLER + "?stencilset="+stencilset.namespace().replace(/#/g, "%23")+"&directory="+parent;
					var modelId;
					this.doRequest(url, function(c,a){
						modelId = a.getResponseHeader("Location").split("=").last();
					});
					
					var modelJson = {
						bounds:{
							upperLeft: {x:0, y:0}, 
							lowerRight: this.facade.getCanvas().bounds.lowerRight()
						},
						childShapes:this.shapesToJson(shapes),
						properties:{},
						resourceId: "canvas",
						ssextensions: extensions,
						stencil: {id: this.facade.getCanvas().getStencil().idWithoutNs()},
						stencilset: {
							url:stencilset._source,
							namespace:stencilset.namespace()
						}
					};
										
					var params 		= {};
					params.name 	= newModelName;
					params.parent 	= parent;
					params.json_xml = Object.toJSON(modelJson);	
					params.id 		= modelId;
					params.type 	= stencilset.title();
					params.description = "";
					params.comment 	= "";
					params.namespace= stencilset.namespace();
					// store the new Model
					this.doRequest(ORYX.CONFIG.SERVER_MODEL_HANDLER, function(){}, params, "post");		
		
					shapes = this.moveShapesBack(shapes,erg.minX,erg.minY);
					var index = 0;
					shapes.each(function(shape){
						if (shape instanceof ORYX.Core.Node){							
							shape.bounds.centerMoveTo(oldBoundsCenter[index]);
							index++;
						}
					});
					
					
					return modelId;
					
				}		
				
			})			
			var subProcessingCommand = new SubProcessingCommandClass(this.facade,selections,this);
	    	this.facade.executeCommands([subProcessingCommand]);
		}	
		
	});

}/**
 * Copyright (c) 2011 Signavio
 * @author Willi Tscheschner
 *
 **/

/**
 * @namespace
 * @name ORYX.Plugins
 */
if ("undefined" === typeof Signavio) { var Signavio = {}; }
if ("undefined" === typeof Signavio.Plugins) { Signavio.Plugins = {}; }
	
new function(){
	
	Signavio.Plugins.GoogleTranslate = ORYX.Plugins.AbstractPlugin.extend({
	
		/**
		 *	Constructor
		 *	@param {Object} Facade: The Facade of the Editor
		 */
		construct: function(facade){
			
			// Init
			this.facade = facade;
			
			var current = this.facade.getCanvas().getLanguage(),
				languages = $H(ORYX.CONFIG.MULTI_LANGUAGES||{}),
				dropDownIcon = ORYX.CONFIG.EXPLORER_PATH + "/src/img/flags/" + (languages[current]);


			this.facade.offer({		
				'name' 				: Signavio.I18N.GoogleTranslate.btnTitle,
				'group'				: "ZZZZZZZZZZGroup.Multilanguage",
	            'dropDownGroupIcon'	: dropDownIcon,
				'index'				: 9,
				'toggle' 			: false,
				'icon' 				: ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/bing.png",
				'functionality' 	: this.doTranslate.bind(this),
				'separatedBefore'	: true,
				'iconCls'			: "x-menu-item-google-translation"
			});
		},
		
		/**
		 * Translate the current model
		 * 
		 */
		doTranslate: function(){
		
			var currentLanguage = this.facade.getCanvas().getLanguage(),
				otherLanguages = $A($H(ORYX.CONFIG.MULTI_LANGUAGES||{})).pluck("key").without(currentLanguage);
			
			var shapes = this.facade.getSelection().length == 0 ?
							this.facade.getCanvas().getChildShapes(true) : 
							this.facade.getSelection();
			
		
			var translate = {shapes: {}, source: otherLanguages.first(), target: currentLanguage};
							
			shapes.each(function(shape){
				var obj = this.getOriginTranslate(shape, currentLanguage, otherLanguages);
				if (obj){
					translate.shapes[shape.resourceId] = obj;
				}
			}.bind(this));
			
			var count = $H(translate.shapes).keys().length;
			if (0 === count){
				Ext.Msg.alert(Signavio.I18N.GoogleTranslate.btnTitle, Signavio.I18N.GoogleTranslate.labelNoElements)
						.setIcon(Ext.Msg.INFO).getDialog().syncSize();
			} else {
				Ext.Msg.confirm(Signavio.I18N.GoogleTranslate.btnTitle, Signavio.I18N.GoogleTranslate.labelConfirm, function(btn){
					if (btn == 'yes')
						this.sendRequest(translate, this.setTranslation.bind(this, shapes, translate, currentLanguage));
				}.bind(this)).setIcon(Ext.Msg.INFO).getDialog().syncSize();
			}
			
			
		},
		
		/**
		 * Set the response of the translation to the 
		 * set of shapes and updates the canvas.
		 * @param shapes
		 * @param originTranslation
		 * @param targetLanguage
		 * @param translation
		 */
		setTranslation: function(shapes, originTranslation, targetLanguage, translation){
			
			/**
			 * Implements the setting of the translation to the
			 * given shapes and the rollback behavior.
			 * @class SetAttributeCommand
			 * @inherit ORYX.Core.Command
			 */
			var SetAttributeCommand = ORYX.Core.Command.extend({
				construct : function(shapes, translation, language) {
					this.shapes = shapes;
					this.translation = translation;
					this.language = language;
					this.origin = {shapes: {}};
				},
				
				/**
				 * Set the property values to the translated ones.
				 */
				execute : function() {
					this.setAttributes(this.translation, this.executedFirst === undefined);
					this.executedFirst = false;
				},
				
				/**
				 * Set the property values to the origin ones.
				 */
				rollback : function() {
					this.setAttributes(this.origin);
				},
				
				setAttributes: function(translations, saveState){
					var translationShapes = translations.shapes;
					
					// Iterate over every shape
					this.shapes.each(function(shape){
						var obj = translationShapes[shape.resourceId];
						if (obj){
							$H(obj).each(function(pair){
								// Get the property id
								var prop = pair.key;
								if (this.language !== ORYX.CONFIG.MULTI_LANGUAGES_DEFAULT){
									prop += "_" + targetLanguage;
								}
								
								// Store value for rollback
								if (saveState){
									if (!this.origin.shapes[shape.resourceId]) this.origin.shapes[shape.resourceId] = {};
									this.origin.shapes[shape.resourceId][pair.key] = shape.properties["oryx-"+prop];
								}
								
								// Set the property value
								shape.setProperty("oryx-"+prop, pair.value);
							}.bind(this));
						}
					}.bind(this));
				}
			});
				
			this.facade.executeCommands([new SetAttributeCommand(shapes, translation, targetLanguage)]);
		},
		
		/**
		 * Returns the origin translation of a shape
		 * for all the given properties which should be
		 * translated. Returns NULL if there is no property
		 * which should translated.
		 * @param shape
		 * @return {<property-id>:<property-value>}
		 */
		getOriginTranslate: function(shape, currentLanguage, allOtherLanguages){

			var result = undefined;
			
			// Iterate over all properties to find those who has more than a language and a refToView
			var properties = shape.getStencil().properties();
			properties.each(function(property){
				// Find the origin property with at least one ref to view
				if (property.origin() === property && property.language() && property.refToView().length > 0){
					
					// Get all the property in all other languages
					var all = properties.findAll(function(r){ return r.origin() === property; });
					
					// Get the property in the current language
					var current = all.find(function(r){ return r.language() == currentLanguage; });
					// Get the property in any other language
					var other = all.find(function(r){ return allOtherLanguages.include(r.language()); });
					
					if (!current || !other){ return; }

					// Get the values of the current and other language
					var currentValue = shape.properties[current.prefix()+"-"+current.id()];
					var otherValue = shape.properties[other.prefix()+"-"+other.id()];
					
					// If the value is defined, set to translate
					if (!currentValue && otherValue){
						if (!result){ result = {}; }
						result[property.id()] = otherValue;
					}
					
				}
			});
			
			return result;
		},
		
		/**
		 * Send the params to the translate API and calls
		 * the success callback if the translation went true.
		 * 
		 */
		sendRequest: function(params, success){
			

			// Set waiting
			var waiting = Ext.Msg.wait(Signavio.I18N.GoogleTranslate.labelWaiting, Signavio.I18N.GoogleTranslate.btnTitle);
			
			
			// Failure callback
			var failure = function(message){
				Ext.Msg.alert(Signavio.I18N.GoogleTranslate.btnTitle, message || Signavio.I18N.GoogleTranslate.labelFailure.replace("[supportMailAdresse]",this.facade.getModelMetaData().supportMailAddress))
					.setIcon(Ext.Msg.WARNING).getDialog().syncSize();
			};
			
			// Parse params
			var obj = {};
			$H(params).each(function(p){
				if ("object" == typeof p.value){
					obj[p.key] = Object.toJSON(p.value);
				} else {
					obj[p.key] = p.value;
				}
			});
			
			// AJAX-CALL
			new Ajax.Request("/p/translate", {
					method		: 'post',
					parameters	: obj, 
					requestHeaders : {'Accept':"application/json", 'Content-Type':'charset=UTF-8'},
					asynchronous: false,
					onSuccess: function(transport){
						var json;
						try {
							json = transport.responseText.evalJSON();	
						} catch(e){
							failure(Signavio.I18N.GoogleTranslate.labelFailure.replace("[supportMailAdresse]",this.facade.getModelMetaData().supportMailAddress), transport);
						}
						
						if (json && json.message !== undefined){
							failure(json.message, transport);
						} else if (json && success instanceof Function) {
							success(json, transport);
							
							// Hide loading
							window.setTimeout(function(){
								waiting.hide();	
							}, 100);
						}
						
						
					}.bind(this),
					onFailure: function(transport){
						if (failure instanceof Function)
							failure(Signavio.I18N.GoogleTranslate.labelFailure.replace("[supportMailAdresse]",this.facade.getModelMetaData().supportMailAddress), transport);
					}.bind(this)
				});			
		}
		
	});
		
}();
/**
 * Copyright (c) 2011 Signavio
 * @author Willi Tscheschner
 *
 **/

/**
 * @namespace
 * @name Signavio.Plugins
 */
if ("undefined" === typeof Signavio) { var Signavio = {}; }
if("undefined" === typeof Signavio.Plugins) { Signavio.Plugins = {};}
	

(function(){
	
	Signavio.Plugins.CoMMed = ORYX.Plugins.AbstractPlugin.extend({
	
		/**
		 *	Constructor
		 *	@param {Object} facade: The facade of the Editor
		 */
		construct: function(facade){
			this.facade = facade;
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanges.bind(this));
		},
		
		/**
		 * Handles changes of the property
		 * @param event
		 * @param node
		 */
		handlePropertyChanges : function(event, node){
			
			var node = event.elements.first();
			
			// Check stencil type
			if(!node || !(node.getStencil().id().endsWith("#Pool") || node.getStencil().id().endsWith("#Lane"))) {
				return;
			}
			// Check extension
			if (!this.facade.getStencilSets().values()[0].extensions()["http://oryx-editor.org/stencilsets/extensions/carestation#"]){
				return;
			}
			// Check attribute
			if(event.key != "oryx-type"){
				return;
			}
			// Check if currently is executing within a command
			if(!this.facade.isExecutingCommands()){
				return;
			}
			
			// Set some attributes
			var key = "oryx-name", name = "Carestation", me = this;
			
			// If no system, use performer
			if(event.value != "system"){
				name = Ext.ux.propertyeditor.ComMedRoleMapping.prototype.renderer(node.properties["oryx-commedrolemapping"]);
			}
			
			// Use a command to set the property
			var Command = ORYX.Core.Command.extend({
				construct: function(){
					this.shape 		= node;
					this.key 		= key;	
					this.value 		= name;
					this.oldValue 	= this.shape.properties[key];
				},
				execute: function(){
					this.shape.setProperty(this.key, this.value);
					this.update();
				},
				rollback: function(){
					this.shape.setProperty(this.key, this.oldValue);
					this.update();
				},
				update: function(){
					me.facade.setSelection([]);
					me.facade.setSelection(this.shape);
				}
			});
			this.facade.executeCommands([new Command()]);
		}

	});
		
}());
/**
 * Copyright (c) 2011 Signavio
 * @author Jan-Felix Schwarz, Philipp Giese
 **/

if(!Signavio) { var Signavio = {}; }
if (!Signavio.Plugins) { Signavio.Plugins = {}; }

(function() {
	
	/**
	 * Custom exception value for containment checks
	 */
	var $containmentError = {};
	
	var NAMESPACE = "http://www.signavio.com/stencilsets/processdoctemplate#";
    
	/**
	 * The following selectors are deprecated. Use
	 * isHeader, isFooter, isMeta instead
	 */
    var HEADER = NAMESPACE + "Header";
    var FOOTER = NAMESPACE + "Footer";
    var META = NAMESPACE + "MetaBlock";
    var TOC_SECTION = NAMESPACE + "TOCPart";
    
    var NON_CHILDREN = [HEADER, FOOTER, META, TOC_SECTION];

    /**
     * Scope definitions
     */
    var SCOPE_GLOBAL = "global";
    var SCOPE_DIAGRAM = "diagram";
    var SCOPE_PROCESS = "process";
    
    /**
     * Prefixes for list and table elements.
     * These are then used in order to substitute element id's
     * during moprhings.
     */
    var ELEMENT_LIST_PREFIX = "ListElements";
    var ELEMENT_TABLE_PREFIX = "TableElements";
    
    /**
     * The grayish tone of all those default texts.
     */
    var CORPORATE_TEXT_COLOR = "#808080";
    
    /**
     * Creates and returns custom check functions for stencils.
     * Through closures, arrays do not have to be created every
     * time the function is called, but only once. 
     */
    var getCheckFn = function(elements) {
    	if(!(elements instanceof Array)) {
    		elements = [elements];
    	}
    	
    	elements = elements.map(function(element) {
            return NAMESPACE + element;
        });
    	
    	return function(element) {
			return element && elements.include(element.getStencil().id());
		};
    };
    
    var ROMAN_KEY_VALUES = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    var ROMAN_VALUES = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];
    
    /**
     * This is the plugin to enable support for custom templates for process documentations.
     * It has to be enabled in order for the editor to work properly. 
     * 
     * In addition the following plugins are available:
     * 
     * 	- removeSignavioBranding -
     * 	Add another option to the style field of headers and footers,
     * 	that allows the user to define custom elements.
     * 
     * 	- kaiserKraftSupport - 
     * 	Adds the kaiser kraft option to the style field of headers
     * 	and footers, that will then show a pre set-up header style.
     * 
     * 	- swissPostSupport - 
     * 	Same as the kaiserKraftSupport plugin, but for swiss post.
     */
    Signavio.Plugins.ProcessdocTemplateSupport = Clazz.extend({
    
        facade: undefined,
        
        construct: function(facade){
        	this.rescueList = [];
        	
        	this.facade = facade;
    
            this.facade.registerOnEvent('layout.processdoctemplate.template', this.handleLayoutTemplate.bind(this));
            
            this.facade.registerOnEvent('layout.processdoctemplate.page.cover', this.handleLayoutCover.bind(this));
            this.facade.registerOnEvent('layout.processdoctemplate.page.toc', this.handleLayoutTOC.bind(this));
            this.facade.registerOnEvent('layout.processdoctemplate.page.following', this.handleLayoutPage.bind(this));
            
            this.facade.registerOnEvent('layout.processdoctemplate.section', this.handleLayoutSection.bind(this));
            this.facade.registerOnEvent('layout.processdoctemplate.table', this.handleLayoutTable.bind(this));
            this.facade.registerOnEvent('layout.processdoctemplate.list', this.handleLayoutList.bind(this));
            this.facade.registerOnEvent('layout.processdoctemplate.header_footer', this.handleLayoutHeaderFooter.bind(this));
            
            this.facade.registerOnEvent('layout.processdoctemplate.column.attribute', this.handleColumnAttributeChange.bind(this));
            this.facade.registerOnEvent('layout.processdoctemplate.row.attribute', this.handleRowAttributeChange.bind(this));
            this.facade.registerOnEvent("layout.processdoctemplate.process.attribute", this.handleLayoutProcessAttribute.bind(this));
            
            this.facade.registerOnEvent("layout.processdoctemplate.meta", this.handleLayoutMeta.bind(this));
            
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, this.handleShapeAdd.bind(this));
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEREMOVED, this.handleShapeRemove.bind(this));
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.handlePropertyChanged.bind(this));
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.handleEditorLoad.bind(this));
            
             // CutCopy mode is needed as shapes, that are inserted with a paste action, are first added to the canvas.
             // If custom containment now kicks in, these shapes would be deleted immediately after the add. When
             // in CutCopy mode these shapes are added to a separate list, that will prevent them from
             // being removed by the standard algorithm.  
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADING_ENABLE, function() {
            	this.cutCopyMode = true;
            }.bind(this));
            
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADING_DISABLE, function() {
            	this.cutCopyMode = false;
            }.bind(this));
        },
        
        // START STANDARD EVENT HANDLERS
        
        handleShapeAdd: function(e) {
        	var shape = e.shape;
        	
        	if(this.cutCopyMode && shape.parent === this.facade.getCanvas()) {
        		 // Do not delete shapes, that are added to the canvas during CutCopy mode
        		 // (see comment in construct())
        		this.rescueList.push(shape);
        	}
        	
        	this.translate(shape);
        	
        	if(this.isHeaderFooterAttribute(shape)) {
        		shape.getLabels().each(function(label) {
        			label.registerOnChange(this.handleLayoutAttribute.bind(this, shape, label));
        		}.bind(this));
            } else if(this.isTOC(shape)) {
            	this.handleTOCAdd(shape);
            } else if(this.isText(shape)) {
            	shape.getLabels().each(function(label) {
            		label.registerOnChange(this.layoutFreeTextLabels.bind(this, shape, label));
            	}.bind(this));
            }
        	
        	this.restoreFocus(shape);
        },
        
        handleShapeRemove: function(e) {
            var shape = e.shape;
            
            if(this.isSection(shape)) {
                this.requestIndexRefresh(shape, true);
            }
        },
        
        handlePropertyChanged: function(e) {
            var shape = e.elements.first();
            
            switch(e.name) {
                case "oryx-text":
                    if(this.isText(shape)) {
                    	this.handleTextChange(shape, e);
                    }
                    break;
                case "oryx-includeintoc":
                    if(!e.value) {
                        // set property on all children
                        shape.getChildShapes(false, function(child) {
                            if(this.isSection(child) && child.getProperty("includeintoc")) {
                                child.setProperty("includeintoc", false);
                            }
                        }.bind(this));
                    } else {
                        // if parent is already excluded, do not include any child
                        var parent = this.findElement(shape.parent, this.isSection);
                        
                        if(parent && !parent.getProperty("includeintoc")) {
                            shape.setProperty("includeintoc", false);
                        }
                    }
                    
                    this.facade.getCanvas().update();
                    break;
                case "oryx-preview":
                	if(this.isTOC(shape)) {
                		window.setTimeout(function() {
                			shape.setProperty("color", "white");
                			shape.setProperty("color", CORPORATE_TEXT_COLOR);
                		}, 1);
                	}
                	
                	break;
            }
            
            this.restoreFocus(this.facade.getSelection());
        },
        
        handleEditorLoad: function(e) {
            // Only enable table layouting after the editor is
            // loaded. Otherwise the count of columns and rows in 
            // static tables would double with each save and load.
            this.enableTableLayouting();

            // Custom containment should only be activated after
            // the editor has been loaded. Otherwise elements
            // could be deleted, even if they are in the right place.
            this.enableCustomContainment();
            
            // Only one header and footer can be added to a page.
            // To avoid errors, this has to be activated only
            // after the editor is loaded.
            // Also page numbers must have the same properties 
            // throughout one page.
            this.enableHeaderFooterConstraints();
            
            // copy headers and footers to new pages, if the previous
            // page had them set
            this.enableHeaderFooterAutoCreate();
            
            // TOC updates should only happen after the editor
            // is loaded
            this.enableTOCPreview();
            
            // Newly added process tables will be equipped with a 
            // index row, name and org-unit column by default.
            this.enableTableIteratorExtension();
            
            // Complex tables and lists, that iterate over
            // elements should be morphable 
            this.enableIteratorMorphing();
            
            var canvas = this.facade.getCanvas();
            var children = canvas.getChildShapes();
            
            if(children.size() === 0) {
                // initially create a cover and the toc
                this.addElement(canvas, "CoverPage");
                this.addElement(canvas, "TableOfContents");
                this.addElement(canvas, "FollowingPage");
                
                canvas.update();
                this.updateTOC();
            }
            
            this.updateSectionNumbering();
        },
        
        // END STANDARD EVENT HANDLERS
        // START LAYOUTING HANDLERS
        
        /**
         * The style of page numbers in headers and footers has to be consistent
         * throughout one page. This function will ensure, that all properties
         * of the page number stencil are kept in sync with all instances.
         */
        handleStyleChange: function(shape) {
        	var page = this.findElement(shape, this.isPage);
        	
        	var header = page.getChildShapes().find(this.isHeader);
        	var footer = page.getChildShapes().find(this.isFooter);
        	
        	var copyProps = function(element) {
        		element.getChildShapes().select(this.isPageNumber).each(function(el) {
        			if(el !== shape) {
        				this.applyProperties(el, shape.properties);
        			}
        		}.bind(this));
        	}.bind(this);
        	
        	if(header) {
        		copyProps(header);
        	}
        	
        	if(footer) {
        		copyProps(footer);
        	}
        	
        	this.restoreFocus(this.facade.getSelection());
        },
        
        handleTOCAdd: function(shape) {
        	var toc = this.facade.getCanvas().getChildShapes().find(this.isTOC);
        	
        	// only one toc allowed for a document
        	if(toc && shape !== toc) {
        		this.removeSilently(shape, toc);
        	}
        	
        	if(!toc) {
        		toc = shape;
        	}
        	
        	toc.setProperty("color", CORPORATE_TEXT_COLOR);
        },
        
        /**
         * General layouting handler, that will ensure vertical ordering of
         * pages and spacing between them. 
         */
        handleLayoutTemplate: function(event) {
            var template = event.shape;
            
            var pages = template.getChildShapes().select(this.isPage).sortBy(function(child) { 
                return child.bounds.upperLeft().y; 
            });
            
            var zoomLevel = this.facade.getCanvas().getZoom();
            
            var y = 50; // padding 
            var x = 50; // padding 
            var spacing = 30;
            var maxWidth = 0;
            
            pages.each(function(page) {
                page.bounds.moveTo(x, y);
                y += page.bounds.height() + spacing;
                
                if(page.bounds.width() > maxWidth) {
                    maxWidth = page.bounds.width();
                }
            }.bind(this));
            
            // extend canvas size if necessary
            var canvas = this.facade.getCanvas();
            canvas.setSize({
                width: (maxWidth + 2*x) * zoomLevel,
                height: (y + 20) * zoomLevel
            });
        },
        
        /**
         * Handler for: layout.processdoctemplate.page.cover
         */
        handleLayoutCover: function(event) {
            var page = event.shape;
            var children = page.getChildShapes();
            var meta = children.select(this.isMeta);
            var padding = 30;
            var alignment = page.getProperty("alignment");
            
            // page has to be updated once, so that all the labels have
            // their texts set correctly after page load
            page._update(true);
            
            page.getLabels().each(function(label) {
               if(alignment === "left") {
                   label.setX(padding + label.getWidth()/2);
               } else if(alignment === "center") {
                   label.setX(page.bounds.center().x - page.bounds.upperLeft().x);
               } else if(alignment === "right") {
                   label.setX(page.bounds.width() - label.getWidth()/2 - padding);
               }
               
               this.updateLabel(label);
            }.bind(this));
            
            this.layoutHeaderFooter(page);
            // move meta information tags
            this.moveMetaBlocks(page, meta);
        },
        
        /**
         * Handler for: layout.processdoctemplate.page.toc
         */
        handleLayoutTOC: function(event) {
            var toc = event.shape;
            
            this.layoutHeaderFooter(toc);
            
            if(!toc.getProperty("preview")) {
                this.cleanTOC(toc);
                
                toc.setProperty("description", Signavio.I18N.ProcessTemplates.tocPreview);
            }
        },
        
        /**
         * Handler for: layout.processdoctemplate.page.following
         */
        handleLayoutPage: function(event) {
            var page = event.shape;
            var children = page.getChildShapes();

            // TODO: replace NON_CHILDREN with this.isSection?
            // Only sections should be layouted
            children = children.select(function(child) { 
                return !NON_CHILDREN.include(child.getStencil().id()); 
            }).sortBy(function(child) { 
                return child.bounds.upperLeft().y;
            });
            
            var y = 65;         // spacing from header
                
            children.each(function(child) {
            	// spacing between sections
            	var spacing = 30;
            	
                child.bounds.moveTo((page.bounds.width()-child.bounds.width())/2, y);
                
                if(this.isIterator(child) && child.getProperty("includeinnumbering")) {
                    spacing += 20;
                }
                
                y += child.bounds.height() + spacing; 
                
            }.bind(this));
            
            // extend page height if necessary
            var ul = page.bounds.upperLeft();
            page.bounds.set(
                ul,
                {
                    x: ul.x + page.bounds.width(),
                    y: ul.y + Math.max(y+35, page.minimumSize.height)
                }
            );
            
            this.layoutHeaderFooter(page);
        },
        
        /**
         * Handler for: layout.processdoctemplate.section
         */
        handleLayoutSection: function(event) {
            var section = event.shape;
            
            var children = section.getChildShapes().sortBy(function(child) { 
                return child.bounds.upperLeft().y; 
            });
            
            var y = 30;
            
            children.each(function(child) {
            	// spacing inside sections
            	var spacing = 30;
            	
                child.bounds.moveTo((section.bounds.width()-child.bounds.width())/2, y);
                
                if(this.isIterator(child) && child.getProperty("includeinnumbering")) {
                    spacing += 20;
                }
                
                y += child.bounds.height() + spacing;
            }.bind(this));
            
            // extend section height if necessary
            var ul = section.bounds.upperLeft();
            section.bounds.set(
                ul,
                {
                    x: ul.x + section.bounds.width(),
                    y: ul.y + Math.max(y, section.minimumSize.height)
                }
            );
            
            this.facade.updateSelection();
            
            if(section.parent !== this.facade.getCanvas()) {
            	// On copy/paste the pasted section will first be added to the canvas
            	// if we would request an index update in this case, this might prevent
            	// the index update, when the section is added to the correct page/section.
            	this.requestIndexRefresh(section);
            }
        },
        
        /**
         * Handler for: layout.processdoctemplate.table
         */
        handleLayoutTable: function(event) {
            var table = this.findElement(event.shape, this.isTable);
            
            if(!table) {
                return;
            }
            
            var children = this.flattenElement(table);
            this.restoreVisibleOrder(table, children);
            
            var columns = children.select(this.isColumn).sortBy(function(column) {
            	if(this.isIndexColumn(column)) {
            		return -1;
            	}
            	
                return column.bounds.upperLeft().x;
            }.bind(this));
           
            var rows = children.select(this.isRow).sortBy(function(row) {
                return row.bounds.upperLeft().y;
            });
            
            if(table.getProperty("showheader") && rows.first()) {
                // Do not add extra color to a row, if a table header is shown
                rows.first().setProperty("bgcolor", "none");
            }
            
            if(table.getProperty("showfooter") && rows.last()) {
                // Do not add extra color to a row, if a table footer is shown
                rows.last().setProperty("bgcolor", "none");
            }
            
            var indexColumns = columns.findAll(this.isIndexColumn);
            var equalWidth = this.computeColumnWidth(table, columns, indexColumns);
            var x = 0;
            var y = rows.length > 0 ? 0 : table.minimumSize.height;
            
            rows.each(function(row) {
                row.bounds.set({
                    a: {
                        x: 0,
                        y: y
                    }, 
                    b: {
                        x: table.bounds.width(),
                        y: y + row.bounds.height()
                    }
                });
                
                y += row.bounds.height();
            });
            
            columns.each(function(column) {
                var width = (indexColumns.include(column) ? column.bounds.width() : equalWidth);
                if(column.getProperty("width") > 0) {
                    width = (table.bounds.width() * column.getProperty("width")) / 100; 
                }
                
                column.bounds.set({
                    a: {
                        x: x,
                        y: 0
                    },
                    b: {
                        x: x + width,
                        y: y
                    }
                });

                x += column.bounds.width();
            });
            
            this.resize(table, table.bounds.width(), y);
            this.updateTable(table, rows, columns);
            this.facade.getCanvas().update();
        },
        
        /**
         * Handler for: layout.processdoctemplate.table.plain
         */
        handleLayoutTablePlain: function(event) {
            var table = this.findElement(event.shape, this.isTable);
            
            if(!table) {
                return;
            }
            
            var children = this.flattenElement(table);

            // ensure, that table is layouted correctly
            // -> add one row and one column, if necessary
            var row = children.find(this.isRow);
            var column = children.find(this.isColumn);
            
            if(!row) {
                this.addRows(table, 1);
            }
            
            if(!column) {
                this.addColumns(table, 1);
            }
            
            this.handleLayoutTable(event);
        },
        
        handleTextChange: function(shape, e) {
        	shape.setProperty("hiddenText", e.value);
            shape._update(true);
        },
        
        layoutFreeTextLabels: function(shape, label) {
        	this.resize(shape, shape.bounds.width(), label.getHeight());
        	
        	this.facade.getCanvas().update();
        },
        
        /**
         * Handler for: layout.processdoctemplate.list
         */
        handleLayoutList: function(event) {
            var list = this.findElement(event.shape, this.isList);
            
            if(!list) {
                return;
            }
            
            var y = 30;
            var spacing = 10;
            var rows = this.flattenElement(list).sortBy(function(row) { 
                return row.bounds.upperLeft().y; 
            });
            
            rows.each(function(row, index) {
                row.bounds.set(
                    0,
                    y,
                    list.bounds.width(),
                    y + row.bounds.height()
                );
                
                y += row.bounds.height() + spacing;
            }.bind(this));
            
            list.bounds.set(list.bounds.upperLeft(), { 
                x: list.bounds.lowerRight().x, 
                y: list.bounds.upperLeft().y + Math.max(75,y+60)
            });
            
            list._update();
        },
        
        updateLabel: function(label) {
        	label.suspendEvents(true);
        	label.update(true);
        },
        
        /**
         * Handler for: layout.processdoctemplate.header_footer
         */
        handleLayoutHeaderFooter: function(event) {
            var element = event.shape;
            var padding = 30;
            var position = {
                left: [],
                center: [],
                right: []
            };
            
            if(element.getProperty("style") !== "none") {
            	element.getChildShapes().each(function(child) {
            		this.removeSilently(child, element);
            	}.bind(this));
            	
            	return;
            }
            
            element.getChildShapes().each(function(child) {
                var dist = this.getDistances(element, child);
                
                if((dist.left < dist.center) && (dist.left < dist.right)) {
                    position.left.push({
                        el: child,
                        x: padding,
                        position: "left"
                    });
                } else if((dist.right < dist.center) && (dist.right < dist.left)) {
                    position.right.push({
                        el: child,
                        x: element.bounds.width() - padding - child.bounds.width(),
                        position: "right"
                    });
                } else {
                    position.center.push({
                        el: child,
                        x: element.bounds.center().x - child.bounds.width()/2,
                        position: "center"
                    });
                }   
            }.bind(this));
            
            var option = {
                y: 10,
                maxY: 30,
                padding: 20
            };
            
            this.placeInRows(position.left, option);
            this.placeInRows(position.center, option);
            this.placeInRows(position.right, option);
        },
        
        /**
         * Handler for: layout.processdoctemplate.column.attribute
         */
        handleColumnAttributeChange: function(event) {
            var column = event.shape;
            
            if(this.isMultiColumn(column)) {
            	this.handleMultiColumnAttributeChange(column);
            	
            	return;
            }
            
            var attributes = (column.getProperty("Attributes") || "{}").evalJSON(true);
            var items = (attributes.items || []).map(function(item) {
                return item.title;
            }).uniq();
            
            var title;
            
            if(items.size() === 0) {
                var conf = attributes.config || {};
                
                if(conf.selectName) {
                    title = Signavio.I18N.ProcessTemplates.name;
                } else if(conf.selectDescription) {
                	title = Signavio.I18N.ProcessTemplates.description;
                } else {
                	title = Signavio.I18N.ProcessTemplates.processTableAttributeEmpty;
                }
            } else {
            	title = items.first();
            }
            
        	column.setProperty("attribute", title);
        },
        
        handleMultiColumnAttributeChange: function(column) {
        	var attributes = (column.getProperty("Attributes") || "{}").evalJSON(true);
        	var items = (attributes.items || []).map(function(item) {
        		return item.title;
        	}).uniq();
        	
        	var title;
        	
        	if(items.size() === 0) {
        		var config = attributes.config || {};
        		
        		if(config.allAttributes) {
        			title = Signavio.I18N.ProcessTemplates.allAttributes;
        		} else if(config.ownAttributes) {
        			title = Signavio.I18N.ProcessTemplates.ownAttributes;
        		} else {
        			title = Signavio.I18N.ProcessTemplates.processTableAttributeEmpty;
        		}
        	} else {
        		title = Signavio.I18N.ProcessTemplates.customAttributes;
        	}
        	
        	column.setProperty("title", column.getProperty("title") || title);
        },
        
        /**
         * Handler for: layout.processdoctemplate.row.attribute 
         */
        handleRowAttributeChange: function(event) {
            var row = event.shape;
            var title;
            var attributes = (row.getProperty("Attributes") || "{}").evalJSON(true);
            var items = (attributes.items || []).map(function(attribute) {
                return attribute.title;
            }).uniq();
            
            var maxItems = 2;
            
            if(items.size() > maxItems) {
                var overflow = items.size() - maxItems;
                items = items.slice(0, maxItems);
                
                var tpl = new Template(Signavio.I18N.ProcessTemplates.andMore);
                
                title = items.join(", ") + " " + tpl.evaluate({
                    times: overflow
                });
            } else if(items.size() > 0) {
                title = items.join(", ");
            } else {
                var conf = attributes.config || {};
                
                if(conf.selectName) {
                    title = Signavio.I18N.ProcessTemplates.name;
                } else if(conf.selectDescription) {
                    title = Signavio.I18N.ProcessTemplates.description;
                } else if(conf.allAttributes) {
                	title = Signavio.I18N.ProcessTemplates.allAttributes;
                } else if(conf.ownAttributes) {
                	title = Signavio.I18N.ProcessTemplates.ownAttributes;
                } else {
                    title = Signavio.I18N.ProcessTemplates.processTableAttributeEmpty;
                }
            }

            row.setProperty("row-title", title);
            row._update(true);
        },
        
        /**
         * Handler for: layout.processdoctemplate.process.attribute
         */
        handleLayoutProcessAttribute: function(e) {
            var shape = e.shape;
            var attributes = (shape.getProperty("Attributes") || "{}").evalJSON(true);
            
            var label = Signavio.I18N.ProcessTemplates.processAttributeEmpty;
            
            if(this.isMultiDiagramAttribute(shape)) {
            	label = Signavio.I18N.ProcessTemplates.processAttributeMultiEmpty;
            }
            
            var sliceSize = 10;
            var items = attributes.items || [];
            var config = attributes.config || {};
            
            if(items.size() > 0) {
                if(items.size() >= sliceSize) {
                    label = items.slice(0, sliceSize).map(function(item) {
                        return item.title;
                    }).uniq().join(", ");
                    
                    var tpl = new Template(Signavio.I18N.ProcessTemplates.andMore);
                    label += " " + tpl.evaluate({
                        times: (items.size() - sliceSize)
                    });
                } else {
                    label = items.map(function(item) {
                        return item.title;
                    }).uniq().join(", ");
                }
            } else {
                if(config.allAttributes) {
                    label = Signavio.I18N.ProcessTemplates.allAttributes;
                } else if(config.ownAttributes) {
                    label = Signavio.I18N.ProcessTemplates.ownAttributes;
                } else if(config.selectName) {
                	label = Signavio.I18N.ProcessTemplates.name;
                } else if(config.selectDescription) {
                	label = Signavio.I18N.ProcessTemplates.description;
                }
            }
            
            shape.setProperty("valueList", label);
        },
        
        /* END LAYOUTING EVENT HANDLERS */
        /* START CUSTOM HANDLERS */
        
        enableHeaderFooterAutoCreate: function() {
        	this.facade.getCanvas().getChildShapes(false, function(child) {
        		if(this.isPage(child)) {
        			// after the editor is loaded all pages, that are already there
        			// are marked extended. That means, that they won't be considered for 
        			// auto header or footer generation.
        			child.extended = true;
        		}
        	}.bind(this));
        	
        	this.facade.registerOnEvent("layout.processdoctemplate.page.generic", function(e) {
        		this.createHeaderAndFooter(e.shape);
        	}.bind(this));
        },
        
        enableIteratorMorphing: function() {
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, function(e) {
                var shape = e.elements.first();
                
                if(e.name === "oryx-displayas") {
                    if(((this.isTable(shape) || this.isList(shape))) && this.isDiagramContent(shape)) {
                        var from = this.isTable(shape) ? ELEMENT_TABLE_PREFIX : ELEMENT_LIST_PREFIX;
                        var to = this.isTable(shape) ? ELEMENT_LIST_PREFIX : ELEMENT_TABLE_PREFIX;
                        
                        if(!this.restoreMap) {
                            this.restoreMap = {};
                        }
                        
                        if(shape.parent) {
                            // no undo scenario as shape has a parent
                            var newShape = this.morph(shape, from, to, function(createdShape, newChild, oldChild) {
                                var bounds = oldChild.bounds;
                                
                                newChild.bounds.set({
                                    a: {
                                        x: bounds.a.y,
                                        y: bounds.a.x
                                    },
                                    b: {
                                        x: bounds.b.x,
                                        y: bounds.a.x + this.isTable(createdShape) ? createdShape.bounds.height() : newChild.bounds.height()
                                    }
                                });
                                
                                window.setTimeout(function() {
                                	if(this.isListRow(newChild) && newChild.hasProperty("row-title")) {
                                		this.handleRowAttributeChange({ shape: newChild });
                                	}
                                }.bind(this), 200);
                            }.bind(this));
                            
                            if(shape.getProperty("showNumbering")) {
                                newShape.setProperty("showNumbering", false);
                                newShape.setProperty("showNumbering", true);
                            } else {
                                newShape.setProperty("showNumbering", true);
                                newShape.setProperty("showNumbering", false);
                            }
                            
                            this.replace(shape.parent, shape, newShape);
                            
                            this.restoreMap[shape.id] = {
                                oldShape: shape,
                                newShape: newShape 
                            };
                        } else {
                            // since shape has no parent it is likely, that an undo
                            // of the property change is performed. Thus we need to manually
                            // restore the shapes.
                            if(this.restoreMap[shape.id]) {
                                var entry = this.restoreMap[shape.id];
                                var parent = entry.newShape.parent;
                                
                                this.replace(parent, entry.newShape, entry.oldShape);
                                
                                delete this.restoreMap[shape.id];
                            }
                        }
                    }
                }
            }.bind(this));  
        },
        
        replace: function(parent, oldShape, newShape) {
            parent.remove(oldShape);
            parent.add(newShape);
            
            this.facade.getCanvas().update();
            this.restoreFocus(newShape, true);
        },
        
        morph: function(original, from, to, onAdd) {
            onAdd = onAdd instanceof Function ? onAdd : Ext.emptyFn;
            
            var shape = this.createElement(to);
            
            original.getChildShapes(false, function(child) {
                var id = to + child.getStencil().id().replace(NAMESPACE + from, "");
                
                try {
                    var newChild = this.addElement(shape, id);
                    
                    this.copyProperties(child, newChild);
                    
                    onAdd(shape, newChild, child);
                } catch(e) {
                	// occurs, if the new child can't be added to the parent
                	// in that case, we just ignore the fact and
                	// continue
                }
                
            }.bind(this));
            
            this.copyProperties(original, shape);
            
            var ul = original.bounds.upperLeft();
            
            shape.bounds.set(ul, {
                x: ul.x + shape.bounds.width(),
                y: ul.y + shape.bounds.height() 
            });
            
            return shape;
        },
        
        copyProperties: function(source, destination) {
        	var allProps = $H(source.properties).merge(source.overflowProps || {}).toJSON().evalJSON();
        	var overflow = this.applyProperties(destination, allProps);
        	
        	destination.overflowProps = overflow;
        },
        
        addCorrectShape: function(shape) {
            var parent = shape.parent;
            
            if(this.isTable(parent)) {
                shape.hide();
                
                if(!this.added) {
                    this.added = [];
                }
                
                if(this.added.include(shape.id)) {
                    return;
                }
                
                this.added.push(shape.id);
                
                var Command = this.createMorphCommand(shape, parent); 
                
                this.facade.executeCommands([new Command(this.facade)]);
            } 
        },
        
        createMorphCommand: function(shape, parent) {
            var that = this;
            
            return ORYX.Core.Command.extend({
                construct: function(facade) {
                    this.facade = facade;

                    this.newShape = that.morph(shape, 
                                               shape.getStencil().idWithoutNs(), 
                                               shape.getStencil().idWithoutNs().replace(ELEMENT_LIST_PREFIX, ELEMENT_TABLE_PREFIX));
                },
                execute: function() {
                    window.setTimeout(function() {
                        parent.remove(shape, true);          
                        
                        // Due to the fact, that we morph the shape before the
                        // bounds have been set correctly, we need to correct them
                        // right now. Otherwise the new shape will always be added
                        // at the wrong place
                        var ul = shape.bounds.upperLeft();
                        var lr = this.newShape.bounds.lowerRight();
                        
                        this.newShape.bounds.set({
                        	x: ul.x,
                        	y: 0
                        }, {
                        	x: ul.x + lr.x,
                        	y: lr.y
                        });
                        
                        parent.add(this.newShape, undefined, true);
                        
                        this.newShape._update(true);
                        this.facade.getCanvas().update(true);
                        
                        that.restoreFocus(this.newShape);
                    }.bind(this), 1);
                },
                rollback: function() {
                    parent.remove(this.newShape, true);
                    parent.add(shape, undefined, true);
                }
            });
        },
        
        enableTableIteratorExtension: function() {
            var move = function(x) {
                return function(child) {
                    child.bounds.moveTo(x, 0);
                };
            };
            
        	this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, function(e) {
        		var shape = e.shape;

                if(this.isListRow(shape)) {
                    this.addCorrectShape(shape);
                }
                
        		if(this.isTable(shape) && this.isDiagramContent(shape)) {
                    if(shape.getChildShapes().size() === 0) {
                        this.addElement(shape, "TableElementsRoles", move(2)), 
                        this.addElement(shape, "TableElementsAttribute", function(child) {
                            move(1)(child);
                            child.setProperty("attributes", $H({
                                items: [],
                                config: {
                                    selectName: true
                                }
                            }).toJSON());
                            child.setProperty("title", Signavio.I18N.ProcessTemplates.activityName);
                        });
                        this.addElement(shape, "TableElementsIndex", move(0));
                        
                        this.restoreFocus(shape, true);
                    }
                }
        	}.bind(this));
        	
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, function(e) {
                var shape = e.elements.first();
                
                if(this.isTable(shape) && this.isDiagramContent(shape)) {
                    if(e.name === "oryx-shownumbering") {
                        if(e.value) {
                            this.addElement(shape, "TableElementsIndex", move(-1));
                        } else {
                            var index = shape.getChildShapes().find(this.isIndexColumn);
                            
                            if(index) {
                                shape.remove(index);
                            }
                        }
                    }
                }
            }.bind(this));
        },
        
        enableTOCPreview: function() {
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, function(e) {
                var shape = e.shape;
                
                if(this.isTOC(shape)) {
                    this.updateTOC(shape);
                }
            }.bind(this));
            
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, function(e) {
                var shape = e.elements.first();
                
                switch(e.name) {
                    case "oryx-title":
                        if(this.isSection(shape)) {
                            this.updateTOC(shape);
                        }
                        
                        break;
                    case "oryx-preview":
                        if(shape.getProperty("preview")) {
                            this.updateTOC(shape);
                        }
                }
            }.bind(this));
        },
        
        /**
         * See comment in handleEditorLoad
         */
        enableHeaderFooterConstraints: function() {
        	this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, function(e) {
        		var shape = e.elements.first();
        		
        		if(this.isHeaderFooterAttribute(shape) && this.isPageNumber(shape)) {
            		this.handleStyleChange(shape);
            	}
        	}.bind(this));
        	
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, function(e) {
                var shape = e.shape;
                
                if(this.isHeader(shape) || this.isFooter(shape)) {
                    this.handleHeaderFooterAdd(shape);
                }
            }.bind(this));
            
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_BEFORE_REMOVE, function(e) {
            	var shape = e.elements.first();
            	
            	if(this.isFooter(shape) || this.isHeader(shape)) {
            		e.cancelled = true;
            	}
            }.bind(this));
        },
        
        createFakeShape: function(args) {
        	if(args.containedShape) {
        		var shape = args.containedShape;
        		
        		return {
        			getStencil: shape.getStencil.bind(shape),
        			getChildShapes: shape.getChildShapes.bind(shape),
        			parent: args.containingShape
        		};
        	}
        	
        	return {
        		getStencil: function() {
        			return args.containedStencil;
        		},
        		parent: args.containingShape
        	};
        },
        
        checkAll: function(shape, parent, checkFn) {
        	if(shape.getChildShapes instanceof Function) {
        		if(checkFn(shape)) {
        			var allowed = true;
        			
        			shape.getChildShapes().each(function(child) {
        				allowed = allowed && this.checkContainment(this.createFakeShape({
        					containedShape: child,
        					containingShape: parent
        				}));
        				
        				if(!allowed) {
        					throw $break;
        				}
        				
        				allowed = allowed && this.checkAll(child, parent, checkFn);
        			}.bind(this));
        			
        			return allowed;
        		}
        		
        		return false;
        	}
        	
        	return checkFn(shape);
        },
        
        checkContainment: function(shape) {
        	if(this.isSection(shape)) {
                return this.checkAll(shape, shape, this.sectionContainmentAllowed.bind(this));
            } else if(this.isProcessContent(shape)) {
            	return this.checkAll(shape, shape, this.processContainmentAllowed.bind(this));
            } else if(this.isDiagramInformation(shape)) {
            	return this.checkAll(shape, shape, this.diagramInformationContainmentAllowed.bind(this));
            } else if(this.isHeaderFooterAttribute(shape)) {
            	if(shape.parent.getProperty("style") == "none") {
            		return true;
            	}
            	
            	return false;
            } else if(this.isTOC(shape)) {
            	return !this.shapeExists(this.facade.getCanvas(), this.isTOC);
            } else if(this.isCoverPage(shape)) {
            	return !this.shapeExists(this.facade.getCanvas(), this.isCoverPage);
            }
        
        	return true;
        },
        
        shapeExists: function(parent, selector) {
        	return !!parent.getChildShapes().find(selector);
        },
        
        /**
         * See comment in handleEditorLoad
         */
        enableCustomContainment: function() {
            var canContain = ORYX.Core.StencilSet.Rules.prototype.canContain;
            var that = this;
            
            ORYX.Core.StencilSet.Rules.prototype.canContain = function(args) {
            	if(canContain.call(this, args)) {
            		var shape = that.createFakeShape(args);
            		
            		return that.checkContainment(shape);
            	} 
            	
            	return false;
            };
            
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, function(e) {
            	var shape = e.shape;
            	
            	if(this.isProcessContent(shape)) {
            		this.handleProcessContentAdd(shape);
            	} else if(this.isDiagramInformation(shape)) {
            		this.handleDiagramInformationAdd(shape);
            	}
            }.bind(this));
        },
        
        /**
         * See comment in handleEditorLoad
         */
        enableTableLayouting: function() {
        	this.facade.registerOnEvent('layout.processdoctemplate.table.plain', this.handleLayoutTablePlain.bind(this));
        	
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, function(e) {
                switch(e.name) {
                    case "oryx-rows": 
                        this.handleRowChange(e);
                        break;
                    case "oryx-columns": 
                        this.handleColumnChange(e);
                        break;
                }
            }.bind(this));
        },
        
        /* END CUSTOM HANDLERS */
        /* START CONTAINMENT HANDLERS */
        
        /**
         * Ensures, that only one header and one footer exist per page.
         * @param element
         */
        handleHeaderFooterAdd: function(element) {
            var page = element.parent;
            var existing;
            
            if(this.isHeader(element)) {
                existing = page.getChildShapes().find(this.isHeader);
            } else {
                existing = page.getChildShapes().find(this.isFooter);
            }
            
            if(existing && existing !== element) {
                this.removeSilently(element, existing);
            }
        },
        
        handleDiagramInformationAdd: function(info) {
        	
            var checkFn = function(parent) {
                if(this.isDiagramIterator(parent)) {
                    info.setProperty("scope", SCOPE_DIAGRAM);
                    
                    return true;
                } else if(parent === this.facade.getCanvas()) {
                    info.setProperty("scope", SCOPE_GLOBAL);
                }
            };
            
            return this.containmentAllowed(info, checkFn.bind(this));
        },
        
        diagramInformationContainmentAllowed: function(info) {
        	var checkFn = function(parent) {
                if(this.isDiagramIterator(parent)) {
                    return true;
                } else if(this.facade.getCanvas() === parent) {
                	throw $containmentError;
                }
            };
            
            return this.containmentAllowed(info, checkFn.bind(this));
        },
        
        /**
         * Checks whether the added content is valid,
         * where is was dropped.
         * 
         * @param content
         */
        handleProcessContentAdd: function(content) {
            var checkFn = Ext.emptyFn;
            
            if(this.isDiagramContent(content)) {
                checkFn = function(parent) {
                    if(this.isProcessIterator(parent)) {
                        if(content.hasProperty("scope")) {
                            content.setProperty("scope", SCOPE_PROCESS);
                        }
                        
                        return true;
                    }
                    if(this.isDiagramIterator(parent)) {
                        if(content.hasProperty("scope")) {
                            content.setProperty("scope", SCOPE_DIAGRAM);
                        }
                        
                        return true;
                    } else if(parent === this.facade.getCanvas()) {
                        throw $containmentError;
                    }
                };
            } else {
                checkFn = function(parent) {
                    if(this.isProcessIterator(parent)) {
                        content.setProperty("scope", SCOPE_PROCESS);
                        return true;
                    } else if(this.isDiagramIterator(parent)) {
                        content.setProperty("scope", SCOPE_DIAGRAM);
                        return true;
                    } else if(parent === this.facade.getCanvas()) {
                        content.setProperty("scope", SCOPE_GLOBAL);
                        return true;
                    }
                };
            }
            
            // i'm using the containment allowed function to acutally set 
            // a property.. not the best way to do it, but it suffices.
            this.containmentAllowed(content, checkFn.bind(this));
        },
        
        processContainmentAllowed: function(content) {
        	var checkFn = Ext.emptyFn;
            
            if(this.isDiagramContent(content)) {
                checkFn = function(parent) {
                    if(this.isProcessIterator(parent) || this.isDiagramIterator(parent)) {
                        return true;
                    } else if(parent === this.facade.getCanvas()) {
                        throw $containmentError;
                    }
                };
            } else {
                checkFn = function(parent) {
                    if(this.isProcessIterator(parent)
                    	|| this.isDiagramIterator(parent)
                    	|| parent === this.facade.getCanvas()) {

                    	return true;
                    }
                };
            }
            
            return this.containmentAllowed(content, checkFn.bind(this));
        },
        
        /**
         * Section containment is a little bit tricky.
         * For example process iterators cannot be contained
         * in a section, if it is a direct child of a page,
         * but they can be contained if the section is a 
         * child of a diagram iterator. 
         * 
         * This function checks for the correct containment
         * conditions after the shape has been added. 
         * 
         * @param section
         */
        sectionContainmentAllowed: function(section) {
        	var checkFn = Ext.emptyFn;
            
            if(this.isFolderIterator(section)) {
                checkFn = function(parent) {
                    if(this.isIterator(parent)) {
                        throw $containmentError;
                    }
                };
            } else if(this.isDiagramIterator(section)) {
                checkFn = function(parent) {
                    if(this.isIterator(parent) && !this.isFolderIterator(parent)) {
                        throw $containmentError;
                    }
                };
            } else if(this.isProcessIterator(section)) {
                checkFn = function(parent) {
                    if(this.isProcessIterator(parent)) {
                        throw $containmentError;
                    }
                    
                    return this.isDiagramIterator(parent);
                };
            }
            
            return this.containmentAllowed(section, checkFn.bind(this)); 
        },
        
        /* END CONTAINMENT HANDLERS */
        
        /**
         * Convenience function, that will create a header and a footer
         * on a newly added page, if the previous page defines them.
         * 
         * @param page
         */
        createHeaderAndFooter: function(page) {
            if(page.extended) {
                return;
            }
            
            page.extended = true;
            
            // only add existing headers and footer, if none are defined on that page
            var oldHeader = page.getChildShapes().find(this.isHeader);
            var oldFooter = page.getChildShapes().find(this.isFooter);
            
            if(oldHeader || oldFooter) {
                return;
            }
            
            var canvas = page.parent;
            var pages = canvas.getChildShapes().sortBy(function(child) {
                return child.bounds.upperLeft().y;
            });
            
            var previousPage = pages[pages.indexOf(page) - 1];
            
            if(previousPage) {
                var header = previousPage.getChildShapes().find(this.isHeader);
                var footer = previousPage.getChildShapes().find(this.isFooter);
                
                if(header) {
                    this.copyElement(header, page);
                }
                
                if(footer) {
                    this.copyElement(footer, page);
                }
            }
            
            // Each page is assigned a header and a footer element
            
            if(!header) {
            	this.addElement(page, "Header");
            }
            
            if(!footer) {
            	this.addElement(page, "Footer");
            }
            
            this.handleLayoutPage({ shape: page });
        },
        
        /**
         * This function will create a copy of the element handed in.
         * That means, that no reference is made, but new elements are
         * created and the properties of the original ones are applied 
         * to it. 
         * 
         * Thus changing the original will NOT affect the copy!
         * 
         * @param element
         * @param destination
         */
        copyElement: function(element, destination) {
            this.addElement(destination, element.getStencil().id(), function(copy) {
                this.applyProperties(copy, element.properties);
                
                copy.bounds.set(element.bounds);
                
                element.getChildShapes().each(function(child) {
                    this.copyElement(child, copy);
                }.bind(this));
            }.bind(this));
        },
        
        restoreFocus: function(elements, force) {
        	if(!(elements instanceof Array)) {
        		elements = [elements];
        	}
        	
        	var isTOCPart = elements.find(this.isTOCPart);
        	
            if(force || (!isTOCPart && !this.restoring)) {
            	this.restoring = true;
            	
                // due to toc creation elements tend to lose focus.
                // most of the time, the focus is restored to the
                // containing section. this sets the focus to the
                // element itself
            	
            	this.restoreFn = function() {
                    this.facade.setSelection(elements);
                    this.restoring = false;
                }.bind(this);
            	
                window.setTimeout(this.restoreFn, 800);
            }
        },
        
        /**
         * Can be called directly after a shape has been added. This function
         * first hides the element, so that no flickering UI takes place,
         * then waits a little bit, so all actions can be finished and finally
         * removes the elmenet. 
         * 
         * @param element
         */
        removeSilently: function(element, focusEl) {
        	if(this.rescueList.include(element)) {
        		// do not remove element this time
        		this.rescueList = this.rescueList.without(element);
        		
        		return;
        	}
        	
        	// No flickering UI
        	element.hide();
        	
        	window.setTimeout(function() {
        		// Wait a little bit, for all the other actions
    			// to finish
        		element.parent.remove(element, true);
        		
        		if(focusEl) {
        		    this.restoreFocus(focusEl);
        		}
        	}.bind(this), 200);
        },
        
        /**
         * In templates the containment methods provided by the framework
         * do not suffice, as they only check one level down. We need more than
         * that. 
         * 
         * This function can be used in order to do a custom containment check.
         * The fn callback will be called with each parent of the element. 
         * 
         * If you return true in the callback this will cause the whole function
         * to return true. If you return false or nothing, your callback will
         * be called with the next parent element. If you throw a $containmentError
         * within the callback, that means, that containment is not allowed and 
         * this function will return false.
         * 
         * @param element
         * @param fn
         * @returns {Boolean}
         */
        containmentAllowed: function(element, fn) {
            fn = fn instanceof Function ? fn : Ext.emptyFn;
            
        	if(!element.parent) {
        		// if no validation error has occurred up till now, 
        		// things should be ok
        		return true;
        	}
        	
        	try {
        		if(fn(element.parent) === true) {
        			// We can be sure, that this element can be added
        			// as some condition has been met.
        			return true;
            	}
        		
        	} catch(e) {
        		if(e === $containmentError) {
        			// A containment violation has occurred.
        			// This element must not be added.
        			return false;
        		}
        		
        		throw e;
        	}
        	
        	// No violation till now. -> Check the parent.
        	return this.containmentAllowed(element.parent, fn);
        },
        
        handleLayoutMeta: function(e) {
        	var shape = e.shape;
        	
            var labels = shape.getLabels().sortBy(function(label)  {
                return label.id.endsWith("text_title") ? -1 : 1;
            });
            
            labels.each(function(label) {
                label.registerOnChange(this.layoutLabels.bind(this, shape, labels));
            }.bind(this));
            
            this.layoutLabels(shape, labels);
        },
        
        /**
         * Positions labels of meta blocks correctly and appends 
         * a colon (:) to each title
         * 
         * @param container
         * @param labels
         */
        layoutLabels: function(container, labels) {
            var padding = 10;   // border padding
            var spacing = 10;   // word spacing
            
            // update the containing shape in order to have
            // the labels up to date.
            container._update(true);
            
            labels.each(function(label) {
                if(label.id.endsWith("text_title")) {
                    if(!label.text().endsWith(":")) {

                        label.text(label.text() + ":");
                        // this update is necessary in order for getWidth
                        // to be calculated correctly
                        this.updateLabel(label);
                    }
                    
                    if(container.getProperty("show_label")) {
                        label.setX(padding);
                    
                        // this update is necessary in order to the
                        // padding change to take effect
                        this.updateLabel(label);
                        
                        padding += label.getWidth() + spacing;
                    }
                } else {
                    if(!label.text().startsWith("<")) {
                    	label.text("<" + label.text());
                    }
                    
                    if(!label.text().endsWith(">")) {
                    	label.text(label.text() + ">");
                    }
                    
                    label.setX(padding);
                    
                    // this update is necessary in order for getWidth
                    // to be calculated correctly
                    this.updateLabel(label);
                    
                    padding += label.getWidth() + spacing;
                }
            }.bind(this));
            
            var ul = container.bounds.upperLeft();
        
            container.bounds.set(
                ul,
                {
                    x: ul.x + Math.max(padding, container.minimumSize.width),
                    y: ul.y + container.bounds.height()
                }   
            );
            
            this.facade.updateSelection();
        },
        
        /**
         * Puts the header and the footer in the right place.
         * 
         * @param page
         */
        layoutHeaderFooter: function(page) {
        	var children = page.getChildShapes();
        	
        	var header = children.find(this.isHeader);
            var footer = children.find(this.isFooter);
            
            // move header and footer to top and bottom of the page
            if(header) header.bounds.moveTo(0,0);
            if(footer) footer.bounds.moveTo(0, page.bounds.height()-footer.bounds.height());
        },
        
        handleLayoutAttribute: function(shape, label) {
            this.resize(shape, label.getWidth(), shape.bounds.height());
            
            this.facade.getCanvas().update();
            this.facade.updateSelection();
        },
        
        /**
         * Reorganizes the meta blocks on the cover page after they have been added. 
         * 
         * @param parent
         * @param blocks
         */
        moveMetaBlocks: function(parent, blocks) {
            blocks = blocks.sort(this.visualSort);
            
            var padding = 30;
            var position = {
                left: [],
                center: [],
                right: []
            };
            
            blocks.each(function(block) {
                var dist = this.getDistances(parent, block);
                
                if(dist.left < dist.right && dist.left < dist.center) {
                    position.left.push({
                        el: block,
                        x: padding,
                        position: "left"
                    });
                } else if(dist.right < dist.left && dist.right < dist.center) {
                    position.right.push({
                        el: block,
                        x: parent.bounds.width() - padding - block.bounds.width(),
                        position: "right"
                    });
                } else {
                    position.center.push({
                        el: block,
                        x: parent.bounds.center().x - block.bounds.width()/2 - parent.bounds.upperLeft().x,
                        position: "center"
                    });
                }
            }.bind(this));

            var option = {
                y: 400,
                maxY: 500,
                padding: padding
            };
            
            this.placeInRows(position.left, option);
            this.placeInRows(position.center, option);
            this.placeInRows(position.right, option);
        },
        
        getDistances: function(container, element) {
            return {
                left: element.bounds.upperLeft().x,
                center: Math.abs(element.bounds.center().x - container.bounds.width()/2),
                right: container.bounds.width() - element.bounds.lowerRight().x
            };
        },
        
        /**
         * When a new section is added a whole bunch of update events
         * is thrown. This is good, because all containing sections are 
         * then able to resize and to do fancy stuff. But this is also
         * bad because the TOC and the index numbering would be updated
         * several times, even though they are correct after the first update.
         * 
         * Thus, this functions ensures that index and numbering updates
         * only occur not more than once a second. This in turn is good,
         * becuase they are very expensive and would slow down the editor
         * big time.
         * 
         * @param shape     The shape, that has been added, modified, deleted
         * @param force     Screw everyone and do the f*cking update!
         */
        requestIndexRefresh: function(shape, force) {
        	if(this.refreshingIndex) {
        		window.clearTimeout(this.refreshingIndex);
        	}
        	
    		this.refreshingIndex = window.setTimeout(function() {
    			this.updateSectionNumbering(shape.parent);
        		this.updateTOC(shape);
        		this.facade.getCanvas().update();
        		
        		if(this.restoreFn) {
        			this.restoreFn();
        		}
    		}.bind(this), 1);
        },
        
        createElement: function(id) {
        	if(!id.startsWith("http://www.signavio.com/stencilsets/processdoctemplate#")) {
        		id = "http://www.signavio.com/stencilsets/processdoctemplate#" + id;
        	}
        	
        	return this.facade.createShape({
        		namespace: "http://www.signavio.com/stencilsets/processdoctemplate",
        		type: id
        	});
        },
        
        addElement: function(parent, elementId, fn, silent) {
        	fn = fn instanceof Function ? fn : Ext.emptyFn;
        	
        	var child = this.createElement(elementId);
        	
        	parent.add(child, undefined, silent);
        	fn(child);
        	
        	return child;
        },
        
        flattenElement: function(element) {
        	if(!element) {
        		return [];
        	}
        	
        	var children = [];
        	
        	// ensure all columns/rows are direct children of the table node
        	element.getChildShapes(false, function(directChild){
            	children.push(directChild);
            	
                directChild.getChildShapes(true).each(function(indirectChild) {
                    directChild.remove(indirectChild);
                    element.add(indirectChild);
                    
                    children.push(indirectChild);
                    
                    if(indirectChild.bounds.upperLeft().x > 0) {
                        indirectChild.bounds.moveTo(directChild.bounds.upperLeft().x+1, 0); // move to the right of the direct child
                    } else { 
                        indirectChild.bounds.moveTo(directChild.bounds.upperLeft().x-1, 0); // move to the left of the direct child
                    }
                });
            });
        	
            return children;
        },
        
        findElement: function(element, selectFn) {
            selectFn = selectFn instanceof Function ? selectFn : Ext.emptyFn;
            
        	while(element && !selectFn(element)) {
        		element = element.parent;
        	}
        	
        	return element;
        },
        
        handleRowChange: function(event) {
        	var table = this.findElement(event.elements.first(), this.isTable);
        	
        	this.addRows(table, event.value);
        },
        
        handleColumnChange: function(event) {
        	var table = this.findElement(event.elements.first(), this.isTable);
        	
        	this.addColumns(table, event.value);
        },
        
        removeChildren: function(parent, sortFn, selectorFn, fn) {
        	fn = fn instanceof Function ? fn : Ext.emptyFn;
        	
        	parent.getChildShapes()
        		  .sort(sortFn)
        		  .select(selectorFn)
        		  .each(function(child) {
        			  fn(child);
        			  parent.remove(child);
        		  });
        },
        
        /**
         * Sets a bunch of properties not using the setProperty function in order to
         * avoid the propertyChanged event.
         * 
         * @param element
         * @param props
         */
        applyProperties: function(element, props) {
        	var overflowProps = {};
        	
        	$H(props).keys().each(function(key) {
                if(element.hasProperty(key)) {
                    element.properties[key] = props[key] !== undefined ? props[key] : "";
                    element.propertiesChanged[key] = props[key] !== undefined;
                } else {
                	overflowProps[key] = props[key];
                }
			});
			
        	// Uh, uh.. Private functions!
        	// I use this, in order to avoid the PROPERTY_CHANGED
        	// to be fired each time
        	element._changed();
        	element._update();
        	
        	return overflowProps;
        },
        
        /**
         * Sorts elements from top to bottom and left to right.
         * 
         * @param a
         * @param b
         * @returns
         */
        visualSort: function(a,b) {
        	var ua = a.bounds.upperLeft();
        	var ub = a.bounds.upperLeft();
			  
			return ua.y < ub.y ? -1 :		// First sort according to vertical order
				   ua.y > ub.y ? 1 :
					   ua.x < ub.x ? -1 :	// then horizontal
				  	   ua.x > ub.x ? 1 :
				  		   0;
        },
        
        addRows: function(table, count) {
        	this.createTableElements(table, "TableRow", this.isRow, count);
        },
        
        addColumns: function(table, count) {
        	var minimumSize = 40;
        	
        	if(table.bounds.width() / count < minimumSize) {
        		count = Math.round(table.bounds.width() / minimumSize);
        	}
        	
        	this.createTableElements(table, "TableColumn", this.isColumn, count);
        },
        
        /**
         * First removes all elements of a given type from the table and rescues
         * their properties. After that {count}?new elements are created and
         * the properties are restored. 
         * 
         * @param table		Table to work on
         * @param name		Name of the stencil that should be created
         * @param selectFn	Selector function, to find child elements
         * @param count		Number of new elements to add to the table
         */
        createTableElements: function(table, name, selectFn, count) {
        	var props = [];
        	
        	this.removeChildren(table, this.visualSort, selectFn, function(child) {
        		props.push(child.properties);
        	});
    		
        	props.reverse();
        	
    		count.times(function() {
    			this.addElement(table, name, function(child) {
    				this.applyProperties(child, props.pop() || {});
    			}.bind(this));
    		}.bind(this));
        },
        
        /**
         * Computes the column width, columns should be set to, that 
         * _do not_ have a fixed width set. 
         * 
         * @param table		Table to work on
         * @param columns	All columns of the table
         * @param indeces	Index columns of the table (won't be resized)
         * @returns {Number}
         */
        computeColumnWidth: function(table, columns, indeces) {
        	var availableSpace = 100;
            var preSizedColumns = 0;
            var minimumWidth = 25;
            var equalWidth = table.bounds.width();
            
            columns.each(function(column, index) {
            	var width = column.getProperty("width");
            	var pixelWidth = (table.bounds.width() * width) / 100;
            	
            	if(width > 0 
            			&& pixelWidth > minimumWidth 
            			&& availableSpace - width > 0 
            			&& equalWidth > minimumWidth) {
            		
            		availableSpace -= width;
            		++preSizedColumns;
            	} else if(column.hasProperty("width")) {
        			column.setProperty("width", 0);
            	}
            	
            	// OK, that's kinda tricky. 
            	// If a width smaller than the minimum width of the column stencil would be assigned
            	// resizing to a greater value doesn't work anymore. What we are doing here
            	// is basically ensuring, that this does not happen. 
                if(this.getEqualWidth(table, columns, availableSpace, preSizedColumns, indeces) <= minimumWidth) {
                	availableSpace += width;
                	preSizedColumns--;
                	column.setProperty("width", 0);
                }
                
                equalWidth = this.getEqualWidth(table, columns, availableSpace, preSizedColumns, indeces);
            }.bind(this));
            
            return equalWidth;
        },
        
        getEqualWidth: function(table, columns, availableSpace, preSizedColumns, indeces) {
        	if(availableSpace <= 0) {
        		availableSpace = 100;
        		preSizedColumns = 0;
        	}
        	
        	var indecesCount = indeces.size();
        	var resizeableColumCount = columns.length - preSizedColumns;
            var resizeableSpace = (table.bounds.width() * availableSpace) / 100;
            
            return (resizeableSpace - indecesCount * ((indecesCount > 0) ? indeces.first().bounds.width() : 0)) / (resizeableColumCount - indecesCount);
        },
        
        /**
         * In order for columns to be visible, they have to come after
         * rows in the dom. This function will sort the rows and columns
         * in a way, that columns come always last and are also sorted
         * from top to bottom and from left to right. 
         * 
         * @param table		Table to work on
         * @param children	All children of the table
         */
        restoreVisibleOrder: function(table, children) {
        	if(!this.isStaticTable(table)) {
        		// As only static tables have rows, this sorting must not 
        		// be applied, if the table isn't a static one.
        		return;
        	}
        	
        	children.sort(function(a, b) {
        		return this.isRow(a) && !this.isRow(b) ? -1 :
        			   !this.isRow(a) && this.isRow(b) ? 1 :
        				   this.isRow(a) ? (
        				       a.bounds.x < b.bounds.x ? -1 :
        				       a.bounds.x > b.bounds.x ? 1 :
        				    	   0
        				   ) : this.isColumn(a) ? (
        			           a.bounds.y < b.bounds.y ? -1 :
        			           a.bounds.y > b.bounds.y ? 1 :
        			        	   0
        				   ) : 0;
        	}.bind(this)).each(function(child) {
        		// add children in the order, that columns come after rows
        		// this is needed, in order to show the stroke of columns
        		table.remove(child);
        		table.add(child);
        	});
        },
        
        /**
         * If row or column count on a table has changed, update
         * the belonging properties. 
         * 
         * @param table		Table to work on
         * @param rows		All rows of the table
         * @param columns	All columns of the table
         */
        updateTable: function(table, rows, columns) {
        	if(table.hasProperty("rows") && table.hasProperty("columns")) {
        		table.properties["oryx-rows"] = rows.size();
                table.propertiesChanged["oryx-rows"] = true;
                
                table.properties["oryx-columns"] = columns.size();
                table.propertiesChanged["oryx-columns"] = true;
                
                table._changed();
        	}
        	
            table._update();
        },
        
        placeInRows: function(elements, option) {
            var y = option.y;
            var maxY = option.maxY;
            
            elements.sortBy(function(element) {
                return element.el.bounds.upperLeft().y;
            }).each(function(element, index) {
                element.el.bounds.moveTo(element.x, y);
                element.el.setProperty("position", element.position);
                element.el.setProperty("row", index);
                
                y = Math.min(y + option.padding, maxY);
            });
        },
        
        resize: function(element, width, height) {
        	var minWidth = element.minimumSize.width;
        	var minHeight = element.minimumSize.height;
        	
        	element.bounds.set({
    			a: {
    				x: element.bounds.a.x,
    				y: element.bounds.a.y
    			},
    			b: {
    				x: element.bounds.a.x + (width > minWidth ? width : minWidth),
    				y: element.bounds.a.y + (height > minHeight ? height : minHeight) 
    			}
    		});
        },
        
        getSectionNumber: function(section, prefix, i) {
        	if(section.getProperty("numberstyle") === "roman") {
        		var result = "";
        		
        		ROMAN_KEY_VALUES.each(function(key, index) {
        			while(i >= key) {
        				i = i - key;
        				result = result + ROMAN_VALUES[index];
        			}
        		});
        		
        		return prefix + result;
        	}

        	return prefix + i;
        },
        
        updateSectionNumbering: function(parent) {
            var prefix = "";
            var that = this;
            
            if(parent && this.isSection(parent)) {
            	if(parent.getProperty("includeinnumbering")) {
	                // parent is a section: use its index as the starting prefix
	                var index = parent.getProperty("indexnumber");
	                
	                prefix = index + ".";
            	} 
            }
            
            var sections = [];
            if(parent) {
            	sections = parent.getChildShapes().select(this.isSection); 
            } else {
                parent = this.facade.getCanvas();
            	var pages = parent.getChildShapes().select(this.isPage);
            	
            	pages.each(function(page) {
            		sections = sections.concat(page.getChildShapes().select(that.isSection));
            	});
            }
            
            var i = 1;
            sections.sortBy(function(child) { 
                return child.absoluteBounds().upperLeft().y;
            }).each((function(child) {
            	if(child.getProperty("includeinnumbering")) {
            		child.setProperty("indexnumber", prefix + i);
            		child.setProperty("visibleindexnumber", that.getSectionNumber(child, prefix, i));
            		
            		var padding = 15;
            		
            		if(that.isIterator(child)) {
            			// create the following numbers, that will
            			// be displayed after each iterator section
            			var following = "";

            			(2).times(function() {
            				++i;
            				following = following + that.getSectionNumber(child, prefix, i) + "...\n";
            			});
            			
            			child.setProperty("followpages", following);
            		} 
            		
            		child.getLabels().each(function(label) {
            			if(label.id.endsWith("text_name")) {
            				// move label to correct position behind index number
            				label.setX(that.computeSectionTitlePadding(padding, child.getProperty("visibleindexnumber")));
            				
            				that.updateLabel(label);
            			}
            		});
            		
                    ++i;
            	} else {
            	    if(that.isIterator(child)){
            	        child.setProperty("followpages", "");
            	    }
            		
            		child.getLabels().each(function(label) {
            			if(label.id.endsWith("text_name")) {
            				label.setX(0);
            				
            				that.updateLabel(label);
            			}
            		});
            	}
            	
            	that.updateSectionNumbering(child);
            }));
        },
        
        computeSectionTitlePadding: function(basePadding, prefix) {
            var parts = prefix.split(".");
            var extraPadding = 10;
            
            // inset title with each level
            basePadding = basePadding * parts.length;
            
            // for every index number, that is
            // greater than 9 add some extra space
            parts.each(function(part) {
                if(part.length > 1) {
                    basePadding = basePadding + extraPadding;
                }
            });
            
            return basePadding;
        },
        
        updateTOC: function(shape) {
        	var canvasChildren = this.facade.getCanvas().getChildShapes();
        	
        	var pages = canvasChildren.select(this.isPage);
        	var toc = canvasChildren.find(this.isTOC);
        	var sections = [];
        	
        	var that = this;
        	
        	pages.sortBy(function(page) {
        	    return page.bounds.upperLeft().y;
        	}).each(function(page) {
        		sections = sections.concat(page.getChildShapes()
        		                               .select(function(section) {
        		                                   return that.isSection(section) && that.inTOC(section);
        		                               })
        		                               .sortBy(function(section) {
        		                                   return section.bounds.upperLeft().y;
        		                               }));
        	});
        	
        	if(toc) {
                this.cleanTOC(toc, true);
                
                if(sections.length > 0 && toc.getProperty("preview")) {
                    toc.setProperty("description", "");
                    var topSpacing = 115;
                    var itemCount = this.createTOCItems(toc, sections);
                    var sample = toc.getChildShapes().find(this.isTOCPart);
                    var height = topSpacing + (itemCount * sample.bounds.height()) + 75; 

                    this.resize(toc, toc.bounds.width(), height);
                } else if(toc.getProperty("preview")){
                    toc.setProperty("description", Signavio.I18N.ProcessTemplates.tocToolTip);
                }
                
        		toc._update(true);
        	}
        },
        
        cleanTOC: function(toc, silent) {
            toc.getChildShapes().reject(function(child) {
        	    return this.isHeader(child) || this.isFooter(child);
        	}.bind(this)).each(function(child) {
        	    toc.remove(child, silent);
        	});
        },
        
        inTOC: function(section) {
        	return section.getProperty("includeintoc");
        },
        
        getSectionTitle: function(section) {
        	var isNumbered = section.getProperty("includeinnumbering");
    		
    		var title = section.getProperty("title");
    		var index = section.getProperty("visibleindexnumber");
    		
    		return (isNumbered ? index + " " : "") + title;
        },
        
        createTOCItems: function(toc, sections, level, position) {
        	level = level === undefined ? 1: level;
        	position = position === undefined ? 0 : position;
        	var hPadding = 20;
        	var vPadding = 30;
        	var topSpacing = 115;
        	var that = this;
        	
        	sections.each(function(section) {
        		var title = that.getSectionTitle(section);
        		
        		that.addElement(toc, "TOCPart", function(part) {
        			part.setProperty("title", title);
        			part.bounds.set({
        				a: {
        					x: level * hPadding,
        					y: topSpacing + (position * vPadding)
        				},
        				b: {
        					x: (level * hPadding) + part.bounds.width(),
        					y: topSpacing + (position * vPadding) + part.bounds.height()
        				}
        			});
        		}, true);
        		
        		var subsections = section.getChildShapes()
        		                         .select(that.isSection)
        		                         .select(that.inTOC)
        		                         .sortBy(function(child) {
        		                             
        			return child.bounds.upperLeft().y;
        		});
        		
        		position = that.createTOCItems(toc, subsections, level + 1, position + 1);
        		
        		if(that.isIterator(section)) {
        			var index = section.getProperty("indexnumber");
        			var isNumbered = section.getProperty("includeinnumbering");
        			var indeces = index.split(".");
        			var i = parseInt(indeces.last());
        			var stem = "";
        			
        			if(isNumbered) {
        			    // Sorry for that. Hard to maintain, but seriously, why would you?
            			stem = index.slice(0, Math.max(index.lastIndexOf(indeces.last()) - 1, 0));
        			}
        			
        			(2).times(function() {
        				i++;
        				that.addElement(toc, "TOCPart", function(part) {
        					part.setProperty("title", (isNumbered ? stem + (stem ? "." : "") + that.getSectionNumber(section, "", i) : "") + " ...");
        					part.bounds.set({
                				a: {
                					x: level * hPadding,
                					y: topSpacing + (position * vPadding)
                				},
                				b: {
                					x: (level * hPadding) + part.bounds.width(),
                					y: topSpacing + (position * vPadding) + part.bounds.height()
                				}
                			});
        				}, true);
        				position++;
        			});
        		}
        	});
        	
        	return position;
        },
        
        translate: function() {
            var language = ORYX.I18N.Language.split("_").first();
            
            return function(shape) {
                var stencil = shape.getStencil();
                var changed = false;
                
                stencil.properties().each(function(property) {
                    var json = property._jsonProp;
                    
                    if(json["value_" + language]) {
                        changed = true;
                        
                        var key = property.prefix() + "-" + property.id();
                        var value = json["value_" + language];

                        if(!property.readonly()) {
                            value = shape.properties[key] || value;
                        }
                        
                        shape.properties[key] = value;
                        shape.propertiesChanged[key] = true;
                    }
                });
                
                if(changed) {
                    shape._changed();
                    shape._update();
                }
            };
        }(),
        
        /* START IDENTITY FUNCTIONS */
        
        isText: function() {
            return getCheckFn("FreeText");
        }(),
        
    	isMeta: function() {
        	return getCheckFn("MetaBlock");
        }(),
        
        isHeader: function() {
        	return getCheckFn("Header");
        }(),
        
        isHeaderFooterAttribute: function() {
            var stencils = ["Version",
                            "FileName",
                            "Date",
                            "LastModified",
                            "HeaderFooterText",
                            "PageNumber"];
            
            return getCheckFn(stencils);
        }(),
        
        isHeaderFooterFreeText: function() {
        	return getCheckFn("HeaderFooterText");
        }(),
        
        isPageNumber: function() {
        	return getCheckFn("PageNumber");
        }(),
        
        isFooter: function() {
        	return getCheckFn("Footer");
        }(),
        
        isCoverPage: function() {
        	return getCheckFn("CoverPage");
        }(),
        
        isTable: function() {
        	var stencils = ["TableActivities",
        	                "TableElements",
        	                "Table"];
        	
        	return getCheckFn(stencils);
        }(),
        
        isStaticTable: function() {
        	return getCheckFn("Table");
        }(),
        
        isColumn: function(element) {
        	var stencils = ["TableColumn",
        	                "TableElementsIndex",
        	                "TableElementsAttribute",
        	                "TableElementsAttributeMulti",
        	                "TableElementsElementType",
        	                "TableElementsDataObjects",
        	                "TableElementsITSystems",
        	                "TableElementsRoles",
        	                "TableElementsGlossary"];
        	
        	return getCheckFn(stencils);
        }(),
        
        isRow: function() {
        	return getCheckFn("TableRow");
        }(),
        
        isListRow: function() {
        	var stencils = ["ListElementsAttribute",
        	                "ListElementsAttributeMulti",
        	                "ListElementsElementType",
        	                "ListElementsDataObjects",
        	                "ListElementsITSystems",
        	                "ListElementsRoles",
        	                "ListElementsGlossary"];
        	
        	return getCheckFn(stencils);
        }(),
        
        isIndexColumn: function() {
        	return getCheckFn("TableElementsIndex");
        }(),
        
        isMultiColumn: function() {
        	return getCheckFn("TableElementsAttributeMulti");
        }(),
        
        isIterator: function() {
        	var stencils = ["SectionPerProcess",
        	                "SectionPerDiagram",
        	                "SectionPerFolder"];
        	
        	return getCheckFn(stencils);
        }(),
        
        isSection: function() {
        	var stencils = ["Section",
        	                "SectionPerProcess",
        	                "SectionPerDiagram",
        	                "SectionPerFolder"];
        	
        	return getCheckFn(stencils);
        }(),
        
        isProcessContent: function() {
        	var stencils = ["DiagramAttribute",
        	                "DiagramAttributeMulti",
                            "AttributeDescription",
        	                "Participants",
        	                "DataObjects",
        	                "ITSystems",
        	                "ProcessTriggers",
        	                "ProcessResults",
        	                "GlossaryEntries",
        	                "TableElements",
        	                "ListElements",
        	                "DiagramImage"];
        	
        	return getCheckFn(stencils);
        }(),
        
        isMultiDiagramAttribute: function() {
        	return getCheckFn("DiagramAttributeMulti");
        }(),
        
        isDiagramContent: function() {
            var stencils = ["DiagramImage",
                            "DiagramAttribute",
                            "DiagramAttributeMulti",
                            "AttributeDescription",
                            "TableElements",
                            "ListElements"];
            
            return getCheckFn(stencils);
        }(),
        
        isDiagramInformation: function() {
            var stencils = ["TableOrigin",
                            "TableRevisions"];
            
            return getCheckFn(stencils);
        }(),
        
        isPage: function() {
        	var stencils = ["CoverPage",
        	                "TableOfContents",
        	                "FollowingPage"];
        	
        	return getCheckFn(stencils);
        }(),
        
        isTOC: function() {
        	return getCheckFn("TableOfContents");
        }(),
        
        isTOCPart: function() {
            return getCheckFn("TOCPart");
        }(),
        
        isList: function() {
            var stencils = ["ListElements",
                            "Participants",
                            "DataObjects",
                            "ITSystems",
                            "ProcessTriggers",
                            "ProcessResults",
                            "GlossaryEntries"];
            
        	return getCheckFn(stencils);
        }(),
        
        isDiagramIterator: function() {
        	return getCheckFn("SectionPerDiagram");
        }(),
        
        isProcessIterator: function() {
        	return getCheckFn("SectionPerProcess");
        }(),
        
        isFolderIterator: function() {
        	return getCheckFn("SectionPerFolder");
        }()
        
    	/* END IDENTITY FUNCTIONS */
    });
}());/**
 * Copyright (c) 2011 Signavio
 * @author Philipp Giese
 **/

if(!Signavio) { var Signavio = {}; }
if (!Signavio.Plugins) { Signavio.Plugins = {}; }

(function() {
	
	Signavio.Plugins.SwissPostSupport = Clazz.extend({
		
		facade: undefined,
		
		construct: function(facade) {
			this.facade = facade;
			
			var jsonProp = {
				id: "swissPost",
				title: "Swiss Post",
				title_de: "Swiss Post",
				value: "swissPost",
				refToView: "swiss-post"
			};
			
			this.createPropertyFor("Header", jsonProp);
			this.createPropertyFor("Footer", jsonProp);
		},
		
		createPropertyFor: function(stencilId, jsonProp) {
			var ns = "http://www.signavio.com/stencilsets/processdoctemplate#";
			var stencilset = this.facade.getStencilSets()[ns];
			
			var stencil = stencilset.stencil(ns + stencilId);
			var property = stencil.property("oryx-style");
			
			property._items[jsonProp.id] = new ORYX.Core.StencilSet.PropertyItem(jsonProp, ns, property);
            
            stencil.property("oryx-showswisspost")._jsonProp.value = true;
		}
		
	});
	
}());/**
 * Copyright (c) 2011 Signavio
 * @author Philipp Giese
 **/

if(!Signavio) { var Signavio = {}; }
if (!Signavio.Plugins) { Signavio.Plugins = {}; }

(function() {
	
	Signavio.Plugins.KaiserKraftSupport = Clazz.extend({
		
		facade: undefined,
		
		construct: function(facade) {
			this.facade = facade;
			
			var jsonProp = {
				id: "kaiserKraft",
				title: "Kaiser Kraft",
				title_de: "Kaiser Kraft",
				value: "kaiserKraft",
				refToView: "kaiser-kraft"
			};
			
			this.createPropertyFor("Header", jsonProp);
			this.createPropertyFor("Footer", jsonProp);
		},
		
		createPropertyFor: function(stencilId, jsonProp) {
			var ns = "http://www.signavio.com/stencilsets/processdoctemplate#";
			var stencilset = this.facade.getStencilSets()[ns];
			
			var stencil = stencilset.stencil(ns + stencilId);
			var property = stencil.property("oryx-style");
			
			property._items[jsonProp.id] = new ORYX.Core.StencilSet.PropertyItem(jsonProp, ns, property);
            
            stencil.property("oryx-showkaiserkraft")._jsonProp.value = true;
		}
		
	});
	
}());/**
 * Copyright (c) 2011 Signavio
 * @author Philipp Giese
 **/

if(!window.Signavio) { window.Signavio = {}; }
if(!Signavio.Plugins) { Signavio.Plugins = {}; }

(function() {
	
	Signavio.Plugins.RemoveSignavioBranding = Clazz.extend({
		
		facade: undefined,
		
		construct: function(facade) {
			this.facade = facade;
			
			var jsonProp = {
				id: "none",
				title: "Own",
				title_de: "Eigener",
				value: "none",
				refToView: "none"
			};
			
			this.createPropertyFor("Header", jsonProp);
			this.createPropertyFor("Footer", jsonProp);
		},
		
		createPropertyFor: function(stencilId, jsonProp) {
			var ns = "http://www.signavio.com/stencilsets/processdoctemplate#";
			var stencilset = this.facade.getStencilSets()[ns];
			
			var stencil = stencilset.stencil(ns + stencilId);
			var property = stencil.property("oryx-style");
			
			property._items[jsonProp.id] = new ORYX.Core.StencilSet.PropertyItem(jsonProp, ns, property);
			property._jsonProp.value = jsonProp.value;
			
			stencil.property("oryx-shownone")._jsonProp.value = true;
		}
		
	});
	
}());/**
 * Copyright (c) 2008, Gero Decker, refactored by Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

/**
   This plugin is a generic syntax checker for different diagram types.
   Needs server communication.
   @class ORYX.Plugins.SyntaxChecker
   @constructor Creates a new instance
   @extends ORYX.Plugins.AbstractPlugin
*/
ORYX.Plugins.SyntaxChecker = ORYX.Plugins.AbstractPlugin.extend({
    /**@private*/
    construct: function(){
        arguments.callee.$.construct.apply(this, arguments);
                
        this.active = false;
        this.raisedEventIds = [];
        
        this.facade.offer({
            'name': ORYX.I18N.SyntaxChecker.name,
            'functionality': this.perform.bind(this),
            'group': ORYX.I18N.SyntaxChecker.group,
            'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/chart_curve_error.png",
            'description': ORYX.I18N.SyntaxChecker.desc,
            'index': 0,
            'toggle': true,
            'minShape': 0,
            'maxShape': 0
        });
        
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT, this.checkForErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT, this.resetErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT, this.doShowErrors.bind(this));
    },
    
    perform: function(button, pressed){
        if (!pressed) {
            this.resetErrors();
        } else {
            this.checkForErrors({
                onNoErrors: function(){
                    this.setActivated(button, false);
                    this.facade.raiseEvent({
            			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
            			text:ORYX.I18N.SyntaxChecker.noErrors,
            			timeout:10000
            		});
                    //Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SyntaxChecker.noErrors);
                }.bind(this),
                onErrors: function(){
                    this.enableDeactivationHandler(button);
                }.bind(this),
                onFailure: function(){
                    this.setActivated(button, false);
                    Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SyntaxChecker.invalid);
                }.bind(this)
            });      
        }
    },
    
    /**
     * Registers handler for deactivating syntax checker as soon as somewhere is clicked...
     * @param {Ext.Button} Toolbar button
     */
    enableDeactivationHandler: function(button){
        var deactivate = function(){
            this.setActivated(button, false);
            this.resetErrors();
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate);
        };
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate.bind(this));
    },
    
    /**
     * Sets the activated state of the plugin
     * @param {Ext.Button} Toolbar button
     * @param {Object} activated
     */
    setActivated: function(button, activated){
        button.toggle(activated);
        if(activated === undefined){
            this.active = !this.active;
        } else {
            this.active = activated;
        }
    },
    
    /**
     * Performs request to server to check for errors on current model.
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Object} options Configuration hash
     * @param {String} context A context send to the syntax checker servlet
     * @param {Function} [options.onNoErrors] Raised when model has no errors.
     * @param {Function} [options.onErrors] Raised when model has errors.
     * @param {Function} [options.onFailure] Raised when server communcation failed.
     * @param {boolean} [options.showErrors=true] Display errors on nodes on canvas (by calling ORYX.Plugins.SyntaxChecker.prototype.showErrors)
     */
    checkForErrors: function(options){
        Ext.applyIf(options || {}, {
          showErrors: true,
          onErrors: Ext.emptyFn,
          onNoErrors: Ext.emptyFn,
          onFailure: Ext.emptyFn
        });
            
        Ext.Msg.wait(ORYX.I18N.SyntaxChecker.checkingMessage);

		var ss = this.facade.getStencilSets();
		var data = null;
		var url = ORYX.CONFIG.SYNTAXCHECKER_URL;
		var params = {
			resource: location.href,
            context: options.context,
			isJson: false	
		};
		
		if(ss.keys().include("http://b3mn.org/stencilset/bpmn2.0#") ||
			ss.keys().include("http://b3mn.org/stencilset/bpmn2.0choreography#") ||
				ss.keys().include("http://b3mn.org/stencilset/bpmn2.0conversation#")) {
			
			params.data_json = this.facade.getSerializedJSON();
			params.ns = "http://b3mn.org/stencilset/bpmn2.0#";
			params.isJson = true;
		} else if (ss.keys().include("http://b3mn.org/stencilset/epc#")) {
			params.data_json = this.facade.getSerializedJSON();
			params.ns = "http://b3mn.org/stencilset/epc#";
			params.isJson = true;
		} else {
			params.data = this.getRDFFromDOM();
		}
        
        // Send the request to the server.
        new Ajax.Request(url, {
            method: 'POST',
            asynchronous: false,
            parameters: params,
            onSuccess: function(request){
                var resp = (request&&request.responseText?request.responseText:"{}").evalJSON();
                
                Ext.Msg.hide();
                
                if (resp instanceof Object) {
                    resp = $H(resp)
                    if (resp.size() > 0) {
                        if(options.showErrors) this.showErrors(resp);
                 
                        options.onErrors();
                    }
                    else {
                        options.onNoErrors();
                    }
                }
                else {
                    options.onFailure();
                }
            }.bind(this),
            onFailure: function(){
                Ext.Msg.hide();
                options.onFailure();
            }
        });
    },
    
    /** Called on SHOW_ERRORS_EVENT.
     * 
     * @param {Object} event
     * @param {Object} args
     */
    doShowErrors: function(event, args){
        this.showErrors(event.errors);
    },
    
    /**
     * Shows overlays for each given error
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Hash|Object} errors
     * @example
     * showErrors({
     *     myShape1: "This has an error!",
     *     myShape2: "Another error!"
     * })
     */
    showErrors: function(errors){
        // If normal object is given, convert to hash
        if(!(errors instanceof Hash)){
            errors = new Hash(errors);
        }
        
        // Get all Valid ResourceIDs and collect all shapes
        errors.keys().each(function(value){
            var sh = this.facade.getCanvas().getChildShapeByResourceId(value);
            if (sh) {
                this.raiseOverlay(sh, this.parseCodeToMsg(errors[value]));
            }
        }.bind(this));
        this.active = !this.active;
        
        //show a status message with a hint to the error messages in the tooltip
        this.facade.raiseEvent({
			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
			text:ORYX.I18N.SyntaxChecker.notice,
			timeout:10000
		});
    },
    parseCodeToMsg: function(code){
    	var msg = code.replace(/: /g, "<br />").replace(/, /g, "<br />");
    	var codes = msg.split("<br />");
    	for (var i=0; i < codes.length; i++) {
    		var singleCode = codes[i];
    		var replacement = this.parseSingleCodeToMsg(singleCode);
    		if (singleCode != replacement) {
    			msg = msg.replace(singleCode, replacement);
    		}
    	}
		
		return msg;
	},
	
	parseSingleCodeToMsg: function(code){
		return ORYX.I18N.SyntaxChecker[code]||code;
	},
    /**
     * Resets all (displayed) errors
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     */
    resetErrors: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }.bind(this))
        
        this.raisedEventIds = [];
        this.active = false;
    },
    
    raiseOverlay: function(shape, errorMsg){
        var id = "syntaxchecker." + this.raisedEventIds.length;
        var crossId = ORYX.Editor.provideId();
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
            "id":crossId,
            "title":"",
            "stroke-width": 5.0,
            "stroke": "red",
            "d": "M20,-5 L5,-20 M5,-5 L20,-20",
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	html:errorMsg,
        	target:crossId
        });
        
        this.raisedEventIds.push(id);
        
        return cross;
    }
});

ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT = "checkForErrors";
ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT = "resetErrors";
ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT = "showErrors";

ORYX.Plugins.PetrinetSyntaxChecker = ORYX.Plugins.SyntaxChecker.extend({
    /*FIXME:: BPMN + EPC syntax checker needs rdf, but petri nets needs erdf.
     * So we override getRDFFromDOM from AbstractPlugin to return erdf.
     */
    getRDFFromDOM: function(){
        return this.facade.getERDF();
    }
});/**
 * Copyright (c) 2009
 * Stefan Krumnow, Ole Eckermann
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.JPDLSupport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,
	
	
	stencilSetExtensionNamespace: 'http://oryx-editor.org/stencilsets/extensions/jbpm#',
	stencilSetExtensionDefinition: 'jbpm/jbpm.json',
	
	stencilSetNamespace: 'http://b3mn.org/stencilset/bpmn1.1#',
	stencilSetUrlSuffix: '/bpmn1.1/bpmn1.1.json',

	/**
	 * constructor method
	 * 
	 */
	construct: function(facade) {
		
		this.facade = facade;
			
		this.facade.offer({
			'name':				ORYX.I18N.jPDLSupport.exp,
			'functionality': 	this.exportJPDL.bind(this),
			'group': 			ORYX.I18N.jPDLSupport.group,
			'icon': 			ORYX.PATH + "images/jpdl_export_icon.png",
			'description': 		ORYX.I18N.jPDLSupport.expDesc,
			'index': 			1,
			'minShape': 		0,
			'maxShape': 		0,
			'maxShape': 		0,
			'isEnabled': 		this._isJpdlStencilSetExtensionLoaded.bind(this)
		});
					
		this.facade.offer({
			'name':				ORYX.I18N.jPDLSupport.imp,
			'functionality': 	this.importJPDL.bind(this),
			'group': 			ORYX.I18N.jPDLSupport.group,
			'icon': 			ORYX.PATH + "images/jpdl_import_icon.png",
			'description': 		ORYX.I18N.jPDLSupport.impDesc,
			'index': 			2,
			'minShape': 		0,
			'maxShape': 		0
		});

	},
	
	/**
	 * Checks if the jPDL stencil set is loaded right now.
	 */
	_isJpdlStencilSetExtensionLoaded: function() {
		return this.isStencilSetExtensionLoaded(this.stencilSetExtensionNamespace);
	},

	/**
	 * Imports jPDL
	 * 
	 */
	importJPDL: function(){
		this._showImportDialog();
	},		

	/**
	 * Exports jPDL
	 * 
	 */
	exportJPDL: function(){
		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
    		this._doExport();			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;

		
	},
	
	/**
	 * Sends request to a given URL.
	 * 
	 */
	_sendRequest: function( url, method, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(url, {
           method			: method,
           asynchronous	: false,
           parameters		: params,
		   onSuccess		: function(transport) {
				
				suc = true;
				
				if(successcallback){
					successcallback( transport.responseText )	
				}
				
			}.bind(this),
			
			onFailure		: function(transport) {

				if(failedcallback){
					
					failedcallback();
					
				} else {
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedReq);
					ORYX.log.warn("Import jPDL failed: " + transport.responseText);	
				}
				
			}.bind(this)		
		});
		
		return suc;		
	},
	
	/**
	 * Loads JSON into the editor
	 * 
	 */
	_loadJSON: function( jsonString ){
		
		if (jsonString) {
			var jsonObj = jsonString.evalJSON();
			if( jsonObj && this._hasStencilset(jsonObj) ) {
				if ( this._isJpdlStencilSetExtensionLoaded() ) {
					this.facade.importJSON(jsonString);
				} else {
					Ext.MessageBox.confirm(
						ORYX.I18N.jPDLSupport.loadSseQuestionTitle,
						ORYX.I18N.jPDLSupport.loadSseQuestionBody,
						function(btn){
							if (btn == 'yes') {
								
								if (this.loadStencilSetExtension(this.stencilSetNamespace, this.stencilSetExtensionDefinition)){
									this.facade.importJSON(jsonString);
								} else {
									this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedJson);
								}
								
							} else {
								this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedJsonAbort);
							}
						},
						this
					);
				}
				
			} else {
				this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedJson);
			}
		} else {
			this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedJson);
		}
	},
	
	loadStencilSetExtension: function(stencilSetNamespace, stencilSetExtensionDefinition) {
		var stencilset = this.facade.getStencilSets()[stencilSetNamespace];
		if (stencilset) {
			stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + stencilSetExtensionDefinition);
			this.facade.getRules().initializeRules(stencilset);
			this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_STENCIL_SET_LOADED});
			return true;
		} 
		return false;
	},
	
	/**
	 * Checks if a json object references the jPDL stencil set extension.
	 * 
	 */
	_hasStencilset: function( jsonObj ){
		return jsonObj.properties.ssextension == this.stencilSetExtensionNamespace && jsonObj.stencilset.url.endsWith(this.stencilSetUrlSuffix);
	},
	

	/**
	 * Opens an export window / tab.
	 * 
	 */
	_doExport: function(){
		var serialized_json = this.facade.getSerializedJSON();

		this._sendRequest(
			ORYX.CONFIG.JPDLEXPORTURL,
			'POST',
			{ data:serialized_json },
			function( result ) { 
				var parser = new DOMParser();
				var parsedResult = parser.parseFromString(result, "text/xml");
				if (parsedResult.firstChild.localName == "error") {
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.expFailedXml + parsedResult.firstChild.firstChild.data);
				} else {
					this.openXMLWindow(result);
				}
			}.bind(this),
			function() { 
				this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.expFailedReq);
		 	}.bind(this)
		)
	}, 
	
	/**
	 * Opens a upload dialog.
	 * 
	 */
	_showImportDialog: function( successCallback ){
	
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: [{
	            text : 		ORYX.I18N.jPDLSupport.selectFile, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	        },{
	            fieldLabel: ORYX.I18N.jPDLSupport.file,
	            name: 		'subject',
				inputType : 'file',
				style : 	'margin-bottom:10px;display:block;',
				itemCls :	'ext_specific_window_overflow'
	        }, {
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -63'  
	        }]
	    });

		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.jPDLSupport.impJPDL, 
			height: 	350, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text:ORYX.I18N.jPDLSupport.impBtn,
					handler:function(){
						
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.jPDLSupport.impProgress});
						loadMask.show();
						
						window.setTimeout(function(){
					
							var jpdlString =  form.items.items[2].getValue();
							
							this._sendRequest(
									ORYX.CONFIG.JPDLIMPORTURL,
									'POST',
									{ 'data' : jpdlString },
									function( arg ) { this._loadJSON( arg );  loadMask.hide();  dialog.hide(); }.bind(this),
									function() { loadMask.hide();  dialog.hide(); }.bind(this)
								);

						}.bind(this), 100);
			
					}.bind(this)
				},{
					text:ORYX.I18N.jPDLSupport.close,
					handler:function(){
						
						dialog.hide();
					
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});


		// Show the panel
		dialog.show();
		
				
		// Adds the change event handler to 
		form.items.items[1].getEl().dom.addEventListener('change',function(evt){
				var text = evt.target.files[0].getAsText('UTF-8');
				form.items.items[2].setValue( text );
			}, true)

	},
	
	_showErrorMessageBox: function(title, msg){
        Ext.MessageBox.show({
           title: title,
           msg: msg,
           buttons: Ext.MessageBox.OK,
           icon: Ext.MessageBox.ERROR
       });
	}
	
});/**
 * Copyright (c) 2009
 * Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
Ext.ns("Oryx.Plugins");

ORYX.Plugins.PetriNetSoundnessChecker = ORYX.Plugins.AbstractPlugin.extend({

    hideOverlays: function(){
        //TODO set in constructor!!!
        if(!this.overlayIds) 
            return;
    
        Ext.each(this.overlayIds, function(overlayId){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: overlayId
            });
        }.bind(this));
    },
    
    getChildShapesByResourceIds: function(resourceIds){
        var shapes = [];
    
        Ext.each(resourceIds, function(resourceId){
            shapes.push(this.facade.getCanvas().getChildShapeByResourceId(resourceId));
        }.bind(this));
        
        return shapes;
    },
    
    /**
       Show overlay on given shape.
       @methodOf ORYX.Plugins.AbstractPlugin.prototype
       @example
       showOverlay(
           myShape,
           { stroke: "green" },
           ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
               "title": "Click the element to execute it!",
               "stroke-width": 2.0,
               "stroke": "black",
               "d": "M0,-5 L5,0 L0,5 Z",
               "line-captions": "round"
           }])
       )
       @param {Oryx.XXX.Shape[]} shapes One shape or array of shapes the overlay should be put on
       @param {Oryx.XXX.Attributes} attributes some attributes...
       @param {Oryx.svg.node} svgNode The svg node which should be used as overlay
       @param {String} [svgNode="NW"] The svg node position where the overlay should be placed
    */
    showOverlay: function(shapes, attributes, svgNode, svgNodePosition ){
        if(!this.overlayIds){
            this.overlayIds = [];
        }
        
        if( !(shapes instanceof Array) ){
            shapes = [shapes]
        }
        
        // Define Shapes
        shapes = shapes.map(function(shape){
            var el = shape;
            if( typeof shape == "string" ){
                el = this.facade.getCanvas().getChildShapeByResourceId( shape );
                el = el || this.facade.getCanvas().getChildById( shape, true );
            }
            return el;
        }.bind(this)).compact();
        
        // Define unified id
        var overlayId = this.type + ORYX.Editor.provideId();
        this.overlayIds.push(overlayId);
        
        this.facade.raiseEvent({
            type        : ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id          : overlayId,
            shapes      : shapes,
            attributes  : attributes,
            node        : svgNode,
            nodePosition: svgNodePosition || "NW"
        });
        
    },

    // Offers the plugin functionality
    construct: function(facade){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
                
        this.facade.offer({
            'name': "Check soundness",//ORYX.I18N.BPMN2PNConverter.name,
            'functionality': this.showCheckerWindow.bind(this),
            'group': "Verification",
            'icon': ORYX.PATH + "images/checker_validation.png",
            'description': "Checks current Petri net for different soundness criteria.",
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    showCheckerWindow: function(){
        var plugin = this;
        
        var CheckNode = Ext.extend(Ext.tree.TreeNode, {
            constructor: function(config) {
                if(!config.icon && !this.icon)
                    config.icon = CheckNode.UNKNOWN_STATUS;

                CheckNode.superclass.constructor.apply(this, arguments);
                
                Ext.apply(this, config);
                
                if(this.clickHandler){
                    this.on('click', this.clickHandler.bind(this));
                }
            },

            setIcon: function(status) {
                this.ui.getIconEl().src = status;
            },
            getIcon: function(status) {
                return this.ui.getIconEl().src;
            },
            reset: function(){
                plugin.hideOverlays();
                this.hideMarking();
                // Reset syntax errors
                plugin.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
            },
            hideMarking: function(){
                if(!plugin.marking)
                    return;
            
                for(place in plugin.marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    if(placeShape)//place can be null if removed
                        placeShape.setProperty("oryx-numberoftokens", 0);
                }
                // Show changes
                plugin.facade.getCanvas().update();
                
                plugin.marking = undefined;
            },
            showMarking: function(marking){
                plugin.marking = marking;
            
                for(place in marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    placeShape.setProperty("oryx-numberoftokens", marking[place]);
                }
                // Show changes
                plugin.facade.getCanvas().update();
            },
            showErrors: function(errors){
                // Remove all old error nodes
                Ext.each(this.childNodes, function(child){
                    if(child && child.itemCls === 'error')
                        child.remove();
                });
                
                // Show Unknown status on child nodes
                Ext.each(this.childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
                
                // Show errors
                Ext.each(errors, function(error){
                    this.insertBefore(new CheckNode({
                        icon: CheckNode.ERROR_STATUS,
                        text: error,
                        itemCls: 'error'
                    }), this.childNodes[0]);
                }.bind(this));
            },
            showOverlayWithStep: function(shapeIds){
                Ext.each(shapeIds, function(shapeId, index){
                    plugin.showOverlay(
                        plugin.facade.getCanvas().getChildShapeByResourceId(shapeId), 
                        {
                            fill: "#FB7E02"//orange
                        },
                        ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                            "style": "font-size: 16px; font-weight: bold;"
                        }, (index + 1)+"."]),
                        "SE" //position in south east
                    );
                });
            },
            showOverlay: function(shapes){
                if(shapes.length === 0)
                    return;

                if(! shapes[0] instanceof ORYX.Core.Node)
                    shapes = plugin.getChildShapesByResourceIds(shapes)
            
                plugin.showOverlay(
                    shapes, 
                    {
                        fill: "#FB7E02"//orange
                    }
                );
            }
        });
        CheckNode.UNKNOWN_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'asterisk_yellow.png';
        CheckNode.ERROR_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'exclamation.png';
        CheckNode.OK_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'accept.png';
        CheckNode.LOADING_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'loading.gif';
        
        var DeadLocksNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Termination Criteria</b>: Makes sure that any process instance that starts in the initial state will eventually reach the final state. If any dead locks are detected, click to show one counter example.';
            
                DeadLocksNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
            
                if(this.deadLocks.length == 0) return;
                
                var deadLock = node.deadLocks[0];
                this.showOverlayWithStep(deadLock.path);
                this.showMarking(deadLock.marking);
            },
            update: function(deadLocks){
                this.deadLocks = deadLocks;
                this.setIcon(this.deadLocks.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There is '+(this.deadLocks.length == 0 ? 'no' : 'a')+' path that leads to a deadlock.');
            }
        });
        
        var ImproperTerminatingsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Proper Termination Criteria</b>: The final state is the only state reachable from the initial state in which there is a token in the final place. If any improper terminating states are detected, click to show one counter example.';
            
                ImproperTerminatingsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
            
                if(node.improperTerminatings.length == 0) return;
                
                var improperTerminating = node.improperTerminatings[0];
                this.showOverlayWithStep(improperTerminating.path);
                this.showMarking(improperTerminating.marking);
            },
            update: function(improperTerminatings){
                this.improperTerminatings = improperTerminatings;
                
                this.setIcon(this.improperTerminatings.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.improperTerminatings.length +' markings covering the final marking.');
            }
        });
        
        var DeadTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>No Dead Transitions Criteria</b>: Each transition can contribute to at least one process instance. Click to see all dead transitions.';
            
                DeadTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.deadTransitions);
            },
            update: function(deadTransitions){
                this.deadTransitions = deadTransitions;
                
                this.setIcon(this.deadTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.deadTransitions.length +' dead transitions.');
            }
        });
        
        var NotParticipatingTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Transition Participation Criteria</b>: Each transition participates in at least one process instance that starts in the initial state and reaches the final state. Click to see all transitions not participating in any process instance.';
            
                NotParticipatingTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.notParticipatingTransitions);
            },
            update: function(notParticipatingTransitions){
                this.notParticipatingTransitions = notParticipatingTransitions;
                
                this.setIcon(this.notParticipatingTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.notParticipatingTransitions.length +' transitions that cannot participate in a properly terminating firing sequence.');
            }
        });
        
        this.checkerWindow = new Ext.Window({
            title: 'Soundness Checker',
            autoScroll: true,
            width: '500',
            tbar: [
                {
                    text: 'Check', 
                    handler: function(){
                        this.checkerWindow.check();
                    }.bind(this)
                },
                {
                    text: 'Hide Errors', 
                    handler: function(){
                        this.checkerWindow.getTree().getRootNode().reset();
                    }.bind(this)
                },
                '->',
                {
                    text: 'Close', 
                    handler: function(){
                        this.checkerWindow.close();
                    }.bind(this)
                }
            ],
            getTree: function(){
                return this.items.get(0);
            },
            check: function(renderAll){
                this.prepareCheck(renderAll);
                this.checkSyntax(this.checkSoundness.bind(this));
            },
            prepareCheck: function(renderAll){//call with renderAll=true if showing for the first time
                var root = this.getTree().getRootNode();
                
                root.reset();
                
                // Set loading status to all child nodes
                Ext.each(root.childNodes, function(childNode){
                    if(renderAll)//this expands all nodes so they're rendered a first time
                        childNode.expand(true);
                    childNode.collapse(true); //collapse deeply
                    childNode.setIcon(CheckNode.LOADING_STATUS);
                });
            },
            checkSyntax: function(callback){
                plugin.facade.raiseEvent({
                    type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
                    onErrors: function(){
                        Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!")
                        this.turnLoadingIntoUnknownStatus();
                    }.bind(this),
                    onNoErrors: function(){
                        callback();
                    }
                });
            },
            // All child nodes with loading status get unknown status
            turnLoadingIntoUnknownStatus: function(){
                Ext.each(this.getTree().getRootNode().childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
            },
            checkSoundness: function(){
                var root = this.getTree().getRootNode();
                
                // Check for structural soundness (no server request needed and return, if any has been found       
                if(! root.findChild("id", "structuralSound").check()){
                    this.turnLoadingIntoUnknownStatus();
                    return;
                }
                
                // Check other soundness criteria which needs server requests
                Ext.Ajax.request({
//                    url: ORYX.CONFIG.SERVER_HANDLER_ROOT + '/checksoundness',
                	url: ORYX.CONFIG.PN_CHECKER,
                    method: 'POST',
                    success: function(request){
                        var res = Ext.decode(request.responseText);
                        
                        root.showErrors(res.errors);
                        
                        if(res.errors.length === 0){
                            root.findChild("id", "sound").check(res);
                            root.findChild("id", "weakSound").check(res);
                            root.findChild("id", "relaxedSound").check(res);
                        }
                    },
                    failure: function(){
                    },
                    params: {
                        data: plugin.getSerializedDOM()
                    }
                });
                
            },
            items: [new Ext.tree.TreePanel({
                useArrows: true,
                autoScroll: true,
                rootVisible: false,
                animate: true,
                containerScroll: true,
                
                root: new CheckNode({
                    text: 'Checks',
                    id: 'source',
                    expanded: true
                }),
                listeners: {
                    render: function(treePanel){
                        var structuralSoundNode = new CheckNode({
                            text: 'Structural Sound (Workflow Net)',
                            id: 'structuralSound',
                            /* Returns false when any error has been found */
                            check: function(){
                                this.checkInitialNode.update();
                                this.checkFinalNode.update();
                                this.checkConnectedNode.update(this.checkInitialNode.initialNodes, this.checkFinalNode.finalNodes);
                                
                                if(this.checkInitialNode.hasErrors() || this.checkFinalNode.hasErrors() || this.checkConnectedNode.hasErrors()){
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                    return false;
                                } else {
                                    this.setIcon(CheckNode.OK_STATUS);
                                    return true;
                                }
                            },
                            checkInitialNode: new CheckNode({
                                qtip: 'There must be exactly one initial place, which is the only place without any incoming edges.',
                                update: function(){
                                    this.initialNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getIncomingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.initialNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.initialNodes.length + ' initial places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.initialNodes);
                                },
                                hasErrors: function(){
                                    return this.initialNodes.length !== 1;
                                }
                            }),
                            checkFinalNode: new CheckNode({
                                qtip: 'There must be exactly one final place, which is the only place without any outgoing edges.',
                                update: function(){
                                    this.finalNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getOutgoingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.finalNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.finalNodes.length + ' final places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.finalNodes);
                                },
                                hasErrors: function(){
                                    return this.finalNodes.length !== 1;
                                }
                            }),
                            checkConnectedNode: new CheckNode({
                                qtip: 'Each node in the process model is on the path from the initial node to the final node.',
                                update: function(initialNodes, finalNodes){
                                    //Step through without semantic knowledge
                                    if(initialNodes.length !== 1 || finalNodes.length !== 1){
                                        this.setText("There must be exactly one initial and final place to perform further checks!");
                                        this.setIcon(CheckNode.UNKNOWN_STATUS);
                                        return;
                                    }
                                    
                                    this.notParticipatingNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape instanceof ORYX.Core.Node)
                                            this.notParticipatingNodes.push(shape);
                                    }.bind(this));
                                    
                                    this.passedNodes = [];
                                    
                                    this.findNotParticipatingNodes(initialNodes[0]);
                                    
                                    this.setText(this.notParticipatingNodes.length + ' nodes that aren\'t on any path from beginning to end found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.notParticipatingNodes);
                                },
                                findNotParticipatingNodes: function(currentNode){
                                    this.passedNodes.push(currentNode);
                                    this.notParticipatingNodes.remove(currentNode);
                                    
                                    Ext.each(currentNode.getOutgoingShapes(), function(nextNode){
                                        if(!this.passedNodes.include(nextNode)){
                                            this.findNotParticipatingNodes(nextNode);
                                        };
                                    }.bind(this));
                                },
                                hasErrors: function(){
                                    return this.notParticipatingNodes.length !== 0;
                                }
                            })
                        });
                        structuralSoundNode.appendChild([
                            structuralSoundNode.checkInitialNode,
                            structuralSoundNode.checkFinalNode,
                            structuralSoundNode.checkConnectedNode
                        ]);
                    
                        var soundNode = new CheckNode({
                            text: 'Sound',
                            id: 'sound',
                            check: function(res){
                                if (res.isSound) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                
                                this.deadTransitionsNode.update(res.deadTransitions);
                                this.improperTerminatingsNode.update(res.improperTerminatings);
                                this.deadLocksNode.update(res.deadLocks);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),
                            improperTerminatingsNode: new ImproperTerminatingsNode({}),
                            deadLocksNode: new DeadLocksNode({})
                        });
                        soundNode.appendChild([
                            soundNode.deadTransitionsNode,
                            soundNode.improperTerminatingsNode,
                            soundNode.deadLocksNode
                        ]);
                        
                        var weakSoundNode = new CheckNode({
                            text: 'Weak Sound',
                            id: 'weakSound',
                            check: function(res){
                                if (res.isWeakSound) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }

                                this.improperTerminatingsNode.update(res.improperTerminatings);
                                this.deadLocksNode.update(res.deadLocks);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),
                            improperTerminatingsNode: new ImproperTerminatingsNode({}),
                            deadLocksNode: new DeadLocksNode({})
                        });
                        weakSoundNode.appendChild([
                            weakSoundNode.improperTerminatingsNode,
                            weakSoundNode.deadLocksNode
                        ]);
                        
                        var relaxedSoundNode = new CheckNode({
                            text: 'Relaxed Sound',
                            id: 'relaxedSound',
                            check: function(res){
                                if (res.isRelaxedSound) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                
                                this.notParticipatingTransitionsNode.update(res.notParticipatingTransitions);
                            },
                            notParticipatingTransitionsNode: new NotParticipatingTransitionsNode({})
                        });
                        relaxedSoundNode.appendChild([
                            relaxedSoundNode.notParticipatingTransitionsNode
                        ]);
                        
                        treePanel.getRootNode().appendChild([structuralSoundNode, soundNode, weakSoundNode, relaxedSoundNode]);
                        
                    }
                }
            })],
            listeners: {
                close: function(window){
                    this.checkerWindow.getTree().getRootNode().reset();
                }.bind(this)
            }
        });
        
        this.checkerWindow.show();
        this.checkerWindow.check(true);
    }
});/**
 * Copyright (c) 2010
 * Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.PetriNet = {

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade){
		this.facade = facade;
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
	},
	
	/**
	 * Checks if the number of tokens on a place has changed. Up to four the 
	 * tokens are visualized as drawings, otherwise a number gets displayed.
	 */
	handlePropertyChanged: function(option) {
		var shapes = option.elements;
		var propertyKey = option.key;
		var propertyValue = option.value;
		
		var changed = false;
		shapes.each(function(shape){
			if((shape.getStencil().id() === "http://b3mn.org/stencilset/petrinet#Place") &&
				(propertyKey === "oryx-numberoftokens")) {
				
				/* Visualize number of Tokens */
				if(propertyValue == 0) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "0");
				} else if(propertyValue == 1) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "1");
				} else if(propertyValue == 2) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "2");
				} else if(propertyValue == 3) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "3");
				} else if(propertyValue == 4) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "4");
				} else {
					var tokens = parseInt(propertyValue, 10);
					if(tokens && tokens > 0) {
						shape.setProperty("oryx-numberoftokens_text", "" + tokens);
						shape.setProperty("oryx-numberoftokens_drawing", "0");
					} else {
						shape.setProperty("oryx-numberoftokens_text", "");
						shape.setProperty("oryx-numberoftokens_drawing", "0");
					}
				}
				changed = true;
			}
		});
		
		if(changed) {this.facade.getCanvas().update();}
	}
};
	
ORYX.Plugins.PetriNet = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.PetriNet);
	/*
 * TODO interaction format step through <=> oryx should be json!!!
 */
/**
 * Copyright (c) 2008, Christoph Neijenhuis, modified by Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
 **/
Ext.namespace("ORYX.Plugins");

ORYX.Plugins.AbstractStepThroughPlugin = ORYX.Plugins.AbstractPlugin.extend({
    construct: function() {
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
        
        this.facade.offer({
            'name': ORYX.I18N.StepThroughPlugin.stepThrough,
            'functionality': this.load.bind(this),
            'group': ORYX.I18N.StepThroughPlugin.group,
            'icon': ORYX.PATH + "images/control_play.png",
            'description': ORYX.I18N.StepThroughPlugin.stepThroughDesc,
            'index': 1,
            'toggle' : true,
            'minShape': 0,
            'maxShape': 0
        });
        
        this.facade.offer({
            'name': ORYX.I18N.StepThroughPlugin.undo,
            'functionality': this.undo.bind(this),
            'group': ORYX.I18N.StepThroughPlugin.group,
            'icon': ORYX.PATH + "images/control_rewind.png",
            'description': ORYX.I18N.StepThroughPlugin.undoDesc,
            'index': 2,
            'minShape': 0,
            'maxShape': 0
        });
    },
    showEnabled: function(shape, display){
        // Creates overlay for an enabled shape
        // display is beeing ignored
        if (!(shape instanceof ORYX.Core.Shape)) {
            return;
        }
        else if (this.isOrSplit(shape)) { //special handling for OR-Split
            this.showEnabledOrSplit(shape);
            return;
        }
        
        this.showPlayOnShape(shape);
    },
    
    showPlayOnShape: function(shape){
        var attr;
        if (shape instanceof ORYX.Core.Edge) {
            attr = {
                stroke: "green"
            };
        }
        else {
            attr = {
                fill: "green"
            };
        }
        
        var play = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
            "title": "Click the element to execute it!",
            "stroke-width": 2.0,
            "stroke": "black",
            "d": "M0,-5 L5,0 L0,5 Z",
            "line-captions": "round"
        }]);
        
        this.showOverlayOnShape(shape, attr, play);
    },
    
    showOverlayOnShape: function(shape, attributes, node){
        this.hideOverlayOnShape(shape);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: "st." + shape.resourceId,
            shapes: [shape],
            attributes: attributes,
            node: (node ? node : null),
            nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"
        });
    },
    
    hideOverlayOnShape: function(shape){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
            id: "st." + shape.resourceId
        });
    },
    
    // Pass preserveInitialMarking = true as config option, if initial marking 
    // should not be deleted 
    hideOverlays: function(preserveInitialMarking){
        // hides all overlays
        var els = this.facade.getCanvas().getChildShapes(true);
        var el;
        for (i = 0; i < els.size(); i++) {
            el = els[i];
            // This may send hide-events for objects that have no overlay
            if (!(preserveInitialMarking && this.isStartNode(el))) {
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                    id: "st." + el.resourceId
                });
            }
        }
    },
    
    /**
     * Called when the user loads or unloads the plugin
     * @methodOf ORYX.Plugins.StepThroughPlugin
     */
    load: function(button, pressed){
        this.initializeLoadButton(button, pressed);
        this.togglePlugin(pressed);
    },

	togglePlugin: function(turn_on) {
		if (turn_on) {
			 this.initialMarking = [];

            if (this.getDiagramType() === "epc") {
                this.prepareInitialMarking();
            }
            else { //only start immediately for bpmn diagrams and Petri nets
                this.startAndCheckSyntax();
            }
		}
		else {
			 // Reset vars
	        this.executionTrace = "";
            this.rdf = undefined;

            // Reset syntax checker errors
            this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});

            this.onDeactivate();
		}
		
		if (this.active()) {
            this.callback = this.doMouseUp.bind(this)
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)
        } else {
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)
            this.callback = undefined;
        }
	},
    
    // When plugin is deactivated through pressing the button
    // Overwrite to implement custom behavior
    onDeactivate: function(){
        // Hide overlays
        this.hideOverlays();
    },
    
    // Very evil, this method is a result from Oryx generalized plugin infrastructure
    // Direct access to button needed, so that this can be done in construct method
    initializeLoadButton: function(button, pressed){
        if(this.loadButton !== button){
            // Sets state of the loadButton and sets the model readonly
            var toggleActive = function(active){
                if(active){
                    //Set "readonly" (edges cannot be moved anymore)
                    this.facade.disableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
                } else {
                    this.facade.enableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
                }
            }.createDelegate(this);
            
            button.on('toggle', function(button, p){
                toggleActive(p);
            });
            // Very evil!! The first time, toggle event isn't thrown 
            // Should be like that listeners can be defined earlier!!!
            toggleActive(button, pressed);
        }
        this.loadButton = button;
    },
    
    active: function(){
        return this.loadButton ? this.loadButton.pressed : false;
    },
    
    onSelectionChanged: function(){
        if (this.active() && this.facade.getSelection().length > 0) {
            // Stop the user from editing the diagram while the plugin is active
            this.facade.setSelection([]);
        }
    },
    
    //TODO generic function
    getDiagramType: function(){
        switch (this.facade.getCanvas().getStencil().namespace()) {
            case "http://b3mn.org/stencilset/epc#":
                return "epc";
            case "http://b3mn.org/stencilset/bpmn#":
                return "bpmn";
            default:
                return null;
        }
    },
    
    showUsed: function(shape, display){
        // Creates overlay for a shape that has been used and is not enabled
        if (!(shape instanceof ORYX.Core.Shape)) 
            return;
        
        var attr;
        if (shape instanceof ORYX.Core.Edge) {
            attr = {
                stroke: "mediumslateblue"
            };
        }
        else {
            attr = {
                fill: "mediumslateblue"
            };
        }
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
            id: "st." + shape.resourceId
        });
        
        if (display != "-1" && display != "1") {
            // Show the number
            var text = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                "style": "font-size: 16px; font-weight: bold;"
            }, display]);
            
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
                id: "st." + shape.resourceId,
                shapes: [shape],
                attributes: attr,
                node: text,
                nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"
            });
        }
        else {
            // This is an XOR split, don't display number
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
                id: "st." + shape.resourceId,
                shapes: [shape],
                attributes: attr
            });
        }
    }
});

ORYX.Plugins.PetriNetStepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({
    construct: function() {
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
    },
    startAndCheckSyntax: function(){
        this.facade.raiseEvent({
            type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
            onErrors: function(){
                Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!");
            }.bind(this),
            onNoErrors: function(){
	            if (this.initializeMarking()) {
					this.firedTransitions = [];
	                this.showEnabledTransition();
				} 
				else {
					this.togglePlugin(false); // turn off 
				}
            }.bind(this)
        });
    },

    /**
     * Initializes the number of tokens for each place. Additionally, if none of the places have a token, the initial places
     * get one.
     */
    initializeMarking: function(){
        
		// monkeypatching place marking (add/remove tokens) towards new stencil set
		// definitions from r3187
		var markPlaces = function(shape, propertyValue) {
			if(propertyValue == 0) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "0");
			} else if(propertyValue == 1) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "1");
			} else if(propertyValue == 2) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "2");
			} else if(propertyValue == 3) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "3");
			} else if(propertyValue == 4) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "4");
			} else {
				var tokens = parseInt(propertyValue, 10);
				if(tokens && tokens > 0) {
					shape.setProperty("oryx-numberoftokens_text", "" + tokens);
					shape.setProperty("oryx-numberoftokens_drawing", "0");
				} else {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "0");
				}
			}
		}
		this.getPlaces().each(function(place){
			if ("undefined" == typeof(place._setProperty_monkey)) {
				place._setProperty_monkey = place.setProperty;
				place.setProperty = function(p,a) {
					if ("oryx-numberoftokens" == p) {
						markPlaces(place, a)
					}
					place._setProperty_monkey.apply(place, arguments);
				}
			}
		})
        
		var anyTokenFound = 0;
        this.getPlaces().each(function(place){
            var tokens = parseInt(place.properties["oryx-numberoftokens"]);
            if(isNaN(tokens)){
                // All places which don't have any number of tokens, gets 0 tokens explicitly
                place.setProperty("oryx-numberoftokens", 0);
            } else if(tokens > 0){
                anyTokenFound += tokens;
            }
        });
        
        // If no place has any token, all incoming places gets tokens
        if(0 == anyTokenFound){
            this.getPlaces().each(function(place){
                if(place.getIncomingShapes().length == 0){
                    place.setProperty("oryx-numberoftokens", 1);
                }
            });
            Ext.Msg.show({
               title:'No Tokens Found',
               msg: 'Current marking of the Petri net doesn\'t contain any token. Tokens are added to the initial places of the net.',
               buttons: Ext.Msg.OK,
               icon: Ext.MessageBox.INFO
            });
        }
		
		if(anyTokenFound > 3){
            Ext.Msg.show({
               title:'Too Many Tokens On Place',
               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',
               buttons: Ext.Msg.OK,
               icon: Ext.MessageBox.WARNING
            });
		}

		return true;
    },
    
    doMouseUp: function(event, shape){
        if (!(this.isTransition(shape))) return; // Can be a docker, place or something else

		// assuming correct syntax
    	var enabled = this.getIncomingNodes(shape).all(function(place) {
			return parseInt(place.properties["oryx-numberoftokens"]) > 0;
		});

		if (enabled) {
        	this.fireTransition(shape);	
		}
        this.showEnabledTransition();
    },
    
    onDeactivate: function(){
        // Hide overlays
        this.hideOverlays();
        
        // Undo all fired transitions so that the marking is the initial marking
        while(this.firedTransitions.length !== 0){
            this.undoLastFiredTransition();
        }
        this.facade.getCanvas().update(); //update markings
        
        this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
    },
    
    fireTransition: function(transition){
        this.firedTransitions.push(transition);
        this.getIncomingNodes(transition).each(function(place){
            this.removeToken(place);
        }.bind(this));
        this.getOutgoingNodes(transition).each(function(place){
            this.addToken(place);
        }.bind(this));

    },
    
    undoLastFiredTransition: function(){
        var transition = this.firedTransitions.pop();
        
        // If there is no transition anymore, just quit
        if(!transition) return;
        
        this.getIncomingNodes(transition).each(function(place){
            this.addToken(place);
        }.bind(this));
        this.getOutgoingNodes(transition).each(function(place){
            this.removeToken(place);
        }.bind(this));

    },
    
    removeToken: function(place){
        place.setProperty("oryx-numberoftokens", parseInt(place.properties["oryx-numberoftokens"])-1);
    },
    
    addToken: function(place){
        var tokens = parseInt(place.properties["oryx-numberoftokens"]) +1;
    
        place.setProperty("oryx-numberoftokens", tokens);
        
        if(tokens > 3){
            Ext.Msg.show({
               title:'Too Many Tokens On Place',
               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',
               buttons: Ext.Msg.OK,
               icon: Ext.MessageBox.WARNING
            });
        }
    },
    
    showEnabledTransition: function(){
        this.hideOverlays();
        
        this.firedTransitions.each(function(transition){
            this.showUsed(transition, "1");
        }.bind(this));
        
        this.getEnabledTransitions().each(function(transition){
            this.showPlayOnShape(transition);
        }.bind(this));
        
        this.facade.getCanvas().update();
    },
    getTransitions: function(){
        return this.facade.getCanvas().getChildShapes().select(function(shape){
            return this.isTransition(shape);
        }.bind(this));
    },
    isTransition: function(shape){
        return shape instanceof ORYX.Core.Shape && shape.getStencil().id().search(/Transition/) > -1;
    },
    getPlaces: function(){
        return this.facade.getCanvas().getChildShapes().select(function(shape){
            return shape.getStencil().id().search(/Place/) > -1;
        });
    },
    getIncomingNodes: function(node){
      return node.getIncomingShapes().collect(function(arc){
        return arc.getIncomingShapes();
      }).flatten();
    },
    getOutgoingNodes: function(node){
      return node.getOutgoingShapes().collect(function(arc){
        return arc.getOutgoingShapes();
      }).flatten();
    },
    getEnabledTransitions:function(){
        return this.getTransitions().select(function(transition){
            // Checks whether all incoming places have at least 1 token
            return this.getIncomingNodes(transition).all(function(place){
                return parseInt(place.properties["oryx-numberoftokens"]) > 0;
            });
        }.bind(this));
    },
    undo: function(){
        this.undoLastFiredTransition();
        this.showEnabledTransition();
    }
});

/**
 * Step Through Plugin
 * @class ORYX.Plugins.StepThroughPlugin
 * @constructor Creates new plugin instance
 */
ORYX.Plugins.StepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({

    /**
     * My method!
     * @methodOf ORYX.Plugins.StepThroughPlugin
     */
    construct: function(facade){
        this.el = undefined;
        this.callback = undefined;
        this.executionTrace = ""; // A string containing all objects that have been fired
        this.rdf = undefined;
                
        arguments.callee.$.construct.apply(this, arguments);
    },
    
    // Each start node and each start arc gets colored
    prepareInitialMarking: function(){
        this.startNodes = [];
        
        Ext.each(this.facade.getCanvas().getChildShapes(true), function(shape){
            if (this.isStartNode(shape)) {
                this.startNodes.push(shape);
                shape.initialMarkingFired = false;
                this.showPlayOnShape(shape);
                if (shape.getOutgoingShapes().size() == 1) {
                    this.showOverlayOnShape(shape.getOutgoingShapes()[0], {
                        stroke: "green"
                    });
                    shape.getOutgoingShapes()[0].initialMarking = true;
                }
            }
        }
.createDelegate(this));
    },
    
    /* Returns true if node is start node */
    isStartNode: function(shape){
        return (shape.getStencil().id().search(/#Event$/) > -1) && shape.getIncomingShapes().length == 0 && shape.getOutgoingShapes().length == 1;
    },
    
    /* Returns true if source node from arc is start node */
    isStartArc: function(shape){
        return this.isStartNode(shape.getIncomingShapes()[0]);
    },
    
    isStartArcOrNode: function(shape){
        return this.isStartNode(shape) || this.isStartArc(shape);
    },
    
    /* TODO this should be a general oryx helper method!! */
    generateRDF: function(){
        
        try {
            var serialized_rdf = this.getRDFFromDOM();
            
            // Firefox 2 to 3 problem?!
            serialized_rdf = !serialized_rdf.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf : serialized_rdf;
        } 
        catch (error) {
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
            Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
        }
        
        this.rdf = serialized_rdf;
    },
    
    getRDF: function(){
        if (this.rdf == undefined) {
            this.generateRDF();
        }
        
        return this.rdf;
    },
    
    startAndCheckSyntax: function(){
        this.postExecutionTrace({
            checkSyntax: true,
            onlyChangedObjects: false,
            onSuccess: function(request){
                //TODO use always json!!!! This is a bad hack!!!
                if (request.responseText.startsWith("{")){ //seems to be json
                    var errors = Ext.decode(request.responseText).syntaxErrors;
                    
                    // Show errors
                    this.facade.raiseEvent({
                        type: ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT,
                        errors: errors
                    });
                } else { //normal step through response
                    this.showObjectStates(request.responseText);
                }
            }.bind(this)
        });
    },
    
    fireObject: function(objResourceId){
        // Add this object to executionTrace
        this.executionTrace += objResourceId + ";";
        
        // Add selected edges for or split
        if (this.isOrSplit(this.el)) {
            //eliminate ;
            this.executionTrace = this.executionTrace.substring(0, this.executionTrace.length - 1);
            this.executionTrace += "#";
            var outgoingEdges = new Ext.util.MixedCollection();
            outgoingEdges.addAll(this.el.getOutgoingShapes());
            var firingEdgesResourceIds = [];
            outgoingEdges.filter("selectedForOrSplit", "true").each(function(edge){
                firingEdgesResourceIds.push(edge.resourceId);
            }
.createDelegate(this));
            outgoingEdges.each(function(edge){
                edge.selectedForOrSplit = false;
                this.hideOverlayOnShape(edge);
            }
.createDelegate(this));
            this.executionTrace += firingEdgesResourceIds.join(",") + ";";
        }
        
        this.postExecutionTrace({
            checkSyntax: false,
            onlyChangedObjects: true,
            onSuccess: function(request){
                if (request.responseText != "") {
                    // successful
                    this.showObjectStates(request.responseText);
                }
                else {
                    // object couldn't be fired, remove it from executionTrace
                    this.removeLastFiredObject();
                }
            }
.bind(this)
        });
    },
    
    doMouseUp: function(event, arg){
        if (arg instanceof ORYX.Core.Shape) {
            // if its an or split
            if (arg instanceof ORYX.Core.Edge && this.isOrSplit(arg.getIncomingShapes()[0])) {
                this.doMouseUpOnEdgeComingFromOrSplit(arg);
                // else if its an epc start node
            }
            else if (arg instanceof ORYX.Core.Edge && this.getDiagramType() === "epc" && this.isStartNode(arg.getIncomingShapes()[0])) {
                this.doMouseUpOnEdgeComingFromStartNode(arg);
            }
            else if (this.getDiagramType() === "epc" && this.isStartNode(arg)) {
                arg.initialMarkingFired = true;
                var edge = arg.getOutgoingShapes()[0];
                this.hideOverlayOnShape(edge);
                if (edge.initialMarking) {
                    this.showUsed(arg, "1");
                    this.initialMarking.push(arg.resourceId);
                }
                else {
                    this.hideOverlayOnShape(arg);
                }
                
                // If clicked node is the last startNode, activate real step through
                var allStartNodesFired = true;
                Ext.each(this.startNodes, function(startNode){
                    if (!startNode.initialMarkingFired) {
                        allStartNodesFired = false;
                    }
                });
                
                if (allStartNodesFired) {
                    this.startAndCheckSyntax();
                }
            }
            else {
                this.el = arg;
                this.fireObject(this.el.resourceId);
            }
        }
    },
    
    showObjectStates: function(objs){
        var objsAndState = objs.split(";");
        for (i = 0; i < objsAndState.size(); i++) {
            var objAndState = objsAndState[i].split(",");
            if (objAndState.size() < 3) {
                continue;
            }
            var obj = this.facade.getCanvas().getChildShapeByResourceId(objAndState[0]);
            if (objAndState[2] == "t") { // Is enabled
                this.showEnabled(obj, objAndState[1]);
            }
            else if (objAndState[1] != "0") { // has been used
                this.showUsed(obj, objAndState[1]);
            }
            else { // Was enabled, has not been used
                this.hideOverlayOnShape(obj);
            }
        }
    },
    
    doMouseUpOnEdgeComingFromOrSplit: function(edge){
        var orSplit = edge.getIncomingShapes()[0];
        
        if (edge.selectedForOrSplit) { //deselect edge
            this.showOverlayOnShape(edge, {
                stroke: "orange"
            });
            
            // Hide or-split overlay, if last edge has been deselected
            var outgoingEdges = new Ext.util.MixedCollection();
            outgoingEdges.addAll(orSplit.getOutgoingShapes());
            if (outgoingEdges.filter("selectedForOrSplit", "true").length <= 1) { // > 1, because current edge is in this list
                this.hideOverlayOnShape(orSplit);
            }
            
        }
        else { //select edge
            this.showOverlayOnShape(edge, {
                stroke: "green"
            });
            this.showPlayOnShape(orSplit);
        }
        
        // toggle selection
        edge.selectedForOrSplit = !edge.selectedForOrSplit;
    },
    
    // Toggles color and initialMarking value of start arcs
    doMouseUpOnEdgeComingFromStartNode: function(edge){
        edge.initialMarking = !edge.initialMarking;
        
        if (edge.initialMarking) {
            this.showOverlayOnShape(edge, {
                stroke: "green"
            });
        }
        else {
            this.showOverlayOnShape(edge, {
                stroke: "orange"
            });
        }
    },
    
    //checks whether shape is OR gateway and hasn't more than 1 outgoing edges
    isOrSplit: function(shape){
        return (shape.getStencil().id().search(/#(OR_Gateway|OrConnector)$/) > -1) && (shape.getOutgoingShapes().length > 1);
    },
    
    showEnabledOrSplit: function(shape){
        Ext.each(shape.getOutgoingShapes(), function(edge){
            Ext.apply(edge, {
                selectedForOrSplit: false
            });
            
            this.showOverlayOnShape(edge, {
                stroke: "orange"
            });
        }
.createDelegate(this));
    },
   
    removeLastFiredObject: function(){
        // Removes last entry in execution trace
        this.executionTrace = this.executionTrace.replace(/[^;]*;$/, "")
    },
    
    undo: function(){
        if (!this.active()) 
            return;
        
        if (this.executionTrace !== "") {
            this.removeLastFiredObject();
            
            this.postExecutionTrace({
                checkSyntax: false,
                onlyChangedObjects: false,
                onSuccess: function(request){
                    // Hide overlays because everything is drawn from scratch
                    this.hideOverlays(true);
                    // Draw new overlays
                    this.showObjectStates(request.responseText);
                }
.bind(this)
            });
        }
        else if (this.getDiagramType() === "epc") {
            this.hideOverlays();
            this.prepareInitialMarking(); // "reset" initial marking
        }
    },
    
    /* Posts current execution trace to server for executing 
     * options is a hash with following keys:
     * - onlyChangedObjects (boolean)
     * - onSuccess (function with parameter request)
     * - checkSyntax (boolean)
     */
    postExecutionTrace: function(options){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
            text: ORYX.I18N.StepThroughPlugin.executing
        });
        
        //TODO merge in default options
        new Ajax.Request(ORYX.CONFIG.STEP_THROUGH, {
            method: 'POST',
            asynchronous: false,
            parameters: {
                rdf: this.getRDF(),
                checkSyntax: options.checkSyntax,
                fire: this.executionTrace,
                onlyChangedObjects: options.onlyChangedObjects,
                initialMarking: this.initialMarking.join(";")
            },
            onSuccess: function(response){
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                options.onSuccess(response);
            }.createDelegate(this),
            onFailure: function(){
                //TODO raise error message?
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
            }.createDelegate(this)
        });
    }
});/**
 * Copyright (c) 2009
 * Philipp Giese
 *
 * This code is proprietary software within the 
 * company Signavio GmbH.
 *  
 **/

 // define namespace
 
if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
 
ORYX.Plugins.BPMN2Migration = Clazz.extend({
		
	enabled : true,
	
	facade : undefined,
	
	construct: function(facade) {
		
		this.facade = facade;

		this.facade.offer({			
					
			'name' 			: Signavio.I18N.Migration.Title,
			'group'			: Signavio.I18N.Migration.group,
			'index'			: 2,
			dropDownGroupIcon : ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/page_transform.png",
			'toggle' 		: false,
			'description' 	: Signavio.I18N.Migration.Description,
			'icon' 			: ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/page_bpmn2.png",
			'functionality' : this.migrateBPMN.bind(this),
			'minShape'		: 0,
			'maxShape'		: 0
						
		});
					
	},
	
	migrateBPMN: function() {
		
		var data = this.facade.getSerializedJSON();
		
		/* Send the BPMN 1.1 JSON to the Server and wait for
		 * the migrated data 
		 */ 
		new Ajax.Request(ORYX.CONFIG.BPMN2MIGRATION, {
			method: 'POST',
			parameters: {
				data : data,
				path : "/stencilsets/bpmn2.0"
			},
			onSuccess: function(request) {
				var response = request.responseText;
				
				/* 
				 * With the new BPMN 2.0 JSON create a new Model
				 */
				new Ajax.Request(ORYX.CONFIG.SERVER_EDITOR_CREATE_HANDLER, {
					method: 'POST',
					parameters: {
						json_xml : response,
						directory : this.facade.getModelMetaData().parent,
						stencilset : "http://b3mn.org/stencilset/bpmn2.0#"
					},
					onSuccess: function(req) {
						var modelId = req.responseText;
						
						/* open the new Model */
						window.setTimeout(function(){
							window.open(ORYX.CONFIG.SERVER_EDITOR_HANDLER + "?id=" + modelId)
						}, 100);
					},
					onFailure: function() {
						Ext.Msg.alert("Signavio", Signavio.I18N.Migration.NewModelCreationError);
					}
				});
			}.bind(this),
			onFailure: function() {
				Ext.Msg.alert("Signavio", Signavio.I18N.Migration.MigrationError);
			}
		});			
	}		
});/**
 * Copyright (c) 2009
 * Philipp Giese, Sven Wagner-Boysen
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
   @namespace Oryx name space for plugins
   @name ORYX.Plugins
*/
if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
	
/**
 * This plugin provides methodes to serialize and deserialize a BPMN 2.0 diagram.
 * 
 * @class ORYX.Plugins.Bpmn2_0Serialization
 * @extends ORYX.Plugins.AbstractPlugin
 * @param {Object} facade
 * 		The facade of the Editor
 */
ORYX.Plugins.BPMN2_0Serialization = {
	bpmnSerializationHandlerUrl: ORYX.CONFIG.ROOT_PATH + "bpmn2_0serialization",
	bpmnDeserializationHandlerUrl : ORYX.CONFIG.ROOT_PATH + "bpmn2_0deserialization",
	bpmn2XpdlSerializationHandlerUrl : ORYX.CONFIG.ROOT_PATH + "bpmn2xpdlserialization",
	
	construct: function(facade) {
	
		this.facade = facade;
	
		/* BPMN 2.0 XML */
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization.show,
			'functionality'		: this.showBpmnXml.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/export2.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.showDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization.download,
			'functionality'		: this.downloadBpmnXml.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/export2.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.downloadDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
		
		/* XPDL 2.2 */
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization.xpdlShow,
			'functionality'		: this.showXpdl.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/export2.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.xpdlShowDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization.download,
			'functionality'		: this.downloadXpdl.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/export2.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.xpdlDownloadDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
		
		/* Import BPMN 2.0 XML */
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization['import'],
			'functionality'		: this.showImportDialog.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/import.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.importDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
	},
	
	showBpmnXml: function() {	
		//var options = JSON.stringify({action : 'transform'});
		
		this.generateBpmnXml( function( response ) {
			var json = response.evalJSON();
			this.showSchemaValidationEvent(json.validationEvents);
			this.openXMLWindow(json.xml);
		}.bind(this),
		this.bpmnSerializationHandlerUrl);
	},
	
	downloadBpmnXml: function() {	
		//var options = JSON.stringify({action : 'transform'});
		this.generateBpmnXml(
			function ( response ) {
				var json = response.evalJSON();
				this.showSchemaValidationEvent(json.validationEvents);
				this.openDownloadWindow("model.bpmn", json.xml);
			}.bind(this),
			this.bpmnSerializationHandlerUrl);
	},
	
	/**
	 * Show the results of the schema validation in a message box, if it is
	 * enabled in the configuration.
	 */
	showSchemaValidationEvent : function(validationEvents) {
		if(validationEvents && ORYX.CONFIG.BPMN20_SCHEMA_VALIDATION_ON) {
			this._showErrorMessageBox("Validation", validationEvents);
		}
	},
	
	/**
	 * Calls the serialization to XPDL 2.2 and shows the result in a XML-Window.
	 */
	showXpdl: function() {
		this.generateBpmnXml( function( xml ) {
			this.openXMLWindow(xml);
		}.bind(this),
		this.bpmn2XpdlSerializationHandlerUrl);
	},
	
	/**
	 * Calls the serialization to XPDL 2.2 and offers the result as a file
	 * download.
	 */
	downloadXpdl: function() {
		this.generateBpmnXml(
			function ( xml ) {
				this.openDownloadWindow("model.xpdl", xml);
			}.bind(this),
			this.bpmn2XpdlSerializationHandlerUrl);
	},
	
	generateBpmnXml: function( bpmnHandleFunction, handlerUrl ) {
		var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:"Serialization of BPMN 2.0 model"});
		loadMask.show();
		
		var jsonString = this.facade.getSerializedJSON();
		this._sendRequest(
				handlerUrl,
				'POST',
				{ 'data' : jsonString },
				function( response ) { 
					bpmnHandleFunction( response );  
					loadMask.hide();
				}.bind(this),
				function(transport) { 
					loadMask.hide();
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.Bpmn2_0Serialization.serialFailed);
					ORYX.log.warn("Serialization of BPMN 2.0 model failed: " + transport.responseText);
				}.bind(this)
			);
	},
	
	/**
     * Opens a upload dialog.
     *
     */
    showImportDialog: function(successCallback){
    
        var form = new Ext.form.FormPanel({
            baseCls: 'x-plain',
            labelWidth: 50,
            defaultType: 'textfield',
            items: [{
                text: ORYX.I18N.Bpmn2_0Serialization.selectFile,
                style: 'font-size:12px;margin-bottom:10px;display:block;',
                anchor: '100%',
                xtype: 'label'
            }, {
                fieldLabel: ORYX.I18N.Bpmn2_0Serialization.file,
                name: 'subject',
                inputType: 'file',
                style: 'margin-bottom:10px;display:block;',
                itemCls: 'ext_specific_window_overflow'
            }, {
                xtype: 'textarea',
                hideLabel: true,
                name: 'msg',
                anchor: '100% -63'
            }]
        });
        
        // Create the panel
        var dialog = new Ext.Window({
            autoCreate: true,
            layout: 'fit',
            plain: true,
            bodyStyle: 'padding:5px;',
            title: ORYX.I18N.Bpmn2_0Serialization.name,
            height: 350,
            width: 500,
            modal: true,
            fixedcenter: true,
            shadow: true,
            proxyDrag: true,
            resizable: true,
            items: [form],
            buttons: [{
                text: ORYX.I18N.Bpmn2_0Serialization.btnImp,
                handler: function(){
                
                    var loadMask = new Ext.LoadMask(Ext.getBody(), {
                        msg: ORYX.I18N.Bpmn2_0Serialization.progress
                    });
                    loadMask.show();
                    
                    window.setTimeout(function(){
                        var bpmnXml = form.items.items[2].getValue();
						try {
							this._sendRequest(
								this.bpmnDeserializationHandlerUrl,
								'POST',
								{ 'data' : bpmnXml },
								function( json ) { 
		                            this.facade.importJSON(json, true);
		                            dialog.close();
								}.bind(this),
								function(transport) { 
									loadMask.hide();
									this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.Bpmn2_0Serialization.serialFailed);
									ORYX.log.warn("Serialization of BPMN 2.0 model failed: " + transport.responseText);
								}.bind(this)
							); 
						} 
                        catch (error) {
                            Ext.Msg.alert(ORYX.I18N.Bpmn2_0Serialization.error, error.message);
                        }
                        finally {
                            loadMask.hide();
                        }
                    }.bind(this), 100);
                    
                }.bind(this)
            }, {
                text: ORYX.I18N.Bpmn2_0Serialization.btnClose,
                handler: function(){
                    dialog.close();
                }.bind(this)
            }]
        });
        
        // Show the panel
        dialog.show();
        
        // Adds the change event handler to 
        form.items.items[1].getEl().dom.addEventListener('change', function(evt){
            var text = evt.target.files[0].getAsText('UTF-8');
            form.items.items[2].setValue(text);
        }, true)
        
    },
	
	_sendRequest: function( url, method, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(url, {
           method			: method,
           asynchronous	: false,
           parameters		: params,
		   onSuccess		: function(transport) {
				
				suc = true;
				
				if(successcallback){
					successcallback( transport.responseText );
				}
				
			}.bind(this),
			
			onFailure : function(transport) {

				if(failedcallback){
					failedcallback(transport);
					
				} else {
					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Bpmn2Bpel.transfFailed);
					ORYX.log.warn("Serialization of BPMN 2.0 model failed: " + transport.responseText);	
				}
				
			}.bind(this)		
		});
		
		return suc;		
	},
	
	_showErrorMessageBox: function(title, msg){
        Ext.MessageBox.show({
           title: title,
           msg: msg,
           buttons: Ext.MessageBox.OK,
           icon: Ext.MessageBox.ERROR
       });
	}
};

ORYX.Plugins.BPMN2_0Serialization = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN2_0Serialization);
/**
 * Copyright (c) 2008
 * Lutz Gericke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

function gup(name){
    name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
    var regexS = "[\\?&]" + name + "=([^&#]*)";
    var regex = new RegExp(regexS);
    var results = regex.exec(window.location.href);
    if (results == null) 
        return "";
    else 
        return results[1];
}

ORYX.Plugins.Pnmlexport = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
        this.facade = facade;
        
        this.facade.offer({
            'name': ORYX.I18N.Pnmlexport.name,
            'functionality': this.exportIt.bind(this),
            'group': ORYX.I18N.Pnmlexport.group,
            'icon': ORYX.PATH + "images/bpmn2pn_deploy.png",
            'description': ORYX.I18N.Pnmlexport.desc,
            'index': 2,
            'minShape': 0,
            'maxShape': 0
        });
        
    },
    
    exportIt: function(){
    
        // raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
        
        // asynchronously ...
        window.setTimeout((function(){
        
            // ... save synchronously
            this.exportSynchronously();
            
            // raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
            
        }).bind(this), 10);
        
        return true;
    },
    
    exportSynchronously: function(){
    
        var resource = location.href;
        
        
        try {
            var serialized_rdf =this.getRDFFromDOM();
            //serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
            
            var diagramTitle = gup('resource');
            
            // Send the request to the server.
            new Ajax.Request(ORYX.CONFIG.PNML_EXPORT_URL, {
                method: 'POST',
                asynchronous: false,
                parameters: {
                    resource: resource,
                    data: serialized_rdf,
                    title: diagramTitle
                },
                onSuccess: function(request){
                    var pnmlfile = request.responseText;
                    if (pnmlfile.indexOf("RDF to BPMN failed with Exception:") == 0) {
                        //open error window
                        alert(pnmlfile); //errormessage
                    }
                    else {
                        var absolutepath = "http://" + location.host + ORYX.CONFIG.ROOT_PATH + pnmlfile;
                        var output = "<h2>Process: " +
                        self.document.title +
                        "</h2><a target=\"_blank\" href=\"" +
                        absolutepath;

                        var win = new Ext.Window({
                            width: 320,
                            height: 240,
                            resizable: false,
                            minimizable: false,
                            modal: true,
                            autoScroll: true,
                            title: 'Deployment successful',
                            html: output,
                            buttons: [{
                                text: 'OK',
                                handler: function(){
                                    win.hide();
                                }
                            }]
                        });
                        win.show();

                    }
                }
            });
            
        } 
        catch (error) {
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
            alert(error);
        }
    }
});

/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();


/**
 * Implements a mapping from EPC Models to BPMN Models
 *
 *
 */
ORYX.Plugins.EPC2BPMN = Clazz.extend({

    facade: undefined,
    
	EPC_NAMESPACE: 'http://b3mn.org/stencilset/epc#',
	BPMN1_0_NAMESPACE: 'http://b3mn.org/stencilset/bpmn#',
	BPMN1_1_NAMESPACE: 'http://b3mn.org/stencilset/bpmn1.1#',
    
	
    // Offers the plugin functionality
    construct: function(facade){
		
        this.facade = facade;
        Facade = facade;
        
		this.isBPMN1_0 = this.facade.getStencilSets().keys().include(this.BPMN1_0_NAMESPACE);
		this.isBPMN1_1 = this.facade.getStencilSets().keys().include(this.BPMN1_1_NAMESPACE);
		
		if( !this.isBPMN1_0 && !this.isBPMN1_1){ return }
		
		this.facade.offer({
            'name': "EPC to BPMN transform",
            'functionality': this.startTransform.bind(this),
            'group': "epc",
            'icon': ORYX.PATH + "images/epc_export.png",
            'description': "Import from EPC",
            'index': 1,
            'minShape': 0,
            'maxShape': 0
        });
        
    },
    
    
    /**
     * Transforming from EPC to BPMN
     */
    startTransform: function(){
	
		this.showPanel( this.sendRequest.bind(this) );
	
	},
	
	/**
	 * Sends the Request out to the EPC-Model with the given url in the options
	 * 
	 * @param {Object} options
	 */
	sendRequest: function(options){

		var waitingpanel = new Ext.Window({id:'oryx-loading-panel_epc2bpmn',bodyStyle:'padding: 8px',title:'Oryx',width:230,height:55,modal:true,resizable:false,closable:false,frame:true,html:'<span style="font-size:11px;">Please wait while importing...</span>'})
		waitingpanel.show()
		
		if( !options || !options.url ){ return }


		//this.facade.raiseEvent({ type: ORYX.CONFIG.EVENT_LOADING_ENABLE,text: 'Import' });
				
		var url = "./engineproxy?url=" + options.url;
				
        new Ajax.Request( url , {
            method: 'GET',
            onSuccess: function(request){
				
				// asynchronously ...
	            window.setTimeout((function(){
	         
			 		try{
						this.doTransform( request.responseText, options);
					} catch(e) {
						Ext.Msg.alert(ORYX.I18N.Oryx.title,"An Error is occured while importing!");
					}
					
					Ext.getCmp("oryx-loading-panel_epc2bpmn").close();

					// If autolayout is needed, it will be calles 'asychronly'
					if (options.autolayout) {
						window.setTimeout((function(){
							this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_AUTOLAYOUT_LAYOUT});
						}).bind(this), 100);
					}
	            }).bind(this), 100);
		

			}.bind(this),
			onFailure: function(request){
				
				// Disable the loading panel
				this.facade.raiseEvent({ type: ORYX.CONFIG.EVENT_LOADING_DISABLE});	
				
				Ext.Msg.alert(ORYX.I18N.Oryx.title, "Request to server failed!");
			
			}.bind(this)
        });
		   
    },
    
	/**
	 * 
	 * Does actually the Tranformation with an given ERDS-String and some advanced options
	 * 
	 * @param {Object} erdfString
	 * @param {Object} options
	 */
    doTransform: function( erdfString , options){

		var elements = this.parseToObject( erdfString );
		
		var shapes = [];
		
		if( !elements ){
			return 
		}
		var getEPCElementById = function(id){ return elements.find(function(el){ return el.id == id })}
		var deleteShape = function(thisEpc){
							var fShape = shapes.find(function(sh){ return sh.epc == thisEpc });
							if( fShape ){
								fShape.shape.parent.remove( fShape.shape );
								shapes = shapes.without( fShape )
							}
						}	
		var eventsMappingsThrow 	= options && options.events_throw ? options.events_throw.split(";").compact().without("").without(" ").collect(function(s){return s.toLowerCase()}) : [];
		var eventsMappingsCatch		= options && options.events_catch ? options.events_catch.split(";").compact().without("").without(" ").collect(function(s){return s.toLowerCase()}) : [];

		var isIncludedInMappingEventThrow	= function(s){ return eventsMappingsThrow.any(function(map){return map.split(" ").all(function(word){ return s.toLowerCase().include(word) })})}
		var isIncludedInMappingEventCatch	= function(s){ return eventsMappingsCatch.any(function(map){return map.split(" ").all(function(word){ return s.toLowerCase().include(word) })})}
		
		
		
		// ------------------------------------------
		// 1. Rule: Map - Function --> Task
		//
		
		// 
		var functions = elements.findAll(function(el){ return el.type.endsWith("Function")})
		functions.each(function(epc){
			// Create a new Task
			var shape = this.createElement("Task", epc, true);
			// Map Title -> Name
			shape.setProperty(	"oryx-name", 			epc.title);
			// Map Description -> Documentation
			shape.setProperty(	"oryx-documentation", 	epc.description);
			
			shapes.push({shape: shape, epc:epc})
		}.bind(this))
		
		
		// ------------------------------------------
		// 2. Rule: Events
		//
		
		// 			
		var events = elements.findAll(function(el){ return el.type.endsWith("Event")})
		
		// ------------------------------------------
		// 2a. Rule: Map - Events without an incoming edge --> StartEvent
		//
		
		// 
		var startevents	= events.findAll(function(ev){ return !elements.any(function(el){ return el.outgoing && el.outgoing.any(function(out){ return out.slice(1) == ev.id }) }) })
		startevents.each(function(epc){		
		
			// If its inculded in the mapping, set the type to StartMessageEvent, otherwise is it a StartEvent
			var startEventType = isIncludedInMappingEventCatch(epc.title) ? "StartMessageEvent" : "StartEvent";
			
			// Create a new Task
			var shape = this.createElement(startEventType, epc, true);
			// Map Title, Description -> Documentation
			if( startEventType == "StartMessageEvent"){
				shape.setProperty(	"oryx-message", epc.title );
			} else {
				shape.setProperty(	"oryx-documentation", epc.title + " - "+ epc.description);			
			}
			shapes.push({shape: shape, epc:epc})
		}.bind(this));		
		
		
		// ------------------------------------------
		// 2b. Rule: Map - Events without an outgoing edge --> EndEvent
		//
		
				
		// 		
		var endevents	= events.findAll(function(ev){ return !ev.outgoing })
		endevents.each(function(epc){

			// If its inculded in the mapping, set the type to StartMessageEvent, otherwise is it a StartEvent
			var endEventType = this.isBPMN1_1 && isIncludedInMappingEventThrow(epc.title) ? "MessageEndEvent" : "EndEvent";
			
			// Create a new Task
			var shape = this.createElement(endEventType, epc, true);
			
			//var fcTitle = deletePreviousFunction( epc )
			
			// Map Title, Description -> Documentation			
			if( endEventType == "MessageEndEvent"){
				shape.setProperty(	"oryx-message", epc.title );
			} else {
				shape.setProperty(	"oryx-documentation", epc.title + " - "+ epc.description);			
			}

			// Set the end event type of message
			if(  this.isBPMN1_0 && isIncludedInMappingEventThrow(epc.title)){
				shape.setProperty(	"oryx-result", "Message");
				shape.setProperty(	"oryx-message", epc.title );
			}
			shapes.push({shape: shape, epc:epc})
			
		}.bind(this));	


		// ------------------------------------------
		// extention Rule: Map - Events to Message Events which are defined in the advance settings
		//
		
		// 	
		var intermediateEvents		= [].without.apply(events, startevents.concat(endevents))
		intermediateEventsCatch		= intermediateEvents.findAll(function(epc){ return isIncludedInMappingEventCatch(epc.title)})
		intermediateEventsCatch.each(function(epc){
			var type = this.isBPMN1_1 ? "IntermediateMessageEventCatching" : "IntermediateMessageEvent";
			// Create a new Task
			var shape = this.createElement(type, epc, true);
			// Map Title -> Message
			shape.setProperty(	"oryx-message", epc.title );
			//shape.setProperty(	"oryx-message", epc.title + " - "+ epc.description);

			shapes.push({shape: shape, epc:epc})
			
		}.bind(this));
			

		intermediateFunctionsThrow		= functions.findAll(function(epc){ return isIncludedInMappingEventThrow(epc.title)})
		intermediateFunctionsThrow.each(function(epc){
			
			deleteShape( epc )
			
			var type = this.isBPMN1_1 ? "IntermediateMessageEventThrowing" : "IntermediateMessageEvent";
			
			var fEdge = epc.outgoing ? getEPCElementById( epc.outgoing[0].slice(1) ) : null;
			if( fEdge && fEdge.outgoing){
				var fEvent = getEPCElementById(fEdge.outgoing[0].slice(1));
				if(fEvent && fEvent.type.endsWith("Event") && !fEvent.outgoing && isIncludedInMappingEventThrow(fEvent.title)){
					deleteShape( fEvent );
					type = this.isBPMN1_1 ? "MessageEndEvent" : "EndEvent";
				}
			}
			
			// Create a new Task
			var shape = this.createElement(type, epc, true);
			
			// Map Title -> Message
			shape.setProperty(	"oryx-message", epc.title );
			//shape.setProperty(	"oryx-message", epc.title + " - "+ epc.description);
			
			if(  this.isBPMN1_0 && type == "EndEvent"){
				shape.setProperty(	"oryx-result", "Message");
			}
			
			shapes.push({shape: shape, epc:epc})
					
		}.bind(this));						
		// ------------------------------------------
		// 3. Rule: Map - Connector --> Gateway
		//
		
		// 	
		var connectors	= elements.findAll(function(el){ return el.type.endsWith("Connector") })
		connectors.each(function(epc){
			
			// Set the BPMN Type
			var type = "Exclusive_Databased_Gateway";
			if(epc.type.endsWith("AndConnector")){ 		type = "AND_Gateway"; } 
			else if(epc.type.endsWith("OrConnector")){ 	type = "OR_Gateway";  }
			
			if( type == "Exclusive_Databased_Gateway" && epc.outgoing && epc.outgoing.all(function(out){  return intermediateEventsCatch.include(getEPCElementById(getEPCElementById(out.slice(1)).outgoing[0].slice(1))) })){
				type = "Exclusive_Eventbased_Gateway";
			}
			// Create a new Task
			var shape = this.createElement(type, epc, true);

			shapes.push({shape: shape, epc:epc})
		}.bind(this))				


				
		// ------------------------------------------
		// 2c. Rule: Map - Events directly after an Split Connectors (except AND-Connector) --> Conditions on the Edges after the Gateway
		//
		
		// 	
		connectors.each(function(epc){
			if(epc.outgoing && epc.outgoing.length > 1 && !epc.type.endsWith("AndConnector")){

				epc.outgoing.each(function(out){
					var next = getEPCElementById(out.slice(1));
					// If its an edge
					if( next.type.endsWith("ControlFlow") && next.outgoing){
						
						next.outgoing.each(function(out2){
							var nextnext = getEPCElementById(out2.slice(1));
							if(nextnext.type.endsWith("Event")){
								next["expression"] = nextnext.title
							}
						})
						
					}					
				})
			}
		}.bind(this))	
		
				

		// ------------------------------------------
		// 5. Rule: Map - Data --> Data Object		
		//
		
		// 	
		var datas = elements.findAll(function(el){ return el.type.endsWith("Data")})
		datas.each(function(epc){
			// Create a new Task
			var shape = this.createElement("DataObject", epc, true);
			// Map Title -> Name
			shape.setProperty(	"oryx-name", 			epc.title);
			// Map Description -> Documentation
			shape.setProperty(	"oryx-documentation", 	epc.description);
			
			shapes.push({shape: shape, epc:epc})
		}.bind(this))


		// ------------------------------------------
		// 6. Rule: Map - System --> Annotation		
		//
		
		// 					
		var systems = elements.findAll(function(el){ return el.type.endsWith("System")})
		systems.each(function(epc){
			// Create a new Task
			var shape = this.createElement("TextAnnotation", epc, true);
			// Map Title -> Text
			shape.setProperty(	"oryx-text", "Used System: " + epc.title);
						
			shapes.push({shape: shape, epc:epc})
		}.bind(this))



		// ------------------------------------------
		// 7. Rule: Map - ProcessLink --> Sub-Process
		//
		
		// 
		var processlinks = elements.findAll(function(el){ return el.type.endsWith("ProcessInterface")})
		processlinks.each(function(epc){
			
			var type = this.isBPMN1_1 ? "collapsedSubprocess" : "Subprocess";
			// Create a new Task
			var shape = this.createElement(type, epc, true);
			// Map Title -> Name
			shape.setProperty(	"oryx-name", 			epc.title);
			// Map Description -> Documentation
			shape.setProperty(	"oryx-documentation", 	epc.description);
			// Map URL -> SubProcessRef
			shape.setProperty(	"raziel-entry",		 	epc.refuri);
			
			shapes.push({shape: shape, epc:epc})
		}.bind(this))		
	
		

		// ------------------------------------------
		// 4. Rule: Map - Organization/Position --> Pool
		//
		
		// 
		var organizations 		= options.organization ? elements.findAll(function(el){ return el.type.endsWith("Organization") || el.type.endsWith("Position")}) : [];
		var organizationNames 	= organizations.collect(function(epc){ return epc.title }).uniq().sort();
		organizations			= organizationNames.collect(function(name){ return organizations.findAll(function(epc){ return epc.title == name}) });
		
		if( organizations.length > 0 ){
			
			var pool 		= this.createElement("Pool");
			
			var lanes 		= [];
			var addedShapes	= [];
			
			organizations.each(function(epcs){
				// Create a new Task
				var lane = this.createElement("Lane");
				// Map Title -> Name
				lane.setProperty(	"oryx-name", epcs[0].title);
				pool.add( lane );
				lanes.push({shape: lane, epc:epcs[0]});
				
				epcs.each(function(epc){

					var prevFunctions = epc.outgoing ? epc.outgoing.collect(function(out){ return getEPCElementById(out.slice(1)).outgoing[0].slice(1) }) : [];
				
					var allRelatedFunctions = shapes.findAll(function(shape){ return shape.epc.type.endsWith("Function") || shape.epc.type.endsWith("ProcessInterface") })
					allRelatedFunctions = allRelatedFunctions.findAll(function(shape){ return  prevFunctions.include(shape.epc.id) || (shape.epc.outgoing && shape.epc.outgoing.any(function(out){ return getEPCElementById(out.slice(1)).outgoing.first().slice(1) == epc.id}))})
					
					allRelatedFunctions.each(function(shape){
						lane.add(shape.shape)
						addedShapes.push(shape)
					})
											
				});
			}.bind(this));	
			
			var notAddedShapes = [].without.apply(shapes, addedShapes);

			// Get all function which are not added to a pool yet
			var notAddedFunctions = notAddedShapes.findAll(function(shape){ return shape.epc.type.endsWith("Function")  || shape.epc.type.endsWith("ProcessInterface") });
			if( notAddedFunctions.length > 0 ){
				// Create a new empty pool
				var emptyLane	= this.createElement("Lane");
				pool.add( emptyLane );
				// Add all functions to this pool
				notAddedFunctions.each(function(shape){
					emptyLane.add( shape.shape )
					addedShapes.push(shape);				
				})			
			}

			var notAddedShapes = [].without.apply(shapes, addedShapes);			
			
			// Finds all shapes which are in the 'notAddedShapes'-Array 
			// but aren't in the 'addedShapes'-Array
			var findNextShapesWhichAreNotAdded = function(outgoings){
				
				if( !outgoings ){ return [] }
				
				var res = [];
				
				outgoings.each(function(out){
					// Find one following shape
					var sh = shapes.find(function(el){ return el.epc.id == out.slice(1) })
					
					if (sh) {
						// Lookup in the addedShapes array
						if (addedShapes.indexOf(sh) >= 0) {
							throw $break
						}
						
						if (notAddedShapes.indexOf(sh) >= 0) {
							res.push(sh)
						}
						
						res = res.concat( findNextShapesWhichAreNotAdded( sh.epc.outgoing ) )
					} else {
						res = res.concat( findNextShapesWhichAreNotAdded( getEPCElementById(out.slice(1)).outgoing ) );
					}
					
				});

				return res;
			}

			// Go thru all added shapes (mainly Functions) 
			// and find all following shapes which are not in the added shapes array
			// and add these to the same pool like this
			addedShapes.each(function(shape){
				var nextShapes = findNextShapesWhichAreNotAdded(shape.epc.outgoing)
				
				nextShapes.each(function(nextShape){
					shape.shape.parent.add( nextShape.shape )
					notAddedShapes = notAddedShapes.without( nextShape );	
				})
			});		


			var findNextShapeWhichIsAdded = function(outgoings){
				
				if( !outgoings ){ return [] }
				var res;
				
				outgoings.each(function(out){
					var sh = shapes.find(function(el){ return el.epc.id == out.slice(1) })
					
					if (sh) {
						// Lookup in the addedShapes array
						if (addedShapes.indexOf(sh) >= 0) {
							res = sh;
							throw $break
						}
						res = findNextShapeWhichIsAdded( sh.epc.outgoing );
					} else {
						res = findNextShapeWhichIsAdded( getEPCElementById(out.slice(1)).outgoing );
					}
					
				});

				return res;
			}			
			// For every shapes which couldn't be a following shape
			// (like a start event) add these to this following shape.
			notAddedShapes.each(function(shape){
				
				var nextShape = findNextShapeWhichIsAdded( shape.epc.outgoing );
				if( nextShape ){
					nextShape.shape.parent.add( shape.shape )
					addedShapes.push( shape );						
				}
			})
			
		
		}
		
					
		// --------------------------
		// Generate all Edges
		//
		
		// Function for finding the following shape which is already instanceiated
		var findFollowingShape = function(edge){
			if( !edge || !edge.outgoing){ return null }
			
			var nextElement = edge
			var nextShape;
			
			while(!nextShape){
				
				// Get the following shape
				nextElement = elements.find(function(el){ return nextElement.outgoing && nextElement.outgoing.any(function(out){ return out.slice(1) == el.id } )})
				// Look up if there is an instanciated shape
				nextShape 	= shapes.find(function(el){ return el.epc === nextElement })
				
				if( !nextElement || !nextElement.outgoing){
					break
				}
			}
			
			return nextShape
		}

		
		var edges = []
		// Push all edges to the array which come up in the available shapes		
		shapes.each(function(from){ 
			if(from.epc.outgoing){
				from.epc.outgoing.each(function(out){
					var edge = elements.find(function(epc){ return ( epc.type.endsWith("ControlFlow") || epc.type.endsWith("Relation") ) && epc.id == out.slice(1)}) 
					var next = findFollowingShape( edge );
					if( edge && next){				
						edges.push({
							from: 	from, 
							edge:	edge,
							to: 	next
						})
					}				
				})				
			}				
		})	
		
		// Create all the edges
		edges.each(function(edge){
			// Create a new Edge
			var shape
			if( edge.edge.type.endsWith("Relation") ) {
				if(edge.edge.informationflow.toLowerCase() == "true"){
					shape = this.createElement("Association_Unidirectional", edge.edge);				
				} else {
					shape = this.createElement("Association_Undirected", edge.edge);					
				}
			} else {
				shape = this.createElement("SequenceFlow", edge.edge);
			}
			
			var from 	= edge.from.shape;
			var to 		= edge.to.shape;
			// Set the docker
			shape.dockers.first().setDockedShape( from );
			shape.dockers.first().setReferencePoint({x: from.bounds.width() / 2.0, y: from.bounds.height() / 2.0});
			//shape.dockers.first().update()

			shape.dockers.last().setDockedShape( to );
			shape.dockers.last().setReferencePoint({x: to.bounds.width() / 2.0, y: to.bounds.height() / 2.0});
			//shape.dockers.last().update()
			
			// If there is an expression, it will be setted
			if( edge.edge.expression ){
				shape.setProperty("oryx-conditionexpression", edge.edge.expression)
			}
			
			shapes.push({shape: shape, epc:edge.edge})
		}.bind(this))		


		// --------------------------
		// UPDATE
		//		
		this.facade.getCanvas().update();
		
	},
	
	/**
	 * Creates a BPMN-Shape with the given type
	 * 
	 * @param {Object} bpmnType
	 * @param {Object} epcElement
	 * @param {Object} setBounds
	 */
	createElement: function(bpmnType, epcElement, setBounds, alternativeBPMNType){

		// Create a new Stencil		
		var ssn 	= this.facade.getStencilSets().keys()[0];						
		var stencil = ORYX.Core.StencilSet.stencil(ssn + bpmnType);
	
		if( !stencil && alternativeBPMNType ){
			stencil = ORYX.Core.StencilSet.stencil(ssn + alternativeBPMNType);
		}

		if( !stencil ){
			return null;
		}
			
		// Create a new Shape
		var newShape = (stencil.type() == "node") ?
										new ORYX.Core.Node(
											{'eventHandlerCallback':this.facade.raiseEvent },
											stencil) :
										new ORYX.Core.Edge(
											{'eventHandlerCallback':this.facade.raiseEvent },
											stencil);

		// Add the shape to the canvas
		this.facade.getCanvas().add(newShape);
		
		if( epcElement && epcElement.bounds && setBounds){
			// Set the bounds
			newShape.bounds.centerMoveTo( epcElement.bounds.center )
		}
		
		return newShape;
					
	},
	
	/**
	 * Parsed the given ERDF-String to a Array with the individual
	 * EPC-Objects
	 * 
	 * @param {Object} erdfString
	 */
	parseToObject: function ( erdfString ){

		var parser	= new DOMParser();			
		var doc		= parser.parseFromString( erdfString ,"text/xml");

		var getElementByIdFromDiv = function(id){ return $A(doc.getElementsByTagName('div')).find(function(el){return el.getAttribute("id")== id})}

		// Get the oryx-editor div
		var editorNode 	= getElementByIdFromDiv('oryxcanvas');
		editorNode 		= editorNode ? editorNode : getElementByIdFromDiv('oryx-canvas123');

		var hasEPC = editorNode ? $A(editorNode.childNodes).any(function(node){return node.nodeName.toLowerCase() == "a" && node.getAttribute('rel') == 'oryx-stencilset' && node.getAttribute('href').endsWith('epc/epc.json')}) : null;

		if( !hasEPC ){
			this.throwErrorMessage('Imported model is not an EPC model!');
			return null
		}


		// Get all ids from the canvas node for rendering
		var renderNodes = $A(editorNode.childNodes).collect(function(el){ return el.nodeName.toLowerCase() == "a" && el.getAttribute('rel') == 'oryx-render' ? el.getAttribute('href').slice(1) : null}).compact()
		// Collect all nodes from the ids
		renderNodes = renderNodes.collect(function(el){return getElementByIdFromDiv(el)});

		// Function for extract all eRDF-Attributes and give them back as an Object
		var parseAttribute = function(node){
		    var res = {}
			// Set the resource id
			if(node.getAttribute("id")){
				res["id"] = node.getAttribute("id");
			}
			
			// Set all attributes
		    $A(node.childNodes).each( function(node){ 
				if( node.nodeName.toLowerCase() == "span" && node.getAttribute('class')){
		            var key = node.getAttribute('class').slice(5);
					res[key] = node.firstChild ? node.firstChild.nodeValue : '';
		        	if( key == "bounds" ){
						var ba = $A(res[key].split(",")).collect(function(el){return Number(el)})
						res[key] = {a:{x:ba[0], y:ba[1]},b:{x:ba[2], y:ba[3]},center:{x:ba[0]+((ba[2]-ba[0])/2),y:ba[1]+((ba[3]-ba[1])/2)}}
					}
				} else if( node.nodeName.toLowerCase() == "a" && node.getAttribute('rel')){
		            var key = node.getAttribute('rel').split("-")[1];
					if( !res[key] ){
						res[key] = [];
					}
					
		            res[key].push( node.getAttribute('href') )
		        }
		    })
		    return res
		}

		// Collect all Attributes out of the Nodes
		return renderNodes.collect(function(el){return parseAttribute(el)});
				
	},
	
	/**
	 * 
	 * @param {Object} message
	 */
	throwErrorMessage: function(message){
		Ext.Msg.alert( ORYX.I18N.Oryx.title, message )
	},
	
	/** ********************************************************
	 * 
	 * UI-WINDOW
	 * 
	 * ********************************************************
	 * 
	 * Shows the Popup Window where u can specify the url
	 * and some advanced parameter
	 * 
	 * @param {Object} callback
	 */
	showPanel: function( callback ){
			
		Ext.QuickTips.init();
		
		var mainForm = new Ext.form.FormPanel({
						id:				'transform-epc-bpmn-id-main',
					    labelWidth: 	40,
					    defaultType: 	'textfield',
					    bodyStyle:		'padding:5px',
					    defaults: 		{width: 300, msgTarget: 'side'},
					    items: [{
								text:'For the import and transformation from EPC to BPMN please set the URL to the EPC model.', 
								xtype:'label',
								style:'padding-bottom:10px;display:block',
								width:"100%"
							},{
								fieldLabel: 'URL',
								name: 		'last',
								//vtype: 		'url',
								allowBlank: false
							}]
					});
		
		
		var advanceForm = new Ext.form.FormPanel({
					    id:				'transform-epc-bpmn-id-advance',
					    collapsed:		true,
					    labelWidth: 	30,
					    defaultType: 	'textfield',
					    bodyStyle:		'padding:15px',
						defaults:		{width: 300,msgTarget: 'side',labelSeparator:''},
					    items: [{
								text:	'Event-Mapping',
								xtype: 	'label',
								cls:	'transform-epc-bpmn-title'
					        },{
								text:	'If u like to transform indivual event from EPC to event in BPMN, please give keyword regarding to these (separated with a \';\').',
								xtype: 	'label',
								width:	'100%',
								style:	'margin-bottom:10px;display:block;'
					        },{
								labelStyle: 'background:transparent url(stencilsets/bpmn/icons/intermediate-message.png) no-repeat scroll 0px -1px;width:30px;height:20px',
					            name: 	'events_catch'
					        },{
								labelStyle: !this.isBPMN1_0 ? 'background:transparent url(stencilsets/bpmn/icons/intermediate-message.png) no-repeat scroll 0px -30px;width:30px;height:20px' : 'display:none',
					            name: 	'events_throw',
								style:	this.isBPMN1_0 ? "display:none;" : ""
					        },{
								text:	'Organization',
								xtype: 	'label',
								style:	'margin-top:10px;display:block;',
								cls:	'transform-epc-bpmn-title'
					        },{
								text:	'Should the organizational units and roles maped to a pool/lane? (Required Auto-Layout)',
								xtype: 	'label',
								width:	'100%',
								style:	'margin-bottom:10px;display:block;'
					        },{
								boxLabel: 'Organization',
								name: 	'autolayout',
								id:		'transform-epc-bpmn-id-organization',
								xtype:	'checkbox',
								labelStyle:	'width:30px;height:20px'
					        },{
								text:	'Auto-Layout',
								xtype: 	'label',
								style:	'margin-top:10px;display:block;',
								cls:	'transform-epc-bpmn-title'
					        },{
								text:	'By enable the autolayout, the model will be auto layouted afterwards with the AutoLayout Plugin. (Needs a while)',
								xtype: 	'label',
								width:	'100%',
								style:	'margin-bottom:10px;display:block;'
					        },{
								boxLabel: 'Auto-Layout',
								name: 	'autolayout',
								id:		'transform-epc-bpmn-id-autolayout',
								xtype:	'checkbox',
								labelStyle:	'width:30px;height:20px'
					        }]
					});

		Ext.getCmp('transform-epc-bpmn-id-organization').on('check', function(obj, check){
			if(check){
				Ext.getCmp('transform-epc-bpmn-id-autolayout').setValue( true );
				Ext.getCmp('transform-epc-bpmn-id-autolayout').disable();
			} else {
				Ext.getCmp('transform-epc-bpmn-id-autolayout').enable();
			}
		})
		
		
		var groupButton = {
			            text:			'Advanced Settings',
			            xtype:			'button',
			            enableToggle:	true,
						cls:			'transform-epc-bpmn-group-button',
			            handler:function(d){
			                var d = Ext.getCmp('transform-epc-bpmn-id-advance');
			                if(d.collapsed){
			                    d.expand();
			                } else {
			                    d.collapse();
			                }
			            }
			        }
					
		
		var windowPanel = new Ext.Window({
					    title:			ORYX.I18N.Oryx.title + " - Transform EPC to BPMN",
					    width:			400,
						id:				'transform-epc-bpmn-id-panel',
						cls:			'transform-epc-bpmn-window',
					    items: 			new Ext.Panel({frame:true,autoHeight:true,items:[mainForm, groupButton , advanceForm]}),
						floating:		true,
						shim:			true,
						modal:			true,
						resizable:		false,
						autoHeight:		true,			    
						buttons:[{
								text:	'Import',
								handler: function(){
									var res = {};
									
									var urlField = Ext.getCmp('transform-epc-bpmn-id-main').findByType('textfield')[0]
									
									if( urlField.validate() ){
										res.url 			= urlField.getValue();
									}
									
									if( !Ext.getCmp('transform-epc-bpmn-id-advance').collapsed ){
										res.events_catch	= Ext.getCmp('transform-epc-bpmn-id-advance').findByType('textfield')[0].getValue();
										if( this.isBPMN1_1 ){
											res.events_throw = Ext.getCmp('transform-epc-bpmn-id-advance').findByType('textfield')[1].getValue();
										}
										res.organization	= Ext.getCmp('transform-epc-bpmn-id-advance').findByType('checkbox')[0].getValue();
										res.autolayout 		= Ext.getCmp('transform-epc-bpmn-id-advance').findByType('checkbox')[1].getValue();
									}
									
									Ext.getCmp('transform-epc-bpmn-id-panel').close();
								
									callback( res );
								}.bind(this)
							},{
								text:	'Cancel',
								handler: function(){
									Ext.getCmp('transform-epc-bpmn-id-panel').close();
								}
							}]  
					})
						
		windowPanel.show()		
	}
	
});


var Facade = undefined;
/**
 * Copyright (c) 2010 Philipp Berger, Kai Schlichting
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
Ext.ns("Oryx.Plugins");

ORYX.Plugins.LolaPetriNetSoundnessChecker = ORYX.Plugins.AbstractPlugin.extend({

    hideOverlays: function(){
        // TODO set in constructor!!!
        if(!this.overlayIds) 
            return;
    
        Ext.each(this.overlayIds, function(overlayId){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: overlayId
            });
        }.bind(this));
    },
    
    getChildShapesByResourceIds: function(resourceIds){
        var shapes = [];
    
        Ext.each(resourceIds, function(resourceId){
            shapes.push(this.facade.getCanvas().getChildShapeByResourceId(resourceId));
        }.bind(this));
        
        return shapes;
    },
    
    /**
	 * Show overlay on given shape.
	 * 
	 * @methodOf ORYX.Plugins.AbstractPlugin.prototype
	 * @example showOverlay( myShape, { stroke: "green" },
	 *          ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
	 *          "title": "Click the element to execute it!", "stroke-width":
	 *          2.0, "stroke": "black", "d": "M0,-5 L5,0 L0,5 Z",
	 *          "line-captions": "round" }]) )
	 * @param {Oryx.XXX.Shape[]}
	 *            shapes One shape or array of shapes the overlay should be put
	 *            on
	 * @param {Oryx.XXX.Attributes}
	 *            attributes some attributes...
	 * @param {Oryx.svg.node}
	 *            svgNode The svg node which should be used as overlay
	 * @param {String}
	 *            [svgNode="NW"] The svg node position where the overlay should
	 *            be placed
	 */
    showOverlay: function(shapes, attributes, svgNode, svgNodePosition ){
        if(!this.overlayIds){
            this.overlayIds = [];
        }
        
        if( !(shapes instanceof Array) ){
            shapes = [shapes]
        }
        
        // Define Shapes
        shapes = shapes.map(function(shape){
            var el = shape;
            if( typeof shape == "string" ){
                el = this.facade.getCanvas().getChildShapeByResourceId( shape );
                el = el || this.facade.getCanvas().getChildById( shape, true );
            }
            return el;
        }.bind(this)).compact();
        
        // Define unified id
        var overlayId = this.type + ORYX.Editor.provideId();
        this.overlayIds.push(overlayId);
        
        this.facade.raiseEvent({
            type        : ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id          : overlayId,
            shapes      : shapes,
            attributes  : attributes,
            node        : svgNode,
            nodePosition: svgNodePosition || "NW"
        });
        
    },

    // Offers the plugin functionality
    construct: function(facade){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
                
        this.facade.offer({
            'name': "Check soundness",// ORYX.I18N.BPMN2PNConverter.name,
            'functionality': this.showCheckerWindow.bind(this),
            'group': "Verification",
            'icon': ORYX.PATH + "images/soundness_checker/accept.png",
            'description': "Checks current Petri net for different soundness criteria with LoLA.",
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    showCheckerWindow: function(){
        var plugin = this;
        
        var CheckNode = Ext.extend(Ext.tree.TreeNode, {
            constructor: function(config) {
                if(!config.icon && !this.icon)
                    config.icon = CheckNode.UNKNOWN_STATUS;

                CheckNode.superclass.constructor.apply(this, arguments);
                
                Ext.apply(this, config);
                
                if(this.clickHandler){
                    this.on('click', this.clickHandler.bind(this));
                }
            },

            setIcon: function(status) {
                this.ui.getIconEl().src = status;
            },
            getIcon: function(status) {
                return this.ui.getIconEl().src;
            },
            reset: function(){
                plugin.hideOverlays();
                this.hideMarking();
                // Reset syntax errors
                plugin.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
            },
            hideMarking: function(){
                if(!plugin.marking)
                    return;
            
                for(place in plugin.marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    if(placeShape)// place can be null if removed
                        placeShape.setProperty("oryx-numberoftokens", 0);
                }
                // Show changes
                plugin.facade.getCanvas().update();
                
                plugin.marking = undefined;
            },
            showMarking: function(marking){
                plugin.marking = marking;
            
                for(place in marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    placeShape.setProperty("oryx-numberoftokens", marking[place]);
                }
                // Show changes
                plugin.facade.getCanvas().update();
            },
            showErrors: function(errors){
                // Remove all old error nodes
                Ext.each(this.childNodes, function(child){
                    if(child && child.itemCls === 'error')
                        child.remove();
                });
                
                // Show Unknown status on child nodes
                Ext.each(this.childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise
					// structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
                
                // Show errors
                Ext.each(errors, function(error){
                    this.insertBefore(new CheckNode({
                        icon: CheckNode.ERROR_STATUS,
                        text: error,
                        itemCls: 'error'
                    }), this.childNodes[0]);
                }.bind(this));
            },
            showOverlayWithStep: function(shapeIds){
                Ext.each(shapeIds, function(shapeId, index){
                    plugin.showOverlay(
                        plugin.facade.getCanvas().getChildShapeByResourceId(shapeId), 
                        {
                            fill: "#FB7E02"// orange
                        },
                        ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                            "style": "font-size: 16px; font-weight: bold;"
                        }, (index + 1)+"."]),
                        "SE" // position in south east
                    );
                });
            },
            /*
             * incoming list of marking resourceId:#tokens
             */
            showOverlayMarking: function(shapeIdsToMark){
                Ext.each(shapeIdsToMark, function(shapeIdToMark, index){
                	var split = shapeIdToMark.split(":");
                    plugin.showOverlay(
                        plugin.facade.getCanvas().getChildShapeByResourceId(split[0].trim()), 
                        {
                            fill: "#FB7E02"// orange
                        },
                        ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                            "style": "font-size: 16px; font-weight: bold;"
                        }, (split[1])]),
                        "SE" // position in south east
                    );
                });
            },
            showOverlay: function(shapes){
                if(shapes.length === 0)
                    return;

                if(! shapes[0] instanceof ORYX.Core.Node)
                    shapes = plugin.getChildShapesByResourceIds(shapes)
            
                plugin.showOverlay(
                    shapes, 
                    {
                        fill: "#FB7E02"// orange
                    }
                );
            }
        });
        CheckNode.UNKNOWN_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'asterisk_yellow.png';
        CheckNode.ERROR_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'exclamation.png';
        CheckNode.OK_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'accept.png';
        CheckNode.LOADING_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'loading.gif';
        
        var LivenessNode = Ext.extend(CheckNode, {
            constructor: function(config) {
//            config.qtip = '<b>AGEF Criteria</b>: Makes sure that any process instance that starts in the initial state will eventually reach the final state.';
            config.qtip = '<b>Weak Termination</b>: Makes sure that from any state, reachable from the initial state, the final state well eventually be reached.';
                // If any dead locks are detected, click to show one counter example.';            
                LivenessNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                this.showOverlayMarking(this.marking);
            },
            update: function(res){
            	this.marking = res.counter?res.counter.split(","):[];
                this.setIcon(res.liveness? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
//                this.setText('The net is '+(res.liveness?  'not' : '')+' AGEF final place.');
                this.setText('There is '+(res.liveness?  'no' : 'a')+' marking from which one cannot reach the final state.');
            }
        });
        
        var BoundednessNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Boundedness Criteria</b>: There are not unbounded places in the net. If any unbounded places are detected, click to show one counter example.';
            
                BoundednessNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                this.showOverlay(this.unboundedplaces);
            },
            update: function(res){
            	this.unboundedplaces  = res.unboundedplaces ;
            	if(res.boundedness){
            		this.unboundedplaces=[];
            	}
                
                this.setIcon(res.boundedness? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.unboundedplaces.length +' unbounded places.');
            }
        });
        
        var DeadTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>No Dead Transitions Criteria</b>: Each transition can contribute to at least one process instance. Click to see all dead transitions.';
            
                DeadTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.deadTransitions);
            },
            update: function(res){
                this.deadTransitions = res.deadtransitions ;
              	if(res.quasiliveness ){
            		this.deadTransitions=[];
            	}
                
                this.setIcon(this.deadTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.deadTransitions.length +' dead transitions.');
            }
        });
        
        var NotParticipatingTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Transition Participation Criteria</b>: Each transition participates in at least one process instance that starts in the initial state and reaches the final state. Click to see all transitions not participating in any process instance.';
            
                NotParticipatingTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.notParticipatingTransitions);
            },
            update: function(res){
//            	res.transitioncover 
                this.notParticipatingTransitions = res.uncoveredtransitions;
                
                this.setIcon(this.notParticipatingTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.notParticipatingTransitions.length +' transitions that cannot participate in a properly terminating firing sequence.');
            }
        });
        
        var service_tech_site_banner = new Object;
        service_tech_site_banner.html='<a href="http://www.service-technology.org/">'+
        '<img src="' + ORYX.CONFIG.ROOT_PATH + '/images/service_tech_site_banner.png" width="400" style="position: relative; left: 35px;"/></a>';
        
        this.checkerWindow = new Ext.Window({
            title: 'Soundness Checker powered by service-technology.org',
            autoScroll: true,
            width: '500',
            tbar: [
                {
                    text: 'Check', 
                    handler: function(){
                        this.checkerWindow.check();
                    }.bind(this)
                },
                {
                    text: 'Hide Errors', 
                    handler: function(){
                        this.checkerWindow.getTree().getRootNode().reset();
                    }.bind(this)
                },
                '->',
                {
                    text: 'Close', 
                    handler: function(){
                        this.checkerWindow.close();
                    }.bind(this)
                }
            ],
            getTree: function(){
                return this.items.get(0);
            },
            check: function(renderAll){
                this.prepareCheck(renderAll);
                this.checkSyntax(this.checkSoundness.bind(this), this.reRender.bind(this));
            },
            reRender: function(){
            	window.setTimeout(function(){
            		this.getResizeEl().beforeAction();
            		this.getResizeEl().sync(true);
            	}.bind(this), 70); 

            },
            prepareCheck: function(renderAll){// call with renderAll=true if
												// showing for the first time
                var root = this.getTree().getRootNode();
                
                root.reset();
                
                // Set loading status to all child nodes
                Ext.each(root.childNodes, function(childNode){
                    if(renderAll)// this expands all nodes so they're
									// rendered a first time
                        childNode.expand(true);
                    childNode.collapse(true); // collapse deeply
                    childNode.setIcon(CheckNode.LOADING_STATUS);
                });
            },
            checkSyntax: function(callback, finshedCallback){
                plugin.facade.raiseEvent({
                    type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
                    onErrors: function(){
                        Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!")
                        this.turnLoadingIntoUnknownStatus();
                        finshedCallback();

                    }.bind(this),
                    onNoErrors: function(){
                        callback();
                        finshedCallback();
                    }
                });
            },
            // All child nodes with loading status get unknown status
            turnLoadingIntoUnknownStatus: function(){
                Ext.each(this.getTree().getRootNode().childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise
					// structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
            },
            checkSoundness: function(){
                var root = this.getTree().getRootNode();
                
                // Check for structural soundness (no server request needed and
				// return, if any has been found
                if(! root.findChild("id", "structuralSound").check()){
                    this.turnLoadingIntoUnknownStatus();
                    return;
                }
                var serialized_rdf = plugin.getRDFFromDOM();
    			if (!serialized_rdf.startsWith("<?xml")) {
    				serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
    			}
                // Check other soundness criteria which needs server requests
                Ext.Ajax.request({
//                    url: ORYX.CONFIG.SERVER_HANDLER_ROOT + '/lola',
                	url: ORYX.CONFIG.LOLA_PN_CHECKER,
                    method: 'POST',
                    success: function(request){
                        var res = Ext.decode(request.responseText);
                        
                        root.showErrors(res.errors);
                        
                        if(res.errors.length === 0){
                            root.findChild("id", "sound").check(res);
                            root.findChild("id", "weakSound").check(res);
                            root.findChild("id", "relaxedSound").check(res);
                        }
                    }.bind(this),
                    failure: function(){

                    }.bind(this),
                    params: {
                        data: serialized_rdf
                    }
                });
                
            },
            items: [new Ext.tree.TreePanel({
                useArrows: true,
                autoScroll: true,
                rootVisible: false,
                animate: true,
                containerScroll: true,
                
                root: new CheckNode({
                    text: 'Checks',
                    id: 'source',
                    expanded: true
                }),
                listeners: {
                    render: function(treePanel){
                        var structuralSoundNode = new CheckNode({
                            text: 'Structural Sound (Workflow Net)',
                            id: 'structuralSound',
                            /* Returns false when any error has been found */
                            check: function(){
                                this.checkInitialNode.update();
                                this.checkFinalNode.update();
                                this.checkConnectedNode.update(this.checkInitialNode.initialNodes, this.checkFinalNode.finalNodes);
                                
                                if(this.checkInitialNode.hasErrors() || this.checkFinalNode.hasErrors() || this.checkConnectedNode.hasErrors()){
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                    return false;
                                } else {
                                    this.setIcon(CheckNode.OK_STATUS);
                                    return true;
                                }
                            },
                            checkInitialNode: new CheckNode({
                                qtip: 'There must be exactly one initial place, which is the only place without any incoming edges.',
                                update: function(){
                                    this.initialNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getIncomingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.initialNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.initialNodes.length + ' initial places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.initialNodes);
                                },
                                hasErrors: function(){
                                    return this.initialNodes.length !== 1;
                                }
                            }),
                            checkFinalNode: new CheckNode({
                                qtip: 'There must be exactly one final place, which is the only place without any outgoing edges.',
                                update: function(){
                                    this.finalNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getOutgoingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.finalNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.finalNodes.length + ' final places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.finalNodes);
                                },
                                hasErrors: function(){
                                    return this.finalNodes.length !== 1;
                                }
                            }),
                            checkConnectedNode: new CheckNode({
                                qtip: 'Each node in the process model is on the path from the initial node to the final node.',
                                update: function(initialNodes, finalNodes){
                                    // Step through without semantic knowledge
                                    if(initialNodes.length !== 1 || finalNodes.length !== 1){
                                        this.setText("There must be exactly one initial and final place to perform further checks!");
                                        this.setIcon(CheckNode.UNKNOWN_STATUS);
                                        return;
                                    }
                                    
                                    this.notParticipatingNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape instanceof ORYX.Core.Node)
                                            this.notParticipatingNodes.push(shape);
                                    }.bind(this));
                                    
                                    this.passedNodes = [];
                                    
                                    this.findNotParticipatingNodes(initialNodes[0]);
                                    
                                    this.setText(this.notParticipatingNodes.length + ' nodes that aren\'t on any path from beginning to end found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.notParticipatingNodes);
                                },
                                findNotParticipatingNodes: function(currentNode){
                                    this.passedNodes.push(currentNode);
                                    this.notParticipatingNodes.remove(currentNode);
                                    
                                    Ext.each(currentNode.getOutgoingShapes(), function(nextNode){
                                        if(!this.passedNodes.include(nextNode)){
                                            this.findNotParticipatingNodes(nextNode);
                                        };
                                    }.bind(this));
                                },
                                hasErrors: function(){
                                    return this.notParticipatingNodes.length !== 0;
                                }
                            })
                        });
                        structuralSoundNode.appendChild([
                            structuralSoundNode.checkInitialNode,
                            structuralSoundNode.checkFinalNode,
                            structuralSoundNode.checkConnectedNode
                        ]);
                    
                        var soundNode = new CheckNode({
                            text: 'Sound',
                            id: 'sound',
                            check: function(res){
                                if (res.soundness) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                
                                this.deadTransitionsNode.update(res);
                                this.boundednessNode.update(res);
                                this.livenessNode.update(res);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),
                            boundednessNode: new BoundednessNode({}),
                            livenessNode: new LivenessNode({})

                        });
                        soundNode.appendChild([
                            soundNode.deadTransitionsNode,
                            soundNode.boundednessNode,
                            soundNode.livenessNode
                        ]);
                        
                        var weakSoundNode = new CheckNode({
                            text: 'Weak Sound',
                            id: 'weakSound',
                            check: function(res){
                                if (res.weaksoundness) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }

                                this.boundednessNode.update(res);
                                this.livenessNode.update(res);
                            },
                            boundednessNode: new BoundednessNode({}),
                            livenessNode: new LivenessNode({})
                        });
                        weakSoundNode.appendChild([
                            weakSoundNode.boundednessNode,
                            weakSoundNode.livenessNode
                        ]);
                        
                        var relaxedSoundNode = new CheckNode({
                            text: 'Relaxed Sound',
                            id: 'relaxedSound',
                            check: function(res){
                                if (res.relaxedsoundness) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                this.deadTransitionsNode.update(res);
                                this.notParticipatingTransitionsNode.update(res);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),

                            notParticipatingTransitionsNode: new NotParticipatingTransitionsNode({})
                        });
                        relaxedSoundNode.appendChild([
                            relaxedSoundNode.notParticipatingTransitionsNode,
							relaxedSoundNode.deadTransitionsNode

                        ]);
                        
                        treePanel.getRootNode().appendChild([structuralSoundNode, soundNode, weakSoundNode, relaxedSoundNode]);
                        
                    }
                }
            }),service_tech_site_banner],
            listeners: {
                close: function(window){
                    this.checkerWindow.getTree().getRootNode().reset();
                }.bind(this)
            }
        });


        this.checkerWindow.show();
        this.checkerWindow.check(true);
    }
});/**
 * Copyright (c) 2009
 * Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
Ext.ns("Oryx.Plugins");

ORYX.Plugins.PetriNetSoundnessChecker = ORYX.Plugins.AbstractPlugin.extend({

    hideOverlays: function(){
        //TODO set in constructor!!!
        if(!this.overlayIds) 
            return;
    
        Ext.each(this.overlayIds, function(overlayId){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: overlayId
            });
        }.bind(this));
    },
    
    getChildShapesByResourceIds: function(resourceIds){
        var shapes = [];
    
        Ext.each(resourceIds, function(resourceId){
            shapes.push(this.facade.getCanvas().getChildShapeByResourceId(resourceId));
        }.bind(this));
        
        return shapes;
    },
    
    /**
       Show overlay on given shape.
       @methodOf ORYX.Plugins.AbstractPlugin.prototype
       @example
       showOverlay(
           myShape,
           { stroke: "green" },
           ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
               "title": "Click the element to execute it!",
               "stroke-width": 2.0,
               "stroke": "black",
               "d": "M0,-5 L5,0 L0,5 Z",
               "line-captions": "round"
           }])
       )
       @param {Oryx.XXX.Shape[]} shapes One shape or array of shapes the overlay should be put on
       @param {Oryx.XXX.Attributes} attributes some attributes...
       @param {Oryx.svg.node} svgNode The svg node which should be used as overlay
       @param {String} [svgNode="NW"] The svg node position where the overlay should be placed
    */
    showOverlay: function(shapes, attributes, svgNode, svgNodePosition ){
        if(!this.overlayIds){
            this.overlayIds = [];
        }
        
        if( !(shapes instanceof Array) ){
            shapes = [shapes]
        }
        
        // Define Shapes
        shapes = shapes.map(function(shape){
            var el = shape;
            if( typeof shape == "string" ){
                el = this.facade.getCanvas().getChildShapeByResourceId( shape );
                el = el || this.facade.getCanvas().getChildById( shape, true );
            }
            return el;
        }.bind(this)).compact();
        
        // Define unified id
        var overlayId = this.type + ORYX.Editor.provideId();
        this.overlayIds.push(overlayId);
        
        this.facade.raiseEvent({
            type        : ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id          : overlayId,
            shapes      : shapes,
            attributes  : attributes,
            node        : svgNode,
            nodePosition: svgNodePosition || "NW"
        });
        
    },

    // Offers the plugin functionality
    construct: function(facade){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
                
        this.facade.offer({
            'name': "Check soundness",//ORYX.I18N.BPMN2PNConverter.name,
            'functionality': this.showCheckerWindow.bind(this),
            'group': "Verification",
            'icon': ORYX.PATH + "images/checker_validation.png",
            'description': "Checks current Petri net for different soundness criteria.",
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    showCheckerWindow: function(){
        var plugin = this;
        
        var CheckNode = Ext.extend(Ext.tree.TreeNode, {
            constructor: function(config) {
                if(!config.icon && !this.icon)
                    config.icon = CheckNode.UNKNOWN_STATUS;

                CheckNode.superclass.constructor.apply(this, arguments);
                
                Ext.apply(this, config);
                
                if(this.clickHandler){
                    this.on('click', this.clickHandler.bind(this));
                }
            },

            setIcon: function(status) {
                this.ui.getIconEl().src = status;
            },
            getIcon: function(status) {
                return this.ui.getIconEl().src;
            },
            reset: function(){
                plugin.hideOverlays();
                this.hideMarking();
                // Reset syntax errors
                plugin.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
            },
            hideMarking: function(){
                if(!plugin.marking)
                    return;
            
                for(place in plugin.marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    if(placeShape)//place can be null if removed
                        placeShape.setProperty("oryx-numberoftokens", 0);
                }
                // Show changes
                plugin.facade.getCanvas().update();
                
                plugin.marking = undefined;
            },
            showMarking: function(marking){
                plugin.marking = marking;
            
                for(place in marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    placeShape.setProperty("oryx-numberoftokens", marking[place]);
                }
                // Show changes
                plugin.facade.getCanvas().update();
            },
            showErrors: function(errors){
                // Remove all old error nodes
                Ext.each(this.childNodes, function(child){
                    if(child && child.itemCls === 'error')
                        child.remove();
                });
                
                // Show Unknown status on child nodes
                Ext.each(this.childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
                
                // Show errors
                Ext.each(errors, function(error){
                    this.insertBefore(new CheckNode({
                        icon: CheckNode.ERROR_STATUS,
                        text: error,
                        itemCls: 'error'
                    }), this.childNodes[0]);
                }.bind(this));
            },
            showOverlayWithStep: function(shapeIds){
                Ext.each(shapeIds, function(shapeId, index){
                    plugin.showOverlay(
                        plugin.facade.getCanvas().getChildShapeByResourceId(shapeId), 
                        {
                            fill: "#FB7E02"//orange
                        },
                        ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                            "style": "font-size: 16px; font-weight: bold;"
                        }, (index + 1)+"."]),
                        "SE" //position in south east
                    );
                });
            },
            showOverlay: function(shapes){
                if(shapes.length === 0)
                    return;

                if(! shapes[0] instanceof ORYX.Core.Node)
                    shapes = plugin.getChildShapesByResourceIds(shapes)
            
                plugin.showOverlay(
                    shapes, 
                    {
                        fill: "#FB7E02"//orange
                    }
                );
            }
        });
        CheckNode.UNKNOWN_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'asterisk_yellow.png';
        CheckNode.ERROR_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'exclamation.png';
        CheckNode.OK_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'accept.png';
        CheckNode.LOADING_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'loading.gif';
        
        var DeadLocksNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Termination Criteria</b>: Makes sure that any process instance that starts in the initial state will eventually reach the final state. If any dead locks are detected, click to show one counter example.';
            
                DeadLocksNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
            
                if(this.deadLocks.length == 0) return;
                
                var deadLock = node.deadLocks[0];
                this.showOverlayWithStep(deadLock.path);
                this.showMarking(deadLock.marking);
            },
            update: function(deadLocks){
                this.deadLocks = deadLocks;
                this.setIcon(this.deadLocks.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There is '+(this.deadLocks.length == 0 ? 'no' : 'a')+' path that leads to a deadlock.');
            }
        });
        
        var ImproperTerminatingsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Proper Termination Criteria</b>: The final state is the only state reachable from the initial state in which there is a token in the final place. If any improper terminating states are detected, click to show one counter example.';
            
                ImproperTerminatingsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
            
                if(node.improperTerminatings.length == 0) return;
                
                var improperTerminating = node.improperTerminatings[0];
                this.showOverlayWithStep(improperTerminating.path);
                this.showMarking(improperTerminating.marking);
            },
            update: function(improperTerminatings){
                this.improperTerminatings = improperTerminatings;
                
                this.setIcon(this.improperTerminatings.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.improperTerminatings.length +' markings covering the final marking.');
            }
        });
        
        var DeadTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>No Dead Transitions Criteria</b>: Each transition can contribute to at least one process instance. Click to see all dead transitions.';
            
                DeadTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.deadTransitions);
            },
            update: function(deadTransitions){
                this.deadTransitions = deadTransitions;
                
                this.setIcon(this.deadTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.deadTransitions.length +' dead transitions.');
            }
        });
        
        var NotParticipatingTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Transition Participation Criteria</b>: Each transition participates in at least one process instance that starts in the initial state and reaches the final state. Click to see all transitions not participating in any process instance.';
            
                NotParticipatingTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.notParticipatingTransitions);
            },
            update: function(notParticipatingTransitions){
                this.notParticipatingTransitions = notParticipatingTransitions;
                
                this.setIcon(this.notParticipatingTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.notParticipatingTransitions.length +' transitions that cannot participate in a properly terminating firing sequence.');
            }
        });
        
        this.checkerWindow = new Ext.Window({
            title: 'Soundness Checker',
            autoScroll: true,
            width: '500',
            tbar: [
                {
                    text: 'Check', 
                    handler: function(){
                        this.checkerWindow.check();
                    }.bind(this)
                },
                {
                    text: 'Hide Errors', 
                    handler: function(){
                        this.checkerWindow.getTree().getRootNode().reset();
                    }.bind(this)
                },
                '->',
                {
                    text: 'Close', 
                    handler: function(){
                        this.checkerWindow.close();
                    }.bind(this)
                }
            ],
            getTree: function(){
                return this.items.get(0);
            },
            check: function(renderAll){
                this.prepareCheck(renderAll);
                this.checkSyntax(this.checkSoundness.bind(this));
            },
            prepareCheck: function(renderAll){//call with renderAll=true if showing for the first time
                var root = this.getTree().getRootNode();
                
                root.reset();
                
                // Set loading status to all child nodes
                Ext.each(root.childNodes, function(childNode){
                    if(renderAll)//this expands all nodes so they're rendered a first time
                        childNode.expand(true);
                    childNode.collapse(true); //collapse deeply
                    childNode.setIcon(CheckNode.LOADING_STATUS);
                });
            },
            checkSyntax: function(callback){
                plugin.facade.raiseEvent({
                    type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
                    onErrors: function(){
                        Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!")
                        this.turnLoadingIntoUnknownStatus();
                    }.bind(this),
                    onNoErrors: function(){
                        callback();
                    }
                });
            },
            // All child nodes with loading status get unknown status
            turnLoadingIntoUnknownStatus: function(){
                Ext.each(this.getTree().getRootNode().childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
            },
            checkSoundness: function(){
                var root = this.getTree().getRootNode();
                
                // Check for structural soundness (no server request needed and return, if any has been found       
                if(! root.findChild("id", "structuralSound").check()){
                    this.turnLoadingIntoUnknownStatus();
                    return;
                }
                
                // Check other soundness criteria which needs server requests
                Ext.Ajax.request({
//                    url: ORYX.CONFIG.SERVER_HANDLER_ROOT + '/checksoundness',
                	url: ORYX.CONFIG.PN_CHECKER,
                    method: 'POST',
                    success: function(request){
                        var res = Ext.decode(request.responseText);
                        
                        root.showErrors(res.errors);
                        
                        if(res.errors.length === 0){
                            root.findChild("id", "sound").check(res);
                            root.findChild("id", "weakSound").check(res);
                            root.findChild("id", "relaxedSound").check(res);
                        }
                    },
                    failure: function(){
                    },
                    params: {
                        data: plugin.getSerializedDOM()
                    }
                });
                
            },
            items: [new Ext.tree.TreePanel({
                useArrows: true,
                autoScroll: true,
                rootVisible: false,
                animate: true,
                containerScroll: true,
                
                root: new CheckNode({
                    text: 'Checks',
                    id: 'source',
                    expanded: true
                }),
                listeners: {
                    render: function(treePanel){
                        var structuralSoundNode = new CheckNode({
                            text: 'Structural Sound (Workflow Net)',
                            id: 'structuralSound',
                            /* Returns false when any error has been found */
                            check: function(){
                                this.checkInitialNode.update();
                                this.checkFinalNode.update();
                                this.checkConnectedNode.update(this.checkInitialNode.initialNodes, this.checkFinalNode.finalNodes);
                                
                                if(this.checkInitialNode.hasErrors() || this.checkFinalNode.hasErrors() || this.checkConnectedNode.hasErrors()){
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                    return false;
                                } else {
                                    this.setIcon(CheckNode.OK_STATUS);
                                    return true;
                                }
                            },
                            checkInitialNode: new CheckNode({
                                qtip: 'There must be exactly one initial place, which is the only place without any incoming edges.',
                                update: function(){
                                    this.initialNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getIncomingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.initialNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.initialNodes.length + ' initial places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.initialNodes);
                                },
                                hasErrors: function(){
                                    return this.initialNodes.length !== 1;
                                }
                            }),
                            checkFinalNode: new CheckNode({
                                qtip: 'There must be exactly one final place, which is the only place without any outgoing edges.',
                                update: function(){
                                    this.finalNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getOutgoingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.finalNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.finalNodes.length + ' final places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.finalNodes);
                                },
                                hasErrors: function(){
                                    return this.finalNodes.length !== 1;
                                }
                            }),
                            checkConnectedNode: new CheckNode({
                                qtip: 'Each node in the process model is on the path from the initial node to the final node.',
                                update: function(initialNodes, finalNodes){
                                    //Step through without semantic knowledge
                                    if(initialNodes.length !== 1 || finalNodes.length !== 1){
                                        this.setText("There must be exactly one initial and final place to perform further checks!");
                                        this.setIcon(CheckNode.UNKNOWN_STATUS);
                                        return;
                                    }
                                    
                                    this.notParticipatingNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape instanceof ORYX.Core.Node)
                                            this.notParticipatingNodes.push(shape);
                                    }.bind(this));
                                    
                                    this.passedNodes = [];
                                    
                                    this.findNotParticipatingNodes(initialNodes[0]);
                                    
                                    this.setText(this.notParticipatingNodes.length + ' nodes that aren\'t on any path from beginning to end found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.notParticipatingNodes);
                                },
                                findNotParticipatingNodes: function(currentNode){
                                    this.passedNodes.push(currentNode);
                                    this.notParticipatingNodes.remove(currentNode);
                                    
                                    Ext.each(currentNode.getOutgoingShapes(), function(nextNode){
                                        if(!this.passedNodes.include(nextNode)){
                                            this.findNotParticipatingNodes(nextNode);
                                        };
                                    }.bind(this));
                                },
                                hasErrors: function(){
                                    return this.notParticipatingNodes.length !== 0;
                                }
                            })
                        });
                        structuralSoundNode.appendChild([
                            structuralSoundNode.checkInitialNode,
                            structuralSoundNode.checkFinalNode,
                            structuralSoundNode.checkConnectedNode
                        ]);
                    
                        var soundNode = new CheckNode({
                            text: 'Sound',
                            id: 'sound',
                            check: function(res){
                                if (res.isSound) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                
                                this.deadTransitionsNode.update(res.deadTransitions);
                                this.improperTerminatingsNode.update(res.improperTerminatings);
                                this.deadLocksNode.update(res.deadLocks);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),
                            improperTerminatingsNode: new ImproperTerminatingsNode({}),
                            deadLocksNode: new DeadLocksNode({})
                        });
                        soundNode.appendChild([
                            soundNode.deadTransitionsNode,
                            soundNode.improperTerminatingsNode,
                            soundNode.deadLocksNode
                        ]);
                        
                        var weakSoundNode = new CheckNode({
                            text: 'Weak Sound',
                            id: 'weakSound',
                            check: function(res){
                                if (res.isWeakSound) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }

                                this.improperTerminatingsNode.update(res.improperTerminatings);
                                this.deadLocksNode.update(res.deadLocks);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),
                            improperTerminatingsNode: new ImproperTerminatingsNode({}),
                            deadLocksNode: new DeadLocksNode({})
                        });
                        weakSoundNode.appendChild([
                            weakSoundNode.improperTerminatingsNode,
                            weakSoundNode.deadLocksNode
                        ]);
                        
                        var relaxedSoundNode = new CheckNode({
                            text: 'Relaxed Sound',
                            id: 'relaxedSound',
                            check: function(res){
                                if (res.isRelaxedSound) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                
                                this.notParticipatingTransitionsNode.update(res.notParticipatingTransitions);
                            },
                            notParticipatingTransitionsNode: new NotParticipatingTransitionsNode({})
                        });
                        relaxedSoundNode.appendChild([
                            relaxedSoundNode.notParticipatingTransitionsNode
                        ]);
                        
                        treePanel.getRootNode().appendChild([structuralSoundNode, soundNode, weakSoundNode, relaxedSoundNode]);
                        
                    }
                }
            })],
            listeners: {
                close: function(window){
                    this.checkerWindow.getTree().getRootNode().reset();
                }.bind(this)
            }
        });
        
        this.checkerWindow.show();
        this.checkerWindow.check(true);
    }
});
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner, Gero Decker
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.SimplePnmlexport = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
        this.facade = facade;
        
        this.facade.offer({
            'name': ORYX.I18N.SimplePnmlexport.name,
            'functionality': this.exportIt.bind(this),
            'group': ORYX.I18N.SimplePnmlexport.group,
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon': ORYX.PATH + "images/page_white_gear.png",
            'description': ORYX.I18N.SimplePnmlexport.desc,
            'index': 1,
            'minShape': 0,
            'maxShape': 0
        });
        this.facade.offer({
            'name': "PNML For LOLA",
            'functionality': this.exportIt.bind(this,true),
            'group': ORYX.I18N.SimplePnmlexport.group,
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon': ORYX.PATH + "images/page_white_gear.png",
            'description': ORYX.I18N.SimplePnmlexport.desc,
            'index': 1,
            'minShape': 0,
            'maxShape': 0
        });
        
    },

    exportIt: function(lola){

		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
            this.exportSynchronously(lola);
			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;
    },

    exportSynchronously: function(lola) {

        var resource = location.href;
		var tool = "none";
		if(lola){
			tool = "lola";
		}
		
		try {
			var serialized_rdf = this.getRDFFromDOM();
			if (!serialized_rdf.startsWith("<?xml")) {
				serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
			}
			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.SIMPLE_PNML_EXPORT_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: resource,
					data: serialized_rdf,
					tool: tool
				},
				onSuccess: function(request){
					this.openDownloadWindow(window.document.title+".xml",request.responseText);
					/* 
					 * Data URIs do not work properly in chrome
					 * this.openXMLWindow(request.responseText);
					 * TODO Check for an better solution for download windows, without remaining open window
					 * @author Philipp Berger
					 */
				}.bind(this)
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}
	}
});
/**
 * Copyright (c) 2008, Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Validator = ORYX.Plugins.AbstractPlugin.extend({
    construct: function(facade){
        this.facade = facade;
        
        this.active = false;
        this.raisedEventIds = [];
        
        this.buttonId = ORYX.Editor.provideId();
        
        this.facade.offer({
            'name': ORYX.I18N.Validator.name,
            'id': this.buttonId,
            'functionality': this.load.bind(this),
            'group': "Verification",
            'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/cog_error.png",
            'description': ORYX.I18N.Validator.description,
            'index': 1,
            'toggle': true,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    load: function(button, pressed){
        if (!pressed) {
            this.hideOverlays();
            this.active = !this.active;
        }
        else {
            this.validate(button);
        }
    },
    
    setActive: function(active){
        this.active = active;
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_BUTTON_UPDATE,
            id: this.buttonId,
            pressed: active
        });
    },
    
    hideOverlays: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }.bind(this));
        
        this.raisedEventIds = [];
    },
    validate: function(button){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
            text: ORYX.I18N.Validator.checking
        });
      
        // Send the request to the server.
        new Ajax.Request(ORYX.CONFIG.VALIDATOR_URL, {
            method: 'POST',
            asynchronous: false,
            parameters: {
                resource: location.href,
                data: this.getRDFFromDOM()
            },
            onSuccess: function(request){
                var result = Ext.decode(request.responseText);
                
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                
                // This should be implemented by child instances of validator 
                this.handleValidationResponse(result, button);
            }.bind(this),
            onFailure: function(){
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                Ext.Msg.alert(ORYX.I18N.Validator.error, ORYX.I18N.Validator.errorDesc);
            }.bind(this)
        });
    },
    
    showOverlay: function(shape, errorMsg, errorTitle){
    
        var id = "syntaxchecker." + this.raisedEventIds.length;
        
        var crossId = ORYX.Editor.provideId();
        
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
        	"id":crossId,
        	"title":"",
            "stroke-width": 5.0,
            "stroke": "red",
            "d": "M20,-5 L5,-20 M5,-5 L20,-20",
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        this.raisedEventIds.push(id);
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	title:errorTitle,
        	html:errorMsg,
        	target:crossId
        });   
        
        return cross;
    },
    
    /**
     * Registers handler for deactivating syntax checker as soon as somewhere is clicked...
     * @param {Ext.Button} Toolbar button
     */
    enableDeactivationHandler: function(button){
        var deactivate = function(){
            this.setActive(false);
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate);
        };
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate.bind(this));
    }
});

ORYX.Plugins.BPMNValidator = Ext.extend(ORYX.Plugins.Validator, {
    handleValidationResponse: function(result, button){
        var conflictingNodes = result.conflictingNodes;
        var leadsToEnd = result.leadsToEnd;
        var unsafeNode = result.unsafeNode;
        // Only stay active if there is anything to visualize
        this.setActive(conflictingNodes.size() > 0);
        
//        if (!leadsToEnd) {
//            Ext.Msg.alert("Validation Result", "The process will never reach a final state!");
//        }
        if (conflictingNodes.size() > 0) {
            conflictingNodes.each(function(node){
                sh = this.facade.getCanvas().getChildShapeByResourceId(node.id);
                if (sh) {
                    this.showOverlay(sh, ORYX.I18N.Validator.bpmnDeadlock,  ORYX.I18N.Validator.bpmnDeadlockTitle);
                }
            }.bind(this));
        }
        if(unsafeNode) {
        	var shape = this.facade.getCanvas().getChildShapeByResourceId(unsafeNode);
        	if (shape) {
                this.showOverlay(shape, ORYX.I18N.Validator.bpmnUnsafe, ORYX.I18N.Validator.bpmnUnsafeTitle);
            }
        }
        if(leadsToEnd && conflictingNodes.size() === 0 && !unsafeNode) {
        	this.facade.raiseEvent({
    			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
    			text:ORYX.I18N.Validator.noErrors,
    			timeout:10000
    		});
        	//Ext.Msg.alert(ORYX.I18N.Validator.result, ORYX.I18N.Validator.noErrors);
        } else if(!leadsToEnd && conflictingNodes.size() === 0 && !unsafeNode){
        	Ext.Msg.alert(ORYX.I18N.Validator.bpmnLeadsToNoEndTitle, ORYX.I18N.Validator.bpmnLeadsToNoEnd);
        } else {
        	this.enableDeactivationHandler(button);
        	//show a status message with a hint to the error messages in the tooltip
            this.facade.raiseEvent({
    			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
    			text:ORYX.I18N.SyntaxChecker.notice,
    			timeout:10000
    		});
        }
    }
});

ORYX.Plugins.EPCValidator = Ext.extend(ORYX.Plugins.Validator, {
  getLabelOfShape: function(node){
    if(node.properties["oryx-title"] === ""){
      return node.id;
    } else {
      return node.properties["oryx-title"];
    }
  },
  findShapeById: function(id){
    return this.facade.getCanvas().getChildShapeByResourceId(id);
  },
  
    handleValidationResponse: function(result, button){
      //TODO use Ext XTemplate
        var isSound = result.isSound;
        var badStartArcs = result.badStartArcs;
        var badEndArcs = result.badEndArcs;
        var goodInitialMarkings = result.goodInitialMarkings;
        var goodFinalMarkings = result.goodFinalMarkings;
        
        var message = "";
        
        if (isSound) {
          message += ORYX.I18N.Validator.epcIsSound;
        } else {
          message += ORYX.I18N.Validator.epcNotSound;
        }
        
        message += "<hr />";
        
        var arrayOfArraysToMessage = function(arrayOfArrays, formatter){
          var message = "<ul>"
          arrayOfArrays.each(function(array){
            message += "<li> - ";
            array.each(function(element){
              message += '"' + formatter(element) + '" ';
            });
            message += "</li>";
          });
          message += "</ul>";
          return message;
        }
        var arrayToMessage = function(array, formatter){
          var message = "<ul>"
          array.each(function(element){
            message += "<li> - " + formatter(element) + "</li>";
          });
          message += "</ul>";
          return message;
        }
        
        message += "<p>There are "+ goodInitialMarkings.length +" initial markings which does not run into a deadlock.</p>";
        message += arrayOfArraysToMessage(goodInitialMarkings, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getIncomingShapes()[0]);
        }.createDelegate(this));
        message += "<p>The initial markings do not include "+ badStartArcs.length +" start nodes.</p>";
        message += arrayToMessage(badStartArcs, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getIncomingShapes()[0]);
        }.createDelegate(this));
        
        message += "<hr />";
        
        message += "<p>There are "+ goodFinalMarkings.length +" final markings which can be reached from the initial markings.</p>";
        message += arrayOfArraysToMessage(goodFinalMarkings, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getOutgoingShapes()[0]);
        }.createDelegate(this));
        message += "<p>The final markings do not include "+ badEndArcs.length +" end nodes.</p>";
        message += arrayToMessage(badEndArcs, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getOutgoingShapes()[0]);
        }.createDelegate(this))
        
        message += "<hr />";
        
        message += "<p><i>Remark: Set titles of functions and events to get some nicer output (names instead of ids)</i></p>"
        
        Ext.Msg.alert('Validation Result', message);
        
        this.setActive(false);
    }
});
/**
 * Copyright (c) 2008, Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Validator = ORYX.Plugins.AbstractPlugin.extend({
    construct: function(facade){
        this.facade = facade;
        
        this.active = false;
        this.raisedEventIds = [];
        
        this.buttonId = ORYX.Editor.provideId();
        
        this.facade.offer({
            'name': ORYX.I18N.Validator.name,
            'id': this.buttonId,
            'functionality': this.load.bind(this),
            'group': "Verification",
            'icon': ORYX.CONFIG.EXPLORER_PATH + "/src/img/famfamfam/cog_error.png",
            'description': ORYX.I18N.Validator.description,
            'index': 1,
            'toggle': true,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    load: function(button, pressed){
        if (!pressed) {
            this.hideOverlays();
            this.active = !this.active;
        }
        else {
            this.validate(button);
        }
    },
    
    setActive: function(active){
        this.active = active;
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_BUTTON_UPDATE,
            id: this.buttonId,
            pressed: active
        });
    },
    
    hideOverlays: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }.bind(this));
        
        this.raisedEventIds = [];
    },
    validate: function(button){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
            text: ORYX.I18N.Validator.checking
        });
      
        // Send the request to the server.
        new Ajax.Request(ORYX.CONFIG.VALIDATOR_URL, {
            method: 'POST',
            asynchronous: false,
            parameters: {
                resource: location.href,
                data: this.getRDFFromDOM()
            },
            onSuccess: function(request){
                var result = Ext.decode(request.responseText);
                
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                
                // This should be implemented by child instances of validator 
                this.handleValidationResponse(result, button);
            }.bind(this),
            onFailure: function(){
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                Ext.Msg.alert(ORYX.I18N.Validator.error, ORYX.I18N.Validator.errorDesc);
            }.bind(this)
        });
    },
    
    showOverlay: function(shape, errorMsg, errorTitle){
    
        var id = "syntaxchecker." + this.raisedEventIds.length;
        
        var crossId = ORYX.Editor.provideId();
        
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
        	"id":crossId,
        	"title":"",
            "stroke-width": 5.0,
            "stroke": "red",
            "d": "M20,-5 L5,-20 M5,-5 L20,-20",
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        this.raisedEventIds.push(id);
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	title:errorTitle,
        	html:errorMsg,
        	target:crossId
        });   
        
        return cross;
    },
    
    /**
     * Registers handler for deactivating syntax checker as soon as somewhere is clicked...
     * @param {Ext.Button} Toolbar button
     */
    enableDeactivationHandler: function(button){
        var deactivate = function(){
            this.setActive(false);
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate);
        };
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate.bind(this));
    }
});

ORYX.Plugins.BPMNValidator = Ext.extend(ORYX.Plugins.Validator, {
    handleValidationResponse: function(result, button){
        var conflictingNodes = result.conflictingNodes;
        var leadsToEnd = result.leadsToEnd;
        var unsafeNode = result.unsafeNode;
        // Only stay active if there is anything to visualize
        this.setActive(conflictingNodes.size() > 0);
        
//        if (!leadsToEnd) {
//            Ext.Msg.alert("Validation Result", "The process will never reach a final state!");
//        }
        if (conflictingNodes.size() > 0) {
            conflictingNodes.each(function(node){
                sh = this.facade.getCanvas().getChildShapeByResourceId(node.id);
                if (sh) {
                    this.showOverlay(sh, ORYX.I18N.Validator.bpmnDeadlock,  ORYX.I18N.Validator.bpmnDeadlockTitle);
                }
            }.bind(this));
        }
        if(unsafeNode) {
        	var shape = this.facade.getCanvas().getChildShapeByResourceId(unsafeNode);
        	if (shape) {
                this.showOverlay(shape, ORYX.I18N.Validator.bpmnUnsafe, ORYX.I18N.Validator.bpmnUnsafeTitle);
            }
        }
        if(leadsToEnd && conflictingNodes.size() === 0 && !unsafeNode) {
        	this.facade.raiseEvent({
    			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
    			text:ORYX.I18N.Validator.noErrors,
    			timeout:10000
    		});
        	//Ext.Msg.alert(ORYX.I18N.Validator.result, ORYX.I18N.Validator.noErrors);
        } else if(!leadsToEnd && conflictingNodes.size() === 0 && !unsafeNode){
        	Ext.Msg.alert(ORYX.I18N.Validator.bpmnLeadsToNoEndTitle, ORYX.I18N.Validator.bpmnLeadsToNoEnd);
        } else {
        	this.enableDeactivationHandler(button);
        	//show a status message with a hint to the error messages in the tooltip
            this.facade.raiseEvent({
    			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
    			text:ORYX.I18N.SyntaxChecker.notice,
    			timeout:10000
    		});
        }
    }
});

ORYX.Plugins.EPCValidator = Ext.extend(ORYX.Plugins.Validator, {
  getLabelOfShape: function(node){
    if(node.properties["oryx-title"] === ""){
      return node.id;
    } else {
      return node.properties["oryx-title"];
    }
  },
  findShapeById: function(id){
    return this.facade.getCanvas().getChildShapeByResourceId(id);
  },
  
    handleValidationResponse: function(result, button){
      //TODO use Ext XTemplate
        var isSound = result.isSound;
        var badStartArcs = result.badStartArcs;
        var badEndArcs = result.badEndArcs;
        var goodInitialMarkings = result.goodInitialMarkings;
        var goodFinalMarkings = result.goodFinalMarkings;
        
        var message = "";
        
        if (isSound) {
          message += ORYX.I18N.Validator.epcIsSound;
        } else {
          message += ORYX.I18N.Validator.epcNotSound;
        }
        
        message += "<hr />";
        
        var arrayOfArraysToMessage = function(arrayOfArrays, formatter){
          var message = "<ul>"
          arrayOfArrays.each(function(array){
            message += "<li> - ";
            array.each(function(element){
              message += '"' + formatter(element) + '" ';
            });
            message += "</li>";
          });
          message += "</ul>";
          return message;
        }
        var arrayToMessage = function(array, formatter){
          var message = "<ul>"
          array.each(function(element){
            message += "<li> - " + formatter(element) + "</li>";
          });
          message += "</ul>";
          return message;
        }
        
        message += "<p>There are "+ goodInitialMarkings.length +" initial markings which does not run into a deadlock.</p>";
        message += arrayOfArraysToMessage(goodInitialMarkings, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getIncomingShapes()[0]);
        }.createDelegate(this));
        message += "<p>The initial markings do not include "+ badStartArcs.length +" start nodes.</p>";
        message += arrayToMessage(badStartArcs, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getIncomingShapes()[0]);
        }.createDelegate(this));
        
        message += "<hr />";
        
        message += "<p>There are "+ goodFinalMarkings.length +" final markings which can be reached from the initial markings.</p>";
        message += arrayOfArraysToMessage(goodFinalMarkings, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getOutgoingShapes()[0]);
        }.createDelegate(this));
        message += "<p>The final markings do not include "+ badEndArcs.length +" end nodes.</p>";
        message += arrayToMessage(badEndArcs, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getOutgoingShapes()[0]);
        }.createDelegate(this))
        
        message += "<hr />";
        
        message += "<p><i>Remark: Set titles of functions and events to get some nicer output (names instead of ids)</i></p>"
        
        Ext.Msg.alert('Validation Result', message);
        
        this.setActive(false);
    }
});/**
 * Copyright (c) 2009
 * Ingo Kitzmann, Christoph Koenig
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if (!ORYX) 
	ORYX = new Object();
if (!ORYX.Plugins) 
	ORYX.Plugins = new Object();

ORYX.Plugins.BpmnLayouter = ORYX.Plugins.AbstractPlugin.extend({
	facade: undefined,
	construct: function(facade){
		this.facade = facade;
		this.facade.offer({
			'name' : "Layout-BPMN",
			'description' : "Layout BPMN Model",
			'functionality' : this.layout.bind(this),
			'group' : "Layout",
			'icon' : ORYX.PATH + "images/auto_layout.png",
			'index' : 1,
			'minShape' : 0,
			'maxShape' : 0
		});
	},
	layout: function(){
		
		this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
			text: ORYX.I18N.Layouting.doing
        });
		
		
		new Ajax.Request(ORYX.CONFIG.BPMN_LAYOUTER, {
			method : 'POST',
			asynchronous : false,
			parameters : {
				data: this.facade.getSerializedJSON(),
				output: "coordinatesonly"
			},
			onFailure: function(request){
				Ext.Msg.alert("Layouting Error", "Error while layouting:!\n" + request.responseText);
            	this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			},
			onSuccess: function(request){

				/*Ext.Msg.alert("Oryx", "New Layout arrived:!\n" + request.responseText);*/
				
				var setLayoutCommandClass = ORYX.Core.Command.extend({
					construct: function(layoutArray, plugin){
						this.layoutArray = layoutArray;
						this.plugin = plugin;
						this.oldLayoutArray = [];
					},
					execute: function(){
						this.layoutArray.each(function(elem){
							/* get shape */
							var shape = this.plugin.facade.getCanvas().getChildShapeByResourceId(elem.id);
							
							/* save old layout for undo*/
							var oldLayout = {
								id : elem.id,
								bounds : shape.bounds.clone()
							};
							this.oldLayoutArray.push(oldLayout);
							
							/* set new bounds */
							var bound = elem.bounds.split(" ");
							shape.bounds.set(bound[0],bound[1],bound[2],bound[3]);
							
							/* set new dockers */
							if(elem.dockers != null){
								this.plugin.setDockersBad(shape,elem.dockers);
							}
							
							shape.update();
						}.bind(this));
						
						this.plugin.facade.getCanvas().update();
						this.plugin.facade.updateSelection();					
						
					},
					rollback: function(){
						this.oldLayoutArray.each(function(elem){
							var shape = this.plugin.facade.getCanvas().getChildShapeByResourceId(elem.id);
							shape.bounds.set(elem.bounds);
							shape.update();
						}.bind(this));
						
						this.plugin.facade.getCanvas().update();
						this.plugin.facade.updateSelection();	
					}
				});
				
				
				var resp = request.responseText.evalJSON();
				if (resp instanceof Array && resp.size() > 0) {
					/* create command */
					var command = new setLayoutCommandClass(resp, this);
					/* execute command */
					this.facade.executeCommands([command]);
				}
            	this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			}.bind(this)
		})
	},
	setDockersBad: function(shape, dockers){
		var dockersString = "";
		dockers.each(function(p){
			dockersString += p.x + " " + p.y + " ";
		});
		dockersString += " # ";
		shape.deserialize([{
								prefix: 'oryx',
								name: 'dockers',
								value: dockersString
							}]);
	},
	setDockersGood: function(shape, dockers){
		if(elem.dockers.length == 1){
			/* docked event */
			
		}else{
			
			/* clear all except of the first and last dockers */
			var dockers = shape.getDockers().slice(1,-1);
			dockers.each(function(docker){
				shape.removeDocker(docker);
			});
			
			/* set first and last docker */
			var firstDocker = shape.getDockers()[0];
			if (firstDocker.getDockedShape()) {
				firstDocker.setReferencePoint(elem.dockers[0]);
			}
			else {
				firstDocker.bounds.moveTo(elem.dockers[0].x,elem.dockers[0].y);
			}
			firstDocker.refresh();
			
			var lastDocker = shape.getDockers()[1];
			if (lastDocker.getDockedShape()) {
				lastDocker.setReferencePoint(elem.dockers[elem.dockers.length - 1]);
			}
			else {
				lastDocker.bounds.moveTo(elem.dockers[elem.dockers.length - 1].x, elem.dockers[elem.dockers.length - 1].y);
			}
			lastDocker.refresh();
			
			/* add new dockers except of the first and last */
			var dockersToAdd = elem.dockers.slice(1,-1);
			dockersToAdd.each(function(dockerPoint){
				var newDocker = shape.createDocker(undefined, dockerPoint);
				newDocker.parent = shape;
				newDocker.bounds.centerMoveTo(dockerPoint.x, dockerPoint.y);
				/*newDocker.setReferencePoint(dockerPoint);*/
				newDocker.update();
			});
		}		
	}
});
/*
 * TODO interaction format step through <=> oryx should be json!!!
 */
/**
 * Copyright (c) 2008, Christoph Neijenhuis, modified by Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
 **/
Ext.namespace("ORYX.Plugins");

ORYX.Plugins.AbstractStepThroughPlugin = ORYX.Plugins.AbstractPlugin.extend({
    construct: function() {
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
        
        this.facade.offer({
            'name': ORYX.I18N.StepThroughPlugin.stepThrough,
            'functionality': this.load.bind(this),
            'group': ORYX.I18N.StepThroughPlugin.group,
            'icon': ORYX.PATH + "images/control_play.png",
            'description': ORYX.I18N.StepThroughPlugin.stepThroughDesc,
            'index': 1,
            'toggle' : true,
            'minShape': 0,
            'maxShape': 0
        });
        
        this.facade.offer({
            'name': ORYX.I18N.StepThroughPlugin.undo,
            'functionality': this.undo.bind(this),
            'group': ORYX.I18N.StepThroughPlugin.group,
            'icon': ORYX.PATH + "images/control_rewind.png",
            'description': ORYX.I18N.StepThroughPlugin.undoDesc,
            'index': 2,
            'minShape': 0,
            'maxShape': 0
        });
    },
    showEnabled: function(shape, display){
        // Creates overlay for an enabled shape
        // display is beeing ignored
        if (!(shape instanceof ORYX.Core.Shape)) {
            return;
        }
        else if (this.isOrSplit(shape)) { //special handling for OR-Split
            this.showEnabledOrSplit(shape);
            return;
        }
        
        this.showPlayOnShape(shape);
    },
    
    showPlayOnShape: function(shape){
        var attr;
        if (shape instanceof ORYX.Core.Edge) {
            attr = {
                stroke: "green"
            };
        }
        else {
            attr = {
                fill: "green"
            };
        }
        
        var play = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
            "title": "Click the element to execute it!",
            "stroke-width": 2.0,
            "stroke": "black",
            "d": "M0,-5 L5,0 L0,5 Z",
            "line-captions": "round"
        }]);
        
        this.showOverlayOnShape(shape, attr, play);
    },
    
    showOverlayOnShape: function(shape, attributes, node){
        this.hideOverlayOnShape(shape);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: "st." + shape.resourceId,
            shapes: [shape],
            attributes: attributes,
            node: (node ? node : null),
            nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"
        });
    },
    
    hideOverlayOnShape: function(shape){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
            id: "st." + shape.resourceId
        });
    },
    
    // Pass preserveInitialMarking = true as config option, if initial marking 
    // should not be deleted 
    hideOverlays: function(preserveInitialMarking){
        // hides all overlays
        var els = this.facade.getCanvas().getChildShapes(true);
        var el;
        for (i = 0; i < els.size(); i++) {
            el = els[i];
            // This may send hide-events for objects that have no overlay
            if (!(preserveInitialMarking && this.isStartNode(el))) {
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                    id: "st." + el.resourceId
                });
            }
        }
    },
    
    /**
     * Called when the user loads or unloads the plugin
     * @methodOf ORYX.Plugins.StepThroughPlugin
     */
    load: function(button, pressed){
        this.initializeLoadButton(button, pressed);
        this.togglePlugin(pressed);
    },

	togglePlugin: function(turn_on) {
		if (turn_on) {
			 this.initialMarking = [];

            if (this.getDiagramType() === "epc") {
                this.prepareInitialMarking();
            }
            else { //only start immediately for bpmn diagrams and Petri nets
                this.startAndCheckSyntax();
            }
		}
		else {
			 // Reset vars
	        this.executionTrace = "";
            this.rdf = undefined;

            // Reset syntax checker errors
            this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});

            this.onDeactivate();
		}
		
		if (this.active()) {
            this.callback = this.doMouseUp.bind(this)
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)
        } else {
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)
            this.callback = undefined;
        }
	},
    
    // When plugin is deactivated through pressing the button
    // Overwrite to implement custom behavior
    onDeactivate: function(){
        // Hide overlays
        this.hideOverlays();
    },
    
    // Very evil, this method is a result from Oryx generalized plugin infrastructure
    // Direct access to button needed, so that this can be done in construct method
    initializeLoadButton: function(button, pressed){
        if(this.loadButton !== button){
            // Sets state of the loadButton and sets the model readonly
            var toggleActive = function(active){
                if(active){
                    //Set "readonly" (edges cannot be moved anymore)
                    this.facade.disableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
                } else {
                    this.facade.enableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
                }
            }.createDelegate(this);
            
            button.on('toggle', function(button, p){
                toggleActive(p);
            });
            // Very evil!! The first time, toggle event isn't thrown 
            // Should be like that listeners can be defined earlier!!!
            toggleActive(button, pressed);
        }
        this.loadButton = button;
    },
    
    active: function(){
        return this.loadButton ? this.loadButton.pressed : false;
    },
    
    onSelectionChanged: function(){
        if (this.active() && this.facade.getSelection().length > 0) {
            // Stop the user from editing the diagram while the plugin is active
            this.facade.setSelection([]);
        }
    },
    
    //TODO generic function
    getDiagramType: function(){
        switch (this.facade.getCanvas().getStencil().namespace()) {
            case "http://b3mn.org/stencilset/epc#":
                return "epc";
            case "http://b3mn.org/stencilset/bpmn#":
                return "bpmn";
            default:
                return null;
        }
    },
    
    showUsed: function(shape, display){
        // Creates overlay for a shape that has been used and is not enabled
        if (!(shape instanceof ORYX.Core.Shape)) 
            return;
        
        var attr;
        if (shape instanceof ORYX.Core.Edge) {
            attr = {
                stroke: "mediumslateblue"
            };
        }
        else {
            attr = {
                fill: "mediumslateblue"
            };
        }
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
            id: "st." + shape.resourceId
        });
        
        if (display != "-1" && display != "1") {
            // Show the number
            var text = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                "style": "font-size: 16px; font-weight: bold;"
            }, display]);
            
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
                id: "st." + shape.resourceId,
                shapes: [shape],
                attributes: attr,
                node: text,
                nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"
            });
        }
        else {
            // This is an XOR split, don't display number
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
                id: "st." + shape.resourceId,
                shapes: [shape],
                attributes: attr
            });
        }
    }
});

ORYX.Plugins.PetriNetStepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({
    construct: function() {
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
    },
    startAndCheckSyntax: function(){
        this.facade.raiseEvent({
            type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
            onErrors: function(){
                Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!");
            }.bind(this),
            onNoErrors: function(){
	            if (this.initializeMarking()) {
					this.firedTransitions = [];
	                this.showEnabledTransition();
				} 
				else {
					this.togglePlugin(false); // turn off 
				}
            }.bind(this)
        });
    },

    /**
     * Initializes the number of tokens for each place. Additionally, if none of the places have a token, the initial places
     * get one.
     */
    initializeMarking: function(){
        
		// monkeypatching place marking (add/remove tokens) towards new stencil set
		// definitions from r3187
		var markPlaces = function(shape, propertyValue) {
			if(propertyValue == 0) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "0");
			} else if(propertyValue == 1) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "1");
			} else if(propertyValue == 2) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "2");
			} else if(propertyValue == 3) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "3");
			} else if(propertyValue == 4) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "4");
			} else {
				var tokens = parseInt(propertyValue, 10);
				if(tokens && tokens > 0) {
					shape.setProperty("oryx-numberoftokens_text", "" + tokens);
					shape.setProperty("oryx-numberoftokens_drawing", "0");
				} else {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "0");
				}
			}
		}
		this.getPlaces().each(function(place){
			if ("undefined" == typeof(place._setProperty_monkey)) {
				place._setProperty_monkey = place.setProperty;
				place.setProperty = function(p,a) {
					if ("oryx-numberoftokens" == p) {
						markPlaces(place, a)
					}
					place._setProperty_monkey.apply(place, arguments);
				}
			}
		})
        
		var anyTokenFound = 0;
        this.getPlaces().each(function(place){
            var tokens = parseInt(place.properties["oryx-numberoftokens"]);
            if(isNaN(tokens)){
                // All places which don't have any number of tokens, gets 0 tokens explicitly
                place.setProperty("oryx-numberoftokens", 0);
            } else if(tokens > 0){
                anyTokenFound += tokens;
            }
        });
        
        // If no place has any token, all incoming places gets tokens
        if(0 == anyTokenFound){
            this.getPlaces().each(function(place){
                if(place.getIncomingShapes().length == 0){
                    place.setProperty("oryx-numberoftokens", 1);
                }
            });
            Ext.Msg.show({
               title:'No Tokens Found',
               msg: 'Current marking of the Petri net doesn\'t contain any token. Tokens are added to the initial places of the net.',
               buttons: Ext.Msg.OK,
               icon: Ext.MessageBox.INFO
            });
        }
		
		if(anyTokenFound > 3){
            Ext.Msg.show({
               title:'Too Many Tokens On Place',
               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',
               buttons: Ext.Msg.OK,
               icon: Ext.MessageBox.WARNING
            });
		}

		return true;
    },
    
    doMouseUp: function(event, shape){
        if (!(this.isTransition(shape))) return; // Can be a docker, place or something else

		// assuming correct syntax
    	var enabled = this.getIncomingNodes(shape).all(function(place) {
			return parseInt(place.properties["oryx-numberoftokens"]) > 0;
		});

		if (enabled) {
        	this.fireTransition(shape);	
		}
        this.showEnabledTransition();
    },
    
    onDeactivate: function(){
        // Hide overlays
        this.hideOverlays();
        
        // Undo all fired transitions so that the marking is the initial marking
        while(this.firedTransitions.length !== 0){
            this.undoLastFiredTransition();
        }
        this.facade.getCanvas().update(); //update markings
        
        this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
    },
    
    fireTransition: function(transition){
        this.firedTransitions.push(transition);
        this.getIncomingNodes(transition).each(function(place){
            this.removeToken(place);
        }.bind(this));
        this.getOutgoingNodes(transition).each(function(place){
            this.addToken(place);
        }.bind(this));

    },
    
    undoLastFiredTransition: function(){
        var transition = this.firedTransitions.pop();
        
        // If there is no transition anymore, just quit
        if(!transition) return;
        
        this.getIncomingNodes(transition).each(function(place){
            this.addToken(place);
        }.bind(this));
        this.getOutgoingNodes(transition).each(function(place){
            this.removeToken(place);
        }.bind(this));

    },
    
    removeToken: function(place){
        place.setProperty("oryx-numberoftokens", parseInt(place.properties["oryx-numberoftokens"])-1);
    },
    
    addToken: function(place){
        var tokens = parseInt(place.properties["oryx-numberoftokens"]) +1;
    
        place.setProperty("oryx-numberoftokens", tokens);
        
        if(tokens > 3){
            Ext.Msg.show({
               title:'Too Many Tokens On Place',
               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',
               buttons: Ext.Msg.OK,
               icon: Ext.MessageBox.WARNING
            });
        }
    },
    
    showEnabledTransition: function(){
        this.hideOverlays();
        
        this.firedTransitions.each(function(transition){
            this.showUsed(transition, "1");
        }.bind(this));
        
        this.getEnabledTransitions().each(function(transition){
            this.showPlayOnShape(transition);
        }.bind(this));
        
        this.facade.getCanvas().update();
    },
    getTransitions: function(){
        return this.facade.getCanvas().getChildShapes().select(function(shape){
            return this.isTransition(shape);
        }.bind(this));
    },
    isTransition: function(shape){
        return shape instanceof ORYX.Core.Shape && shape.getStencil().id().search(/Transition/) > -1;
    },
    getPlaces: function(){
        return this.facade.getCanvas().getChildShapes().select(function(shape){
            return shape.getStencil().id().search(/Place/) > -1;
        });
    },
    getIncomingNodes: function(node){
      return node.getIncomingShapes().collect(function(arc){
        return arc.getIncomingShapes();
      }).flatten();
    },
    getOutgoingNodes: function(node){
      return node.getOutgoingShapes().collect(function(arc){
        return arc.getOutgoingShapes();
      }).flatten();
    },
    getEnabledTransitions:function(){
        return this.getTransitions().select(function(transition){
            // Checks whether all incoming places have at least 1 token
            return this.getIncomingNodes(transition).all(function(place){
                return parseInt(place.properties["oryx-numberoftokens"]) > 0;
            });
        }.bind(this));
    },
    undo: function(){
        this.undoLastFiredTransition();
        this.showEnabledTransition();
    }
});

/**
 * Step Through Plugin
 * @class ORYX.Plugins.StepThroughPlugin
 * @constructor Creates new plugin instance
 */
ORYX.Plugins.StepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({

    /**
     * My method!
     * @methodOf ORYX.Plugins.StepThroughPlugin
     */
    construct: function(facade){
        this.el = undefined;
        this.callback = undefined;
        this.executionTrace = ""; // A string containing all objects that have been fired
        this.rdf = undefined;
                
        arguments.callee.$.construct.apply(this, arguments);
    },
    
    // Each start node and each start arc gets colored
    prepareInitialMarking: function(){
        this.startNodes = [];
        
        Ext.each(this.facade.getCanvas().getChildShapes(true), function(shape){
            if (this.isStartNode(shape)) {
                this.startNodes.push(shape);
                shape.initialMarkingFired = false;
                this.showPlayOnShape(shape);
                if (shape.getOutgoingShapes().size() == 1) {
                    this.showOverlayOnShape(shape.getOutgoingShapes()[0], {
                        stroke: "green"
                    });
                    shape.getOutgoingShapes()[0].initialMarking = true;
                }
            }
        }
.createDelegate(this));
    },
    
    /* Returns true if node is start node */
    isStartNode: function(shape){
        return (shape.getStencil().id().search(/#Event$/) > -1) && shape.getIncomingShapes().length == 0 && shape.getOutgoingShapes().length == 1;
    },
    
    /* Returns true if source node from arc is start node */
    isStartArc: function(shape){
        return this.isStartNode(shape.getIncomingShapes()[0]);
    },
    
    isStartArcOrNode: function(shape){
        return this.isStartNode(shape) || this.isStartArc(shape);
    },
    
    /* TODO this should be a general oryx helper method!! */
    generateRDF: function(){
        
        try {
            var serialized_rdf = this.getRDFFromDOM();
            
            // Firefox 2 to 3 problem?!
            serialized_rdf = !serialized_rdf.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf : serialized_rdf;
        } 
        catch (error) {
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
            Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
        }
        
        this.rdf = serialized_rdf;
    },
    
    getRDF: function(){
        if (this.rdf == undefined) {
            this.generateRDF();
        }
        
        return this.rdf;
    },
    
    startAndCheckSyntax: function(){
        this.postExecutionTrace({
            checkSyntax: true,
            onlyChangedObjects: false,
            onSuccess: function(request){
                //TODO use always json!!!! This is a bad hack!!!
                if (request.responseText.startsWith("{")){ //seems to be json
                    var errors = Ext.decode(request.responseText).syntaxErrors;
                    
                    // Show errors
                    this.facade.raiseEvent({
                        type: ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT,
                        errors: errors
                    });
                } else { //normal step through response
                    this.showObjectStates(request.responseText);
                }
            }.bind(this)
        });
    },
    
    fireObject: function(objResourceId){
        // Add this object to executionTrace
        this.executionTrace += objResourceId + ";";
        
        // Add selected edges for or split
        if (this.isOrSplit(this.el)) {
            //eliminate ;
            this.executionTrace = this.executionTrace.substring(0, this.executionTrace.length - 1);
            this.executionTrace += "#";
            var outgoingEdges = new Ext.util.MixedCollection();
            outgoingEdges.addAll(this.el.getOutgoingShapes());
            var firingEdgesResourceIds = [];
            outgoingEdges.filter("selectedForOrSplit", "true").each(function(edge){
                firingEdgesResourceIds.push(edge.resourceId);
            }
.createDelegate(this));
            outgoingEdges.each(function(edge){
                edge.selectedForOrSplit = false;
                this.hideOverlayOnShape(edge);
            }
.createDelegate(this));
            this.executionTrace += firingEdgesResourceIds.join(",") + ";";
        }
        
        this.postExecutionTrace({
            checkSyntax: false,
            onlyChangedObjects: true,
            onSuccess: function(request){
                if (request.responseText != "") {
                    // successful
                    this.showObjectStates(request.responseText);
                }
                else {
                    // object couldn't be fired, remove it from executionTrace
                    this.removeLastFiredObject();
                }
            }
.bind(this)
        });
    },
    
    doMouseUp: function(event, arg){
        if (arg instanceof ORYX.Core.Shape) {
            // if its an or split
            if (arg instanceof ORYX.Core.Edge && this.isOrSplit(arg.getIncomingShapes()[0])) {
                this.doMouseUpOnEdgeComingFromOrSplit(arg);
                // else if its an epc start node
            }
            else if (arg instanceof ORYX.Core.Edge && this.getDiagramType() === "epc" && this.isStartNode(arg.getIncomingShapes()[0])) {
                this.doMouseUpOnEdgeComingFromStartNode(arg);
            }
            else if (this.getDiagramType() === "epc" && this.isStartNode(arg)) {
                arg.initialMarkingFired = true;
                var edge = arg.getOutgoingShapes()[0];
                this.hideOverlayOnShape(edge);
                if (edge.initialMarking) {
                    this.showUsed(arg, "1");
                    this.initialMarking.push(arg.resourceId);
                }
                else {
                    this.hideOverlayOnShape(arg);
                }
                
                // If clicked node is the last startNode, activate real step through
                var allStartNodesFired = true;
                Ext.each(this.startNodes, function(startNode){
                    if (!startNode.initialMarkingFired) {
                        allStartNodesFired = false;
                    }
                });
                
                if (allStartNodesFired) {
                    this.startAndCheckSyntax();
                }
            }
            else {
                this.el = arg;
                this.fireObject(this.el.resourceId);
            }
        }
    },
    
    showObjectStates: function(objs){
        var objsAndState = objs.split(";");
        for (i = 0; i < objsAndState.size(); i++) {
            var objAndState = objsAndState[i].split(",");
            if (objAndState.size() < 3) {
                continue;
            }
            var obj = this.facade.getCanvas().getChildShapeByResourceId(objAndState[0]);
            if (objAndState[2] == "t") { // Is enabled
                this.showEnabled(obj, objAndState[1]);
            }
            else if (objAndState[1] != "0") { // has been used
                this.showUsed(obj, objAndState[1]);
            }
            else { // Was enabled, has not been used
                this.hideOverlayOnShape(obj);
            }
        }
    },
    
    doMouseUpOnEdgeComingFromOrSplit: function(edge){
        var orSplit = edge.getIncomingShapes()[0];
        
        if (edge.selectedForOrSplit) { //deselect edge
            this.showOverlayOnShape(edge, {
                stroke: "orange"
            });
            
            // Hide or-split overlay, if last edge has been deselected
            var outgoingEdges = new Ext.util.MixedCollection();
            outgoingEdges.addAll(orSplit.getOutgoingShapes());
            if (outgoingEdges.filter("selectedForOrSplit", "true").length <= 1) { // > 1, because current edge is in this list
                this.hideOverlayOnShape(orSplit);
            }
            
        }
        else { //select edge
            this.showOverlayOnShape(edge, {
                stroke: "green"
            });
            this.showPlayOnShape(orSplit);
        }
        
        // toggle selection
        edge.selectedForOrSplit = !edge.selectedForOrSplit;
    },
    
    // Toggles color and initialMarking value of start arcs
    doMouseUpOnEdgeComingFromStartNode: function(edge){
        edge.initialMarking = !edge.initialMarking;
        
        if (edge.initialMarking) {
            this.showOverlayOnShape(edge, {
                stroke: "green"
            });
        }
        else {
            this.showOverlayOnShape(edge, {
                stroke: "orange"
            });
        }
    },
    
    //checks whether shape is OR gateway and hasn't more than 1 outgoing edges
    isOrSplit: function(shape){
        return (shape.getStencil().id().search(/#(OR_Gateway|OrConnector)$/) > -1) && (shape.getOutgoingShapes().length > 1);
    },
    
    showEnabledOrSplit: function(shape){
        Ext.each(shape.getOutgoingShapes(), function(edge){
            Ext.apply(edge, {
                selectedForOrSplit: false
            });
            
            this.showOverlayOnShape(edge, {
                stroke: "orange"
            });
        }
.createDelegate(this));
    },
   
    removeLastFiredObject: function(){
        // Removes last entry in execution trace
        this.executionTrace = this.executionTrace.replace(/[^;]*;$/, "")
    },
    
    undo: function(){
        if (!this.active()) 
            return;
        
        if (this.executionTrace !== "") {
            this.removeLastFiredObject();
            
            this.postExecutionTrace({
                checkSyntax: false,
                onlyChangedObjects: false,
                onSuccess: function(request){
                    // Hide overlays because everything is drawn from scratch
                    this.hideOverlays(true);
                    // Draw new overlays
                    this.showObjectStates(request.responseText);
                }
.bind(this)
            });
        }
        else if (this.getDiagramType() === "epc") {
            this.hideOverlays();
            this.prepareInitialMarking(); // "reset" initial marking
        }
    },
    
    /* Posts current execution trace to server for executing 
     * options is a hash with following keys:
     * - onlyChangedObjects (boolean)
     * - onSuccess (function with parameter request)
     * - checkSyntax (boolean)
     */
    postExecutionTrace: function(options){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
            text: ORYX.I18N.StepThroughPlugin.executing
        });
        
        //TODO merge in default options
        new Ajax.Request(ORYX.CONFIG.STEP_THROUGH, {
            method: 'POST',
            asynchronous: false,
            parameters: {
                rdf: this.getRDF(),
                checkSyntax: options.checkSyntax,
                fire: this.executionTrace,
                onlyChangedObjects: options.onlyChangedObjects,
                initialMarking: this.initialMarking.join(";")
            },
            onSuccess: function(response){
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                options.onSuccess(response);
            }.createDelegate(this),
            onFailure: function(){
                //TODO raise error message?
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
            }.createDelegate(this)
        });
    }
});/*
 * TODO interaction format step through <=> oryx should be json!!!
 */
/**
 * Copyright (c) 2008, Christoph Neijenhuis, modified by Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
 **/
Ext.namespace("ORYX.Plugins");

ORYX.Plugins.AbstractStepThroughPlugin = ORYX.Plugins.AbstractPlugin.extend({
    construct: function() {
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
        
        this.facade.offer({
            'name': ORYX.I18N.StepThroughPlugin.stepThrough,
            'functionality': this.load.bind(this),
            'group': ORYX.I18N.StepThroughPlugin.group,
            'icon': ORYX.PATH + "images/control_play.png",
            'description': ORYX.I18N.StepThroughPlugin.stepThroughDesc,
            'index': 1,
            'toggle' : true,
            'minShape': 0,
            'maxShape': 0
        });
        
        this.facade.offer({
            'name': ORYX.I18N.StepThroughPlugin.undo,
            'functionality': this.undo.bind(this),
            'group': ORYX.I18N.StepThroughPlugin.group,
            'icon': ORYX.PATH + "images/control_rewind.png",
            'description': ORYX.I18N.StepThroughPlugin.undoDesc,
            'index': 2,
            'minShape': 0,
            'maxShape': 0
        });
    },
    showEnabled: function(shape, display){
        // Creates overlay for an enabled shape
        // display is beeing ignored
        if (!(shape instanceof ORYX.Core.Shape)) {
            return;
        }
        else if (this.isOrSplit(shape)) { //special handling for OR-Split
            this.showEnabledOrSplit(shape);
            return;
        }
        
        this.showPlayOnShape(shape);
    },
    
    showPlayOnShape: function(shape){
        var attr;
        if (shape instanceof ORYX.Core.Edge) {
            attr = {
                stroke: "green"
            };
        }
        else {
            attr = {
                fill: "green"
            };
        }
        
        var play = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
            "title": "Click the element to execute it!",
            "stroke-width": 2.0,
            "stroke": "black",
            "d": "M0,-5 L5,0 L0,5 Z",
            "line-captions": "round"
        }]);
        
        this.showOverlayOnShape(shape, attr, play);
    },
    
    showOverlayOnShape: function(shape, attributes, node){
        this.hideOverlayOnShape(shape);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: "st." + shape.resourceId,
            shapes: [shape],
            attributes: attributes,
            node: (node ? node : null),
            nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"
        });
    },
    
    hideOverlayOnShape: function(shape){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
            id: "st." + shape.resourceId
        });
    },
    
    // Pass preserveInitialMarking = true as config option, if initial marking 
    // should not be deleted 
    hideOverlays: function(preserveInitialMarking){
        // hides all overlays
        var els = this.facade.getCanvas().getChildShapes(true);
        var el;
        for (i = 0; i < els.size(); i++) {
            el = els[i];
            // This may send hide-events for objects that have no overlay
            if (!(preserveInitialMarking && this.isStartNode(el))) {
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                    id: "st." + el.resourceId
                });
            }
        }
    },
    
    /**
     * Called when the user loads or unloads the plugin
     * @methodOf ORYX.Plugins.StepThroughPlugin
     */
    load: function(button, pressed){
        this.initializeLoadButton(button, pressed);
        this.togglePlugin(pressed);
    },

	togglePlugin: function(turn_on) {
		if (turn_on) {
			 this.initialMarking = [];

            if (this.getDiagramType() === "epc") {
                this.prepareInitialMarking();
            }
            else { //only start immediately for bpmn diagrams and Petri nets
                this.startAndCheckSyntax();
            }
		}
		else {
			 // Reset vars
	        this.executionTrace = "";
            this.rdf = undefined;

            // Reset syntax checker errors
            this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});

            this.onDeactivate();
		}
		
		if (this.active()) {
            this.callback = this.doMouseUp.bind(this)
            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)
        } else {
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)
            this.callback = undefined;
        }
	},
    
    // When plugin is deactivated through pressing the button
    // Overwrite to implement custom behavior
    onDeactivate: function(){
        // Hide overlays
        this.hideOverlays();
    },
    
    // Very evil, this method is a result from Oryx generalized plugin infrastructure
    // Direct access to button needed, so that this can be done in construct method
    initializeLoadButton: function(button, pressed){
        if(this.loadButton !== button){
            // Sets state of the loadButton and sets the model readonly
            var toggleActive = function(active){
                if(active){
                    //Set "readonly" (edges cannot be moved anymore)
                    this.facade.disableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
                } else {
                    this.facade.enableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
                }
            }.createDelegate(this);
            
            button.on('toggle', function(button, p){
                toggleActive(p);
            });
            // Very evil!! The first time, toggle event isn't thrown 
            // Should be like that listeners can be defined earlier!!!
            toggleActive(button, pressed);
        }
        this.loadButton = button;
    },
    
    active: function(){
        return this.loadButton ? this.loadButton.pressed : false;
    },
    
    onSelectionChanged: function(){
        if (this.active() && this.facade.getSelection().length > 0) {
            // Stop the user from editing the diagram while the plugin is active
            this.facade.setSelection([]);
        }
    },
    
    //TODO generic function
    getDiagramType: function(){
        switch (this.facade.getCanvas().getStencil().namespace()) {
            case "http://b3mn.org/stencilset/epc#":
                return "epc";
            case "http://b3mn.org/stencilset/bpmn#":
                return "bpmn";
            default:
                return null;
        }
    },
    
    showUsed: function(shape, display){
        // Creates overlay for a shape that has been used and is not enabled
        if (!(shape instanceof ORYX.Core.Shape)) 
            return;
        
        var attr;
        if (shape instanceof ORYX.Core.Edge) {
            attr = {
                stroke: "mediumslateblue"
            };
        }
        else {
            attr = {
                fill: "mediumslateblue"
            };
        }
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
            id: "st." + shape.resourceId
        });
        
        if (display != "-1" && display != "1") {
            // Show the number
            var text = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                "style": "font-size: 16px; font-weight: bold;"
            }, display]);
            
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
                id: "st." + shape.resourceId,
                shapes: [shape],
                attributes: attr,
                node: text,
                nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"
            });
        }
        else {
            // This is an XOR split, don't display number
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
                id: "st." + shape.resourceId,
                shapes: [shape],
                attributes: attr
            });
        }
    }
});

ORYX.Plugins.PetriNetStepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({
    construct: function() {
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
    },
    startAndCheckSyntax: function(){
        this.facade.raiseEvent({
            type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
            onErrors: function(){
                Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!");
            }.bind(this),
            onNoErrors: function(){
	            if (this.initializeMarking()) {
					this.firedTransitions = [];
	                this.showEnabledTransition();
				} 
				else {
					this.togglePlugin(false); // turn off 
				}
            }.bind(this)
        });
    },

    /**
     * Initializes the number of tokens for each place. Additionally, if none of the places have a token, the initial places
     * get one.
     */
    initializeMarking: function(){
        
		// monkeypatching place marking (add/remove tokens) towards new stencil set
		// definitions from r3187
		var markPlaces = function(shape, propertyValue) {
			if(propertyValue == 0) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "0");
			} else if(propertyValue == 1) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "1");
			} else if(propertyValue == 2) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "2");
			} else if(propertyValue == 3) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "3");
			} else if(propertyValue == 4) {
				shape.setProperty("oryx-numberoftokens_text", "");
				shape.setProperty("oryx-numberoftokens_drawing", "4");
			} else {
				var tokens = parseInt(propertyValue, 10);
				if(tokens && tokens > 0) {
					shape.setProperty("oryx-numberoftokens_text", "" + tokens);
					shape.setProperty("oryx-numberoftokens_drawing", "0");
				} else {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "0");
				}
			}
		}
		this.getPlaces().each(function(place){
			if ("undefined" == typeof(place._setProperty_monkey)) {
				place._setProperty_monkey = place.setProperty;
				place.setProperty = function(p,a) {
					if ("oryx-numberoftokens" == p) {
						markPlaces(place, a)
					}
					place._setProperty_monkey.apply(place, arguments);
				}
			}
		})
        
		var anyTokenFound = 0;
        this.getPlaces().each(function(place){
            var tokens = parseInt(place.properties["oryx-numberoftokens"]);
            if(isNaN(tokens)){
                // All places which don't have any number of tokens, gets 0 tokens explicitly
                place.setProperty("oryx-numberoftokens", 0);
            } else if(tokens > 0){
                anyTokenFound += tokens;
            }
        });
        
        // If no place has any token, all incoming places gets tokens
        if(0 == anyTokenFound){
            this.getPlaces().each(function(place){
                if(place.getIncomingShapes().length == 0){
                    place.setProperty("oryx-numberoftokens", 1);
                }
            });
            Ext.Msg.show({
               title:'No Tokens Found',
               msg: 'Current marking of the Petri net doesn\'t contain any token. Tokens are added to the initial places of the net.',
               buttons: Ext.Msg.OK,
               icon: Ext.MessageBox.INFO
            });
        }
		
		if(anyTokenFound > 3){
            Ext.Msg.show({
               title:'Too Many Tokens On Place',
               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',
               buttons: Ext.Msg.OK,
               icon: Ext.MessageBox.WARNING
            });
		}

		return true;
    },
    
    doMouseUp: function(event, shape){
        if (!(this.isTransition(shape))) return; // Can be a docker, place or something else

		// assuming correct syntax
    	var enabled = this.getIncomingNodes(shape).all(function(place) {
			return parseInt(place.properties["oryx-numberoftokens"]) > 0;
		});

		if (enabled) {
        	this.fireTransition(shape);	
		}
        this.showEnabledTransition();
    },
    
    onDeactivate: function(){
        // Hide overlays
        this.hideOverlays();
        
        // Undo all fired transitions so that the marking is the initial marking
        while(this.firedTransitions.length !== 0){
            this.undoLastFiredTransition();
        }
        this.facade.getCanvas().update(); //update markings
        
        this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
    },
    
    fireTransition: function(transition){
        this.firedTransitions.push(transition);
        this.getIncomingNodes(transition).each(function(place){
            this.removeToken(place);
        }.bind(this));
        this.getOutgoingNodes(transition).each(function(place){
            this.addToken(place);
        }.bind(this));

    },
    
    undoLastFiredTransition: function(){
        var transition = this.firedTransitions.pop();
        
        // If there is no transition anymore, just quit
        if(!transition) return;
        
        this.getIncomingNodes(transition).each(function(place){
            this.addToken(place);
        }.bind(this));
        this.getOutgoingNodes(transition).each(function(place){
            this.removeToken(place);
        }.bind(this));

    },
    
    removeToken: function(place){
        place.setProperty("oryx-numberoftokens", parseInt(place.properties["oryx-numberoftokens"])-1);
    },
    
    addToken: function(place){
        var tokens = parseInt(place.properties["oryx-numberoftokens"]) +1;
    
        place.setProperty("oryx-numberoftokens", tokens);
        
        if(tokens > 3){
            Ext.Msg.show({
               title:'Too Many Tokens On Place',
               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',
               buttons: Ext.Msg.OK,
               icon: Ext.MessageBox.WARNING
            });
        }
    },
    
    showEnabledTransition: function(){
        this.hideOverlays();
        
        this.firedTransitions.each(function(transition){
            this.showUsed(transition, "1");
        }.bind(this));
        
        this.getEnabledTransitions().each(function(transition){
            this.showPlayOnShape(transition);
        }.bind(this));
        
        this.facade.getCanvas().update();
    },
    getTransitions: function(){
        return this.facade.getCanvas().getChildShapes().select(function(shape){
            return this.isTransition(shape);
        }.bind(this));
    },
    isTransition: function(shape){
        return shape instanceof ORYX.Core.Shape && shape.getStencil().id().search(/Transition/) > -1;
    },
    getPlaces: function(){
        return this.facade.getCanvas().getChildShapes().select(function(shape){
            return shape.getStencil().id().search(/Place/) > -1;
        });
    },
    getIncomingNodes: function(node){
      return node.getIncomingShapes().collect(function(arc){
        return arc.getIncomingShapes();
      }).flatten();
    },
    getOutgoingNodes: function(node){
      return node.getOutgoingShapes().collect(function(arc){
        return arc.getOutgoingShapes();
      }).flatten();
    },
    getEnabledTransitions:function(){
        return this.getTransitions().select(function(transition){
            // Checks whether all incoming places have at least 1 token
            return this.getIncomingNodes(transition).all(function(place){
                return parseInt(place.properties["oryx-numberoftokens"]) > 0;
            });
        }.bind(this));
    },
    undo: function(){
        this.undoLastFiredTransition();
        this.showEnabledTransition();
    }
});

/**
 * Step Through Plugin
 * @class ORYX.Plugins.StepThroughPlugin
 * @constructor Creates new plugin instance
 */
ORYX.Plugins.StepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({

    /**
     * My method!
     * @methodOf ORYX.Plugins.StepThroughPlugin
     */
    construct: function(facade){
        this.el = undefined;
        this.callback = undefined;
        this.executionTrace = ""; // A string containing all objects that have been fired
        this.rdf = undefined;
                
        arguments.callee.$.construct.apply(this, arguments);
    },
    
    // Each start node and each start arc gets colored
    prepareInitialMarking: function(){
        this.startNodes = [];
        
        Ext.each(this.facade.getCanvas().getChildShapes(true), function(shape){
            if (this.isStartNode(shape)) {
                this.startNodes.push(shape);
                shape.initialMarkingFired = false;
                this.showPlayOnShape(shape);
                if (shape.getOutgoingShapes().size() == 1) {
                    this.showOverlayOnShape(shape.getOutgoingShapes()[0], {
                        stroke: "green"
                    });
                    shape.getOutgoingShapes()[0].initialMarking = true;
                }
            }
        }
.createDelegate(this));
    },
    
    /* Returns true if node is start node */
    isStartNode: function(shape){
        return (shape.getStencil().id().search(/#Event$/) > -1) && shape.getIncomingShapes().length == 0 && shape.getOutgoingShapes().length == 1;
    },
    
    /* Returns true if source node from arc is start node */
    isStartArc: function(shape){
        return this.isStartNode(shape.getIncomingShapes()[0]);
    },
    
    isStartArcOrNode: function(shape){
        return this.isStartNode(shape) || this.isStartArc(shape);
    },
    
    /* TODO this should be a general oryx helper method!! */
    generateRDF: function(){
        
        try {
            var serialized_rdf = this.getRDFFromDOM();
            
            // Firefox 2 to 3 problem?!
            serialized_rdf = !serialized_rdf.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf : serialized_rdf;
        } 
        catch (error) {
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
            Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
        }
        
        this.rdf = serialized_rdf;
    },
    
    getRDF: function(){
        if (this.rdf == undefined) {
            this.generateRDF();
        }
        
        return this.rdf;
    },
    
    startAndCheckSyntax: function(){
        this.postExecutionTrace({
            checkSyntax: true,
            onlyChangedObjects: false,
            onSuccess: function(request){
                //TODO use always json!!!! This is a bad hack!!!
                if (request.responseText.startsWith("{")){ //seems to be json
                    var errors = Ext.decode(request.responseText).syntaxErrors;
                    
                    // Show errors
                    this.facade.raiseEvent({
                        type: ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT,
                        errors: errors
                    });
                } else { //normal step through response
                    this.showObjectStates(request.responseText);
                }
            }.bind(this)
        });
    },
    
    fireObject: function(objResourceId){
        // Add this object to executionTrace
        this.executionTrace += objResourceId + ";";
        
        // Add selected edges for or split
        if (this.isOrSplit(this.el)) {
            //eliminate ;
            this.executionTrace = this.executionTrace.substring(0, this.executionTrace.length - 1);
            this.executionTrace += "#";
            var outgoingEdges = new Ext.util.MixedCollection();
            outgoingEdges.addAll(this.el.getOutgoingShapes());
            var firingEdgesResourceIds = [];
            outgoingEdges.filter("selectedForOrSplit", "true").each(function(edge){
                firingEdgesResourceIds.push(edge.resourceId);
            }
.createDelegate(this));
            outgoingEdges.each(function(edge){
                edge.selectedForOrSplit = false;
                this.hideOverlayOnShape(edge);
            }
.createDelegate(this));
            this.executionTrace += firingEdgesResourceIds.join(",") + ";";
        }
        
        this.postExecutionTrace({
            checkSyntax: false,
            onlyChangedObjects: true,
            onSuccess: function(request){
                if (request.responseText != "") {
                    // successful
                    this.showObjectStates(request.responseText);
                }
                else {
                    // object couldn't be fired, remove it from executionTrace
                    this.removeLastFiredObject();
                }
            }
.bind(this)
        });
    },
    
    doMouseUp: function(event, arg){
        if (arg instanceof ORYX.Core.Shape) {
            // if its an or split
            if (arg instanceof ORYX.Core.Edge && this.isOrSplit(arg.getIncomingShapes()[0])) {
                this.doMouseUpOnEdgeComingFromOrSplit(arg);
                // else if its an epc start node
            }
            else if (arg instanceof ORYX.Core.Edge && this.getDiagramType() === "epc" && this.isStartNode(arg.getIncomingShapes()[0])) {
                this.doMouseUpOnEdgeComingFromStartNode(arg);
            }
            else if (this.getDiagramType() === "epc" && this.isStartNode(arg)) {
                arg.initialMarkingFired = true;
                var edge = arg.getOutgoingShapes()[0];
                this.hideOverlayOnShape(edge);
                if (edge.initialMarking) {
                    this.showUsed(arg, "1");
                    this.initialMarking.push(arg.resourceId);
                }
                else {
                    this.hideOverlayOnShape(arg);
                }
                
                // If clicked node is the last startNode, activate real step through
                var allStartNodesFired = true;
                Ext.each(this.startNodes, function(startNode){
                    if (!startNode.initialMarkingFired) {
                        allStartNodesFired = false;
                    }
                });
                
                if (allStartNodesFired) {
                    this.startAndCheckSyntax();
                }
            }
            else {
                this.el = arg;
                this.fireObject(this.el.resourceId);
            }
        }
    },
    
    showObjectStates: function(objs){
        var objsAndState = objs.split(";");
        for (i = 0; i < objsAndState.size(); i++) {
            var objAndState = objsAndState[i].split(",");
            if (objAndState.size() < 3) {
                continue;
            }
            var obj = this.facade.getCanvas().getChildShapeByResourceId(objAndState[0]);
            if (objAndState[2] == "t") { // Is enabled
                this.showEnabled(obj, objAndState[1]);
            }
            else if (objAndState[1] != "0") { // has been used
                this.showUsed(obj, objAndState[1]);
            }
            else { // Was enabled, has not been used
                this.hideOverlayOnShape(obj);
            }
        }
    },
    
    doMouseUpOnEdgeComingFromOrSplit: function(edge){
        var orSplit = edge.getIncomingShapes()[0];
        
        if (edge.selectedForOrSplit) { //deselect edge
            this.showOverlayOnShape(edge, {
                stroke: "orange"
            });
            
            // Hide or-split overlay, if last edge has been deselected
            var outgoingEdges = new Ext.util.MixedCollection();
            outgoingEdges.addAll(orSplit.getOutgoingShapes());
            if (outgoingEdges.filter("selectedForOrSplit", "true").length <= 1) { // > 1, because current edge is in this list
                this.hideOverlayOnShape(orSplit);
            }
            
        }
        else { //select edge
            this.showOverlayOnShape(edge, {
                stroke: "green"
            });
            this.showPlayOnShape(orSplit);
        }
        
        // toggle selection
        edge.selectedForOrSplit = !edge.selectedForOrSplit;
    },
    
    // Toggles color and initialMarking value of start arcs
    doMouseUpOnEdgeComingFromStartNode: function(edge){
        edge.initialMarking = !edge.initialMarking;
        
        if (edge.initialMarking) {
            this.showOverlayOnShape(edge, {
                stroke: "green"
            });
        }
        else {
            this.showOverlayOnShape(edge, {
                stroke: "orange"
            });
        }
    },
    
    //checks whether shape is OR gateway and hasn't more than 1 outgoing edges
    isOrSplit: function(shape){
        return (shape.getStencil().id().search(/#(OR_Gateway|OrConnector)$/) > -1) && (shape.getOutgoingShapes().length > 1);
    },
    
    showEnabledOrSplit: function(shape){
        Ext.each(shape.getOutgoingShapes(), function(edge){
            Ext.apply(edge, {
                selectedForOrSplit: false
            });
            
            this.showOverlayOnShape(edge, {
                stroke: "orange"
            });
        }
.createDelegate(this));
    },
   
    removeLastFiredObject: function(){
        // Removes last entry in execution trace
        this.executionTrace = this.executionTrace.replace(/[^;]*;$/, "")
    },
    
    undo: function(){
        if (!this.active()) 
            return;
        
        if (this.executionTrace !== "") {
            this.removeLastFiredObject();
            
            this.postExecutionTrace({
                checkSyntax: false,
                onlyChangedObjects: false,
                onSuccess: function(request){
                    // Hide overlays because everything is drawn from scratch
                    this.hideOverlays(true);
                    // Draw new overlays
                    this.showObjectStates(request.responseText);
                }
.bind(this)
            });
        }
        else if (this.getDiagramType() === "epc") {
            this.hideOverlays();
            this.prepareInitialMarking(); // "reset" initial marking
        }
    },
    
    /* Posts current execution trace to server for executing 
     * options is a hash with following keys:
     * - onlyChangedObjects (boolean)
     * - onSuccess (function with parameter request)
     * - checkSyntax (boolean)
     */
    postExecutionTrace: function(options){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
            text: ORYX.I18N.StepThroughPlugin.executing
        });
        
        //TODO merge in default options
        new Ajax.Request(ORYX.CONFIG.STEP_THROUGH, {
            method: 'POST',
            asynchronous: false,
            parameters: {
                rdf: this.getRDF(),
                checkSyntax: options.checkSyntax,
                fire: this.executionTrace,
                onlyChangedObjects: options.onlyChangedObjects,
                initialMarking: this.initialMarking.join(";")
            },
            onSuccess: function(response){
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                options.onSuccess(response);
            }.createDelegate(this),
            onFailure: function(){
                //TODO raise error message?
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
            }.createDelegate(this)
        });
    }
});/**
 * Copyright (c) 2008
 * Stefan Krumnow
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * Supports EPCs by offering a syntax check and export and import ability..
 * 
 * 
 */
ORYX.Plugins.EPCSupport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,

	/**
	 * Offers the plugin functionality:
	 * 
	 */
	construct: function(facade) {
		this.facade = facade;
		
		this.facade.offer({
			'name':ORYX.I18N.EPCSupport.exp,
			'functionality': this.exportEPC.bind(this),
			'group': ORYX.I18N.EPCSupport.group,
			'icon': ORYX.PATH + "images/epml_export_icon.png",
			'description': ORYX.I18N.EPCSupport.expDesc,
			'index': 1,
			'minShape': 0,
			'maxShape': 0});
			
		this.facade.offer({
			'name':ORYX.I18N.EPCSupport.imp,
			'functionality': this.importEPC.bind(this),
			'group': ORYX.I18N.EPCSupport.group,
			'icon': ORYX.PATH + "images/epml_import_icon.png",
			'description': ORYX.I18N.EPCSupport.impDesc,
			'index': 2,
			'minShape': 0,
			'maxShape': 0});
	
	},

	
	/**
	 * Imports an AML or EPML description
	 */
	importEPC: function(){
		this.openUploadDialog();
	},		

	
	/**
	 * Exports the diagram into an AML or EPML file
	 */
	exportEPC: function(){

		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.EPCSupport.progressExp});
		var xmlSerializer = new XMLSerializer();

		
		// TODO: a Syntax Syntax-Check should be triggered, here.
		 
		// TODO: get process' name
		var resource = "Oryx-EPC";
		
		// Force to set all resource IDs
		var serializedDOM = DataManager.serializeDOM( this.facade );

		//add namespaces
		serializedDOM = '<?xml version="1.0" encoding="utf-8"?>' +
		'<html xmlns="http://www.w3.org/1999/xhtml" ' +
		'xmlns:b3mn="http://b3mn.org/2007/b3mn" ' +
		'xmlns:ext="http://b3mn.org/2007/ext" ' +
		'xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ' +
		'xmlns:atom="http://b3mn.org/2007/atom+xhtml">' +
		'<head profile="http://purl.org/NET/erdf/profile">' +
		'<link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" />' +
		'<link rel="schema.dcTerms" href="http://purl.org/dc/terms/ " />' +
		'<link rel="schema.b3mn" href="http://b3mn.org" />' +
		'<link rel="schema.oryx" href="http://oryx-editor.org/" />' +
		'<link rel="schema.raziel" href="http://raziel.org/" />' +
		'<base href="' +
		location.href.split("?")[0] +
		'" />' +
		'</head><body>' +
		serializedDOM +
		'<div id="generatedProcessInfos"><span class="oryx-id">' + resource + '</span>' + 
		'<span class="oryx-name">' + resource + '</span></div>' +
		'</body></html>';
		
		/*
		 * Transform eRDF -> RDF
		 */
		var erdf2rdfXslt = ORYX.PATH + "/lib/extract-rdf.xsl";

		var rdfResultString;
		rdfResult = this.transformString(serializedDOM, erdf2rdfXslt, true);
		if (rdfResult instanceof String) {
			rdfResultString = rdfResult;
			rdfResult = null;
		} else {
			rdfResultString = xmlSerializer.serializeToString(rdfResult);
			if (!rdfResultString.startsWith("<?xml")) {
				rdfResultString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + rdfResultString;
			}
		}
		
		/*
		 * Transform RDF -> EPML
		 */
		var rdf2epmlXslt = ORYX.PATH + "/xslt/RDF2EPML.xslt";
		
		var epmlResult = this.transformDOM(rdfResult, rdf2epmlXslt, true);
		var epmlResultString;
		if (epmlResult instanceof String) {
			epmlResultString = epmlResult;
			epmlResult = null;
		} else {
			epmlResultString = xmlSerializer.serializeToString(epmlResult);
			if (!epmlResultString.startsWith("<?xml")) {
				epmlResultString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + epmlResultString;
			}
		}
		
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
		
		// At the moment, only EPML is going to be returned.
		this.openDownloadWindow(resource + ".epml", epmlResultString);
    },
	
	/**
	 * Transforms the given string via xslt.
	 * 
	 * @param {String} string
	 * @param {String} xsltPath
	 * @param {Boolean} getDOM
	 */
	transformString: function(string_, xsltPath, getDOM){
		var parser = new DOMParser();
		var parsedDOM = parser.parseFromString(string_,"text/xml");	
		
		return this.transformDOM(parsedDOM, xsltPath, getDOM);
	},
	
	/**
	 * Transforms the given dom via xslt.
	 * 
	 * @param {Object} domContent
	 * @param {String} xsltPath
	 * @param {Boolean} getDOM
	 */
	transformDOM: function(domContent, xsltPath, getDOM){	
		if (domContent == null) {
			return new String("Parse Error: \nThe given dom content is null.");
		}
		var xsl = "";
		source=ORYX.PATH + "lib/extract-rdf.xsl";
		new Ajax.Request(source, {
			asynchronous: false,
			method: 'get',
			onSuccess: function(transport){
				xsl = transport.responseText
			}.bind(this),
			onFailure: (function(transport){
				ORYX.Log.error("XSL load failed" + transport);
			}).bind(this)
		});
		var result;
		var resultString;
		var xsltProcessor = new XSLTProcessor();
		var domParser = new DOMParser();
		var xslObject = domParser.parseFromString(xsl, "text/xml");
		xsltProcessor.importStylesheet(xslObject);
		try {
			result = xsltProcessor.transformToFragment(domContent, document);
		} catch (error){
			return new String("Parse Error: "+error.name + "\n" + error.message);
		}
		if (getDOM){
			return result;
		}
		resultString = (new XMLSerializer()).serializeToString(result);
		return resultString;
	},

	/**
	 * Opens a upload dialog.
	 * 
	 */
	openUploadDialog: function(){
		
		var form = new Ext.form.FormPanel({
			frame : 		true,
			bodyStyle:		'padding:5px;',
			defaultType : 	'textfield',
		  	labelAlign : 	'left',
		  	buttonAlign: 	'right',
		  	fileUpload : 	true,
		  	enctype : 		'multipart/form-data',
		  	items : [
		  	{
		    	text : 		ORYX.I18N.EPCSupport.selectFile, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
				xtype : 	'label'
		  	},{
		    	fieldLabel : 	ORYX.I18N.EPCSupport.file,
		    	inputType : 	'file',
				labelStyle :	'width:50px;',
				itemCls :		'ext_specific_window_overflow'
		  	}]
		});


		var dialog = new Ext.Window({ 
			autoCreate: true, 
			title: 		ORYX.I18N.EPCSupport.impPanel, 
			height: 	'auto', 
			width: 		'auto', 
			modal:		true,
			collapsible:false,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	false,
			items: [form],
			buttons:[
				{
					text:ORYX.I18N.EPCSupport.impBtn,
					handler: function(){
						
							
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.EPCSupport.progressImp});
						loadMask.show();
												
						form.form.submit({
				      		url: ORYX.PATH + '/epc-upload',
				      		success: function(f,a){
								
								dialog.hide();
								
								// Get the erdf string					
								var erdf = a.result;
								erdf = erdf.startsWith('<?xml') ? erdf : '<?xml version="1.0" encoding="utf-8"?><div>'+erdf+'</div>';	
								// Load the content to the editor
								this.loadContent(erdf);
								// Hide the waiting panel
								loadMask.hide();
								
				      		}.bind(this),
							failure: function(f,a){
								dialog.hide();
								loadMask.hide();
								Ext.MessageBox.show({
		           					title: ORYX.I18N.EPCSupport.error,
		          	 				msg: a.response.responseText.substring(a.response.responseText.indexOf("content:'")+9, a.response.responseText.indexOf("'}")),
		           					buttons: Ext.MessageBox.OK,
		           					icon: Ext.MessageBox.ERROR
		       					});
				      		}
				  		});
					}.bind(this)
				},{
					text:ORYX.I18N.EPCSupport.close,
					handler:function(){
						dialog.hide();
					}.bind(this)
				}
			]
		});

		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});
		dialog.show();
	},
	
	/**
	 * Creates a hidden form element to communicate parameter values
	 * to a php file.
	 * 
	 * @param {Object} name  The name of the hidden field
	 * @param {Object} value The value of the hidden field
	 */
	createHiddenElement: function(name, value) {
		var newElement = document.createElement("input");
		newElement.name=name;
		newElement.type="hidden";
		newElement.value = value;
		return newElement
	},
	
	/**
	 * Returns the file name to the given result-entry.
	 * 
	 * @param {String} entry.
	 */
	getFileName: function(entry) {
		var l = entry.length;
		if (l > 5){
			if (entry.substr(l-5, 5) == "(AML)"){
				return entry.substr(0, l-6);
			}
		}
		return entry
	},
	
	
	/**
	 * Loads the imported string into the oryx
	 * 
	 * @param {Object} content
	 */
	loadContent: function( content ){
		
		var parser	= new DOMParser();			
		var doc 	= parser.parseFromString( content ,"text/xml");
		
		this.facade.importERDF( doc );
		
	}
	
});/**
 * Copyright (c) 2008
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.XFormsExport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,

	construct: function(facade) {
		this.facade = facade;

		this.facade.offer({
			'name':ORYX.I18N.XFormsSerialization.exportXForms,
			'functionality': this.exportXForms.bind(this),
			'group': ORYX.I18N.XFormsSerialization.group,
			'icon': ORYX.PATH + "images/xforms_export.png",
			'description': ORYX.I18N.XFormsSerialization.exportXFormsDesc,
			'index': 2,
			'minShape': 0,
			'maxShape': 0});
	},
	
	exportXForms: function(){
		this._showCssDialog();
	},

	exportIt: function(cssUrl){

		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
		
		//this.checkClientXFormsSupport();
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
            this.exportSynchronously(cssUrl);
			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;
    },

    exportSynchronously: function(cssUrl) {
		 var resource = location.href;
		try {
			var serialized_rdf 	= this.getRDFFromDOM();
			serialized_rdf 		= serialized_rdf.startsWith("<?xml") ? serialized_rdf : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;

			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.XFORMS_EXPORT_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: resource,
					data: serialized_rdf,
					css: cssUrl
				},
				onSuccess: function(request){
					
						var win = window.open("data:text/xml," +
								request.responseText, 
								"_blank", 
								"resizable=yes,width=640,height=480,toolbar=0,scrollbars=yes");
						
				}
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}
	},
	
	checkClientXFormsSupport: function() {
		if(!clientSupportsXForms) {
			
			var output = ORYX.I18N.XFormsSerialization.noClientXFormsSupportDesc;

			var win = new Ext.Window({
                            width: 320,
                            height: 240,
                            resizable: false,
                            minimizable: false,
                            modal: true,
                            autoScroll: true,
                            title: ORYX.I18N.XFormsSerialization.noClientXFormsSupport,
                            html: output,
                            buttons: [{
                                text: ORYX.I18N.XFormsSerialization.ok,
                                handler: function(){
                                    win.hide();
                                }
                            }]
                        });
        	win.show();
			
		}
	},
	
	/**
	 * Opens dialog
	 * 
	 */
	_showCssDialog: function( successCallback ){
	
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: [{
	            text : 		ORYX.I18N.XFormsSerialization.selectCss, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	        },{
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -30' 
	        }]
	    });



		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.XFormsSerialization.expTitle, 
			height: 	150, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text:ORYX.I18N.XFormsSerialization.ok,
					handler:function(){		
						this.exportIt(form.items.items[1].getValue());
						dialog.hide();
					}.bind(this)
				},{
					text:ORYX.I18N.XFormsSerialization.close,
					handler:function(){
						dialog.hide();
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});


		// Show the panel
		dialog.show();

	}

});

/**
 * Copyright (c) 2008
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.XFormsImport = Clazz.extend({

	facade: undefined,

	construct: function(facade) {
		this.facade = facade;

		this.facade.offer({
			'name':ORYX.I18N.XFormsSerialization.importXForms,
			'functionality': this.importXForms.bind(this),
			'group': ORYX.I18N.XFormsSerialization.group,
			'icon': ORYX.PATH + "images/xforms_import.png",
			'description': ORYX.I18N.XFormsSerialization.importXFormsDesc,
			'index': 3,
			'minShape': 0,
			'maxShape': 0});
	},

	
	/**
	 * Imports a XForms+XHTML document
	 * 
	 */
	importXForms: function(){
		this._showImportDialog();
	},		

	
	/**
	 * 
	 * 
	 * @param {Object} url
	 * @param {Object} params
	 * @param {Object} successcallback
	 */
	sendRequest: function( url, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(url, {
            method			: 'POST',
            asynchronous	: false,
            parameters		: params,
			onSuccess		: function(request) {
				
				suc = true;
				
				if(successcallback){
					successcallback( request )	
				}
				
			}.bind(this),
			
			onFailure		: function(request) {

				if(failedcallback){
					
					failedcallback();
					
				} else {
					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.XFormsSerialization.impFailed);
					ORYX.log.warn("Import XForms failed: " + transport.responseText);	
				}
				
			}.bind(this)		
		});
		
		
		return suc;
							
	},

	
	throwWarning: function( text ){
		Ext.MessageBox.show({
					title: 		ORYX.I18N.Oryx.title,
 					msg: 		text,
					buttons: 	Ext.MessageBox.OK,
					icon: 		Ext.MessageBox.WARNING
				});
	},
	
	
	/**
	 * Opens an upload dialog.
	 * 
	 */
	_showImportDialog: function( successCallback ){
	
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: [{
	            text : 		ORYX.I18N.XFormsSerialization.selectFile, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	        },{
	            fieldLabel: ORYX.I18N.XFormsSerialization.file,
	            name: 		'subject',
				inputType : 'file',
				style : 	'margin-bottom:10px;display:block;',
				itemCls :	'ext_specific_window_overflow'
	        }, {
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -63'  
	        }]
	    });



		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.XFormsSerialization.impTitle, 
			height: 	350, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text:ORYX.I18N.XFormsSerialization.impButton,
					handler:function(){
						
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.XFormsSerialization.impProgress});
						loadMask.show();
						
						window.setTimeout(function(){
					
							var xhtmlString =  form.items.items[2].getValue();
							
							var params = { resource: location.href, data: xhtmlString };
							this.sendRequest(
								ORYX.CONFIG.XFORMS_IMPORT_URL, 
								params, 
								function(request) {
									this.facade.importJSON(request.responseText);
									loadMask.hide();
									dialog.hide();
									//this.loadERDF(request.responseText, function(){loadMask.hide();dialog.hide()}.bind(this), function(){loadMask.hide();}.bind(this))
								}.bind(this) );
														
							
						}.bind(this), 100);
			
					}.bind(this)
				},{
					text:ORYX.I18N.XFormsSerialization.close,
					handler:function(){
						
						dialog.hide();
					
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});


		// Show the panel
		dialog.show();
		
				
		// Adds the change event handler to 
		form.items.items[1].getEl().dom.addEventListener('change',function(evt){
				var text = evt.target.files[0].getAsBinary();
				form.items.items[2].setValue( text );
			}, true)

	}
	
});
/**
 * Copyright (c) 2008
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.RowLayouting = {

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;
		// Initialize variables
		
		this.currentShapes = [];			// Current selected Shapes
		this.toMoveShapes = [];				// Shapes that are moved
	
		this.dragBounds = undefined;
		this.offSetPosition = {x:0, y:0};
		this.evCoord = {x:0, y:0};

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAYOUT_ROWS, this.handleLayoutRows.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));
	},
	
	
	/**
	 * On the Selection-Changed
	 *
	 */
	onSelectionChanged: function(event) {
		
		var elements = event.elements;

		// If there are no elements
		if(!elements || elements.length == 0) {
			// reset all variables
			this.currentShapes = [];
			this.toMoveShapes = [];
			this.dragBounds = undefined;
		} else {

			// Set the current Shapes
			this.currentShapes = elements;

			// Get all shapes with the highest parent in object hierarchy (canvas is the top most parent)
			this.toMoveShapes = this.facade.getCanvas().getShapesWithSharedParent(elements);
			
			this.toMoveShapes = this.toMoveShapes.findAll( function(shape) { return shape instanceof ORYX.Core.Node && 
																			(shape.dockers.length === 0 || !elements.member(shape.dockers.first().getDockedShape()))});		
		
			// Calculate the area-bounds of the selection
			var newBounds = undefined;
			elements.each(function(value) {
				if(!newBounds)
					newBounds = value.absoluteBounds();
				else
					newBounds.include(value.absoluteBounds());
			});

			// Set the new bounds
			this.dragBounds = newBounds;

		}
		
		/*if(!this.dragBounds) {return};
		
		
		var ul = this.dragBounds.upperLeft();
		
		var offSetPosition = {
			x: this.evCoord.x - ul.x,
			y: this.evCoord.y - ul.y
		}
		
		this.toMoveShapes.each(function(shape) {
			shape.bounds.moveBy(offSetPosition);
		});*/
		
		return;
	},
	
	handleMouseDown: function(event, uiObj) {
		if(!this.dragBounds || !this.toMoveShapes.member(uiObj)) {return};
		
		var evCoord 	= this.facade.eventCoordinates( event );
		var ul = this.dragBounds.upperLeft();
		
		this.offSetPosition = {
			x: evCoord.x - ul.x,
			y: evCoord.y - ul.y
		}
		
		return;
	},	
	
	/**
	 * On Layout Rows
	 *
	 */
	handleLayoutRows: function(event) {
		var shape = event.shape;
		
		var offsetPos = this.offSetPosition;
		
		var marginLeft = event.marginLeft;
		var marginTop = event.marginTop;
		var spacingX = event.spacingX;
		var spacingY = event.spacingY;
		var elements = event.shape.getChildShapes(false);
		
		var movedShapes = this.toMoveShapes;
		movedShapes.each(function(shape){
			if(elements.include(shape)) shape.bounds.moveBy(offsetPos);
		});
		
		// exclude specified stencils from layouting
		if (event.exclude) {
			elements = elements.filter(function(element){
				return !event.exclude.some(function(value){
					return element.getStencil().id() == value;
				});
			});
		}
		
		var rowTop = marginTop;
		var rowBottom = marginTop - spacingY;
		
		if (event.horizontalLayout) {
			// in case of horizontal layout: reset Y values
			elements.each(function(element){
				var ul = element.bounds.upperLeft();
				element.bounds.moveTo(ul.x, rowTop);
			})
		}
		else 
			if (event.verticalLayout) {
				// in case of vertical layout: reset X values
				elements.each(function(element){
					var ul = element.bounds.upperLeft();
					element.bounds.moveTo(marginLeft, ul.y);
				})
			}
		
		// Sort top-down
		elements = elements.sortBy(function(element){
			return element.bounds.upperLeft().y;
		});
		
		var insertRowOffset = 0;
		var deleteRowOffset = 0;
		var isNewRow = false;
		
		// Assign shapes to rows
		elements.each(function(element){
		
			var ul = element.bounds.upperLeft();
			var lr = element.bounds.lowerRight();
			
			// save old values
			var oldUlX = ul.x;
			var oldUlY = ul.y;
			var oldLrX = lr.x;
			var oldLrY = lr.y;
			
			if (movedShapes.include(element)) {
				ul.y -= deleteRowOffset;
				
				if ((ul.y > rowBottom) || ((element == elements.first()) && ul.y < marginTop)) {
					// ul.y < marginTop wird bei nebeneinander nach oben verschobenen shapes
					// mehrmals erfüllt, dadurch mehrmals neue row und untereinanderrutschen
					// -> nur falls erstes element
					
					// next row
					isNewRow = false;
					rowTop = rowBottom + spacingY;
					if (ul.y < rowTop) {
						// insert new row
						//insertRowOffset += element.bounds.height() + 1;
						isNewRow = true;
					}
				}
			}
			else {
				ul.y += insertRowOffset;
				ul.y -= deleteRowOffset;
				
				if (ul.y > rowTop) {
					// next row
					isNewRow = false;
					rowTop = rowBottom + spacingY;
				}
			}
			
			// align shape at row top
			ul.y = rowTop;
			lr.y = ul.y + element.bounds.height();
			
			if (lr.y > rowBottom) {
				// extend row height and inserted rows offset
				// following lines don't work as required
				if (isNewRow) 
					insertRowOffset += lr.y - rowBottom;
				else 
					if (movedShapes.include(element)) 
						insertRowOffset += lr.y - rowBottom;
				rowBottom = lr.y;
			}
			
			if ((ul.x != oldUlX) || (ul.y != oldUlY) || (lr.x != oldLrX) || (lr.y != oldLrY)) {
				// only set bounds if ul or lr updated
				if (!movedShapes.include(element)) {
					// if non-moved elements are repositioned upwards also move following [moved] elements upwards
					// (otherwise dropping the moved element to a row below wouldn't work correctly)
					if ((oldUlY - ul.y) > deleteRowOffset) 
						deleteRowOffset = oldUlY - ul.y;
				}
				element.bounds.set(ul.x, ul.y, lr.x, lr.y);
			}
		});
		
		// Sort top-down from left to right
		elements = elements.sortBy(function(element){
			return element.bounds.upperLeft().y * 10000 + element.bounds.upperLeft().x;
		});
		
		rowTop = marginTop;
		var rowRight = marginLeft - spacingX;
		var maxRowRight = rowRight;
		var maxRowBottom = 0;
		
		// Arrange shapes on rows (align left)
		elements.each(function(element){
		
			var ul = element.bounds.upperLeft();
			var lr = element.bounds.lowerRight();
			
			// save old values
			var oldUlX = ul.x;
			var oldUlY = ul.y;
			var oldLrX = lr.x;
			var oldLrY = lr.y;
			
			if (ul.y > rowTop) {
				// next row
				rowTop = ul.y;
				rowRight = marginLeft - spacingX;
			}
			
			// align at right border of the row
			ul.x = rowRight + spacingX;
			lr.x = ul.x + element.bounds.width();
			rowRight = lr.x;
			
			if (rowRight > maxRowRight) 
				maxRowRight = rowRight;
			if (lr.y > maxRowBottom) 
				maxRowBottom = lr.y;
			
			if ((ul.x != oldUlX) || (ul.y != oldUlY) || (lr.x != oldLrX) || (lr.y != oldLrY)) {
				// only set bounds if ul or lr updated
				element.bounds.set(ul.x, ul.y, lr.x, lr.y);
			}
			
		});
		
		if (event.shape != this.facade.getCanvas()) {
			// adjust parents bounds
			var ul = event.shape.bounds.upperLeft();
			if (maxRowRight > marginLeft) 
				event.shape.bounds.set(ul.x, ul.y, ul.x + maxRowRight + marginLeft, ul.y + rowBottom + marginTop);
		}
		else {
			// extend canvas size if necessary
			if (maxRowRight > this.facade.getCanvas().bounds.width()) {
				this.facade.getCanvas().setSize({
					width: (maxRowRight + marginLeft),
					height: this.facade.getCanvas().bounds.height()
				});
			}
			if (maxRowBottom > this.facade.getCanvas().bounds.height()) {
				this.facade.getCanvas().setSize({
					width: this.facade.getCanvas().bounds.width(),
					height: (rowBottom + marginTop)
				});
			}
		}
		
		
		return;
	}
};

ORYX.Plugins.RowLayouting = Clazz.extend(ORYX.Plugins.RowLayouting);/**
 * Copyright (c) 2008
 * Jan-Felix Schwarz
 * Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
*/
 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * The XForms plugin provides layout methods primarily referring to the XForms stencilset. 
 * 
 * @class ORYX.Plugins.XForms
 * @extends Clazz
 * @param {Object} facade The facade of the editor
 */
ORYX.Plugins.XForms = 
/** @lends ORYX.Plugins.XForms.prototype */
{
	/**
	 * Creates a new instance of the XForms plugin and registers it on the
	 * layout events listed in the XForms stencil set.
	 * 
	 * @constructor
	 * @param {Object} facade The facade of the editor
	 */
	construct: function(facade) {
		this.facade = facade;
		this.facade.registerOnEvent('layout.xforms.label', this.handleLayoutLabel.bind(this));
		this.facade.registerOnEvent('layout.xforms.label.button', this.handleLayoutLabelButton.bind(this));
		this.facade.registerOnEvent('layout.xforms.label.item', this.handleLayoutLabelItem.bind(this));
		this.facade.registerOnEvent('layout.xforms.item', this.handleLayoutItem.bind(this));
		this.facade.registerOnEvent('layout.xforms.case', this.handleLayoutCase.bind(this));
		this.facade.registerOnEvent('layout.xforms.action', this.handleLayoutAction.bind(this));
	},
	
	/**
	 * 
	 * @param {Object} event
	 */
	handleLayoutLabel : function(event) {
		var shape = event.shape;
		var moveX = event.moveX;
		var moveY = event.moveY;
		
		var labels = shape.getChildNodes(false).findAll(function(node) {
				return (node.getStencil().id() === "http://b3mn.org/stencilset/xforms#Label");
			});
			
			if(labels.length > 0) {
				labels.each(function(label) {
					var ul = label.bounds.upperLeft();
					var lr = label.bounds.lowerRight();
					ul.y = - label.bounds.height() + moveY;
					lr.y = moveY;
					ul.x = moveX;
					lr.x = label.bounds.width() + moveX;
					label.bounds.set(ul, lr);
				});
			}
	},
	
	handleLayoutLabelButton : function(event) {
		var shape = event.shape;
		
		var labels = shape.getChildNodes(false).findAll(function(node) {
			return (node.getStencil().id() === "http://b3mn.org/stencilset/xforms#Label");
		});
		
		if(labels.length > 0) {
			labels.each(function(label) {
				
				var ul = label.bounds.upperLeft();
				var lr = label.bounds.lowerRight();
				ul.y = 2;
				lr.y = 2 + label.bounds.height();
				
				if((shape.bounds.width()-4)<label.bounds.width()) {
					var sul = shape.bounds.upperLeft();
					var slr = shape.bounds.lowerRight();
					slr.x = sul.x + label.bounds.width() + 4;
					shape.bounds.set(sul, slr);
				}

				ul.x = (shape.bounds.width() - 4 - label.bounds.width()) * 0.5;
				lr.x = ul.x + label.bounds.width();
				label.bounds.set(ul, lr);
			});
		}
	},
	
	handleLayoutItem : function(event) {
		var shape = event.shape;
		
		var items = shape.getChildNodes(false).findAll(function(node) {
			return ((node.getStencil().id()==="http://b3mn.org/stencilset/xforms#Item")||(node.getStencil().id()==="http://b3mn.org/stencilset/xforms#Choices")||(node.getStencil().id()==="http://b3mn.org/stencilset/xforms#Itemset"));
		});
		
		if(items.length > 0) {
		
			items = items.sortBy(function(item) {
				return item.bounds.upperLeft().y;
			});
			
			var shapeWidth = shape.bounds.width();
			var shapeHeight = 0;
			items.each(function(item) {
				var ul = item.bounds.upperLeft();
				var lr = item.bounds.lowerRight();
				if(item.getStencil().id()==="http://b3mn.org/stencilset/xforms#Choices") {
					ul.y = shapeHeight + 25;
					shapeHeight += 25;
				} else {
					ul.y = shapeHeight + 5;
					shapeHeight += 5;
				}
				lr.y = ul.y + item.bounds.height();
				shapeHeight += item.bounds.height();
				ul.x = 30;
				lr.x = shapeWidth;
				item.bounds.set(ul, lr);
			});
			
			var upl = shape.bounds.upperLeft();
			shape.bounds.set(upl.x, upl.y, shape.bounds.lowerRight().x, upl.y + shapeHeight + 5);
		}
		
		var labels = shape.getChildNodes(false).findAll(function(node) {
			return (node.getStencil().id() === "http://b3mn.org/stencilset/xforms#Label");
		});
		
		if(labels.length > 0) {
			labels.each(function(label) {
				var ul = label.bounds.upperLeft();
				var lr = label.bounds.lowerRight();
				ul.y = - label.bounds.height() - 1;
				lr.y = - 1;
				ul.x = 0;
				lr.x = label.bounds.width();
				label.bounds.set(ul, lr);
			});
		}
	},
	
	handleLayoutCase : function(event) {
		var shape = event.shape;
		
		var cases = shape.getChildNodes(false);
				
		var maxWidth = 0;
		cases.each(function(c) {
			if(c.bounds.width()>maxWidth) maxWidth = c.bounds.width();
		});

		if(cases.length > 0) {
			
			cases = cases.sortBy(function(c) {
				return c.bounds.upperLeft().y;
			});
			
			var shapeHeight = 5;
			cases.each(function(c) {
				var ul = c.bounds.upperLeft();
				var lr = c.bounds.lowerRight();
				ul.y = shapeHeight;
				lr.y = ul.y + c.bounds.height();
				shapeHeight += c.bounds.height() + 5;
				ul.x = 0;
				lr.x = maxWidth;
				c.bounds.set(ul, lr);
			});
			
			var upl = shape.bounds.upperLeft();
			shape.bounds.set(upl.x, upl.y, upl.x + maxWidth, upl.y + shapeHeight + 20);
		}
	},
	
	handleLayoutLabelItem : function(event) {
		var shape = event.shape;
		
		var labels = shape.getChildNodes(false).findAll(function(node) {
			return (node.getStencil().id() === "http://b3mn.org/stencilset/xforms#Label");
		});
		
		if(labels.length > 0) {
			labels.each(function(label) {
				var ul = label.bounds.upperLeft();
				var lr = label.bounds.lowerRight();
				ul.y = 2;
				ul.x = 2;
				lr.y = 2 + label.bounds.height();
				lr.x = 2 + label.bounds.width();
				label.bounds.set(ul, lr);
			});
		}
	},
	
	handleLayoutAction : function(event) {
		var shape = event.shape;
		
		var actions = shape.getChildNodes(false);

		if(actions.length > 0) {
			
			actions = actions.sortBy(function(action) {
				return action.bounds.upperLeft().y;
			});
			
			var shapeHeight = 5;
			actions.each(function(action) {
				var ul = action.bounds.upperLeft();
				var lr = action.bounds.lowerRight();
				ul.y = shapeHeight;
				lr.y = ul.y + action.bounds.height();
				shapeHeight += action.bounds.height() + 5;
				ul.x = 2;
				lr.x = 2 + action.bounds.width();
				action.bounds.set(ul, lr);
			});
			
			var upl = shape.bounds.upperLeft();
			var lor = shape.bounds.lowerRight();
			shape.bounds.set(upl.x, upl.y, lor.x, upl.y + shapeHeight + 15);
		}
	}
	
};

ORYX.Plugins.XForms = Clazz.extend(ORYX.Plugins.XForms);
/**
 * Copyright (c) 2008
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.XFormsExportOrbeon = ORYX.Plugins.AbstractPlugin.extend({
	
	CSS_URL: "/oryx/css/xforms_default.css",

	facade: undefined,

	construct: function(facade) {
		this.facade = facade;

		this.facade.offer({
			'name': "Run XForm with Orbeon",
			'functionality': this.exportIt.bind(this),
			'group': ORYX.I18N.XFormsSerialization.group,
			'icon': ORYX.PATH + "images/xforms_orbeon_export.png",
			'description': 'XForms export for Orbeon',
			'index': 1,
			'minShape': 0,
			'maxShape': 0});
	},

	exportIt: function(){

		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
		
		//this.checkClientXFormsSupport();
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
            this.exportSynchronously();
			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;
    },

    exportSynchronously: function() {

        var resource = location.href;
		
		
		try {
			var serialized_rdf 	= this.getRDFFromDOM();
			serialized_rdf 		= serialized_rdf.startsWith("<?xml") ? serialized_rdf : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;

			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.XFORMS_EXPORT_ORBEON_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: resource,
					data: serialized_rdf,
					css: this.CSS_URL
				},
				onSuccess: function(request){
					
						var win = window.open("");
						win.document.write(request.responseText);
						
				},
				onFailure: function(request){
					var win = window.open("");
					win.document.write(request.responseText);
				}
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}
	},
	
	checkClientXFormsSupport: function() {
		if(!clientSupportsXForms) {
			
			var output = ORYX.I18N.XFormsSerialization.noClientXFormsSupportDesc;

			var win = new Ext.Window({
                            width: 320,
                            height: 240,
                            resizable: false,
                            minimizable: false,
                            modal: true,
                            autoScroll: true,
                            title: ORYX.I18N.XFormsSerialization.noClientXFormsSupport,
                            html: output,
                            buttons: [{
                                text: ORYX.I18N.XFormsSerialization.ok,
                                handler: function(){
                                    win.hide();
                                }
                            }]
                        });
        	win.show();
			
		}
	}

});

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.CpnSupport = Clazz.extend({

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) 
	{
		this.facade = facade;
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_RESIZE_END, this.resetTokenPosition.bind(this));
	},
	
	resetTokenPosition: function()
	{
		// Get selected places		
		var allplaces = this.facade.getSelection().findAll(function(selectedItem) {
			return (selectedItem.getStencil().id() === "http://b3mn.org/stencilset/coloredpetrinet#Place");
		});
		
		if (allplaces.length > 0)
		{
			allplaces.each(function(place) {
				
				var placeBounds = place.absoluteBounds();
				var placeCenter = placeBounds.center();
				
				// Calculate radius in order to check if a token is in the place
				var radiusY = placeCenter.y - placeBounds.upperLeft().y;
				var radiusX = placeCenter.x - placeBounds.upperLeft().x;
				var radius = Math.min(radiusY,radiusX);
				var c = radius / 2;
				
				// Get all tokens inside the place 
				var alltokens = place.getChildNodes(false).findAll(function(child) {
					return (child.getStencil().id() === "http://b3mn.org/stencilset/coloredpetrinet#Token");
				});
				
				if (alltokens.length > 0)
				{
					var i = 0;
					var x = 0;
					var y = 0;
					
					alltokens.each(function(token) {
						var tokenBounds = token.absoluteBounds();
						var tokenCenter = tokenBounds.center();
						
						// Calculate the distance between token and center of the place
						var diffX = placeCenter.x - tokenCenter.x;
						var diffY = placeCenter.y - tokenCenter.y;
						var distanceToPlaceCenter= diffX*diffX + diffY*diffY; // take care it's squared
						
						// Check if the token is in the place
						if (radius*radius <= distanceToPlaceCenter)
						{	// if the token is out of the place, calculate the position for the token
							// the token are positioned in circle which is in the place
							y = Math.round(Math.sin((Math.PI / 6) * i) * c);
							x = Math.round(Math.cos((Math.PI / 6) * i) * c);
							// take care centerMoveTo is referred to the position in the selected place (not absolute) 
							token.bounds.centerMoveTo(place.bounds.width() / 2  + x, place.bounds.height() / 2 + y);
							token.update();
							i = i + 1;
						}
					});					
				}
			});

		}			
		this.facade.getCanvas().update();
	}	
});

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.CPNToolsSupport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,
	
	stencilSetNamespace: 'http://b3mn.org/stencilset/coloredpetrinet#',

	construct: function(facade) 
	{
		
		this.facade = facade;
			
		this.facade.offer({
			'name':				"Export to CPN Tools",
			'functionality': 	this.exportCPN.bind(this),
			'group': 			ORYX.I18N.cpntoolsSupport.group,
			'dropDownGroupIcon':ORYX.PATH + "images/export2.png",
			'icon': 			ORYX.PATH + "images/cpn/cpn_export.png",
			'description': 		ORYX.I18N.cpntoolsSupport.exportDescription,
			'index': 			0,
			'minShape': 		0,
			'maxShape': 		0,
			'maxShape': 		0
		});
					
		this.facade.offer({
			'name':				"Import from CPN Tools",
			'functionality': 	this.importCPN.bind(this),
			'group': 			ORYX.I18N.cpntoolsSupport.group,
			'dropDownGroupIcon':ORYX.PATH + "images/import.png",
			'icon': 			ORYX.PATH + "images/cpn/cpn_import.png",
			'description': 		ORYX.I18N.cpntoolsSupport.importDescription,
			'index': 			1,
			'minShape': 		0,
			'maxShape': 		0
		});

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_RESIZE_END, this.resetTokenPosition.bind(this));
	},

	// Imports CPN - File
	importCPN: function()
	{
		this._showImportDialog();
	},		
	
	// Exports CPN - File
	exportCPN: function()
	{
				
		// Get the JSON representation which is needed for the mapping 
		var cpnJson = this.facade.getSerializedJSON();
		
		// Do the export
		this._doExportToCPNTools( cpnJson );
	},
	
	resetTokenPosition: function()
	{
		// Get selected places		
		var allplaces = this.facade.getSelection().findAll(function(selectedItem) {
			return (selectedItem.getStencil().id() === "http://b3mn.org/stencilset/coloredpetrinet#Place");
		});
		
		if (allplaces.length > 0)
		{
			allplaces.each(function(place) {
				
				var placeBounds = place.absoluteBounds();
				var placeCenter = placeBounds.center();
				
				// Calculate radius in order to check if a token is in the place
				var radiusY = placeCenter.y - placeBounds.upperLeft().y;
				var radiusX = placeCenter.x - placeBounds.upperLeft().x;
				var radius = Math.min(radiusY,radiusX);
				var c = radius / 2;
				
				// Get all tokens inside the place 
				var alltokens = place.getChildNodes(false).findAll(function(child) {
					return (child.getStencil().id() === "http://b3mn.org/stencilset/coloredpetrinet#Token");
				});
				
				if (alltokens.length > 0)
				{
					var i = 0;
					var x = 0;
					var y = 0;
					
					alltokens.each(function(token) {
						var tokenBounds = token.absoluteBounds();
						var tokenCenter = tokenBounds.center();
						
						// Calculate the distance between token and center of the place
						var diffX = placeCenter.x - tokenCenter.x;
						var diffY = placeCenter.y - tokenCenter.y;
						var distanceToPlaceCenter= diffX*diffX + diffY*diffY; // take care it's squared
						
						// Check if the token is in the place
						if (radius*radius <= distanceToPlaceCenter)
						{	// if the token is out of the place, calculate the position for the token
							// the token are positioned in circle which is in the place
							y = Math.round(Math.sin((Math.PI / 6) * i) * c);
							x = Math.round(Math.cos((Math.PI / 6) * i) * c);
							// take care centerMoveTo is referred to the position in the selected place (not absolute) 
							token.bounds.centerMoveTo(place.bounds.width() / 2  + x, place.bounds.height() / 2 + y);
							token.update();
							i = i + 1;
						}
					});					
				}
			});

		}			
		this.facade.getCanvas().update();
	},

	// ---------------------------------------- Ajax Request --------------------------------
	
	_sendRequest: function( url, method, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(
		url, 
		{
           method			: method,
           asynchronous		: false,
           parameters		: params,
		   onSuccess		: function(transport) 
		   {
				suc = true;
		
				if(successcallback)
				{
					successcallback( transport.responseText )	
				}
		
		   }.bind(this),
		   onFailure		: function(transport) 
		   {
				if(failedcallback)
				{							
					failedcallback();							
				} 
				else 
				{
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.cpntoolsSupport.serverConnectionFailed);
					ORYX.log.warn("Communication failed: " + transport.responseText);	
				}					
		   }.bind(this)		
		});
		
		return suc;		
	},	

// -------------------------------------------- Export Functions ----------------------------
	
	_doExportToCPNTools: function( cpnJSON )
	{		
		this._sendRequest
		(
			ORYX.CONFIG.CPNTOOLSEXPORTER,
			'POST',
			{ 
				data: cpnJSON
			},
			function( result )
			{ 			
				if (result.startsWith("error:"))
				{
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, result);
				}
				else
				{
					this.openDownloadWindow( window.document.title + ".cpn", result );
				}				
			}.bind(this),
			function()
			{ 
				this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.cpntoolsSupport.serverConnectionFailed);
		 	}.bind(this)
		)
	}, 

// -------------------------------------------- Import Functions ------------------------
	
	 // Opens a upload dialog
	_showImportDialog: function( successCallback )
	{
		// Define the form panel
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: 
	        [
	         {
	            text : 		ORYX.I18N.cpntoolsSupport.importTask, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	         },
	         {
	            fieldLabel: ORYX.I18N.cpntoolsSupport.File,
	            name: 		'subject',
				inputType : 'file',
				style : 	'margin-bottom:10px;display:block;',
				itemCls :	'ext_specific_window_overflow'
	         }, 
	         {
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -63'  
	         }
	        ]
	    });

		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.cpntoolsSupport.cpn, 
			height: 	350, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text: ORYX.I18N.cpntoolsSupport.importLable,
					handler:function(){
						
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.jPDLSupport.impProgress});
						loadMask.show();
						
						window.setTimeout(function()
						{					
							// Get the text which is in the text field
							var cpnToImport =  form.items.items[2].getValue();							
							this._getAllPages(cpnToImport, loadMask);

						}.bind(this), 100);

						dialog.hide();
						
					}.bind(this)
					
				},{
					text: ORYX.I18N.cpntoolsSupport.close,
					handler:function()
					{						
						dialog.hide();					
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function()
		{
			dialog.destroy(true);
			delete dialog;
		});

		// Show the panel
		dialog.show();
		
				
		// Adds the change event handler to 
		form.items.items[1].getEl().dom.addEventListener('change',function(evt)
			{
				var text = evt.target.files[0].getAsText('UTF-8');
				form.items.items[2].setValue( text );
			}, true)

	},
	
	_getAllPages: function(cpnXML, loadMask)
	{
		var parser = new DOMParser();
		var xmlDoc = parser.parseFromString(cpnXML,"text/xml");
		var allPages = xmlDoc.getElementsByTagName("page");
		
		// If there are no pages then it is propably that cpnXML is not a cpn - File
		if (allPages.length == 0)
		{
			loadMask.hide();
			this._showErrorMessageBox(ORYX.I18N.cpntoolsSupport.title, ORYX.I18N.cpntoolsSupport.wrongCPNFile);
			
			return;
		}
		
		
		if (allPages.length == 1)
		{
			pageAttr = allPages[0].children[0];
			pageName = pageAttr.attributes[0].nodeValue;
			
			this._sendRequest(
					ORYX.CONFIG.CPNTOOLSIMPORTER,
					'POST',
					{ 
						'pagesToImport': pageName,
						'data' : cpnXML 
					},
					function( arg )
					{
						if (arg.startsWith("error:"))
						{
							this._showErrorMessageBox(ORYX.I18N.Oryx.title, arg);
							loadMask.hide();
						}
						else
						{
							this.facade.importJSON(arg); 
							loadMask.hide();							
						}
					}.bind(this),
					function()
					{
						loadMask.hide();
						this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.cpntoolsSupport.serverConnectionFailed);
					}.bind(this)
				);
			
			return;
		}
		
		var i, pageName, data = [];
		for (i = 0; i < allPages.length; i++)
		{
			pageAttr = allPages[i].children[0];
			pageName = pageAttr.attributes[0].nodeValue;
			data.push([pageName]);
		}
		
		loadMask.hide();
		this.showPageDialog(data, cpnXML);		
	},
	
	_showErrorMessageBox: function(title, msg)
	{
        Ext.MessageBox.show({
           title: title,
           msg: msg,
           buttons: Ext.MessageBox.OK,
           icon: Ext.MessageBox.ERROR
       });
	},
	
	
	showPageDialog: function(data, cpnXML)
	{
		var reader = new Ext.data.ArrayReader(
				{}, 
				[ {name: 'name'} ]);
		
		var sm = new Ext.grid.CheckboxSelectionModel(
			{
				singleSelect: true
			});
		
	    var grid2 = new Ext.grid.GridPanel({
	    		store: new Ext.data.Store({
		            reader: reader,
		            data: data
		        	}),
		        cm: new Ext.grid.ColumnModel([
		            {
		            	id:'name',
		            	width:200,
		            	sortable: true, 
		            	dataIndex: 'name'
		            },
					sm]),
			sm: sm,
	        frame:true,
			hideHeaders:true,
	        iconCls:'icon-grid',
			listeners : {
				render: function() {
					var recs=[];
					this.grid.getStore().each(function(rec)
					{
						if(rec.data.engaged){
							recs.push(rec);
						}
					}.bind(this));
					this.suspendEvents();
					this.selectRecords(recs);
					this.resumeEvents();
				}.bind(sm)
			}
	    });
	    
	 // Create a new Panel
        var panel = new Ext.Panel({
            items: [{
                xtype: 'label',
                text: 'CPNTools Page',
                style: 'margin:10px;display:block'
            }, grid2],
            frame: true
        })
        
        // Create a new Window
        var window = new Ext.Window({
            id: 'oryx_new_page_selection',
            autoWidth: true,
            title: ORYX.I18N.cpntoolsSupport.title,
            floating: true,
            shim: true,
            modal: true,
            resizable: true,
            autoHeight: true,
            items: [panel],
            buttons: [{
                text: ORYX.I18N.cpntoolsSupport.importLable,
                handler: function()
                {
            		var chosenRecs = "";

            		// Actually it doesn't matter because it's one
            		sm.getSelections().each(function(rec)
            		{
						chosenRecs = rec.data.name;						
					}.bind(this));
            		
            		var strLen = chosenRecs.length; 
            		
            		if (chosenRecs.length == 0)
            		{
            			alert(ORYX.I18N.cpntoolsSupport.noPageSelection);
            			return;
            		}
            		
            		var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.cpntoolsSupport.importProgress});
					loadMask.show();
					
            		window.hide();
            		
        			pageName = chosenRecs;
        			this._sendRequest(
        					ORYX.CONFIG.CPNTOOLSIMPORTER,
        					'POST',
        					{ 
        						'pagesToImport': pageName,
        						'data' : cpnXML 
        					},
        					function( arg )
        					{
								if (arg.startsWith("error:"))
								{
									this._showErrorMessageBox(ORYX.I18N.Oryx.title, arg);
									loadMask.hide();
								}
								else
								{
									this.facade.importJSON(arg); 
									loadMask.hide();							
								}
							}.bind(this),
        					function()
        					{
								loadMask.hide();
								this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.cpntoolsSupport.serverConnectionFailed);
							}.bind(this)
        				);
                }.bind(this)
            }, 
            {
                text: ORYX.I18N.cpntoolsSupport.close,
                handler: function(){
                    window.hide();
                }.bind(this)
            }]
        })
        
        // Show the window
        window.show();
	}		
	
});
